
quadcopter_dev.elf:     formato del fichero elf32-avr

Secciones:
Ind Nombre        Tamaño    VMA       LMA       Desp fich Alin
  0 .data         0000001e  00800200  000067ba  0000684e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000067ba  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000009c  0080021e  0080021e  0000686c  2**0
                  ALLOC
  3 .stab         0000a3b0  00000000  00000000  0000686c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003b71  00000000  00000000  00010c1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0001478d  2**0
                  CONTENTS, READONLY

Desensamblado de la sección .text:

00000000 <__vectors>:
       0:	0c 94 24 01 	jmp	0x248	; 0x248 <__ctors_end>
       4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
       8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
       c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      10:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      14:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      18:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      1c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      20:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      24:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      28:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      2c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      30:	0c 94 ef 13 	jmp	0x27de	; 0x27de <__vector_12>
      34:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      38:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      3c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      40:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      44:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      48:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      4c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      50:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      54:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      58:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      5c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      60:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      64:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      68:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      6c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      70:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      74:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      78:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      7c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      80:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      84:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      88:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      8c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      90:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      94:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      98:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      9c:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      a0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      a4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      a8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      ac:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      b0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      b4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      b8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      bc:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      c0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      c4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      c8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      cc:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      d0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      d4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      d8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      dc:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>
      e0:	0c 94 45 01 	jmp	0x28a	; 0x28a <__bad_interrupt>

000000e4 <__trampolines_start>:
      e4:	0c 94 11 01 	jmp	0x222	; 0x222 <prvIdleTask>
      e8:	0c 94 71 0f 	jmp	0x1ee2	; 0x1ee2 <Led>

000000ec <__trampolines_end>:
      ec:	4e 41       	sbci	r20, 0x1E	; 30
      ee:	4e 49       	sbci	r20, 0x9E	; 158

000000ef <pstr_inity>:
      ef:	49 4e 49 54 59                                      INITY

000000f4 <pstr_inf>:
      f4:	49 4e 46                                            INF

000000f7 <pwr_m10>:
      f7:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     107:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

0000010f <pwr_p10>:
     10f:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     11f:	ca 1b 0e 5a ae c5 9d 74 00 40 7a 10 f3 5a 00 a0     ...Z...t.@z..Z..
     12f:	72 4e 18 09 00 10 a5 d4 e8 00 00 e8 76 48 17 00     rN..........vH..
     13f:	00 e4 0b 54 02 00 00 ca 9a 3b 00 00 00 e1 f5 05     ...T.....;......
     14f:	00 00 80 96 98 00 00 00 40 42 0f 00 00 00 a0 86     ........@B......
     15f:	01 00 00 00 10 27 00 00 00 00 e8 03 00 00 00 00     .....'..........
     16f:	64 00 00 00 00 00 0a 00 00 00 00 00 01 00 00 00     d...............
     17f:	00 00 2c 76 d8 88 dc 67 4f 08 23 df c1 df ae 59     ..,v...gO.#....Y
     18f:	e1 b1 b7 96 e5 e3 e4 53 c6 3a e6 51 99 76 96 e8     .......S.:.Q.v..
     19f:	e6 c2 84 26 eb 89 8c 9b 62 ed 40 7c 6f fc ef bc     ...&....b.@|o...
     1af:	9c 9f 40 f2 ba a5 6f a5 f4 90 05 5a 2a f7 5c 93     ..@...o....Z*.\.
     1bf:	6b 6c f9 67 6d c1 1b fc e0 e4 0d 47 fe f5 20 e6     kl.gm......G.. .
     1cf:	b5 00 d0 ed 90 2e 03 00 94 35 77 05 00 80 84 1e     .........5w.....
     1df:	08 00 00 20 4e 0a 00 00 00 c8 0c 33 33 33 33 0f     ... N......3333.
     1ef:	98 6e 12 83 11 41 ef 8d 21 14 89 3b e6 55 16 cf     .n...A..!..;.U..
     1ff:	fe e6 db 18 d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb     ......K8..|.....
     20f:	e4 24 20 32 84 72 5e 22 81 00 c9 f1 24 ec a1 e5     .$ 2.r^"....$...
     21f:	3d 27 00                                            ='.

00000222 <prvIdleTask>:
     222:	cf 93       	push	r28
     224:	df 93       	push	r29
     226:	1f 92       	push	r1
     228:	1f 92       	push	r1
     22a:	cd b7       	in	r28, 0x3d	; 61
     22c:	de b7       	in	r29, 0x3e	; 62
     22e:	9a 83       	std	Y+2, r25	; 0x02
     230:	89 83       	std	Y+1, r24	; 0x01
     232:	0e 94 38 25 	call	0x4a70	; 0x4a70 <prvCheckTasksWaitingTermination>
     236:	80 91 44 02 	lds	r24, 0x0244
     23a:	82 30       	cpi	r24, 0x02	; 2
     23c:	10 f0       	brcs	.+4      	; 0x242 <prvIdleTask+0x20>
     23e:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
     242:	0e 94 75 0c 	call	0x18ea	; 0x18ea <vApplicationIdleHook>
     246:	f5 cf       	rjmp	.-22     	; 0x232 <prvIdleTask+0x10>

00000248 <__ctors_end>:
     248:	11 24       	eor	r1, r1
     24a:	1f be       	out	0x3f, r1	; 63
     24c:	cf ef       	ldi	r28, 0xFF	; 255
     24e:	d1 e2       	ldi	r29, 0x21	; 33
     250:	de bf       	out	0x3e, r29	; 62
     252:	cd bf       	out	0x3d, r28	; 61
     254:	00 e0       	ldi	r16, 0x00	; 0
     256:	0c bf       	out	0x3c, r16	; 60

00000258 <__do_copy_data>:
     258:	12 e0       	ldi	r17, 0x02	; 2
     25a:	a0 e0       	ldi	r26, 0x00	; 0
     25c:	b2 e0       	ldi	r27, 0x02	; 2
     25e:	ea eb       	ldi	r30, 0xBA	; 186
     260:	f7 e6       	ldi	r31, 0x67	; 103
     262:	00 e0       	ldi	r16, 0x00	; 0
     264:	0b bf       	out	0x3b, r16	; 59
     266:	02 c0       	rjmp	.+4      	; 0x26c <__do_copy_data+0x14>
     268:	07 90       	elpm	r0, Z+
     26a:	0d 92       	st	X+, r0
     26c:	ae 31       	cpi	r26, 0x1E	; 30
     26e:	b1 07       	cpc	r27, r17
     270:	d9 f7       	brne	.-10     	; 0x268 <__do_copy_data+0x10>

00000272 <__do_clear_bss>:
     272:	22 e0       	ldi	r18, 0x02	; 2
     274:	ae e1       	ldi	r26, 0x1E	; 30
     276:	b2 e0       	ldi	r27, 0x02	; 2
     278:	01 c0       	rjmp	.+2      	; 0x27c <.do_clear_bss_start>

0000027a <.do_clear_bss_loop>:
     27a:	1d 92       	st	X+, r1

0000027c <.do_clear_bss_start>:
     27c:	aa 3b       	cpi	r26, 0xBA	; 186
     27e:	b2 07       	cpc	r27, r18
     280:	e1 f7       	brne	.-8      	; 0x27a <.do_clear_bss_loop>
     282:	0e 94 57 0f 	call	0x1eae	; 0x1eae <main>
     286:	0c 94 db 33 	jmp	0x67b6	; 0x67b6 <_exit>

0000028a <__bad_interrupt>:
     28a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000028e <usart_init>:
     28e:	cf 93       	push	r28
     290:	df 93       	push	r29
     292:	cd b7       	in	r28, 0x3d	; 61
     294:	de b7       	in	r29, 0x3e	; 62
     296:	80 ec       	ldi	r24, 0xC0	; 192
     298:	90 e0       	ldi	r25, 0x00	; 0
     29a:	20 ec       	ldi	r18, 0xC0	; 192
     29c:	30 e0       	ldi	r19, 0x00	; 0
     29e:	f9 01       	movw	r30, r18
     2a0:	20 81       	ld	r18, Z
     2a2:	22 60       	ori	r18, 0x02	; 2
     2a4:	fc 01       	movw	r30, r24
     2a6:	20 83       	st	Z, r18
     2a8:	84 ec       	ldi	r24, 0xC4	; 196
     2aa:	90 e0       	ldi	r25, 0x00	; 0
     2ac:	2b e8       	ldi	r18, 0x8B	; 139
     2ae:	35 e0       	ldi	r19, 0x05	; 5
     2b0:	fc 01       	movw	r30, r24
     2b2:	31 83       	std	Z+1, r19	; 0x01
     2b4:	20 83       	st	Z, r18
     2b6:	82 ec       	ldi	r24, 0xC2	; 194
     2b8:	90 e0       	ldi	r25, 0x00	; 0
     2ba:	26 e0       	ldi	r18, 0x06	; 6
     2bc:	fc 01       	movw	r30, r24
     2be:	20 83       	st	Z, r18
     2c0:	81 ec       	ldi	r24, 0xC1	; 193
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	28 e1       	ldi	r18, 0x18	; 24
     2c6:	fc 01       	movw	r30, r24
     2c8:	20 83       	st	Z, r18
     2ca:	df 91       	pop	r29
     2cc:	cf 91       	pop	r28
     2ce:	08 95       	ret

000002d0 <put_char>:
	UCSR0B = (1 << TXEN0) | (1 << RXEN0);			// Enable module TX adn RX
	//fdevopen((int (*)(char, FILE*))put_char, (int (*)(FILE*))get_char);		// For use with printf and scanf
}

// TX data char through USART
int put_char (int dato){
     2d0:	cf 93       	push	r28
     2d2:	df 93       	push	r29
     2d4:	1f 92       	push	r1
     2d6:	1f 92       	push	r1
     2d8:	cd b7       	in	r28, 0x3d	; 61
     2da:	de b7       	in	r29, 0x3e	; 62
     2dc:	9a 83       	std	Y+2, r25	; 0x02
     2de:	89 83       	std	Y+1, r24	; 0x01
	while ((UCSR0A & (1 << UDRE0)) == 0);	// Wait for empty buffer
     2e0:	00 00       	nop
     2e2:	80 ec       	ldi	r24, 0xC0	; 192
     2e4:	90 e0       	ldi	r25, 0x00	; 0
     2e6:	fc 01       	movw	r30, r24
     2e8:	80 81       	ld	r24, Z
     2ea:	88 2f       	mov	r24, r24
     2ec:	90 e0       	ldi	r25, 0x00	; 0
     2ee:	80 72       	andi	r24, 0x20	; 32
     2f0:	99 27       	eor	r25, r25
     2f2:	00 97       	sbiw	r24, 0x00	; 0
     2f4:	b1 f3       	breq	.-20     	; 0x2e2 <put_char+0x12>
	UDR0 = dato;
     2f6:	86 ec       	ldi	r24, 0xC6	; 198
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	29 81       	ldd	r18, Y+1	; 0x01
     2fc:	fc 01       	movw	r30, r24
     2fe:	20 83       	st	Z, r18
	return dato;
     300:	89 81       	ldd	r24, Y+1	; 0x01
     302:	9a 81       	ldd	r25, Y+2	; 0x02
}
     304:	0f 90       	pop	r0
     306:	0f 90       	pop	r0
     308:	df 91       	pop	r29
     30a:	cf 91       	pop	r28
     30c:	08 95       	ret

0000030e <put_string>:

// TX data string ASCII through USART
void put_string(char *s){
     30e:	cf 93       	push	r28
     310:	df 93       	push	r29
     312:	1f 92       	push	r1
     314:	1f 92       	push	r1
     316:	cd b7       	in	r28, 0x3d	; 61
     318:	de b7       	in	r29, 0x3e	; 62
     31a:	9a 83       	std	Y+2, r25	; 0x02
     31c:	89 83       	std	Y+1, r24	; 0x01
	while (*s){
     31e:	0d c0       	rjmp	.+26     	; 0x33a <put_string+0x2c>
		put_char(*s);
     320:	89 81       	ldd	r24, Y+1	; 0x01
     322:	9a 81       	ldd	r25, Y+2	; 0x02
     324:	fc 01       	movw	r30, r24
     326:	80 81       	ld	r24, Z
     328:	88 2f       	mov	r24, r24
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	0e 94 68 01 	call	0x2d0	; 0x2d0 <put_char>
		s++;
     330:	89 81       	ldd	r24, Y+1	; 0x01
     332:	9a 81       	ldd	r25, Y+2	; 0x02
     334:	01 96       	adiw	r24, 0x01	; 1
     336:	9a 83       	std	Y+2, r25	; 0x02
     338:	89 83       	std	Y+1, r24	; 0x01
	return dato;
}

// TX data string ASCII through USART
void put_string(char *s){
	while (*s){
     33a:	89 81       	ldd	r24, Y+1	; 0x01
     33c:	9a 81       	ldd	r25, Y+2	; 0x02
     33e:	fc 01       	movw	r30, r24
     340:	80 81       	ld	r24, Z
     342:	88 23       	and	r24, r24
     344:	69 f7       	brne	.-38     	; 0x320 <put_string+0x12>
		put_char(*s);
		s++;
	}
}
     346:	0f 90       	pop	r0
     348:	0f 90       	pop	r0
     34a:	df 91       	pop	r29
     34c:	cf 91       	pop	r28
     34e:	08 95       	ret

00000350 <put_int>:

// TX integer variable through USART
void put_int (int dato){
     350:	cf 93       	push	r28
     352:	df 93       	push	r29
     354:	cd b7       	in	r28, 0x3d	; 61
     356:	de b7       	in	r29, 0x3e	; 62
     358:	66 97       	sbiw	r28, 0x16	; 22
     35a:	0f b6       	in	r0, 0x3f	; 63
     35c:	f8 94       	cli
     35e:	de bf       	out	0x3e, r29	; 62
     360:	0f be       	out	0x3f, r0	; 63
     362:	cd bf       	out	0x3d, r28	; 61
     364:	9e 8b       	std	Y+22, r25	; 0x16
     366:	8d 8b       	std	Y+21, r24	; 0x15
	char s[20];
	itoa(dato,s,10);	// Converting data integer to ASCII
     368:	8d 89       	ldd	r24, Y+21	; 0x15
     36a:	9e 89       	ldd	r25, Y+22	; 0x16
     36c:	4a e0       	ldi	r20, 0x0A	; 10
     36e:	50 e0       	ldi	r21, 0x00	; 0
     370:	9e 01       	movw	r18, r28
     372:	2f 5f       	subi	r18, 0xFF	; 255
     374:	3f 4f       	sbci	r19, 0xFF	; 255
     376:	b9 01       	movw	r22, r18
     378:	0e 94 53 2f 	call	0x5ea6	; 0x5ea6 <itoa>
	put_string(s);
     37c:	ce 01       	movw	r24, r28
     37e:	01 96       	adiw	r24, 0x01	; 1
     380:	0e 94 87 01 	call	0x30e	; 0x30e <put_string>
}
     384:	66 96       	adiw	r28, 0x16	; 22
     386:	0f b6       	in	r0, 0x3f	; 63
     388:	f8 94       	cli
     38a:	de bf       	out	0x3e, r29	; 62
     38c:	0f be       	out	0x3f, r0	; 63
     38e:	cd bf       	out	0x3d, r28	; 61
     390:	df 91       	pop	r29
     392:	cf 91       	pop	r28
     394:	08 95       	ret

00000396 <put_long>:

// TX long variable through USART
void put_long (long dato){
     396:	cf 93       	push	r28
     398:	df 93       	push	r29
     39a:	cd b7       	in	r28, 0x3d	; 61
     39c:	de b7       	in	r29, 0x3e	; 62
     39e:	68 97       	sbiw	r28, 0x18	; 24
     3a0:	0f b6       	in	r0, 0x3f	; 63
     3a2:	f8 94       	cli
     3a4:	de bf       	out	0x3e, r29	; 62
     3a6:	0f be       	out	0x3f, r0	; 63
     3a8:	cd bf       	out	0x3d, r28	; 61
     3aa:	6d 8b       	std	Y+21, r22	; 0x15
     3ac:	7e 8b       	std	Y+22, r23	; 0x16
     3ae:	8f 8b       	std	Y+23, r24	; 0x17
     3b0:	98 8f       	std	Y+24, r25	; 0x18
	char s[20];
	ltoa(dato,s,10);	// Converting data integer to ASCII
     3b2:	8d 89       	ldd	r24, Y+21	; 0x15
     3b4:	9e 89       	ldd	r25, Y+22	; 0x16
     3b6:	af 89       	ldd	r26, Y+23	; 0x17
     3b8:	b8 8d       	ldd	r27, Y+24	; 0x18
     3ba:	2a e0       	ldi	r18, 0x0A	; 10
     3bc:	30 e0       	ldi	r19, 0x00	; 0
     3be:	ae 01       	movw	r20, r28
     3c0:	4f 5f       	subi	r20, 0xFF	; 255
     3c2:	5f 4f       	sbci	r21, 0xFF	; 255
     3c4:	bc 01       	movw	r22, r24
     3c6:	cd 01       	movw	r24, r26
     3c8:	0e 94 69 2f 	call	0x5ed2	; 0x5ed2 <ltoa>
	put_string(s);
     3cc:	ce 01       	movw	r24, r28
     3ce:	01 96       	adiw	r24, 0x01	; 1
     3d0:	0e 94 87 01 	call	0x30e	; 0x30e <put_string>
}
     3d4:	68 96       	adiw	r28, 0x18	; 24
     3d6:	0f b6       	in	r0, 0x3f	; 63
     3d8:	f8 94       	cli
     3da:	de bf       	out	0x3e, r29	; 62
     3dc:	0f be       	out	0x3f, r0	; 63
     3de:	cd bf       	out	0x3d, r28	; 61
     3e0:	df 91       	pop	r29
     3e2:	cf 91       	pop	r28
     3e4:	08 95       	ret

000003e6 <put_float>:

// Tx float variable through USART
void put_float (float dato){
     3e6:	0f 93       	push	r16
     3e8:	1f 93       	push	r17
     3ea:	cf 93       	push	r28
     3ec:	df 93       	push	r29
     3ee:	cd b7       	in	r28, 0x3d	; 61
     3f0:	de b7       	in	r29, 0x3e	; 62
     3f2:	68 97       	sbiw	r28, 0x18	; 24
     3f4:	0f b6       	in	r0, 0x3f	; 63
     3f6:	f8 94       	cli
     3f8:	de bf       	out	0x3e, r29	; 62
     3fa:	0f be       	out	0x3f, r0	; 63
     3fc:	cd bf       	out	0x3d, r28	; 61
     3fe:	6d 8b       	std	Y+21, r22	; 0x15
     400:	7e 8b       	std	Y+22, r23	; 0x16
     402:	8f 8b       	std	Y+23, r24	; 0x17
     404:	98 8f       	std	Y+24, r25	; 0x18
	char s[20];
	dtostrf(dato,8,3,s);	// Converting data integer to ASCII. 3 Decimals
     406:	8d 89       	ldd	r24, Y+21	; 0x15
     408:	9e 89       	ldd	r25, Y+22	; 0x16
     40a:	af 89       	ldd	r26, Y+23	; 0x17
     40c:	b8 8d       	ldd	r27, Y+24	; 0x18
     40e:	9e 01       	movw	r18, r28
     410:	2f 5f       	subi	r18, 0xFF	; 255
     412:	3f 4f       	sbci	r19, 0xFF	; 255
     414:	89 01       	movw	r16, r18
     416:	23 e0       	ldi	r18, 0x03	; 3
     418:	48 e0       	ldi	r20, 0x08	; 8
     41a:	bc 01       	movw	r22, r24
     41c:	cd 01       	movw	r24, r26
     41e:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <dtostrf>
	put_string(s);
     422:	ce 01       	movw	r24, r28
     424:	01 96       	adiw	r24, 0x01	; 1
     426:	0e 94 87 01 	call	0x30e	; 0x30e <put_string>
}
     42a:	68 96       	adiw	r28, 0x18	; 24
     42c:	0f b6       	in	r0, 0x3f	; 63
     42e:	f8 94       	cli
     430:	de bf       	out	0x3e, r29	; 62
     432:	0f be       	out	0x3f, r0	; 63
     434:	cd bf       	out	0x3d, r28	; 61
     436:	df 91       	pop	r29
     438:	cf 91       	pop	r28
     43a:	1f 91       	pop	r17
     43c:	0f 91       	pop	r16
     43e:	08 95       	ret

00000440 <get_char>:

// Rx data char through USART
int get_char(void){
     440:	cf 93       	push	r28
     442:	df 93       	push	r29
     444:	1f 92       	push	r1
     446:	1f 92       	push	r1
     448:	cd b7       	in	r28, 0x3d	; 61
     44a:	de b7       	in	r29, 0x3e	; 62
	int dato;
	while ((UCSR0A & (1<<RXC0)) == 0 );		// Wait for data in buffer
     44c:	00 00       	nop
     44e:	80 ec       	ldi	r24, 0xC0	; 192
     450:	90 e0       	ldi	r25, 0x00	; 0
     452:	fc 01       	movw	r30, r24
     454:	80 81       	ld	r24, Z
     456:	88 23       	and	r24, r24
     458:	d4 f7       	brge	.-12     	; 0x44e <get_char+0xe>
	dato = UDR0;
     45a:	86 ec       	ldi	r24, 0xC6	; 198
     45c:	90 e0       	ldi	r25, 0x00	; 0
     45e:	fc 01       	movw	r30, r24
     460:	80 81       	ld	r24, Z
     462:	88 2f       	mov	r24, r24
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	9a 83       	std	Y+2, r25	; 0x02
     468:	89 83       	std	Y+1, r24	; 0x01
	return dato;
     46a:	89 81       	ldd	r24, Y+1	; 0x01
     46c:	9a 81       	ldd	r25, Y+2	; 0x02
}
     46e:	0f 90       	pop	r0
     470:	0f 90       	pop	r0
     472:	df 91       	pop	r29
     474:	cf 91       	pop	r28
     476:	08 95       	ret

00000478 <get_float>:

// Rx string  through USART
float get_float(void){
     478:	cf 93       	push	r28
     47a:	df 93       	push	r29
     47c:	cd b7       	in	r28, 0x3d	; 61
     47e:	de b7       	in	r29, 0x3e	; 62
     480:	6a 97       	sbiw	r28, 0x1a	; 26
     482:	0f b6       	in	r0, 0x3f	; 63
     484:	f8 94       	cli
     486:	de bf       	out	0x3e, r29	; 62
     488:	0f be       	out	0x3f, r0	; 63
     48a:	cd bf       	out	0x3d, r28	; 61
	char k[20];
	float f;
	int i = 0;
     48c:	1a 82       	std	Y+2, r1	; 0x02
     48e:	19 82       	std	Y+1, r1	; 0x01
	while (1) {
		k[i] = get_char();
     490:	0e 94 20 02 	call	0x440	; 0x440 <get_char>
     494:	48 2f       	mov	r20, r24
     496:	9e 01       	movw	r18, r28
     498:	29 5f       	subi	r18, 0xF9	; 249
     49a:	3f 4f       	sbci	r19, 0xFF	; 255
     49c:	89 81       	ldd	r24, Y+1	; 0x01
     49e:	9a 81       	ldd	r25, Y+2	; 0x02
     4a0:	82 0f       	add	r24, r18
     4a2:	93 1f       	adc	r25, r19
     4a4:	fc 01       	movw	r30, r24
     4a6:	40 83       	st	Z, r20
		if (k[i] == '\n') break;
     4a8:	9e 01       	movw	r18, r28
     4aa:	29 5f       	subi	r18, 0xF9	; 249
     4ac:	3f 4f       	sbci	r19, 0xFF	; 255
     4ae:	89 81       	ldd	r24, Y+1	; 0x01
     4b0:	9a 81       	ldd	r25, Y+2	; 0x02
     4b2:	82 0f       	add	r24, r18
     4b4:	93 1f       	adc	r25, r19
     4b6:	fc 01       	movw	r30, r24
     4b8:	80 81       	ld	r24, Z
     4ba:	8a 30       	cpi	r24, 0x0A	; 10
     4bc:	09 f4       	brne	.+2      	; 0x4c0 <get_float+0x48>
     4be:	06 c0       	rjmp	.+12     	; 0x4cc <get_float+0x54>
		i++;
     4c0:	89 81       	ldd	r24, Y+1	; 0x01
     4c2:	9a 81       	ldd	r25, Y+2	; 0x02
     4c4:	01 96       	adiw	r24, 0x01	; 1
     4c6:	9a 83       	std	Y+2, r25	; 0x02
     4c8:	89 83       	std	Y+1, r24	; 0x01
	}
     4ca:	e2 cf       	rjmp	.-60     	; 0x490 <get_float+0x18>
	f = atof(k);
     4cc:	ce 01       	movw	r24, r28
     4ce:	07 96       	adiw	r24, 0x07	; 7
     4d0:	0e 94 21 2f 	call	0x5e42	; 0x5e42 <atof>
     4d4:	dc 01       	movw	r26, r24
     4d6:	cb 01       	movw	r24, r22
     4d8:	8b 83       	std	Y+3, r24	; 0x03
     4da:	9c 83       	std	Y+4, r25	; 0x04
     4dc:	ad 83       	std	Y+5, r26	; 0x05
     4de:	be 83       	std	Y+6, r27	; 0x06
	put_float(f);		// Echo print
     4e0:	8b 81       	ldd	r24, Y+3	; 0x03
     4e2:	9c 81       	ldd	r25, Y+4	; 0x04
     4e4:	ad 81       	ldd	r26, Y+5	; 0x05
     4e6:	be 81       	ldd	r27, Y+6	; 0x06
     4e8:	bc 01       	movw	r22, r24
     4ea:	cd 01       	movw	r24, r26
     4ec:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <put_float>
	put_string("\n");
     4f0:	86 e0       	ldi	r24, 0x06	; 6
     4f2:	92 e0       	ldi	r25, 0x02	; 2
     4f4:	0e 94 87 01 	call	0x30e	; 0x30e <put_string>
	return f;
     4f8:	8b 81       	ldd	r24, Y+3	; 0x03
     4fa:	9c 81       	ldd	r25, Y+4	; 0x04
     4fc:	ad 81       	ldd	r26, Y+5	; 0x05
     4fe:	be 81       	ldd	r27, Y+6	; 0x06
}
     500:	bc 01       	movw	r22, r24
     502:	cd 01       	movw	r24, r26
     504:	6a 96       	adiw	r28, 0x1a	; 26
     506:	0f b6       	in	r0, 0x3f	; 63
     508:	f8 94       	cli
     50a:	de bf       	out	0x3e, r29	; 62
     50c:	0f be       	out	0x3f, r0	; 63
     50e:	cd bf       	out	0x3d, r28	; 61
     510:	df 91       	pop	r29
     512:	cf 91       	pop	r28
     514:	08 95       	ret

00000516 <get_int>:

// Rx string  through USART
int get_int(void){
     516:	cf 93       	push	r28
     518:	df 93       	push	r29
     51a:	cd b7       	in	r28, 0x3d	; 61
     51c:	de b7       	in	r29, 0x3e	; 62
     51e:	68 97       	sbiw	r28, 0x18	; 24
     520:	0f b6       	in	r0, 0x3f	; 63
     522:	f8 94       	cli
     524:	de bf       	out	0x3e, r29	; 62
     526:	0f be       	out	0x3f, r0	; 63
     528:	cd bf       	out	0x3d, r28	; 61
	char k[20];
	int data;
	int i = 0;
     52a:	1a 82       	std	Y+2, r1	; 0x02
     52c:	19 82       	std	Y+1, r1	; 0x01
	while (1) {
		k[i] = get_char();
     52e:	0e 94 20 02 	call	0x440	; 0x440 <get_char>
     532:	48 2f       	mov	r20, r24
     534:	9e 01       	movw	r18, r28
     536:	2b 5f       	subi	r18, 0xFB	; 251
     538:	3f 4f       	sbci	r19, 0xFF	; 255
     53a:	89 81       	ldd	r24, Y+1	; 0x01
     53c:	9a 81       	ldd	r25, Y+2	; 0x02
     53e:	82 0f       	add	r24, r18
     540:	93 1f       	adc	r25, r19
     542:	fc 01       	movw	r30, r24
     544:	40 83       	st	Z, r20
		if (k[i] == '\n') break;
     546:	9e 01       	movw	r18, r28
     548:	2b 5f       	subi	r18, 0xFB	; 251
     54a:	3f 4f       	sbci	r19, 0xFF	; 255
     54c:	89 81       	ldd	r24, Y+1	; 0x01
     54e:	9a 81       	ldd	r25, Y+2	; 0x02
     550:	82 0f       	add	r24, r18
     552:	93 1f       	adc	r25, r19
     554:	fc 01       	movw	r30, r24
     556:	80 81       	ld	r24, Z
     558:	8a 30       	cpi	r24, 0x0A	; 10
     55a:	09 f4       	brne	.+2      	; 0x55e <get_int+0x48>
     55c:	06 c0       	rjmp	.+12     	; 0x56a <get_int+0x54>
		i++;
     55e:	89 81       	ldd	r24, Y+1	; 0x01
     560:	9a 81       	ldd	r25, Y+2	; 0x02
     562:	01 96       	adiw	r24, 0x01	; 1
     564:	9a 83       	std	Y+2, r25	; 0x02
     566:	89 83       	std	Y+1, r24	; 0x01
	}
     568:	e2 cf       	rjmp	.-60     	; 0x52e <get_int+0x18>
	data = atoi(k);			// ASCII to data int
     56a:	ce 01       	movw	r24, r28
     56c:	05 96       	adiw	r24, 0x05	; 5
     56e:	0e 94 25 2f 	call	0x5e4a	; 0x5e4a <atoi>
     572:	9c 83       	std	Y+4, r25	; 0x04
     574:	8b 83       	std	Y+3, r24	; 0x03
	put_int(data);			// Echo print
     576:	8b 81       	ldd	r24, Y+3	; 0x03
     578:	9c 81       	ldd	r25, Y+4	; 0x04
     57a:	0e 94 a8 01 	call	0x350	; 0x350 <put_int>
	put_string("\n");
     57e:	86 e0       	ldi	r24, 0x06	; 6
     580:	92 e0       	ldi	r25, 0x02	; 2
     582:	0e 94 87 01 	call	0x30e	; 0x30e <put_string>
	return data;
     586:	8b 81       	ldd	r24, Y+3	; 0x03
     588:	9c 81       	ldd	r25, Y+4	; 0x04
}
     58a:	68 96       	adiw	r28, 0x18	; 24
     58c:	0f b6       	in	r0, 0x3f	; 63
     58e:	f8 94       	cli
     590:	de bf       	out	0x3e, r29	; 62
     592:	0f be       	out	0x3f, r0	; 63
     594:	cd bf       	out	0x3d, r28	; 61
     596:	df 91       	pop	r29
     598:	cf 91       	pop	r28
     59a:	08 95       	ret

0000059c <i2c_init>:

/*************************************************************************
 Initialization of the I2C bus interface. Need to be called only once
*************************************************************************/
void i2c_init(void)
{
     59c:	cf 93       	push	r28
     59e:	df 93       	push	r29
     5a0:	cd b7       	in	r28, 0x3d	; 61
     5a2:	de b7       	in	r29, 0x3e	; 62
  /* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */

  TWSR = 0;                         /* no prescaler */
     5a4:	89 eb       	ldi	r24, 0xB9	; 185
     5a6:	90 e0       	ldi	r25, 0x00	; 0
     5a8:	fc 01       	movw	r30, r24
     5aa:	10 82       	st	Z, r1
  TWBR = ((F_CPU/SCL_CLOCK)-16)/2;  /* must be > 10 for stable operation */
     5ac:	88 eb       	ldi	r24, 0xB8	; 184
     5ae:	90 e0       	ldi	r25, 0x00	; 0
     5b0:	28 e4       	ldi	r18, 0x48	; 72
     5b2:	fc 01       	movw	r30, r24
     5b4:	20 83       	st	Z, r18

}/* i2c_init */
     5b6:	df 91       	pop	r29
     5b8:	cf 91       	pop	r28
     5ba:	08 95       	ret

000005bc <i2c_start>:
/*************************************************************************
  Issues a start condition and sends address and transfer direction.
  return 0 = device accessible, 1= failed to access device
*************************************************************************/
unsigned char i2c_start(unsigned char address)
{
     5bc:	cf 93       	push	r28
     5be:	df 93       	push	r29
     5c0:	00 d0       	rcall	.+0      	; 0x5c2 <i2c_start+0x6>
     5c2:	00 d0       	rcall	.+0      	; 0x5c4 <i2c_start+0x8>
     5c4:	cd b7       	in	r28, 0x3d	; 61
     5c6:	de b7       	in	r29, 0x3e	; 62
     5c8:	8e 83       	std	Y+6, r24	; 0x06
	uint32_t  i2c_timer = 0;
     5ca:	19 82       	std	Y+1, r1	; 0x01
     5cc:	1a 82       	std	Y+2, r1	; 0x02
     5ce:	1b 82       	std	Y+3, r1	; 0x03
     5d0:	1c 82       	std	Y+4, r1	; 0x04
    uint8_t   twst;

	// send START condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
     5d2:	8c eb       	ldi	r24, 0xBC	; 188
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	24 ea       	ldi	r18, 0xA4	; 164
     5d8:	fc 01       	movw	r30, r24
     5da:	20 83       	st	Z, r18

	// wait until transmission completed
	i2c_timer = I2C_TIMER_DELAY;
     5dc:	8f ef       	ldi	r24, 0xFF	; 255
     5de:	90 e0       	ldi	r25, 0x00	; 0
     5e0:	a0 e0       	ldi	r26, 0x00	; 0
     5e2:	b0 e0       	ldi	r27, 0x00	; 0
     5e4:	89 83       	std	Y+1, r24	; 0x01
     5e6:	9a 83       	std	Y+2, r25	; 0x02
     5e8:	ab 83       	std	Y+3, r26	; 0x03
     5ea:	bc 83       	std	Y+4, r27	; 0x04
	while(!(TWCR & (1<<TWINT)) && i2c_timer--);
     5ec:	00 00       	nop
     5ee:	8c eb       	ldi	r24, 0xBC	; 188
     5f0:	90 e0       	ldi	r25, 0x00	; 0
     5f2:	fc 01       	movw	r30, r24
     5f4:	80 81       	ld	r24, Z
     5f6:	88 23       	and	r24, r24
     5f8:	94 f0       	brlt	.+36     	; 0x61e <i2c_start+0x62>
     5fa:	89 81       	ldd	r24, Y+1	; 0x01
     5fc:	9a 81       	ldd	r25, Y+2	; 0x02
     5fe:	ab 81       	ldd	r26, Y+3	; 0x03
     600:	bc 81       	ldd	r27, Y+4	; 0x04
     602:	9c 01       	movw	r18, r24
     604:	ad 01       	movw	r20, r26
     606:	21 50       	subi	r18, 0x01	; 1
     608:	31 09       	sbc	r19, r1
     60a:	41 09       	sbc	r20, r1
     60c:	51 09       	sbc	r21, r1
     60e:	29 83       	std	Y+1, r18	; 0x01
     610:	3a 83       	std	Y+2, r19	; 0x02
     612:	4b 83       	std	Y+3, r20	; 0x03
     614:	5c 83       	std	Y+4, r21	; 0x04
     616:	00 97       	sbiw	r24, 0x00	; 0
     618:	a1 05       	cpc	r26, r1
     61a:	b1 05       	cpc	r27, r1
     61c:	41 f7       	brne	.-48     	; 0x5ee <i2c_start+0x32>
	if(i2c_timer == 0)
     61e:	89 81       	ldd	r24, Y+1	; 0x01
     620:	9a 81       	ldd	r25, Y+2	; 0x02
     622:	ab 81       	ldd	r26, Y+3	; 0x03
     624:	bc 81       	ldd	r27, Y+4	; 0x04
     626:	00 97       	sbiw	r24, 0x00	; 0
     628:	a1 05       	cpc	r26, r1
     62a:	b1 05       	cpc	r27, r1
     62c:	11 f4       	brne	.+4      	; 0x632 <i2c_start+0x76>
		return 1;
     62e:	81 e0       	ldi	r24, 0x01	; 1
     630:	52 c0       	rjmp	.+164    	; 0x6d6 <i2c_start+0x11a>

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
     632:	89 eb       	ldi	r24, 0xB9	; 185
     634:	90 e0       	ldi	r25, 0x00	; 0
     636:	fc 01       	movw	r30, r24
     638:	80 81       	ld	r24, Z
     63a:	88 7f       	andi	r24, 0xF8	; 248
     63c:	8d 83       	std	Y+5, r24	; 0x05
	if ( (twst != TW_START) && (twst != TW_REP_START)) return 1;
     63e:	8d 81       	ldd	r24, Y+5	; 0x05
     640:	88 30       	cpi	r24, 0x08	; 8
     642:	29 f0       	breq	.+10     	; 0x64e <i2c_start+0x92>
     644:	8d 81       	ldd	r24, Y+5	; 0x05
     646:	80 31       	cpi	r24, 0x10	; 16
     648:	11 f0       	breq	.+4      	; 0x64e <i2c_start+0x92>
     64a:	81 e0       	ldi	r24, 0x01	; 1
     64c:	44 c0       	rjmp	.+136    	; 0x6d6 <i2c_start+0x11a>

	// send device address
	TWDR = address;
     64e:	8b eb       	ldi	r24, 0xBB	; 187
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	2e 81       	ldd	r18, Y+6	; 0x06
     654:	fc 01       	movw	r30, r24
     656:	20 83       	st	Z, r18
	TWCR = (1<<TWINT) | (1<<TWEN);
     658:	8c eb       	ldi	r24, 0xBC	; 188
     65a:	90 e0       	ldi	r25, 0x00	; 0
     65c:	24 e8       	ldi	r18, 0x84	; 132
     65e:	fc 01       	movw	r30, r24
     660:	20 83       	st	Z, r18

	// wail until transmission completed and ACK/NACK has been received
	i2c_timer = I2C_TIMER_DELAY;
     662:	8f ef       	ldi	r24, 0xFF	; 255
     664:	90 e0       	ldi	r25, 0x00	; 0
     666:	a0 e0       	ldi	r26, 0x00	; 0
     668:	b0 e0       	ldi	r27, 0x00	; 0
     66a:	89 83       	std	Y+1, r24	; 0x01
     66c:	9a 83       	std	Y+2, r25	; 0x02
     66e:	ab 83       	std	Y+3, r26	; 0x03
     670:	bc 83       	std	Y+4, r27	; 0x04
	while(!(TWCR & (1<<TWINT)) && i2c_timer--);
     672:	00 00       	nop
     674:	8c eb       	ldi	r24, 0xBC	; 188
     676:	90 e0       	ldi	r25, 0x00	; 0
     678:	fc 01       	movw	r30, r24
     67a:	80 81       	ld	r24, Z
     67c:	88 23       	and	r24, r24
     67e:	94 f0       	brlt	.+36     	; 0x6a4 <i2c_start+0xe8>
     680:	89 81       	ldd	r24, Y+1	; 0x01
     682:	9a 81       	ldd	r25, Y+2	; 0x02
     684:	ab 81       	ldd	r26, Y+3	; 0x03
     686:	bc 81       	ldd	r27, Y+4	; 0x04
     688:	9c 01       	movw	r18, r24
     68a:	ad 01       	movw	r20, r26
     68c:	21 50       	subi	r18, 0x01	; 1
     68e:	31 09       	sbc	r19, r1
     690:	41 09       	sbc	r20, r1
     692:	51 09       	sbc	r21, r1
     694:	29 83       	std	Y+1, r18	; 0x01
     696:	3a 83       	std	Y+2, r19	; 0x02
     698:	4b 83       	std	Y+3, r20	; 0x03
     69a:	5c 83       	std	Y+4, r21	; 0x04
     69c:	00 97       	sbiw	r24, 0x00	; 0
     69e:	a1 05       	cpc	r26, r1
     6a0:	b1 05       	cpc	r27, r1
     6a2:	41 f7       	brne	.-48     	; 0x674 <i2c_start+0xb8>
	if(i2c_timer == 0)
     6a4:	89 81       	ldd	r24, Y+1	; 0x01
     6a6:	9a 81       	ldd	r25, Y+2	; 0x02
     6a8:	ab 81       	ldd	r26, Y+3	; 0x03
     6aa:	bc 81       	ldd	r27, Y+4	; 0x04
     6ac:	00 97       	sbiw	r24, 0x00	; 0
     6ae:	a1 05       	cpc	r26, r1
     6b0:	b1 05       	cpc	r27, r1
     6b2:	11 f4       	brne	.+4      	; 0x6b8 <i2c_start+0xfc>
		return 1;
     6b4:	81 e0       	ldi	r24, 0x01	; 1
     6b6:	0f c0       	rjmp	.+30     	; 0x6d6 <i2c_start+0x11a>

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
     6b8:	89 eb       	ldi	r24, 0xB9	; 185
     6ba:	90 e0       	ldi	r25, 0x00	; 0
     6bc:	fc 01       	movw	r30, r24
     6be:	80 81       	ld	r24, Z
     6c0:	88 7f       	andi	r24, 0xF8	; 248
     6c2:	8d 83       	std	Y+5, r24	; 0x05
	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
     6c4:	8d 81       	ldd	r24, Y+5	; 0x05
     6c6:	88 31       	cpi	r24, 0x18	; 24
     6c8:	29 f0       	breq	.+10     	; 0x6d4 <i2c_start+0x118>
     6ca:	8d 81       	ldd	r24, Y+5	; 0x05
     6cc:	80 34       	cpi	r24, 0x40	; 64
     6ce:	11 f0       	breq	.+4      	; 0x6d4 <i2c_start+0x118>
     6d0:	81 e0       	ldi	r24, 0x01	; 1
     6d2:	01 c0       	rjmp	.+2      	; 0x6d6 <i2c_start+0x11a>

	return 0;
     6d4:	80 e0       	ldi	r24, 0x00	; 0

}/* i2c_start */
     6d6:	26 96       	adiw	r28, 0x06	; 6
     6d8:	0f b6       	in	r0, 0x3f	; 63
     6da:	f8 94       	cli
     6dc:	de bf       	out	0x3e, r29	; 62
     6de:	0f be       	out	0x3f, r0	; 63
     6e0:	cd bf       	out	0x3d, r28	; 61
     6e2:	df 91       	pop	r29
     6e4:	cf 91       	pop	r28
     6e6:	08 95       	ret

000006e8 <i2c_start_wait>:
 If device is busy, use ack polling to wait until device is ready

 Input:   address and transfer direction of I2C device
*************************************************************************/
void i2c_start_wait(unsigned char address)
{
     6e8:	cf 93       	push	r28
     6ea:	df 93       	push	r29
     6ec:	00 d0       	rcall	.+0      	; 0x6ee <i2c_start_wait+0x6>
     6ee:	00 d0       	rcall	.+0      	; 0x6f0 <i2c_start_wait+0x8>
     6f0:	cd b7       	in	r28, 0x3d	; 61
     6f2:	de b7       	in	r29, 0x3e	; 62
     6f4:	8e 83       	std	Y+6, r24	; 0x06
	uint32_t  i2c_timer = 0;
     6f6:	19 82       	std	Y+1, r1	; 0x01
     6f8:	1a 82       	std	Y+2, r1	; 0x02
     6fa:	1b 82       	std	Y+3, r1	; 0x03
     6fc:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t   twst;

    while ( 1 )
    {
	    // send START condition
	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
     6fe:	8c eb       	ldi	r24, 0xBC	; 188
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	24 ea       	ldi	r18, 0xA4	; 164
     704:	fc 01       	movw	r30, r24
     706:	20 83       	st	Z, r18

    	// wait until transmission completed
	    i2c_timer = I2C_TIMER_DELAY;
     708:	8f ef       	ldi	r24, 0xFF	; 255
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	a0 e0       	ldi	r26, 0x00	; 0
     70e:	b0 e0       	ldi	r27, 0x00	; 0
     710:	89 83       	std	Y+1, r24	; 0x01
     712:	9a 83       	std	Y+2, r25	; 0x02
     714:	ab 83       	std	Y+3, r26	; 0x03
     716:	bc 83       	std	Y+4, r27	; 0x04
    	while(!(TWCR & (1<<TWINT)) && i2c_timer--);
     718:	00 00       	nop
     71a:	8c eb       	ldi	r24, 0xBC	; 188
     71c:	90 e0       	ldi	r25, 0x00	; 0
     71e:	fc 01       	movw	r30, r24
     720:	80 81       	ld	r24, Z
     722:	88 23       	and	r24, r24
     724:	94 f0       	brlt	.+36     	; 0x74a <i2c_start_wait+0x62>
     726:	89 81       	ldd	r24, Y+1	; 0x01
     728:	9a 81       	ldd	r25, Y+2	; 0x02
     72a:	ab 81       	ldd	r26, Y+3	; 0x03
     72c:	bc 81       	ldd	r27, Y+4	; 0x04
     72e:	9c 01       	movw	r18, r24
     730:	ad 01       	movw	r20, r26
     732:	21 50       	subi	r18, 0x01	; 1
     734:	31 09       	sbc	r19, r1
     736:	41 09       	sbc	r20, r1
     738:	51 09       	sbc	r21, r1
     73a:	29 83       	std	Y+1, r18	; 0x01
     73c:	3a 83       	std	Y+2, r19	; 0x02
     73e:	4b 83       	std	Y+3, r20	; 0x03
     740:	5c 83       	std	Y+4, r21	; 0x04
     742:	00 97       	sbiw	r24, 0x00	; 0
     744:	a1 05       	cpc	r26, r1
     746:	b1 05       	cpc	r27, r1
     748:	41 f7       	brne	.-48     	; 0x71a <i2c_start_wait+0x32>

    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
     74a:	89 eb       	ldi	r24, 0xB9	; 185
     74c:	90 e0       	ldi	r25, 0x00	; 0
     74e:	fc 01       	movw	r30, r24
     750:	80 81       	ld	r24, Z
     752:	88 7f       	andi	r24, 0xF8	; 248
     754:	8d 83       	std	Y+5, r24	; 0x05
    	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
     756:	8d 81       	ldd	r24, Y+5	; 0x05
     758:	88 30       	cpi	r24, 0x08	; 8
     75a:	21 f0       	breq	.+8      	; 0x764 <i2c_start_wait+0x7c>
     75c:	8d 81       	ldd	r24, Y+5	; 0x05
     75e:	80 31       	cpi	r24, 0x10	; 16
     760:	09 f0       	breq	.+2      	; 0x764 <i2c_start_wait+0x7c>
     762:	63 c0       	rjmp	.+198    	; 0x82a <i2c_start_wait+0x142>

    	// send device address
    	TWDR = address;
     764:	8b eb       	ldi	r24, 0xBB	; 187
     766:	90 e0       	ldi	r25, 0x00	; 0
     768:	2e 81       	ldd	r18, Y+6	; 0x06
     76a:	fc 01       	movw	r30, r24
     76c:	20 83       	st	Z, r18
    	TWCR = (1<<TWINT) | (1<<TWEN);
     76e:	8c eb       	ldi	r24, 0xBC	; 188
     770:	90 e0       	ldi	r25, 0x00	; 0
     772:	24 e8       	ldi	r18, 0x84	; 132
     774:	fc 01       	movw	r30, r24
     776:	20 83       	st	Z, r18

    	// wail until transmission completed
    	i2c_timer = I2C_TIMER_DELAY;
     778:	8f ef       	ldi	r24, 0xFF	; 255
     77a:	90 e0       	ldi	r25, 0x00	; 0
     77c:	a0 e0       	ldi	r26, 0x00	; 0
     77e:	b0 e0       	ldi	r27, 0x00	; 0
     780:	89 83       	std	Y+1, r24	; 0x01
     782:	9a 83       	std	Y+2, r25	; 0x02
     784:	ab 83       	std	Y+3, r26	; 0x03
     786:	bc 83       	std	Y+4, r27	; 0x04
    	while(!(TWCR & (1<<TWINT)) && i2c_timer--);
     788:	00 00       	nop
     78a:	8c eb       	ldi	r24, 0xBC	; 188
     78c:	90 e0       	ldi	r25, 0x00	; 0
     78e:	fc 01       	movw	r30, r24
     790:	80 81       	ld	r24, Z
     792:	88 23       	and	r24, r24
     794:	94 f0       	brlt	.+36     	; 0x7ba <i2c_start_wait+0xd2>
     796:	89 81       	ldd	r24, Y+1	; 0x01
     798:	9a 81       	ldd	r25, Y+2	; 0x02
     79a:	ab 81       	ldd	r26, Y+3	; 0x03
     79c:	bc 81       	ldd	r27, Y+4	; 0x04
     79e:	9c 01       	movw	r18, r24
     7a0:	ad 01       	movw	r20, r26
     7a2:	21 50       	subi	r18, 0x01	; 1
     7a4:	31 09       	sbc	r19, r1
     7a6:	41 09       	sbc	r20, r1
     7a8:	51 09       	sbc	r21, r1
     7aa:	29 83       	std	Y+1, r18	; 0x01
     7ac:	3a 83       	std	Y+2, r19	; 0x02
     7ae:	4b 83       	std	Y+3, r20	; 0x03
     7b0:	5c 83       	std	Y+4, r21	; 0x04
     7b2:	00 97       	sbiw	r24, 0x00	; 0
     7b4:	a1 05       	cpc	r26, r1
     7b6:	b1 05       	cpc	r27, r1
     7b8:	41 f7       	brne	.-48     	; 0x78a <i2c_start_wait+0xa2>

    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
     7ba:	89 eb       	ldi	r24, 0xB9	; 185
     7bc:	90 e0       	ldi	r25, 0x00	; 0
     7be:	fc 01       	movw	r30, r24
     7c0:	80 81       	ld	r24, Z
     7c2:	88 7f       	andi	r24, 0xF8	; 248
     7c4:	8d 83       	std	Y+5, r24	; 0x05
    	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) )
     7c6:	8d 81       	ldd	r24, Y+5	; 0x05
     7c8:	80 32       	cpi	r24, 0x20	; 32
     7ca:	19 f0       	breq	.+6      	; 0x7d2 <i2c_start_wait+0xea>
     7cc:	8d 81       	ldd	r24, Y+5	; 0x05
     7ce:	88 35       	cpi	r24, 0x58	; 88
     7d0:	59 f5       	brne	.+86     	; 0x828 <i2c_start_wait+0x140>
    	{
    	    /* device busy, send stop condition to terminate write operation */
	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
     7d2:	8c eb       	ldi	r24, 0xBC	; 188
     7d4:	90 e0       	ldi	r25, 0x00	; 0
     7d6:	24 e9       	ldi	r18, 0x94	; 148
     7d8:	fc 01       	movw	r30, r24
     7da:	20 83       	st	Z, r18

	        // wait until stop condition is executed and bus released
	        i2c_timer = I2C_TIMER_DELAY;
     7dc:	8f ef       	ldi	r24, 0xFF	; 255
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	a0 e0       	ldi	r26, 0x00	; 0
     7e2:	b0 e0       	ldi	r27, 0x00	; 0
     7e4:	89 83       	std	Y+1, r24	; 0x01
     7e6:	9a 83       	std	Y+2, r25	; 0x02
     7e8:	ab 83       	std	Y+3, r26	; 0x03
     7ea:	bc 83       	std	Y+4, r27	; 0x04
	        while((TWCR & (1<<TWSTO)) && i2c_timer--);
     7ec:	00 00       	nop
     7ee:	8c eb       	ldi	r24, 0xBC	; 188
     7f0:	90 e0       	ldi	r25, 0x00	; 0
     7f2:	fc 01       	movw	r30, r24
     7f4:	80 81       	ld	r24, Z
     7f6:	88 2f       	mov	r24, r24
     7f8:	90 e0       	ldi	r25, 0x00	; 0
     7fa:	80 71       	andi	r24, 0x10	; 16
     7fc:	99 27       	eor	r25, r25
     7fe:	00 97       	sbiw	r24, 0x00	; 0
     800:	91 f0       	breq	.+36     	; 0x826 <i2c_start_wait+0x13e>
     802:	89 81       	ldd	r24, Y+1	; 0x01
     804:	9a 81       	ldd	r25, Y+2	; 0x02
     806:	ab 81       	ldd	r26, Y+3	; 0x03
     808:	bc 81       	ldd	r27, Y+4	; 0x04
     80a:	9c 01       	movw	r18, r24
     80c:	ad 01       	movw	r20, r26
     80e:	21 50       	subi	r18, 0x01	; 1
     810:	31 09       	sbc	r19, r1
     812:	41 09       	sbc	r20, r1
     814:	51 09       	sbc	r21, r1
     816:	29 83       	std	Y+1, r18	; 0x01
     818:	3a 83       	std	Y+2, r19	; 0x02
     81a:	4b 83       	std	Y+3, r20	; 0x03
     81c:	5c 83       	std	Y+4, r21	; 0x04
     81e:	00 97       	sbiw	r24, 0x00	; 0
     820:	a1 05       	cpc	r26, r1
     822:	b1 05       	cpc	r27, r1
     824:	21 f7       	brne	.-56     	; 0x7ee <i2c_start_wait+0x106>

    	    continue;
     826:	01 c0       	rjmp	.+2      	; 0x82a <i2c_start_wait+0x142>
    	}
    	//if( twst != TW_MT_SLA_ACK) return 1;
    	break;
     828:	01 c0       	rjmp	.+2      	; 0x82c <i2c_start_wait+0x144>
     }
     82a:	69 cf       	rjmp	.-302    	; 0x6fe <i2c_start_wait+0x16>

}/* i2c_start_wait */
     82c:	26 96       	adiw	r28, 0x06	; 6
     82e:	0f b6       	in	r0, 0x3f	; 63
     830:	f8 94       	cli
     832:	de bf       	out	0x3e, r29	; 62
     834:	0f be       	out	0x3f, r0	; 63
     836:	cd bf       	out	0x3d, r28	; 61
     838:	df 91       	pop	r29
     83a:	cf 91       	pop	r28
     83c:	08 95       	ret

0000083e <i2c_rep_start>:

 Return:  0 device accessible
          1 failed to access device
*************************************************************************/
unsigned char i2c_rep_start(unsigned char address)
{
     83e:	cf 93       	push	r28
     840:	df 93       	push	r29
     842:	1f 92       	push	r1
     844:	cd b7       	in	r28, 0x3d	; 61
     846:	de b7       	in	r29, 0x3e	; 62
     848:	89 83       	std	Y+1, r24	; 0x01
    return i2c_start( address );
     84a:	89 81       	ldd	r24, Y+1	; 0x01
     84c:	0e 94 de 02 	call	0x5bc	; 0x5bc <i2c_start>

}/* i2c_rep_start */
     850:	0f 90       	pop	r0
     852:	df 91       	pop	r29
     854:	cf 91       	pop	r28
     856:	08 95       	ret

00000858 <i2c_stop>:

/*************************************************************************
 Terminates the data transfer and releases the I2C bus
*************************************************************************/
void i2c_stop(void)
{
     858:	cf 93       	push	r28
     85a:	df 93       	push	r29
     85c:	00 d0       	rcall	.+0      	; 0x85e <i2c_stop+0x6>
     85e:	1f 92       	push	r1
     860:	cd b7       	in	r28, 0x3d	; 61
     862:	de b7       	in	r29, 0x3e	; 62
	uint32_t  i2c_timer = 0;
     864:	19 82       	std	Y+1, r1	; 0x01
     866:	1a 82       	std	Y+2, r1	; 0x02
     868:	1b 82       	std	Y+3, r1	; 0x03
     86a:	1c 82       	std	Y+4, r1	; 0x04

    /* send stop condition */
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
     86c:	8c eb       	ldi	r24, 0xBC	; 188
     86e:	90 e0       	ldi	r25, 0x00	; 0
     870:	24 e9       	ldi	r18, 0x94	; 148
     872:	fc 01       	movw	r30, r24
     874:	20 83       	st	Z, r18

	// wait until stop condition is executed and bus released
	i2c_timer = I2C_TIMER_DELAY;
     876:	8f ef       	ldi	r24, 0xFF	; 255
     878:	90 e0       	ldi	r25, 0x00	; 0
     87a:	a0 e0       	ldi	r26, 0x00	; 0
     87c:	b0 e0       	ldi	r27, 0x00	; 0
     87e:	89 83       	std	Y+1, r24	; 0x01
     880:	9a 83       	std	Y+2, r25	; 0x02
     882:	ab 83       	std	Y+3, r26	; 0x03
     884:	bc 83       	std	Y+4, r27	; 0x04
	while((TWCR & (1<<TWSTO)) && i2c_timer--);
     886:	00 00       	nop
     888:	8c eb       	ldi	r24, 0xBC	; 188
     88a:	90 e0       	ldi	r25, 0x00	; 0
     88c:	fc 01       	movw	r30, r24
     88e:	80 81       	ld	r24, Z
     890:	88 2f       	mov	r24, r24
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	80 71       	andi	r24, 0x10	; 16
     896:	99 27       	eor	r25, r25
     898:	00 97       	sbiw	r24, 0x00	; 0
     89a:	91 f0       	breq	.+36     	; 0x8c0 <i2c_stop+0x68>
     89c:	89 81       	ldd	r24, Y+1	; 0x01
     89e:	9a 81       	ldd	r25, Y+2	; 0x02
     8a0:	ab 81       	ldd	r26, Y+3	; 0x03
     8a2:	bc 81       	ldd	r27, Y+4	; 0x04
     8a4:	9c 01       	movw	r18, r24
     8a6:	ad 01       	movw	r20, r26
     8a8:	21 50       	subi	r18, 0x01	; 1
     8aa:	31 09       	sbc	r19, r1
     8ac:	41 09       	sbc	r20, r1
     8ae:	51 09       	sbc	r21, r1
     8b0:	29 83       	std	Y+1, r18	; 0x01
     8b2:	3a 83       	std	Y+2, r19	; 0x02
     8b4:	4b 83       	std	Y+3, r20	; 0x03
     8b6:	5c 83       	std	Y+4, r21	; 0x04
     8b8:	00 97       	sbiw	r24, 0x00	; 0
     8ba:	a1 05       	cpc	r26, r1
     8bc:	b1 05       	cpc	r27, r1
     8be:	21 f7       	brne	.-56     	; 0x888 <i2c_stop+0x30>

}/* i2c_stop */
     8c0:	0f 90       	pop	r0
     8c2:	0f 90       	pop	r0
     8c4:	0f 90       	pop	r0
     8c6:	0f 90       	pop	r0
     8c8:	df 91       	pop	r29
     8ca:	cf 91       	pop	r28
     8cc:	08 95       	ret

000008ce <i2c_write>:
  Input:    byte to be transfered
  Return:   0 write successful
            1 write failed
*************************************************************************/
unsigned char i2c_write( unsigned char data )
{
     8ce:	cf 93       	push	r28
     8d0:	df 93       	push	r29
     8d2:	00 d0       	rcall	.+0      	; 0x8d4 <i2c_write+0x6>
     8d4:	00 d0       	rcall	.+0      	; 0x8d6 <i2c_write+0x8>
     8d6:	cd b7       	in	r28, 0x3d	; 61
     8d8:	de b7       	in	r29, 0x3e	; 62
     8da:	8e 83       	std	Y+6, r24	; 0x06
	uint32_t  i2c_timer = 0;
     8dc:	19 82       	std	Y+1, r1	; 0x01
     8de:	1a 82       	std	Y+2, r1	; 0x02
     8e0:	1b 82       	std	Y+3, r1	; 0x03
     8e2:	1c 82       	std	Y+4, r1	; 0x04
    uint8_t   twst;

	// send data to the previously addressed device
	TWDR = data;
     8e4:	8b eb       	ldi	r24, 0xBB	; 187
     8e6:	90 e0       	ldi	r25, 0x00	; 0
     8e8:	2e 81       	ldd	r18, Y+6	; 0x06
     8ea:	fc 01       	movw	r30, r24
     8ec:	20 83       	st	Z, r18
	TWCR = (1<<TWINT) | (1<<TWEN);
     8ee:	8c eb       	ldi	r24, 0xBC	; 188
     8f0:	90 e0       	ldi	r25, 0x00	; 0
     8f2:	24 e8       	ldi	r18, 0x84	; 132
     8f4:	fc 01       	movw	r30, r24
     8f6:	20 83       	st	Z, r18

	// wait until transmission completed
	i2c_timer = I2C_TIMER_DELAY;
     8f8:	8f ef       	ldi	r24, 0xFF	; 255
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	a0 e0       	ldi	r26, 0x00	; 0
     8fe:	b0 e0       	ldi	r27, 0x00	; 0
     900:	89 83       	std	Y+1, r24	; 0x01
     902:	9a 83       	std	Y+2, r25	; 0x02
     904:	ab 83       	std	Y+3, r26	; 0x03
     906:	bc 83       	std	Y+4, r27	; 0x04
	while(!(TWCR & (1<<TWINT)) && i2c_timer--);
     908:	00 00       	nop
     90a:	8c eb       	ldi	r24, 0xBC	; 188
     90c:	90 e0       	ldi	r25, 0x00	; 0
     90e:	fc 01       	movw	r30, r24
     910:	80 81       	ld	r24, Z
     912:	88 23       	and	r24, r24
     914:	94 f0       	brlt	.+36     	; 0x93a <i2c_write+0x6c>
     916:	89 81       	ldd	r24, Y+1	; 0x01
     918:	9a 81       	ldd	r25, Y+2	; 0x02
     91a:	ab 81       	ldd	r26, Y+3	; 0x03
     91c:	bc 81       	ldd	r27, Y+4	; 0x04
     91e:	9c 01       	movw	r18, r24
     920:	ad 01       	movw	r20, r26
     922:	21 50       	subi	r18, 0x01	; 1
     924:	31 09       	sbc	r19, r1
     926:	41 09       	sbc	r20, r1
     928:	51 09       	sbc	r21, r1
     92a:	29 83       	std	Y+1, r18	; 0x01
     92c:	3a 83       	std	Y+2, r19	; 0x02
     92e:	4b 83       	std	Y+3, r20	; 0x03
     930:	5c 83       	std	Y+4, r21	; 0x04
     932:	00 97       	sbiw	r24, 0x00	; 0
     934:	a1 05       	cpc	r26, r1
     936:	b1 05       	cpc	r27, r1
     938:	41 f7       	brne	.-48     	; 0x90a <i2c_write+0x3c>
	if(i2c_timer == 0)
     93a:	89 81       	ldd	r24, Y+1	; 0x01
     93c:	9a 81       	ldd	r25, Y+2	; 0x02
     93e:	ab 81       	ldd	r26, Y+3	; 0x03
     940:	bc 81       	ldd	r27, Y+4	; 0x04
     942:	00 97       	sbiw	r24, 0x00	; 0
     944:	a1 05       	cpc	r26, r1
     946:	b1 05       	cpc	r27, r1
     948:	11 f4       	brne	.+4      	; 0x94e <i2c_write+0x80>
		return 1;
     94a:	81 e0       	ldi	r24, 0x01	; 1
     94c:	0c c0       	rjmp	.+24     	; 0x966 <i2c_write+0x98>

	// check value of TWI Status Register. Mask prescaler bits
	twst = TW_STATUS & 0xF8;
     94e:	89 eb       	ldi	r24, 0xB9	; 185
     950:	90 e0       	ldi	r25, 0x00	; 0
     952:	fc 01       	movw	r30, r24
     954:	80 81       	ld	r24, Z
     956:	88 7f       	andi	r24, 0xF8	; 248
     958:	8d 83       	std	Y+5, r24	; 0x05
	if( twst != TW_MT_DATA_ACK) return 1;
     95a:	8d 81       	ldd	r24, Y+5	; 0x05
     95c:	88 32       	cpi	r24, 0x28	; 40
     95e:	11 f0       	breq	.+4      	; 0x964 <i2c_write+0x96>
     960:	81 e0       	ldi	r24, 0x01	; 1
     962:	01 c0       	rjmp	.+2      	; 0x966 <i2c_write+0x98>
	return 0;
     964:	80 e0       	ldi	r24, 0x00	; 0

}/* i2c_write */
     966:	26 96       	adiw	r28, 0x06	; 6
     968:	0f b6       	in	r0, 0x3f	; 63
     96a:	f8 94       	cli
     96c:	de bf       	out	0x3e, r29	; 62
     96e:	0f be       	out	0x3f, r0	; 63
     970:	cd bf       	out	0x3d, r28	; 61
     972:	df 91       	pop	r29
     974:	cf 91       	pop	r28
     976:	08 95       	ret

00000978 <i2c_readAck>:
 Read one byte from the I2C device, request more data from device

 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readAck(void)
{
     978:	cf 93       	push	r28
     97a:	df 93       	push	r29
     97c:	00 d0       	rcall	.+0      	; 0x97e <i2c_readAck+0x6>
     97e:	1f 92       	push	r1
     980:	cd b7       	in	r28, 0x3d	; 61
     982:	de b7       	in	r29, 0x3e	; 62
	uint32_t  i2c_timer = 0;
     984:	19 82       	std	Y+1, r1	; 0x01
     986:	1a 82       	std	Y+2, r1	; 0x02
     988:	1b 82       	std	Y+3, r1	; 0x03
     98a:	1c 82       	std	Y+4, r1	; 0x04

	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
     98c:	8c eb       	ldi	r24, 0xBC	; 188
     98e:	90 e0       	ldi	r25, 0x00	; 0
     990:	24 ec       	ldi	r18, 0xC4	; 196
     992:	fc 01       	movw	r30, r24
     994:	20 83       	st	Z, r18
	i2c_timer = I2C_TIMER_DELAY;
     996:	8f ef       	ldi	r24, 0xFF	; 255
     998:	90 e0       	ldi	r25, 0x00	; 0
     99a:	a0 e0       	ldi	r26, 0x00	; 0
     99c:	b0 e0       	ldi	r27, 0x00	; 0
     99e:	89 83       	std	Y+1, r24	; 0x01
     9a0:	9a 83       	std	Y+2, r25	; 0x02
     9a2:	ab 83       	std	Y+3, r26	; 0x03
     9a4:	bc 83       	std	Y+4, r27	; 0x04
	while(!(TWCR & (1<<TWINT)) && i2c_timer--);
     9a6:	00 00       	nop
     9a8:	8c eb       	ldi	r24, 0xBC	; 188
     9aa:	90 e0       	ldi	r25, 0x00	; 0
     9ac:	fc 01       	movw	r30, r24
     9ae:	80 81       	ld	r24, Z
     9b0:	88 23       	and	r24, r24
     9b2:	94 f0       	brlt	.+36     	; 0x9d8 <i2c_readAck+0x60>
     9b4:	89 81       	ldd	r24, Y+1	; 0x01
     9b6:	9a 81       	ldd	r25, Y+2	; 0x02
     9b8:	ab 81       	ldd	r26, Y+3	; 0x03
     9ba:	bc 81       	ldd	r27, Y+4	; 0x04
     9bc:	9c 01       	movw	r18, r24
     9be:	ad 01       	movw	r20, r26
     9c0:	21 50       	subi	r18, 0x01	; 1
     9c2:	31 09       	sbc	r19, r1
     9c4:	41 09       	sbc	r20, r1
     9c6:	51 09       	sbc	r21, r1
     9c8:	29 83       	std	Y+1, r18	; 0x01
     9ca:	3a 83       	std	Y+2, r19	; 0x02
     9cc:	4b 83       	std	Y+3, r20	; 0x03
     9ce:	5c 83       	std	Y+4, r21	; 0x04
     9d0:	00 97       	sbiw	r24, 0x00	; 0
     9d2:	a1 05       	cpc	r26, r1
     9d4:	b1 05       	cpc	r27, r1
     9d6:	41 f7       	brne	.-48     	; 0x9a8 <i2c_readAck+0x30>
	if(i2c_timer == 0)
     9d8:	89 81       	ldd	r24, Y+1	; 0x01
     9da:	9a 81       	ldd	r25, Y+2	; 0x02
     9dc:	ab 81       	ldd	r26, Y+3	; 0x03
     9de:	bc 81       	ldd	r27, Y+4	; 0x04
     9e0:	00 97       	sbiw	r24, 0x00	; 0
     9e2:	a1 05       	cpc	r26, r1
     9e4:	b1 05       	cpc	r27, r1
     9e6:	11 f4       	brne	.+4      	; 0x9ec <i2c_readAck+0x74>
		return 0;
     9e8:	80 e0       	ldi	r24, 0x00	; 0
     9ea:	04 c0       	rjmp	.+8      	; 0x9f4 <i2c_readAck+0x7c>

    return TWDR;
     9ec:	8b eb       	ldi	r24, 0xBB	; 187
     9ee:	90 e0       	ldi	r25, 0x00	; 0
     9f0:	fc 01       	movw	r30, r24
     9f2:	80 81       	ld	r24, Z

}/* i2c_readAck */
     9f4:	0f 90       	pop	r0
     9f6:	0f 90       	pop	r0
     9f8:	0f 90       	pop	r0
     9fa:	0f 90       	pop	r0
     9fc:	df 91       	pop	r29
     9fe:	cf 91       	pop	r28
     a00:	08 95       	ret

00000a02 <i2c_readNak>:
 Read one byte from the I2C device, read is followed by a stop condition

 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readNak(void)
{
     a02:	cf 93       	push	r28
     a04:	df 93       	push	r29
     a06:	00 d0       	rcall	.+0      	; 0xa08 <i2c_readNak+0x6>
     a08:	1f 92       	push	r1
     a0a:	cd b7       	in	r28, 0x3d	; 61
     a0c:	de b7       	in	r29, 0x3e	; 62
	uint32_t  i2c_timer = 0;
     a0e:	19 82       	std	Y+1, r1	; 0x01
     a10:	1a 82       	std	Y+2, r1	; 0x02
     a12:	1b 82       	std	Y+3, r1	; 0x03
     a14:	1c 82       	std	Y+4, r1	; 0x04

	TWCR = (1<<TWINT) | (1<<TWEN);
     a16:	8c eb       	ldi	r24, 0xBC	; 188
     a18:	90 e0       	ldi	r25, 0x00	; 0
     a1a:	24 e8       	ldi	r18, 0x84	; 132
     a1c:	fc 01       	movw	r30, r24
     a1e:	20 83       	st	Z, r18
	i2c_timer = I2C_TIMER_DELAY;
     a20:	8f ef       	ldi	r24, 0xFF	; 255
     a22:	90 e0       	ldi	r25, 0x00	; 0
     a24:	a0 e0       	ldi	r26, 0x00	; 0
     a26:	b0 e0       	ldi	r27, 0x00	; 0
     a28:	89 83       	std	Y+1, r24	; 0x01
     a2a:	9a 83       	std	Y+2, r25	; 0x02
     a2c:	ab 83       	std	Y+3, r26	; 0x03
     a2e:	bc 83       	std	Y+4, r27	; 0x04
	while(!(TWCR & (1<<TWINT)) && i2c_timer--);
     a30:	00 00       	nop
     a32:	8c eb       	ldi	r24, 0xBC	; 188
     a34:	90 e0       	ldi	r25, 0x00	; 0
     a36:	fc 01       	movw	r30, r24
     a38:	80 81       	ld	r24, Z
     a3a:	88 23       	and	r24, r24
     a3c:	94 f0       	brlt	.+36     	; 0xa62 <i2c_readNak+0x60>
     a3e:	89 81       	ldd	r24, Y+1	; 0x01
     a40:	9a 81       	ldd	r25, Y+2	; 0x02
     a42:	ab 81       	ldd	r26, Y+3	; 0x03
     a44:	bc 81       	ldd	r27, Y+4	; 0x04
     a46:	9c 01       	movw	r18, r24
     a48:	ad 01       	movw	r20, r26
     a4a:	21 50       	subi	r18, 0x01	; 1
     a4c:	31 09       	sbc	r19, r1
     a4e:	41 09       	sbc	r20, r1
     a50:	51 09       	sbc	r21, r1
     a52:	29 83       	std	Y+1, r18	; 0x01
     a54:	3a 83       	std	Y+2, r19	; 0x02
     a56:	4b 83       	std	Y+3, r20	; 0x03
     a58:	5c 83       	std	Y+4, r21	; 0x04
     a5a:	00 97       	sbiw	r24, 0x00	; 0
     a5c:	a1 05       	cpc	r26, r1
     a5e:	b1 05       	cpc	r27, r1
     a60:	41 f7       	brne	.-48     	; 0xa32 <i2c_readNak+0x30>
	if(i2c_timer == 0)
     a62:	89 81       	ldd	r24, Y+1	; 0x01
     a64:	9a 81       	ldd	r25, Y+2	; 0x02
     a66:	ab 81       	ldd	r26, Y+3	; 0x03
     a68:	bc 81       	ldd	r27, Y+4	; 0x04
     a6a:	00 97       	sbiw	r24, 0x00	; 0
     a6c:	a1 05       	cpc	r26, r1
     a6e:	b1 05       	cpc	r27, r1
     a70:	11 f4       	brne	.+4      	; 0xa76 <i2c_readNak+0x74>
		return 0;
     a72:	80 e0       	ldi	r24, 0x00	; 0
     a74:	04 c0       	rjmp	.+8      	; 0xa7e <i2c_readNak+0x7c>

    return TWDR;
     a76:	8b eb       	ldi	r24, 0xBB	; 187
     a78:	90 e0       	ldi	r25, 0x00	; 0
     a7a:	fc 01       	movw	r30, r24
     a7c:	80 81       	ld	r24, Z

}/* i2c_readNak */
     a7e:	0f 90       	pop	r0
     a80:	0f 90       	pop	r0
     a82:	0f 90       	pop	r0
     a84:	0f 90       	pop	r0
     a86:	df 91       	pop	r29
     a88:	cf 91       	pop	r28
     a8a:	08 95       	ret

00000a8c <mpu6050_readBytes>:
volatile uint8_t buffer[14];

/*
 * read bytes from chip register
 */
int8_t mpu6050_readBytes(uint8_t regAddr, uint8_t length, uint8_t *data) {
     a8c:	0f 93       	push	r16
     a8e:	1f 93       	push	r17
     a90:	cf 93       	push	r28
     a92:	df 93       	push	r29
     a94:	00 d0       	rcall	.+0      	; 0xa96 <mpu6050_readBytes+0xa>
     a96:	00 d0       	rcall	.+0      	; 0xa98 <mpu6050_readBytes+0xc>
     a98:	cd b7       	in	r28, 0x3d	; 61
     a9a:	de b7       	in	r29, 0x3e	; 62
     a9c:	8b 83       	std	Y+3, r24	; 0x03
     a9e:	6c 83       	std	Y+4, r22	; 0x04
     aa0:	5e 83       	std	Y+6, r21	; 0x06
     aa2:	4d 83       	std	Y+5, r20	; 0x05
	uint8_t i = 0;
     aa4:	19 82       	std	Y+1, r1	; 0x01
	int8_t count = 0;
     aa6:	1a 82       	std	Y+2, r1	; 0x02
	if(length > 0) {
     aa8:	8c 81       	ldd	r24, Y+4	; 0x04
     aaa:	88 23       	and	r24, r24
     aac:	d1 f1       	breq	.+116    	; 0xb22 <mpu6050_readBytes+0x96>
		//request register
		i2c_start(MPU6050_ADDR | I2C_WRITE);
     aae:	80 ed       	ldi	r24, 0xD0	; 208
     ab0:	0e 94 de 02 	call	0x5bc	; 0x5bc <i2c_start>
		i2c_write(regAddr);
     ab4:	8b 81       	ldd	r24, Y+3	; 0x03
     ab6:	0e 94 67 04 	call	0x8ce	; 0x8ce <i2c_write>

		//read data
		i2c_start(MPU6050_ADDR | I2C_READ);
     aba:	81 ed       	ldi	r24, 0xD1	; 209
     abc:	0e 94 de 02 	call	0x5bc	; 0x5bc <i2c_start>
		for(i=0; i<length; i++) {
     ac0:	19 82       	std	Y+1, r1	; 0x01
     ac2:	29 c0       	rjmp	.+82     	; 0xb16 <mpu6050_readBytes+0x8a>
			count++;
     ac4:	8a 81       	ldd	r24, Y+2	; 0x02
     ac6:	8f 5f       	subi	r24, 0xFF	; 255
     ac8:	8a 83       	std	Y+2, r24	; 0x02
			if(i==length-1)
     aca:	89 81       	ldd	r24, Y+1	; 0x01
     acc:	28 2f       	mov	r18, r24
     ace:	30 e0       	ldi	r19, 0x00	; 0
     ad0:	8c 81       	ldd	r24, Y+4	; 0x04
     ad2:	88 2f       	mov	r24, r24
     ad4:	90 e0       	ldi	r25, 0x00	; 0
     ad6:	01 97       	sbiw	r24, 0x01	; 1
     ad8:	28 17       	cp	r18, r24
     ada:	39 07       	cpc	r19, r25
     adc:	69 f4       	brne	.+26     	; 0xaf8 <mpu6050_readBytes+0x6c>
				data[i] = i2c_readNak();
     ade:	89 81       	ldd	r24, Y+1	; 0x01
     ae0:	88 2f       	mov	r24, r24
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	2d 81       	ldd	r18, Y+5	; 0x05
     ae6:	3e 81       	ldd	r19, Y+6	; 0x06
     ae8:	89 01       	movw	r16, r18
     aea:	08 0f       	add	r16, r24
     aec:	19 1f       	adc	r17, r25
     aee:	0e 94 01 05 	call	0xa02	; 0xa02 <i2c_readNak>
     af2:	f8 01       	movw	r30, r16
     af4:	80 83       	st	Z, r24
     af6:	0c c0       	rjmp	.+24     	; 0xb10 <mpu6050_readBytes+0x84>
			else
				data[i] = i2c_readAck();
     af8:	89 81       	ldd	r24, Y+1	; 0x01
     afa:	88 2f       	mov	r24, r24
     afc:	90 e0       	ldi	r25, 0x00	; 0
     afe:	2d 81       	ldd	r18, Y+5	; 0x05
     b00:	3e 81       	ldd	r19, Y+6	; 0x06
     b02:	89 01       	movw	r16, r18
     b04:	08 0f       	add	r16, r24
     b06:	19 1f       	adc	r17, r25
     b08:	0e 94 bc 04 	call	0x978	; 0x978 <i2c_readAck>
     b0c:	f8 01       	movw	r30, r16
     b0e:	80 83       	st	Z, r24
		i2c_start(MPU6050_ADDR | I2C_WRITE);
		i2c_write(regAddr);

		//read data
		i2c_start(MPU6050_ADDR | I2C_READ);
		for(i=0; i<length; i++) {
     b10:	89 81       	ldd	r24, Y+1	; 0x01
     b12:	8f 5f       	subi	r24, 0xFF	; 255
     b14:	89 83       	std	Y+1, r24	; 0x01
     b16:	99 81       	ldd	r25, Y+1	; 0x01
     b18:	8c 81       	ldd	r24, Y+4	; 0x04
     b1a:	98 17       	cp	r25, r24
     b1c:	98 f2       	brcs	.-90     	; 0xac4 <mpu6050_readBytes+0x38>
			if(i==length-1)
				data[i] = i2c_readNak();
			else
				data[i] = i2c_readAck();
		}
		i2c_stop();
     b1e:	0e 94 2c 04 	call	0x858	; 0x858 <i2c_stop>
	}
	return count;
     b22:	8a 81       	ldd	r24, Y+2	; 0x02
}
     b24:	26 96       	adiw	r28, 0x06	; 6
     b26:	0f b6       	in	r0, 0x3f	; 63
     b28:	f8 94       	cli
     b2a:	de bf       	out	0x3e, r29	; 62
     b2c:	0f be       	out	0x3f, r0	; 63
     b2e:	cd bf       	out	0x3d, r28	; 61
     b30:	df 91       	pop	r29
     b32:	cf 91       	pop	r28
     b34:	1f 91       	pop	r17
     b36:	0f 91       	pop	r16
     b38:	08 95       	ret

00000b3a <mpu6050_readByte>:

/*
 * read 1 byte from chip register
 */
int8_t mpu6050_readByte(uint8_t regAddr, uint8_t *data) {
     b3a:	cf 93       	push	r28
     b3c:	df 93       	push	r29
     b3e:	00 d0       	rcall	.+0      	; 0xb40 <mpu6050_readByte+0x6>
     b40:	cd b7       	in	r28, 0x3d	; 61
     b42:	de b7       	in	r29, 0x3e	; 62
     b44:	89 83       	std	Y+1, r24	; 0x01
     b46:	7b 83       	std	Y+3, r23	; 0x03
     b48:	6a 83       	std	Y+2, r22	; 0x02
    return mpu6050_readBytes(regAddr, 1, data);
     b4a:	8a 81       	ldd	r24, Y+2	; 0x02
     b4c:	9b 81       	ldd	r25, Y+3	; 0x03
     b4e:	ac 01       	movw	r20, r24
     b50:	61 e0       	ldi	r22, 0x01	; 1
     b52:	89 81       	ldd	r24, Y+1	; 0x01
     b54:	0e 94 46 05 	call	0xa8c	; 0xa8c <mpu6050_readBytes>
}
     b58:	0f 90       	pop	r0
     b5a:	0f 90       	pop	r0
     b5c:	0f 90       	pop	r0
     b5e:	df 91       	pop	r29
     b60:	cf 91       	pop	r28
     b62:	08 95       	ret

00000b64 <mpu6050_writeBytes>:

/*
 * write bytes to chip register
 */
void mpu6050_writeBytes(uint8_t regAddr, uint8_t length, uint8_t* data) {
     b64:	cf 93       	push	r28
     b66:	df 93       	push	r29
     b68:	00 d0       	rcall	.+0      	; 0xb6a <mpu6050_writeBytes+0x6>
     b6a:	1f 92       	push	r1
     b6c:	1f 92       	push	r1
     b6e:	cd b7       	in	r28, 0x3d	; 61
     b70:	de b7       	in	r29, 0x3e	; 62
     b72:	8a 83       	std	Y+2, r24	; 0x02
     b74:	6b 83       	std	Y+3, r22	; 0x03
     b76:	5d 83       	std	Y+5, r21	; 0x05
     b78:	4c 83       	std	Y+4, r20	; 0x04
	if(length > 0) {
     b7a:	8b 81       	ldd	r24, Y+3	; 0x03
     b7c:	88 23       	and	r24, r24
     b7e:	e1 f0       	breq	.+56     	; 0xbb8 <mpu6050_writeBytes+0x54>
		//write data
		i2c_start(MPU6050_ADDR | I2C_WRITE);
     b80:	80 ed       	ldi	r24, 0xD0	; 208
     b82:	0e 94 de 02 	call	0x5bc	; 0x5bc <i2c_start>
		i2c_write(regAddr); //reg
     b86:	8a 81       	ldd	r24, Y+2	; 0x02
     b88:	0e 94 67 04 	call	0x8ce	; 0x8ce <i2c_write>
		for (uint8_t i = 0; i < length; i++) {
     b8c:	19 82       	std	Y+1, r1	; 0x01
     b8e:	0e c0       	rjmp	.+28     	; 0xbac <mpu6050_writeBytes+0x48>
			i2c_write((uint8_t) data[i]);
     b90:	89 81       	ldd	r24, Y+1	; 0x01
     b92:	88 2f       	mov	r24, r24
     b94:	90 e0       	ldi	r25, 0x00	; 0
     b96:	2c 81       	ldd	r18, Y+4	; 0x04
     b98:	3d 81       	ldd	r19, Y+5	; 0x05
     b9a:	82 0f       	add	r24, r18
     b9c:	93 1f       	adc	r25, r19
     b9e:	fc 01       	movw	r30, r24
     ba0:	80 81       	ld	r24, Z
     ba2:	0e 94 67 04 	call	0x8ce	; 0x8ce <i2c_write>
void mpu6050_writeBytes(uint8_t regAddr, uint8_t length, uint8_t* data) {
	if(length > 0) {
		//write data
		i2c_start(MPU6050_ADDR | I2C_WRITE);
		i2c_write(regAddr); //reg
		for (uint8_t i = 0; i < length; i++) {
     ba6:	89 81       	ldd	r24, Y+1	; 0x01
     ba8:	8f 5f       	subi	r24, 0xFF	; 255
     baa:	89 83       	std	Y+1, r24	; 0x01
     bac:	99 81       	ldd	r25, Y+1	; 0x01
     bae:	8b 81       	ldd	r24, Y+3	; 0x03
     bb0:	98 17       	cp	r25, r24
     bb2:	70 f3       	brcs	.-36     	; 0xb90 <mpu6050_writeBytes+0x2c>
			i2c_write((uint8_t) data[i]);
		}
		i2c_stop();
     bb4:	0e 94 2c 04 	call	0x858	; 0x858 <i2c_stop>
	}
}
     bb8:	0f 90       	pop	r0
     bba:	0f 90       	pop	r0
     bbc:	0f 90       	pop	r0
     bbe:	0f 90       	pop	r0
     bc0:	0f 90       	pop	r0
     bc2:	df 91       	pop	r29
     bc4:	cf 91       	pop	r28
     bc6:	08 95       	ret

00000bc8 <mpu6050_writeByte>:
/*
 * write 1 byte to chip register
 */
void mpu6050_writeByte(uint8_t regAddr, uint8_t data) {
     bc8:	cf 93       	push	r28
     bca:	df 93       	push	r29
     bcc:	1f 92       	push	r1
     bce:	1f 92       	push	r1
     bd0:	cd b7       	in	r28, 0x3d	; 61
     bd2:	de b7       	in	r29, 0x3e	; 62
     bd4:	89 83       	std	Y+1, r24	; 0x01
     bd6:	6a 83       	std	Y+2, r22	; 0x02
    return mpu6050_writeBytes(regAddr, 1, &data);
     bd8:	ce 01       	movw	r24, r28
     bda:	02 96       	adiw	r24, 0x02	; 2
     bdc:	ac 01       	movw	r20, r24
     bde:	61 e0       	ldi	r22, 0x01	; 1
     be0:	89 81       	ldd	r24, Y+1	; 0x01
     be2:	0e 94 b2 05 	call	0xb64	; 0xb64 <mpu6050_writeBytes>
     be6:	00 00       	nop
}
     be8:	0f 90       	pop	r0
     bea:	0f 90       	pop	r0
     bec:	df 91       	pop	r29
     bee:	cf 91       	pop	r28
     bf0:	08 95       	ret

00000bf2 <mpu6050_readBits>:

/*
 * read bits from chip register
 */
int8_t mpu6050_readBits(uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t *data) {
     bf2:	cf 93       	push	r28
     bf4:	df 93       	push	r29
     bf6:	cd b7       	in	r28, 0x3d	; 61
     bf8:	de b7       	in	r29, 0x3e	; 62
     bfa:	28 97       	sbiw	r28, 0x08	; 8
     bfc:	0f b6       	in	r0, 0x3f	; 63
     bfe:	f8 94       	cli
     c00:	de bf       	out	0x3e, r29	; 62
     c02:	0f be       	out	0x3f, r0	; 63
     c04:	cd bf       	out	0x3d, r28	; 61
     c06:	8c 83       	std	Y+4, r24	; 0x04
     c08:	6d 83       	std	Y+5, r22	; 0x05
     c0a:	4e 83       	std	Y+6, r20	; 0x06
     c0c:	38 87       	std	Y+8, r19	; 0x08
     c0e:	2f 83       	std	Y+7, r18	; 0x07
    // 01101001 read byte
    // 76543210 bit numbers
    //    xxx   args: bitStart=4, length=3
    //    010   masked
    //   -> 010 shifted
    int8_t count = 0;
     c10:	19 82       	std	Y+1, r1	; 0x01
    if(length > 0) {
     c12:	8e 81       	ldd	r24, Y+6	; 0x06
     c14:	88 23       	and	r24, r24
     c16:	09 f4       	brne	.+2      	; 0xc1a <mpu6050_readBits+0x28>
     c18:	45 c0       	rjmp	.+138    	; 0xca4 <mpu6050_readBits+0xb2>
		uint8_t b;
		if ((count = mpu6050_readByte(regAddr, &b)) != 0) {
     c1a:	ce 01       	movw	r24, r28
     c1c:	03 96       	adiw	r24, 0x03	; 3
     c1e:	bc 01       	movw	r22, r24
     c20:	8c 81       	ldd	r24, Y+4	; 0x04
     c22:	0e 94 9d 05 	call	0xb3a	; 0xb3a <mpu6050_readByte>
     c26:	89 83       	std	Y+1, r24	; 0x01
     c28:	89 81       	ldd	r24, Y+1	; 0x01
     c2a:	88 23       	and	r24, r24
     c2c:	d9 f1       	breq	.+118    	; 0xca4 <mpu6050_readBits+0xb2>
			uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
     c2e:	8e 81       	ldd	r24, Y+6	; 0x06
     c30:	28 2f       	mov	r18, r24
     c32:	30 e0       	ldi	r19, 0x00	; 0
     c34:	81 e0       	ldi	r24, 0x01	; 1
     c36:	90 e0       	ldi	r25, 0x00	; 0
     c38:	02 c0       	rjmp	.+4      	; 0xc3e <mpu6050_readBits+0x4c>
     c3a:	88 0f       	add	r24, r24
     c3c:	99 1f       	adc	r25, r25
     c3e:	2a 95       	dec	r18
     c40:	e2 f7       	brpl	.-8      	; 0xc3a <mpu6050_readBits+0x48>
     c42:	01 97       	sbiw	r24, 0x01	; 1
     c44:	2d 81       	ldd	r18, Y+5	; 0x05
     c46:	42 2f       	mov	r20, r18
     c48:	50 e0       	ldi	r21, 0x00	; 0
     c4a:	2e 81       	ldd	r18, Y+6	; 0x06
     c4c:	22 2f       	mov	r18, r18
     c4e:	30 e0       	ldi	r19, 0x00	; 0
     c50:	ba 01       	movw	r22, r20
     c52:	62 1b       	sub	r22, r18
     c54:	73 0b       	sbc	r23, r19
     c56:	9b 01       	movw	r18, r22
     c58:	2f 5f       	subi	r18, 0xFF	; 255
     c5a:	3f 4f       	sbci	r19, 0xFF	; 255
     c5c:	02 c0       	rjmp	.+4      	; 0xc62 <mpu6050_readBits+0x70>
     c5e:	88 0f       	add	r24, r24
     c60:	99 1f       	adc	r25, r25
     c62:	2a 95       	dec	r18
     c64:	e2 f7       	brpl	.-8      	; 0xc5e <mpu6050_readBits+0x6c>
     c66:	8a 83       	std	Y+2, r24	; 0x02
			b &= mask;
     c68:	9b 81       	ldd	r25, Y+3	; 0x03
     c6a:	8a 81       	ldd	r24, Y+2	; 0x02
     c6c:	89 23       	and	r24, r25
     c6e:	8b 83       	std	Y+3, r24	; 0x03
			b >>= (bitStart - length + 1);
     c70:	8b 81       	ldd	r24, Y+3	; 0x03
     c72:	88 2f       	mov	r24, r24
     c74:	90 e0       	ldi	r25, 0x00	; 0
     c76:	2d 81       	ldd	r18, Y+5	; 0x05
     c78:	42 2f       	mov	r20, r18
     c7a:	50 e0       	ldi	r21, 0x00	; 0
     c7c:	2e 81       	ldd	r18, Y+6	; 0x06
     c7e:	22 2f       	mov	r18, r18
     c80:	30 e0       	ldi	r19, 0x00	; 0
     c82:	fa 01       	movw	r30, r20
     c84:	e2 1b       	sub	r30, r18
     c86:	f3 0b       	sbc	r31, r19
     c88:	9f 01       	movw	r18, r30
     c8a:	2f 5f       	subi	r18, 0xFF	; 255
     c8c:	3f 4f       	sbci	r19, 0xFF	; 255
     c8e:	02 c0       	rjmp	.+4      	; 0xc94 <mpu6050_readBits+0xa2>
     c90:	95 95       	asr	r25
     c92:	87 95       	ror	r24
     c94:	2a 95       	dec	r18
     c96:	e2 f7       	brpl	.-8      	; 0xc90 <mpu6050_readBits+0x9e>
     c98:	8b 83       	std	Y+3, r24	; 0x03
			*data = b;
     c9a:	2b 81       	ldd	r18, Y+3	; 0x03
     c9c:	8f 81       	ldd	r24, Y+7	; 0x07
     c9e:	98 85       	ldd	r25, Y+8	; 0x08
     ca0:	fc 01       	movw	r30, r24
     ca2:	20 83       	st	Z, r18
		}
    }
    return count;
     ca4:	89 81       	ldd	r24, Y+1	; 0x01
}
     ca6:	28 96       	adiw	r28, 0x08	; 8
     ca8:	0f b6       	in	r0, 0x3f	; 63
     caa:	f8 94       	cli
     cac:	de bf       	out	0x3e, r29	; 62
     cae:	0f be       	out	0x3f, r0	; 63
     cb0:	cd bf       	out	0x3d, r28	; 61
     cb2:	df 91       	pop	r29
     cb4:	cf 91       	pop	r28
     cb6:	08 95       	ret

00000cb8 <mpu6050_readBit>:

/*
 * read 1 bit from chip register
 */
int8_t mpu6050_readBit(uint8_t regAddr, uint8_t bitNum, uint8_t *data) {
     cb8:	cf 93       	push	r28
     cba:	df 93       	push	r29
     cbc:	00 d0       	rcall	.+0      	; 0xcbe <mpu6050_readBit+0x6>
     cbe:	00 d0       	rcall	.+0      	; 0xcc0 <mpu6050_readBit+0x8>
     cc0:	cd b7       	in	r28, 0x3d	; 61
     cc2:	de b7       	in	r29, 0x3e	; 62
     cc4:	8b 83       	std	Y+3, r24	; 0x03
     cc6:	6c 83       	std	Y+4, r22	; 0x04
     cc8:	5e 83       	std	Y+6, r21	; 0x06
     cca:	4d 83       	std	Y+5, r20	; 0x05
    uint8_t b;
    uint8_t count = mpu6050_readByte(regAddr, &b);
     ccc:	ce 01       	movw	r24, r28
     cce:	02 96       	adiw	r24, 0x02	; 2
     cd0:	bc 01       	movw	r22, r24
     cd2:	8b 81       	ldd	r24, Y+3	; 0x03
     cd4:	0e 94 9d 05 	call	0xb3a	; 0xb3a <mpu6050_readByte>
     cd8:	89 83       	std	Y+1, r24	; 0x01
    *data = b & (1 << bitNum);
     cda:	8c 81       	ldd	r24, Y+4	; 0x04
     cdc:	28 2f       	mov	r18, r24
     cde:	30 e0       	ldi	r19, 0x00	; 0
     ce0:	81 e0       	ldi	r24, 0x01	; 1
     ce2:	90 e0       	ldi	r25, 0x00	; 0
     ce4:	02 c0       	rjmp	.+4      	; 0xcea <mpu6050_readBit+0x32>
     ce6:	88 0f       	add	r24, r24
     ce8:	99 1f       	adc	r25, r25
     cea:	2a 95       	dec	r18
     cec:	e2 f7       	brpl	.-8      	; 0xce6 <mpu6050_readBit+0x2e>
     cee:	98 2f       	mov	r25, r24
     cf0:	8a 81       	ldd	r24, Y+2	; 0x02
     cf2:	89 23       	and	r24, r25
     cf4:	28 2f       	mov	r18, r24
     cf6:	8d 81       	ldd	r24, Y+5	; 0x05
     cf8:	9e 81       	ldd	r25, Y+6	; 0x06
     cfa:	fc 01       	movw	r30, r24
     cfc:	20 83       	st	Z, r18
    return count;
     cfe:	89 81       	ldd	r24, Y+1	; 0x01
}
     d00:	26 96       	adiw	r28, 0x06	; 6
     d02:	0f b6       	in	r0, 0x3f	; 63
     d04:	f8 94       	cli
     d06:	de bf       	out	0x3e, r29	; 62
     d08:	0f be       	out	0x3f, r0	; 63
     d0a:	cd bf       	out	0x3d, r28	; 61
     d0c:	df 91       	pop	r29
     d0e:	cf 91       	pop	r28
     d10:	08 95       	ret

00000d12 <mpu6050_writeBits>:


/*
 * write bit/bits to chip register
 */
void mpu6050_writeBits(uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data) {
     d12:	cf 93       	push	r28
     d14:	df 93       	push	r29
     d16:	00 d0       	rcall	.+0      	; 0xd18 <mpu6050_writeBits+0x6>
     d18:	00 d0       	rcall	.+0      	; 0xd1a <mpu6050_writeBits+0x8>
     d1a:	cd b7       	in	r28, 0x3d	; 61
     d1c:	de b7       	in	r29, 0x3e	; 62
     d1e:	8b 83       	std	Y+3, r24	; 0x03
     d20:	6c 83       	std	Y+4, r22	; 0x04
     d22:	4d 83       	std	Y+5, r20	; 0x05
     d24:	2e 83       	std	Y+6, r18	; 0x06
    //    xxx   args: bitStart=4, length=3
    // 00011100 mask byte
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
	if(length > 0) {
     d26:	8d 81       	ldd	r24, Y+5	; 0x05
     d28:	88 23       	and	r24, r24
     d2a:	09 f4       	brne	.+2      	; 0xd2e <mpu6050_writeBits+0x1c>
     d2c:	4f c0       	rjmp	.+158    	; 0xdcc <mpu6050_writeBits+0xba>
		uint8_t b = 0;
     d2e:	1a 82       	std	Y+2, r1	; 0x02
		if (mpu6050_readByte(regAddr, &b) != 0) { //get current data
     d30:	ce 01       	movw	r24, r28
     d32:	02 96       	adiw	r24, 0x02	; 2
     d34:	bc 01       	movw	r22, r24
     d36:	8b 81       	ldd	r24, Y+3	; 0x03
     d38:	0e 94 9d 05 	call	0xb3a	; 0xb3a <mpu6050_readByte>
     d3c:	88 23       	and	r24, r24
     d3e:	09 f4       	brne	.+2      	; 0xd42 <mpu6050_writeBits+0x30>
     d40:	45 c0       	rjmp	.+138    	; 0xdcc <mpu6050_writeBits+0xba>
			uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
     d42:	8d 81       	ldd	r24, Y+5	; 0x05
     d44:	28 2f       	mov	r18, r24
     d46:	30 e0       	ldi	r19, 0x00	; 0
     d48:	81 e0       	ldi	r24, 0x01	; 1
     d4a:	90 e0       	ldi	r25, 0x00	; 0
     d4c:	02 c0       	rjmp	.+4      	; 0xd52 <mpu6050_writeBits+0x40>
     d4e:	88 0f       	add	r24, r24
     d50:	99 1f       	adc	r25, r25
     d52:	2a 95       	dec	r18
     d54:	e2 f7       	brpl	.-8      	; 0xd4e <mpu6050_writeBits+0x3c>
     d56:	01 97       	sbiw	r24, 0x01	; 1
     d58:	2c 81       	ldd	r18, Y+4	; 0x04
     d5a:	42 2f       	mov	r20, r18
     d5c:	50 e0       	ldi	r21, 0x00	; 0
     d5e:	2d 81       	ldd	r18, Y+5	; 0x05
     d60:	22 2f       	mov	r18, r18
     d62:	30 e0       	ldi	r19, 0x00	; 0
     d64:	ba 01       	movw	r22, r20
     d66:	62 1b       	sub	r22, r18
     d68:	73 0b       	sbc	r23, r19
     d6a:	9b 01       	movw	r18, r22
     d6c:	2f 5f       	subi	r18, 0xFF	; 255
     d6e:	3f 4f       	sbci	r19, 0xFF	; 255
     d70:	02 c0       	rjmp	.+4      	; 0xd76 <mpu6050_writeBits+0x64>
     d72:	88 0f       	add	r24, r24
     d74:	99 1f       	adc	r25, r25
     d76:	2a 95       	dec	r18
     d78:	e2 f7       	brpl	.-8      	; 0xd72 <mpu6050_writeBits+0x60>
     d7a:	89 83       	std	Y+1, r24	; 0x01
			data <<= (bitStart - length + 1); // shift data into correct position
     d7c:	8e 81       	ldd	r24, Y+6	; 0x06
     d7e:	88 2f       	mov	r24, r24
     d80:	90 e0       	ldi	r25, 0x00	; 0
     d82:	2c 81       	ldd	r18, Y+4	; 0x04
     d84:	42 2f       	mov	r20, r18
     d86:	50 e0       	ldi	r21, 0x00	; 0
     d88:	2d 81       	ldd	r18, Y+5	; 0x05
     d8a:	22 2f       	mov	r18, r18
     d8c:	30 e0       	ldi	r19, 0x00	; 0
     d8e:	ba 01       	movw	r22, r20
     d90:	62 1b       	sub	r22, r18
     d92:	73 0b       	sbc	r23, r19
     d94:	9b 01       	movw	r18, r22
     d96:	2f 5f       	subi	r18, 0xFF	; 255
     d98:	3f 4f       	sbci	r19, 0xFF	; 255
     d9a:	02 c0       	rjmp	.+4      	; 0xda0 <mpu6050_writeBits+0x8e>
     d9c:	88 0f       	add	r24, r24
     d9e:	99 1f       	adc	r25, r25
     da0:	2a 95       	dec	r18
     da2:	e2 f7       	brpl	.-8      	; 0xd9c <mpu6050_writeBits+0x8a>
     da4:	8e 83       	std	Y+6, r24	; 0x06
			data &= mask; // zero all non-important bits in data
     da6:	9e 81       	ldd	r25, Y+6	; 0x06
     da8:	89 81       	ldd	r24, Y+1	; 0x01
     daa:	89 23       	and	r24, r25
     dac:	8e 83       	std	Y+6, r24	; 0x06
			b &= ~(mask); // zero all important bits in existing byte
     dae:	89 81       	ldd	r24, Y+1	; 0x01
     db0:	98 2f       	mov	r25, r24
     db2:	90 95       	com	r25
     db4:	8a 81       	ldd	r24, Y+2	; 0x02
     db6:	89 23       	and	r24, r25
     db8:	8a 83       	std	Y+2, r24	; 0x02
			b |= data; // combine data with existing byte
     dba:	9a 81       	ldd	r25, Y+2	; 0x02
     dbc:	8e 81       	ldd	r24, Y+6	; 0x06
     dbe:	89 2b       	or	r24, r25
     dc0:	8a 83       	std	Y+2, r24	; 0x02
			mpu6050_writeByte(regAddr, b);
     dc2:	8a 81       	ldd	r24, Y+2	; 0x02
     dc4:	68 2f       	mov	r22, r24
     dc6:	8b 81       	ldd	r24, Y+3	; 0x03
     dc8:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <mpu6050_writeByte>
		}
	}
}
     dcc:	26 96       	adiw	r28, 0x06	; 6
     dce:	0f b6       	in	r0, 0x3f	; 63
     dd0:	f8 94       	cli
     dd2:	de bf       	out	0x3e, r29	; 62
     dd4:	0f be       	out	0x3f, r0	; 63
     dd6:	cd bf       	out	0x3d, r28	; 61
     dd8:	df 91       	pop	r29
     dda:	cf 91       	pop	r28
     ddc:	08 95       	ret

00000dde <mpu6050_writeBit>:

/*
 * write one bit to chip register
 */
void mpu6050_writeBit(uint8_t regAddr, uint8_t bitNum, uint8_t data) {
     dde:	cf 93       	push	r28
     de0:	df 93       	push	r29
     de2:	00 d0       	rcall	.+0      	; 0xde4 <mpu6050_writeBit+0x6>
     de4:	1f 92       	push	r1
     de6:	cd b7       	in	r28, 0x3d	; 61
     de8:	de b7       	in	r29, 0x3e	; 62
     dea:	8a 83       	std	Y+2, r24	; 0x02
     dec:	6b 83       	std	Y+3, r22	; 0x03
     dee:	4c 83       	std	Y+4, r20	; 0x04
    uint8_t b;
    mpu6050_readByte(regAddr, &b);
     df0:	ce 01       	movw	r24, r28
     df2:	01 96       	adiw	r24, 0x01	; 1
     df4:	bc 01       	movw	r22, r24
     df6:	8a 81       	ldd	r24, Y+2	; 0x02
     df8:	0e 94 9d 05 	call	0xb3a	; 0xb3a <mpu6050_readByte>
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
     dfc:	8c 81       	ldd	r24, Y+4	; 0x04
     dfe:	88 23       	and	r24, r24
     e00:	79 f0       	breq	.+30     	; 0xe20 <mpu6050_writeBit+0x42>
     e02:	8b 81       	ldd	r24, Y+3	; 0x03
     e04:	28 2f       	mov	r18, r24
     e06:	30 e0       	ldi	r19, 0x00	; 0
     e08:	81 e0       	ldi	r24, 0x01	; 1
     e0a:	90 e0       	ldi	r25, 0x00	; 0
     e0c:	02 2e       	mov	r0, r18
     e0e:	02 c0       	rjmp	.+4      	; 0xe14 <mpu6050_writeBit+0x36>
     e10:	88 0f       	add	r24, r24
     e12:	99 1f       	adc	r25, r25
     e14:	0a 94       	dec	r0
     e16:	e2 f7       	brpl	.-8      	; 0xe10 <mpu6050_writeBit+0x32>
     e18:	98 2f       	mov	r25, r24
     e1a:	89 81       	ldd	r24, Y+1	; 0x01
     e1c:	89 2b       	or	r24, r25
     e1e:	0e c0       	rjmp	.+28     	; 0xe3c <mpu6050_writeBit+0x5e>
     e20:	8b 81       	ldd	r24, Y+3	; 0x03
     e22:	28 2f       	mov	r18, r24
     e24:	30 e0       	ldi	r19, 0x00	; 0
     e26:	81 e0       	ldi	r24, 0x01	; 1
     e28:	90 e0       	ldi	r25, 0x00	; 0
     e2a:	02 c0       	rjmp	.+4      	; 0xe30 <mpu6050_writeBit+0x52>
     e2c:	88 0f       	add	r24, r24
     e2e:	99 1f       	adc	r25, r25
     e30:	2a 95       	dec	r18
     e32:	e2 f7       	brpl	.-8      	; 0xe2c <mpu6050_writeBit+0x4e>
     e34:	98 2f       	mov	r25, r24
     e36:	90 95       	com	r25
     e38:	89 81       	ldd	r24, Y+1	; 0x01
     e3a:	89 23       	and	r24, r25
     e3c:	89 83       	std	Y+1, r24	; 0x01
    mpu6050_writeByte(regAddr, b);
     e3e:	89 81       	ldd	r24, Y+1	; 0x01
     e40:	68 2f       	mov	r22, r24
     e42:	8a 81       	ldd	r24, Y+2	; 0x02
     e44:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <mpu6050_writeByte>
}
     e48:	0f 90       	pop	r0
     e4a:	0f 90       	pop	r0
     e4c:	0f 90       	pop	r0
     e4e:	0f 90       	pop	r0
     e50:	df 91       	pop	r29
     e52:	cf 91       	pop	r28
     e54:	08 95       	ret

00000e56 <mpu6050_getRawData>:


void mpu6050_getRawData(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
     e56:	ef 92       	push	r14
     e58:	ff 92       	push	r15
     e5a:	0f 93       	push	r16
     e5c:	1f 93       	push	r17
     e5e:	cf 93       	push	r28
     e60:	df 93       	push	r29
     e62:	cd b7       	in	r28, 0x3d	; 61
     e64:	de b7       	in	r29, 0x3e	; 62
     e66:	2c 97       	sbiw	r28, 0x0c	; 12
     e68:	0f b6       	in	r0, 0x3f	; 63
     e6a:	f8 94       	cli
     e6c:	de bf       	out	0x3e, r29	; 62
     e6e:	0f be       	out	0x3f, r0	; 63
     e70:	cd bf       	out	0x3d, r28	; 61
     e72:	9a 83       	std	Y+2, r25	; 0x02
     e74:	89 83       	std	Y+1, r24	; 0x01
     e76:	7c 83       	std	Y+4, r23	; 0x04
     e78:	6b 83       	std	Y+3, r22	; 0x03
     e7a:	5e 83       	std	Y+6, r21	; 0x06
     e7c:	4d 83       	std	Y+5, r20	; 0x05
     e7e:	38 87       	std	Y+8, r19	; 0x08
     e80:	2f 83       	std	Y+7, r18	; 0x07
     e82:	1a 87       	std	Y+10, r17	; 0x0a
     e84:	09 87       	std	Y+9, r16	; 0x09
     e86:	fc 86       	std	Y+12, r15	; 0x0c
     e88:	eb 86       	std	Y+11, r14	; 0x0b
	mpu6050_readBytes(MPU6050_RA_ACCEL_XOUT_H, 14, (uint8_t *)buffer);
     e8a:	46 ea       	ldi	r20, 0xA6	; 166
     e8c:	52 e0       	ldi	r21, 0x02	; 2
     e8e:	6e e0       	ldi	r22, 0x0E	; 14
     e90:	8b e3       	ldi	r24, 0x3B	; 59
     e92:	0e 94 46 05 	call	0xa8c	; 0xa8c <mpu6050_readBytes>

    *ax = (((int16_t)buffer[0]) << 8) | buffer[1];
     e96:	80 91 a6 02 	lds	r24, 0x02A6
     e9a:	88 2f       	mov	r24, r24
     e9c:	90 e0       	ldi	r25, 0x00	; 0
     e9e:	38 2f       	mov	r19, r24
     ea0:	22 27       	eor	r18, r18
     ea2:	80 91 a7 02 	lds	r24, 0x02A7
     ea6:	88 2f       	mov	r24, r24
     ea8:	90 e0       	ldi	r25, 0x00	; 0
     eaa:	28 2b       	or	r18, r24
     eac:	39 2b       	or	r19, r25
     eae:	89 81       	ldd	r24, Y+1	; 0x01
     eb0:	9a 81       	ldd	r25, Y+2	; 0x02
     eb2:	fc 01       	movw	r30, r24
     eb4:	31 83       	std	Z+1, r19	; 0x01
     eb6:	20 83       	st	Z, r18
    *ay = (((int16_t)buffer[2]) << 8) | buffer[3];
     eb8:	80 91 a8 02 	lds	r24, 0x02A8
     ebc:	88 2f       	mov	r24, r24
     ebe:	90 e0       	ldi	r25, 0x00	; 0
     ec0:	38 2f       	mov	r19, r24
     ec2:	22 27       	eor	r18, r18
     ec4:	80 91 a9 02 	lds	r24, 0x02A9
     ec8:	88 2f       	mov	r24, r24
     eca:	90 e0       	ldi	r25, 0x00	; 0
     ecc:	28 2b       	or	r18, r24
     ece:	39 2b       	or	r19, r25
     ed0:	8b 81       	ldd	r24, Y+3	; 0x03
     ed2:	9c 81       	ldd	r25, Y+4	; 0x04
     ed4:	fc 01       	movw	r30, r24
     ed6:	31 83       	std	Z+1, r19	; 0x01
     ed8:	20 83       	st	Z, r18
    *az = (((int16_t)buffer[4]) << 8) | buffer[5];
     eda:	80 91 aa 02 	lds	r24, 0x02AA
     ede:	88 2f       	mov	r24, r24
     ee0:	90 e0       	ldi	r25, 0x00	; 0
     ee2:	38 2f       	mov	r19, r24
     ee4:	22 27       	eor	r18, r18
     ee6:	80 91 ab 02 	lds	r24, 0x02AB
     eea:	88 2f       	mov	r24, r24
     eec:	90 e0       	ldi	r25, 0x00	; 0
     eee:	28 2b       	or	r18, r24
     ef0:	39 2b       	or	r19, r25
     ef2:	8d 81       	ldd	r24, Y+5	; 0x05
     ef4:	9e 81       	ldd	r25, Y+6	; 0x06
     ef6:	fc 01       	movw	r30, r24
     ef8:	31 83       	std	Z+1, r19	; 0x01
     efa:	20 83       	st	Z, r18
    *gx = (((int16_t)buffer[8]) << 8) | buffer[9];
     efc:	80 91 ae 02 	lds	r24, 0x02AE
     f00:	88 2f       	mov	r24, r24
     f02:	90 e0       	ldi	r25, 0x00	; 0
     f04:	38 2f       	mov	r19, r24
     f06:	22 27       	eor	r18, r18
     f08:	80 91 af 02 	lds	r24, 0x02AF
     f0c:	88 2f       	mov	r24, r24
     f0e:	90 e0       	ldi	r25, 0x00	; 0
     f10:	28 2b       	or	r18, r24
     f12:	39 2b       	or	r19, r25
     f14:	8f 81       	ldd	r24, Y+7	; 0x07
     f16:	98 85       	ldd	r25, Y+8	; 0x08
     f18:	fc 01       	movw	r30, r24
     f1a:	31 83       	std	Z+1, r19	; 0x01
     f1c:	20 83       	st	Z, r18
    *gy = (((int16_t)buffer[10]) << 8) | buffer[11];
     f1e:	80 91 b0 02 	lds	r24, 0x02B0
     f22:	88 2f       	mov	r24, r24
     f24:	90 e0       	ldi	r25, 0x00	; 0
     f26:	38 2f       	mov	r19, r24
     f28:	22 27       	eor	r18, r18
     f2a:	80 91 b1 02 	lds	r24, 0x02B1
     f2e:	88 2f       	mov	r24, r24
     f30:	90 e0       	ldi	r25, 0x00	; 0
     f32:	28 2b       	or	r18, r24
     f34:	39 2b       	or	r19, r25
     f36:	89 85       	ldd	r24, Y+9	; 0x09
     f38:	9a 85       	ldd	r25, Y+10	; 0x0a
     f3a:	fc 01       	movw	r30, r24
     f3c:	31 83       	std	Z+1, r19	; 0x01
     f3e:	20 83       	st	Z, r18
    *gz = (((int16_t)buffer[12]) << 8) | buffer[13];
     f40:	80 91 b2 02 	lds	r24, 0x02B2
     f44:	88 2f       	mov	r24, r24
     f46:	90 e0       	ldi	r25, 0x00	; 0
     f48:	38 2f       	mov	r19, r24
     f4a:	22 27       	eor	r18, r18
     f4c:	80 91 b3 02 	lds	r24, 0x02B3
     f50:	88 2f       	mov	r24, r24
     f52:	90 e0       	ldi	r25, 0x00	; 0
     f54:	28 2b       	or	r18, r24
     f56:	39 2b       	or	r19, r25
     f58:	8b 85       	ldd	r24, Y+11	; 0x0b
     f5a:	9c 85       	ldd	r25, Y+12	; 0x0c
     f5c:	fc 01       	movw	r30, r24
     f5e:	31 83       	std	Z+1, r19	; 0x01
     f60:	20 83       	st	Z, r18
}
     f62:	2c 96       	adiw	r28, 0x0c	; 12
     f64:	0f b6       	in	r0, 0x3f	; 63
     f66:	f8 94       	cli
     f68:	de bf       	out	0x3e, r29	; 62
     f6a:	0f be       	out	0x3f, r0	; 63
     f6c:	cd bf       	out	0x3d, r28	; 61
     f6e:	df 91       	pop	r29
     f70:	cf 91       	pop	r28
     f72:	1f 91       	pop	r17
     f74:	0f 91       	pop	r16
     f76:	ff 90       	pop	r15
     f78:	ef 90       	pop	r14
     f7a:	08 95       	ret

00000f7c <mpu6050_getConvData>:


/*
 * get raw data converted to g and deg/sec values
 */
void mpu6050_getConvData(double* axg, double* ayg, double* azg, double* gxds, double* gyds, double* gzds) {
     f7c:	ef 92       	push	r14
     f7e:	ff 92       	push	r15
     f80:	0f 93       	push	r16
     f82:	1f 93       	push	r17
     f84:	cf 93       	push	r28
     f86:	df 93       	push	r29
     f88:	cd b7       	in	r28, 0x3d	; 61
     f8a:	de b7       	in	r29, 0x3e	; 62
     f8c:	68 97       	sbiw	r28, 0x18	; 24
     f8e:	0f b6       	in	r0, 0x3f	; 63
     f90:	f8 94       	cli
     f92:	de bf       	out	0x3e, r29	; 62
     f94:	0f be       	out	0x3f, r0	; 63
     f96:	cd bf       	out	0x3d, r28	; 61
     f98:	9e 87       	std	Y+14, r25	; 0x0e
     f9a:	8d 87       	std	Y+13, r24	; 0x0d
     f9c:	78 8b       	std	Y+16, r23	; 0x10
     f9e:	6f 87       	std	Y+15, r22	; 0x0f
     fa0:	5a 8b       	std	Y+18, r21	; 0x12
     fa2:	49 8b       	std	Y+17, r20	; 0x11
     fa4:	3c 8b       	std	Y+20, r19	; 0x14
     fa6:	2b 8b       	std	Y+19, r18	; 0x13
     fa8:	1e 8b       	std	Y+22, r17	; 0x16
     faa:	0d 8b       	std	Y+21, r16	; 0x15
     fac:	f8 8e       	std	Y+24, r15	; 0x18
     fae:	ef 8a       	std	Y+23, r14	; 0x17
	int16_t ax = 0;
     fb0:	1a 82       	std	Y+2, r1	; 0x02
     fb2:	19 82       	std	Y+1, r1	; 0x01
	int16_t ay = 0;
     fb4:	1c 82       	std	Y+4, r1	; 0x04
     fb6:	1b 82       	std	Y+3, r1	; 0x03
	int16_t az = 0;
     fb8:	1e 82       	std	Y+6, r1	; 0x06
     fba:	1d 82       	std	Y+5, r1	; 0x05
	int16_t gx = 0;
     fbc:	18 86       	std	Y+8, r1	; 0x08
     fbe:	1f 82       	std	Y+7, r1	; 0x07
	int16_t gy = 0;
     fc0:	1a 86       	std	Y+10, r1	; 0x0a
     fc2:	19 86       	std	Y+9, r1	; 0x09
	int16_t gz = 0;
     fc4:	1c 86       	std	Y+12, r1	; 0x0c
     fc6:	1b 86       	std	Y+11, r1	; 0x0b
	mpu6050_getRawData(&ax, &ay, &az, &gx, &gy, &gz);
     fc8:	fe 01       	movw	r30, r28
     fca:	3b 96       	adiw	r30, 0x0b	; 11
     fcc:	be 01       	movw	r22, r28
     fce:	67 5f       	subi	r22, 0xF7	; 247
     fd0:	7f 4f       	sbci	r23, 0xFF	; 255
     fd2:	9e 01       	movw	r18, r28
     fd4:	29 5f       	subi	r18, 0xF9	; 249
     fd6:	3f 4f       	sbci	r19, 0xFF	; 255
     fd8:	ae 01       	movw	r20, r28
     fda:	4b 5f       	subi	r20, 0xFB	; 251
     fdc:	5f 4f       	sbci	r21, 0xFF	; 255
     fde:	ce 01       	movw	r24, r28
     fe0:	03 96       	adiw	r24, 0x03	; 3
     fe2:	7f 01       	movw	r14, r30
     fe4:	8b 01       	movw	r16, r22
     fe6:	bc 01       	movw	r22, r24
     fe8:	ce 01       	movw	r24, r28
     fea:	01 96       	adiw	r24, 0x01	; 1
     fec:	0e 94 2b 07 	call	0xe56	; 0xe56 <mpu6050_getRawData>

	#if MPU6050_CALIBRATEDACCGYRO == 1
    *axg = (double)(ax-MPU6050_AXOFFSET)/MPU6050_AXGAIN;
     ff0:	89 81       	ldd	r24, Y+1	; 0x01
     ff2:	9a 81       	ldd	r25, Y+2	; 0x02
     ff4:	aa 27       	eor	r26, r26
     ff6:	97 fd       	sbrc	r25, 7
     ff8:	a0 95       	com	r26
     ffa:	ba 2f       	mov	r27, r26
     ffc:	bc 01       	movw	r22, r24
     ffe:	cd 01       	movw	r24, r26
    1000:	0e 94 c2 2c 	call	0x5984	; 0x5984 <__floatsisf>
    1004:	dc 01       	movw	r26, r24
    1006:	cb 01       	movw	r24, r22
    1008:	20 e0       	ldi	r18, 0x00	; 0
    100a:	30 e0       	ldi	r19, 0x00	; 0
    100c:	40 e8       	ldi	r20, 0x80	; 128
    100e:	56 e4       	ldi	r21, 0x46	; 70
    1010:	bc 01       	movw	r22, r24
    1012:	cd 01       	movw	r24, r26
    1014:	0e 94 2c 2c 	call	0x5858	; 0x5858 <__divsf3>
    1018:	dc 01       	movw	r26, r24
    101a:	cb 01       	movw	r24, r22
    101c:	2d 85       	ldd	r18, Y+13	; 0x0d
    101e:	3e 85       	ldd	r19, Y+14	; 0x0e
    1020:	f9 01       	movw	r30, r18
    1022:	80 83       	st	Z, r24
    1024:	91 83       	std	Z+1, r25	; 0x01
    1026:	a2 83       	std	Z+2, r26	; 0x02
    1028:	b3 83       	std	Z+3, r27	; 0x03
    *ayg = (double)(ay-MPU6050_AYOFFSET)/MPU6050_AYGAIN;
    102a:	8b 81       	ldd	r24, Y+3	; 0x03
    102c:	9c 81       	ldd	r25, Y+4	; 0x04
    102e:	aa 27       	eor	r26, r26
    1030:	97 fd       	sbrc	r25, 7
    1032:	a0 95       	com	r26
    1034:	ba 2f       	mov	r27, r26
    1036:	bc 01       	movw	r22, r24
    1038:	cd 01       	movw	r24, r26
    103a:	0e 94 c2 2c 	call	0x5984	; 0x5984 <__floatsisf>
    103e:	dc 01       	movw	r26, r24
    1040:	cb 01       	movw	r24, r22
    1042:	20 e0       	ldi	r18, 0x00	; 0
    1044:	30 e0       	ldi	r19, 0x00	; 0
    1046:	40 e8       	ldi	r20, 0x80	; 128
    1048:	56 e4       	ldi	r21, 0x46	; 70
    104a:	bc 01       	movw	r22, r24
    104c:	cd 01       	movw	r24, r26
    104e:	0e 94 2c 2c 	call	0x5858	; 0x5858 <__divsf3>
    1052:	dc 01       	movw	r26, r24
    1054:	cb 01       	movw	r24, r22
    1056:	2f 85       	ldd	r18, Y+15	; 0x0f
    1058:	38 89       	ldd	r19, Y+16	; 0x10
    105a:	f9 01       	movw	r30, r18
    105c:	80 83       	st	Z, r24
    105e:	91 83       	std	Z+1, r25	; 0x01
    1060:	a2 83       	std	Z+2, r26	; 0x02
    1062:	b3 83       	std	Z+3, r27	; 0x03
    *azg = (double)(az-MPU6050_AZOFFSET)/MPU6050_AZGAIN;
    1064:	8d 81       	ldd	r24, Y+5	; 0x05
    1066:	9e 81       	ldd	r25, Y+6	; 0x06
    1068:	aa 27       	eor	r26, r26
    106a:	97 fd       	sbrc	r25, 7
    106c:	a0 95       	com	r26
    106e:	ba 2f       	mov	r27, r26
    1070:	bc 01       	movw	r22, r24
    1072:	cd 01       	movw	r24, r26
    1074:	0e 94 c2 2c 	call	0x5984	; 0x5984 <__floatsisf>
    1078:	dc 01       	movw	r26, r24
    107a:	cb 01       	movw	r24, r22
    107c:	20 e0       	ldi	r18, 0x00	; 0
    107e:	30 e0       	ldi	r19, 0x00	; 0
    1080:	40 e8       	ldi	r20, 0x80	; 128
    1082:	56 e4       	ldi	r21, 0x46	; 70
    1084:	bc 01       	movw	r22, r24
    1086:	cd 01       	movw	r24, r26
    1088:	0e 94 2c 2c 	call	0x5858	; 0x5858 <__divsf3>
    108c:	dc 01       	movw	r26, r24
    108e:	cb 01       	movw	r24, r22
    1090:	29 89       	ldd	r18, Y+17	; 0x11
    1092:	3a 89       	ldd	r19, Y+18	; 0x12
    1094:	f9 01       	movw	r30, r18
    1096:	80 83       	st	Z, r24
    1098:	91 83       	std	Z+1, r25	; 0x01
    109a:	a2 83       	std	Z+2, r26	; 0x02
    109c:	b3 83       	std	Z+3, r27	; 0x03
    *gxds = (double)(gx-MPU6050_GXOFFSET)/MPU6050_GXGAIN;
    109e:	8f 81       	ldd	r24, Y+7	; 0x07
    10a0:	98 85       	ldd	r25, Y+8	; 0x08
    10a2:	8a 96       	adiw	r24, 0x2a	; 42
    10a4:	aa 27       	eor	r26, r26
    10a6:	97 fd       	sbrc	r25, 7
    10a8:	a0 95       	com	r26
    10aa:	ba 2f       	mov	r27, r26
    10ac:	bc 01       	movw	r22, r24
    10ae:	cd 01       	movw	r24, r26
    10b0:	0e 94 c2 2c 	call	0x5984	; 0x5984 <__floatsisf>
    10b4:	dc 01       	movw	r26, r24
    10b6:	cb 01       	movw	r24, r22
    10b8:	23 e3       	ldi	r18, 0x33	; 51
    10ba:	33 e3       	ldi	r19, 0x33	; 51
    10bc:	43 e8       	ldi	r20, 0x83	; 131
    10be:	51 e4       	ldi	r21, 0x41	; 65
    10c0:	bc 01       	movw	r22, r24
    10c2:	cd 01       	movw	r24, r26
    10c4:	0e 94 2c 2c 	call	0x5858	; 0x5858 <__divsf3>
    10c8:	dc 01       	movw	r26, r24
    10ca:	cb 01       	movw	r24, r22
    10cc:	2b 89       	ldd	r18, Y+19	; 0x13
    10ce:	3c 89       	ldd	r19, Y+20	; 0x14
    10d0:	f9 01       	movw	r30, r18
    10d2:	80 83       	st	Z, r24
    10d4:	91 83       	std	Z+1, r25	; 0x01
    10d6:	a2 83       	std	Z+2, r26	; 0x02
    10d8:	b3 83       	std	Z+3, r27	; 0x03
	*gyds = (double)(gy-MPU6050_GYOFFSET)/MPU6050_GYGAIN;
    10da:	89 85       	ldd	r24, Y+9	; 0x09
    10dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    10de:	09 97       	sbiw	r24, 0x09	; 9
    10e0:	aa 27       	eor	r26, r26
    10e2:	97 fd       	sbrc	r25, 7
    10e4:	a0 95       	com	r26
    10e6:	ba 2f       	mov	r27, r26
    10e8:	bc 01       	movw	r22, r24
    10ea:	cd 01       	movw	r24, r26
    10ec:	0e 94 c2 2c 	call	0x5984	; 0x5984 <__floatsisf>
    10f0:	dc 01       	movw	r26, r24
    10f2:	cb 01       	movw	r24, r22
    10f4:	23 e3       	ldi	r18, 0x33	; 51
    10f6:	33 e3       	ldi	r19, 0x33	; 51
    10f8:	43 e8       	ldi	r20, 0x83	; 131
    10fa:	51 e4       	ldi	r21, 0x41	; 65
    10fc:	bc 01       	movw	r22, r24
    10fe:	cd 01       	movw	r24, r26
    1100:	0e 94 2c 2c 	call	0x5858	; 0x5858 <__divsf3>
    1104:	dc 01       	movw	r26, r24
    1106:	cb 01       	movw	r24, r22
    1108:	2d 89       	ldd	r18, Y+21	; 0x15
    110a:	3e 89       	ldd	r19, Y+22	; 0x16
    110c:	f9 01       	movw	r30, r18
    110e:	80 83       	st	Z, r24
    1110:	91 83       	std	Z+1, r25	; 0x01
    1112:	a2 83       	std	Z+2, r26	; 0x02
    1114:	b3 83       	std	Z+3, r27	; 0x03
	*gzds = (double)(gz-MPU6050_GZOFFSET)/MPU6050_GZGAIN;
    1116:	8b 85       	ldd	r24, Y+11	; 0x0b
    1118:	9c 85       	ldd	r25, Y+12	; 0x0c
    111a:	4d 96       	adiw	r24, 0x1d	; 29
    111c:	aa 27       	eor	r26, r26
    111e:	97 fd       	sbrc	r25, 7
    1120:	a0 95       	com	r26
    1122:	ba 2f       	mov	r27, r26
    1124:	bc 01       	movw	r22, r24
    1126:	cd 01       	movw	r24, r26
    1128:	0e 94 c2 2c 	call	0x5984	; 0x5984 <__floatsisf>
    112c:	dc 01       	movw	r26, r24
    112e:	cb 01       	movw	r24, r22
    1130:	23 e3       	ldi	r18, 0x33	; 51
    1132:	33 e3       	ldi	r19, 0x33	; 51
    1134:	43 e8       	ldi	r20, 0x83	; 131
    1136:	51 e4       	ldi	r21, 0x41	; 65
    1138:	bc 01       	movw	r22, r24
    113a:	cd 01       	movw	r24, r26
    113c:	0e 94 2c 2c 	call	0x5858	; 0x5858 <__divsf3>
    1140:	dc 01       	movw	r26, r24
    1142:	cb 01       	movw	r24, r22
    1144:	2f 89       	ldd	r18, Y+23	; 0x17
    1146:	38 8d       	ldd	r19, Y+24	; 0x18
    1148:	f9 01       	movw	r30, r18
    114a:	80 83       	st	Z, r24
    114c:	91 83       	std	Z+1, r25	; 0x01
    114e:	a2 83       	std	Z+2, r26	; 0x02
    1150:	b3 83       	std	Z+3, r27	; 0x03
    *azg = (double)(az)/MPU6050_AGAIN;
    *gxds = (double)(gx)/MPU6050_GGAIN;
	*gyds = (double)(gy)/MPU6050_GGAIN;
	*gzds = (double)(gz)/MPU6050_GGAIN;
	#endif
}
    1152:	68 96       	adiw	r28, 0x18	; 24
    1154:	0f b6       	in	r0, 0x3f	; 63
    1156:	f8 94       	cli
    1158:	de bf       	out	0x3e, r29	; 62
    115a:	0f be       	out	0x3f, r0	; 63
    115c:	cd bf       	out	0x3d, r28	; 61
    115e:	df 91       	pop	r29
    1160:	cf 91       	pop	r28
    1162:	1f 91       	pop	r17
    1164:	0f 91       	pop	r16
    1166:	ff 90       	pop	r15
    1168:	ef 90       	pop	r14
    116a:	08 95       	ret

0000116c <mpu6050_init>:
/*
 * initialize the accel and gyro
 */
void mpu6050_init() {
    116c:	cf 93       	push	r28
    116e:	df 93       	push	r29
    1170:	cd b7       	in	r28, 0x3d	; 61
    1172:	de b7       	in	r29, 0x3e	; 62
	mpu6050_writeBits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, MPU6050_CLOCK_PLL_XGYRO);
    1174:	21 e0       	ldi	r18, 0x01	; 1
    1176:	43 e0       	ldi	r20, 0x03	; 3
    1178:	62 e0       	ldi	r22, 0x02	; 2
    117a:	8b e6       	ldi	r24, 0x6B	; 107
    117c:	0e 94 89 06 	call	0xd12	; 0xd12 <mpu6050_writeBits>
	//set DLPF bandwidth to 42Hz
	mpu6050_writeBits(MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, MPU6050_DLPF_BW_42);
    1180:	23 e0       	ldi	r18, 0x03	; 3
    1182:	43 e0       	ldi	r20, 0x03	; 3
    1184:	62 e0       	ldi	r22, 0x02	; 2
    1186:	8a e1       	ldi	r24, 0x1A	; 26
    1188:	0e 94 89 06 	call	0xd12	; 0xd12 <mpu6050_writeBits>
    //set sampe rate
	mpu6050_writeByte(MPU6050_RA_SMPLRT_DIV, 4); //1khz / (1 + 4) = 200Hz
    118c:	64 e0       	ldi	r22, 0x04	; 4
    118e:	89 e1       	ldi	r24, 0x19	; 25
    1190:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <mpu6050_writeByte>
	//set gyro range
	mpu6050_writeBits(MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, MPU6050_GYRO_FS);
    1194:	23 e0       	ldi	r18, 0x03	; 3
    1196:	42 e0       	ldi	r20, 0x02	; 2
    1198:	64 e0       	ldi	r22, 0x04	; 4
    119a:	8b e1       	ldi	r24, 0x1B	; 27
    119c:	0e 94 89 06 	call	0xd12	; 0xd12 <mpu6050_writeBits>
	//set accel range
	mpu6050_writeBits(MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, MPU6050_ACCEL_FS);
    11a0:	20 e0       	ldi	r18, 0x00	; 0
    11a2:	42 e0       	ldi	r20, 0x02	; 2
    11a4:	64 e0       	ldi	r22, 0x04	; 4
    11a6:	8c e1       	ldi	r24, 0x1C	; 28
    11a8:	0e 94 89 06 	call	0xd12	; 0xd12 <mpu6050_writeBits>


}
    11ac:	df 91       	pop	r29
    11ae:	cf 91       	pop	r28
    11b0:	08 95       	ret

000011b2 <mpu6050_setSleepDisabled>:
/*
 * set sleep disabled
 */
void mpu6050_setSleepDisabled() {
    11b2:	cf 93       	push	r28
    11b4:	df 93       	push	r29
    11b6:	cd b7       	in	r28, 0x3d	; 61
    11b8:	de b7       	in	r29, 0x3e	; 62
	mpu6050_writeBit(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 0);
    11ba:	40 e0       	ldi	r20, 0x00	; 0
    11bc:	66 e0       	ldi	r22, 0x06	; 6
    11be:	8b e6       	ldi	r24, 0x6B	; 107
    11c0:	0e 94 ef 06 	call	0xdde	; 0xdde <mpu6050_writeBit>
}
    11c4:	df 91       	pop	r29
    11c6:	cf 91       	pop	r28
    11c8:	08 95       	ret

000011ca <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
    11ca:	cf 93       	push	r28
    11cc:	df 93       	push	r29
    11ce:	1f 92       	push	r1
    11d0:	1f 92       	push	r1
    11d2:	cd b7       	in	r28, 0x3d	; 61
    11d4:	de b7       	in	r29, 0x3e	; 62
EventGroup_t *pxEventBits;

	pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
    11d6:	8b e0       	ldi	r24, 0x0B	; 11
    11d8:	90 e0       	ldi	r25, 0x00	; 0
    11da:	0e 94 3b 0c 	call	0x1876	; 0x1876 <pvPortMalloc>
    11de:	9a 83       	std	Y+2, r25	; 0x02
    11e0:	89 83       	std	Y+1, r24	; 0x01
	if( pxEventBits != NULL )
    11e2:	89 81       	ldd	r24, Y+1	; 0x01
    11e4:	9a 81       	ldd	r25, Y+2	; 0x02
    11e6:	00 97       	sbiw	r24, 0x00	; 0
    11e8:	51 f0       	breq	.+20     	; 0x11fe <xEventGroupCreate+0x34>
	{
		pxEventBits->uxEventBits = 0;
    11ea:	89 81       	ldd	r24, Y+1	; 0x01
    11ec:	9a 81       	ldd	r25, Y+2	; 0x02
    11ee:	fc 01       	movw	r30, r24
    11f0:	11 82       	std	Z+1, r1	; 0x01
    11f2:	10 82       	st	Z, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    11f4:	89 81       	ldd	r24, Y+1	; 0x01
    11f6:	9a 81       	ldd	r25, Y+2	; 0x02
    11f8:	02 96       	adiw	r24, 0x02	; 2
    11fa:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInitialise>
	else
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
    11fe:	89 81       	ldd	r24, Y+1	; 0x01
    1200:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1202:	0f 90       	pop	r0
    1204:	0f 90       	pop	r0
    1206:	df 91       	pop	r29
    1208:	cf 91       	pop	r28
    120a:	08 95       	ret

0000120c <xEventGroupSync>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    120c:	cf 93       	push	r28
    120e:	df 93       	push	r29
    1210:	cd b7       	in	r28, 0x3d	; 61
    1212:	de b7       	in	r29, 0x3e	; 62
    1214:	60 97       	sbiw	r28, 0x10	; 16
    1216:	0f b6       	in	r0, 0x3f	; 63
    1218:	f8 94       	cli
    121a:	de bf       	out	0x3e, r29	; 62
    121c:	0f be       	out	0x3f, r0	; 63
    121e:	cd bf       	out	0x3d, r28	; 61
    1220:	9a 87       	std	Y+10, r25	; 0x0a
    1222:	89 87       	std	Y+9, r24	; 0x09
    1224:	7c 87       	std	Y+12, r23	; 0x0c
    1226:	6b 87       	std	Y+11, r22	; 0x0b
    1228:	5e 87       	std	Y+14, r21	; 0x0e
    122a:	4d 87       	std	Y+13, r20	; 0x0d
    122c:	38 8b       	std	Y+16, r19	; 0x10
    122e:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1230:	89 85       	ldd	r24, Y+9	; 0x09
    1232:	9a 85       	ldd	r25, Y+10	; 0x0a
    1234:	9c 83       	std	Y+4, r25	; 0x04
    1236:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1238:	1d 82       	std	Y+5, r1	; 0x05
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    123a:	0e 94 13 20 	call	0x4026	; 0x4026 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    123e:	8b 81       	ldd	r24, Y+3	; 0x03
    1240:	9c 81       	ldd	r25, Y+4	; 0x04
    1242:	fc 01       	movw	r30, r24
    1244:	80 81       	ld	r24, Z
    1246:	91 81       	ldd	r25, Z+1	; 0x01
    1248:	9f 83       	std	Y+7, r25	; 0x07
    124a:	8e 83       	std	Y+6, r24	; 0x06

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    124c:	2b 85       	ldd	r18, Y+11	; 0x0b
    124e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1250:	89 85       	ldd	r24, Y+9	; 0x09
    1252:	9a 85       	ldd	r25, Y+10	; 0x0a
    1254:	b9 01       	movw	r22, r18
    1256:	0e 94 e3 0a 	call	0x15c6	; 0x15c6 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    125a:	2e 81       	ldd	r18, Y+6	; 0x06
    125c:	3f 81       	ldd	r19, Y+7	; 0x07
    125e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1260:	9c 85       	ldd	r25, Y+12	; 0x0c
    1262:	28 2b       	or	r18, r24
    1264:	39 2b       	or	r19, r25
    1266:	8d 85       	ldd	r24, Y+13	; 0x0d
    1268:	9e 85       	ldd	r25, Y+14	; 0x0e
    126a:	28 23       	and	r18, r24
    126c:	39 23       	and	r19, r25
    126e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1270:	9e 85       	ldd	r25, Y+14	; 0x0e
    1272:	28 17       	cp	r18, r24
    1274:	39 07       	cpc	r19, r25
    1276:	d9 f4       	brne	.+54     	; 0x12ae <xEventGroupSync+0xa2>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1278:	2e 81       	ldd	r18, Y+6	; 0x06
    127a:	3f 81       	ldd	r19, Y+7	; 0x07
    127c:	8b 85       	ldd	r24, Y+11	; 0x0b
    127e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1280:	82 2b       	or	r24, r18
    1282:	93 2b       	or	r25, r19
    1284:	9a 83       	std	Y+2, r25	; 0x02
    1286:	89 83       	std	Y+1, r24	; 0x01

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1288:	8b 81       	ldd	r24, Y+3	; 0x03
    128a:	9c 81       	ldd	r25, Y+4	; 0x04
    128c:	fc 01       	movw	r30, r24
    128e:	20 81       	ld	r18, Z
    1290:	31 81       	ldd	r19, Z+1	; 0x01
    1292:	8d 85       	ldd	r24, Y+13	; 0x0d
    1294:	9e 85       	ldd	r25, Y+14	; 0x0e
    1296:	80 95       	com	r24
    1298:	90 95       	com	r25
    129a:	28 23       	and	r18, r24
    129c:	39 23       	and	r19, r25
    129e:	8b 81       	ldd	r24, Y+3	; 0x03
    12a0:	9c 81       	ldd	r25, Y+4	; 0x04
    12a2:	fc 01       	movw	r30, r24
    12a4:	31 83       	std	Z+1, r19	; 0x01
    12a6:	20 83       	st	Z, r18

			xTicksToWait = 0;
    12a8:	18 8a       	std	Y+16, r1	; 0x10
    12aa:	1f 86       	std	Y+15, r1	; 0x0f
    12ac:	1a c0       	rjmp	.+52     	; 0x12e2 <xEventGroupSync+0xd6>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    12ae:	8f 85       	ldd	r24, Y+15	; 0x0f
    12b0:	98 89       	ldd	r25, Y+16	; 0x10
    12b2:	00 97       	sbiw	r24, 0x00	; 0
    12b4:	79 f0       	breq	.+30     	; 0x12d4 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    12b6:	8d 85       	ldd	r24, Y+13	; 0x0d
    12b8:	9e 85       	ldd	r25, Y+14	; 0x0e
    12ba:	9c 01       	movw	r18, r24
    12bc:	35 60       	ori	r19, 0x05	; 5
    12be:	8b 81       	ldd	r24, Y+3	; 0x03
    12c0:	9c 81       	ldd	r25, Y+4	; 0x04
    12c2:	02 96       	adiw	r24, 0x02	; 2
    12c4:	4f 85       	ldd	r20, Y+15	; 0x0f
    12c6:	58 89       	ldd	r21, Y+16	; 0x10
    12c8:	b9 01       	movw	r22, r18
    12ca:	0e 94 a4 22 	call	0x4548	; 0x4548 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    12ce:	1a 82       	std	Y+2, r1	; 0x02
    12d0:	19 82       	std	Y+1, r1	; 0x01
    12d2:	07 c0       	rjmp	.+14     	; 0x12e2 <xEventGroupSync+0xd6>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    12d4:	8b 81       	ldd	r24, Y+3	; 0x03
    12d6:	9c 81       	ldd	r25, Y+4	; 0x04
    12d8:	fc 01       	movw	r30, r24
    12da:	80 81       	ld	r24, Z
    12dc:	91 81       	ldd	r25, Z+1	; 0x01
    12de:	9a 83       	std	Y+2, r25	; 0x02
    12e0:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    12e2:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>
    12e6:	88 87       	std	Y+8, r24	; 0x08

	if( xTicksToWait != ( TickType_t ) 0 )
    12e8:	8f 85       	ldd	r24, Y+15	; 0x0f
    12ea:	98 89       	ldd	r25, Y+16	; 0x10
    12ec:	00 97       	sbiw	r24, 0x00	; 0
    12ee:	09 f4       	brne	.+2      	; 0x12f2 <xEventGroupSync+0xe6>
    12f0:	3d c0       	rjmp	.+122    	; 0x136c <xEventGroupSync+0x160>
	{
		if( xAlreadyYielded == pdFALSE )
    12f2:	88 85       	ldd	r24, Y+8	; 0x08
    12f4:	88 23       	and	r24, r24
    12f6:	11 f4       	brne	.+4      	; 0x12fc <xEventGroupSync+0xf0>
		{
			portYIELD_WITHIN_API();
    12f8:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    12fc:	0e 94 e0 27 	call	0x4fc0	; 0x4fc0 <uxTaskResetEventItemValue>
    1300:	9a 83       	std	Y+2, r25	; 0x02
    1302:	89 83       	std	Y+1, r24	; 0x01

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1304:	89 81       	ldd	r24, Y+1	; 0x01
    1306:	9a 81       	ldd	r25, Y+2	; 0x02
    1308:	88 27       	eor	r24, r24
    130a:	92 70       	andi	r25, 0x02	; 2
    130c:	00 97       	sbiw	r24, 0x00	; 0
    130e:	49 f5       	brne	.+82     	; 0x1362 <xEventGroupSync+0x156>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1310:	0f b6       	in	r0, 0x3f	; 63
    1312:	f8 94       	cli
    1314:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1316:	8b 81       	ldd	r24, Y+3	; 0x03
    1318:	9c 81       	ldd	r25, Y+4	; 0x04
    131a:	fc 01       	movw	r30, r24
    131c:	80 81       	ld	r24, Z
    131e:	91 81       	ldd	r25, Z+1	; 0x01
    1320:	9a 83       	std	Y+2, r25	; 0x02
    1322:	89 83       	std	Y+1, r24	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1324:	29 81       	ldd	r18, Y+1	; 0x01
    1326:	3a 81       	ldd	r19, Y+2	; 0x02
    1328:	8d 85       	ldd	r24, Y+13	; 0x0d
    132a:	9e 85       	ldd	r25, Y+14	; 0x0e
    132c:	28 23       	and	r18, r24
    132e:	39 23       	and	r19, r25
    1330:	8d 85       	ldd	r24, Y+13	; 0x0d
    1332:	9e 85       	ldd	r25, Y+14	; 0x0e
    1334:	28 17       	cp	r18, r24
    1336:	39 07       	cpc	r19, r25
    1338:	81 f4       	brne	.+32     	; 0x135a <xEventGroupSync+0x14e>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    133a:	8b 81       	ldd	r24, Y+3	; 0x03
    133c:	9c 81       	ldd	r25, Y+4	; 0x04
    133e:	fc 01       	movw	r30, r24
    1340:	20 81       	ld	r18, Z
    1342:	31 81       	ldd	r19, Z+1	; 0x01
    1344:	8d 85       	ldd	r24, Y+13	; 0x0d
    1346:	9e 85       	ldd	r25, Y+14	; 0x0e
    1348:	80 95       	com	r24
    134a:	90 95       	com	r25
    134c:	28 23       	and	r18, r24
    134e:	39 23       	and	r19, r25
    1350:	8b 81       	ldd	r24, Y+3	; 0x03
    1352:	9c 81       	ldd	r25, Y+4	; 0x04
    1354:	fc 01       	movw	r30, r24
    1356:	31 83       	std	Z+1, r19	; 0x01
    1358:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    135a:	0f 90       	pop	r0
    135c:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    135e:	81 e0       	ldi	r24, 0x01	; 1
    1360:	8d 83       	std	Y+5, r24	; 0x05
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1362:	89 81       	ldd	r24, Y+1	; 0x01
    1364:	9a 81       	ldd	r25, Y+2	; 0x02
    1366:	99 27       	eor	r25, r25
    1368:	9a 83       	std	Y+2, r25	; 0x02
    136a:	89 83       	std	Y+1, r24	; 0x01
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    136c:	89 81       	ldd	r24, Y+1	; 0x01
    136e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1370:	60 96       	adiw	r28, 0x10	; 16
    1372:	0f b6       	in	r0, 0x3f	; 63
    1374:	f8 94       	cli
    1376:	de bf       	out	0x3e, r29	; 62
    1378:	0f be       	out	0x3f, r0	; 63
    137a:	cd bf       	out	0x3d, r28	; 61
    137c:	df 91       	pop	r29
    137e:	cf 91       	pop	r28
    1380:	08 95       	ret

00001382 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    1382:	0f 93       	push	r16
    1384:	1f 93       	push	r17
    1386:	cf 93       	push	r28
    1388:	df 93       	push	r29
    138a:	cd b7       	in	r28, 0x3d	; 61
    138c:	de b7       	in	r29, 0x3e	; 62
    138e:	63 97       	sbiw	r28, 0x13	; 19
    1390:	0f b6       	in	r0, 0x3f	; 63
    1392:	f8 94       	cli
    1394:	de bf       	out	0x3e, r29	; 62
    1396:	0f be       	out	0x3f, r0	; 63
    1398:	cd bf       	out	0x3d, r28	; 61
    139a:	9d 87       	std	Y+13, r25	; 0x0d
    139c:	8c 87       	std	Y+12, r24	; 0x0c
    139e:	7f 87       	std	Y+15, r23	; 0x0f
    13a0:	6e 87       	std	Y+14, r22	; 0x0e
    13a2:	48 8b       	std	Y+16, r20	; 0x10
    13a4:	29 8b       	std	Y+17, r18	; 0x11
    13a6:	1b 8b       	std	Y+19, r17	; 0x13
    13a8:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    13aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    13ac:	9d 85       	ldd	r25, Y+13	; 0x0d
    13ae:	9e 83       	std	Y+6, r25	; 0x06
    13b0:	8d 83       	std	Y+5, r24	; 0x05
EventBits_t uxReturn, uxControlBits = 0;
    13b2:	1c 82       	std	Y+4, r1	; 0x04
    13b4:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    13b6:	1f 82       	std	Y+7, r1	; 0x07
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    13b8:	0e 94 13 20 	call	0x4026	; 0x4026 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    13bc:	8d 81       	ldd	r24, Y+5	; 0x05
    13be:	9e 81       	ldd	r25, Y+6	; 0x06
    13c0:	fc 01       	movw	r30, r24
    13c2:	80 81       	ld	r24, Z
    13c4:	91 81       	ldd	r25, Z+1	; 0x01
    13c6:	99 87       	std	Y+9, r25	; 0x09
    13c8:	88 87       	std	Y+8, r24	; 0x08

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    13ca:	2e 85       	ldd	r18, Y+14	; 0x0e
    13cc:	3f 85       	ldd	r19, Y+15	; 0x0f
    13ce:	88 85       	ldd	r24, Y+8	; 0x08
    13d0:	99 85       	ldd	r25, Y+9	; 0x09
    13d2:	49 89       	ldd	r20, Y+17	; 0x11
    13d4:	b9 01       	movw	r22, r18
    13d6:	0e 94 0a 0c 	call	0x1814	; 0x1814 <prvTestWaitCondition>
    13da:	8a 87       	std	Y+10, r24	; 0x0a

		if( xWaitConditionMet != pdFALSE )
    13dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    13de:	88 23       	and	r24, r24
    13e0:	d1 f0       	breq	.+52     	; 0x1416 <xEventGroupWaitBits+0x94>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    13e2:	88 85       	ldd	r24, Y+8	; 0x08
    13e4:	99 85       	ldd	r25, Y+9	; 0x09
    13e6:	9a 83       	std	Y+2, r25	; 0x02
    13e8:	89 83       	std	Y+1, r24	; 0x01
			xTicksToWait = ( TickType_t ) 0;
    13ea:	1b 8a       	std	Y+19, r1	; 0x13
    13ec:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    13ee:	88 89       	ldd	r24, Y+16	; 0x10
    13f0:	88 23       	and	r24, r24
    13f2:	d1 f1       	breq	.+116    	; 0x1468 <xEventGroupWaitBits+0xe6>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    13f4:	8d 81       	ldd	r24, Y+5	; 0x05
    13f6:	9e 81       	ldd	r25, Y+6	; 0x06
    13f8:	fc 01       	movw	r30, r24
    13fa:	20 81       	ld	r18, Z
    13fc:	31 81       	ldd	r19, Z+1	; 0x01
    13fe:	8e 85       	ldd	r24, Y+14	; 0x0e
    1400:	9f 85       	ldd	r25, Y+15	; 0x0f
    1402:	80 95       	com	r24
    1404:	90 95       	com	r25
    1406:	28 23       	and	r18, r24
    1408:	39 23       	and	r19, r25
    140a:	8d 81       	ldd	r24, Y+5	; 0x05
    140c:	9e 81       	ldd	r25, Y+6	; 0x06
    140e:	fc 01       	movw	r30, r24
    1410:	31 83       	std	Z+1, r19	; 0x01
    1412:	20 83       	st	Z, r18
    1414:	29 c0       	rjmp	.+82     	; 0x1468 <xEventGroupWaitBits+0xe6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    1416:	8a 89       	ldd	r24, Y+18	; 0x12
    1418:	9b 89       	ldd	r25, Y+19	; 0x13
    141a:	00 97       	sbiw	r24, 0x00	; 0
    141c:	29 f4       	brne	.+10     	; 0x1428 <xEventGroupWaitBits+0xa6>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    141e:	88 85       	ldd	r24, Y+8	; 0x08
    1420:	99 85       	ldd	r25, Y+9	; 0x09
    1422:	9a 83       	std	Y+2, r25	; 0x02
    1424:	89 83       	std	Y+1, r24	; 0x01
    1426:	20 c0       	rjmp	.+64     	; 0x1468 <xEventGroupWaitBits+0xe6>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    1428:	88 89       	ldd	r24, Y+16	; 0x10
    142a:	88 23       	and	r24, r24
    142c:	29 f0       	breq	.+10     	; 0x1438 <xEventGroupWaitBits+0xb6>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    142e:	8b 81       	ldd	r24, Y+3	; 0x03
    1430:	9c 81       	ldd	r25, Y+4	; 0x04
    1432:	91 60       	ori	r25, 0x01	; 1
    1434:	9c 83       	std	Y+4, r25	; 0x04
    1436:	8b 83       	std	Y+3, r24	; 0x03
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    1438:	89 89       	ldd	r24, Y+17	; 0x11
    143a:	88 23       	and	r24, r24
    143c:	29 f0       	breq	.+10     	; 0x1448 <xEventGroupWaitBits+0xc6>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    143e:	8b 81       	ldd	r24, Y+3	; 0x03
    1440:	9c 81       	ldd	r25, Y+4	; 0x04
    1442:	94 60       	ori	r25, 0x04	; 4
    1444:	9c 83       	std	Y+4, r25	; 0x04
    1446:	8b 83       	std	Y+3, r24	; 0x03
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1448:	2e 85       	ldd	r18, Y+14	; 0x0e
    144a:	3f 85       	ldd	r19, Y+15	; 0x0f
    144c:	8b 81       	ldd	r24, Y+3	; 0x03
    144e:	9c 81       	ldd	r25, Y+4	; 0x04
    1450:	28 2b       	or	r18, r24
    1452:	39 2b       	or	r19, r25
    1454:	8d 81       	ldd	r24, Y+5	; 0x05
    1456:	9e 81       	ldd	r25, Y+6	; 0x06
    1458:	02 96       	adiw	r24, 0x02	; 2
    145a:	4a 89       	ldd	r20, Y+18	; 0x12
    145c:	5b 89       	ldd	r21, Y+19	; 0x13
    145e:	b9 01       	movw	r22, r18
    1460:	0e 94 a4 22 	call	0x4548	; 0x4548 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    1464:	1a 82       	std	Y+2, r1	; 0x02
    1466:	19 82       	std	Y+1, r1	; 0x01

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1468:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>
    146c:	8b 87       	std	Y+11, r24	; 0x0b

	if( xTicksToWait != ( TickType_t ) 0 )
    146e:	8a 89       	ldd	r24, Y+18	; 0x12
    1470:	9b 89       	ldd	r25, Y+19	; 0x13
    1472:	00 97       	sbiw	r24, 0x00	; 0
    1474:	09 f4       	brne	.+2      	; 0x1478 <xEventGroupWaitBits+0xf6>
    1476:	3e c0       	rjmp	.+124    	; 0x14f4 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
    1478:	8b 85       	ldd	r24, Y+11	; 0x0b
    147a:	88 23       	and	r24, r24
    147c:	11 f4       	brne	.+4      	; 0x1482 <xEventGroupWaitBits+0x100>
		{
			portYIELD_WITHIN_API();
    147e:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1482:	0e 94 e0 27 	call	0x4fc0	; 0x4fc0 <uxTaskResetEventItemValue>
    1486:	9a 83       	std	Y+2, r25	; 0x02
    1488:	89 83       	std	Y+1, r24	; 0x01

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    148a:	89 81       	ldd	r24, Y+1	; 0x01
    148c:	9a 81       	ldd	r25, Y+2	; 0x02
    148e:	88 27       	eor	r24, r24
    1490:	92 70       	andi	r25, 0x02	; 2
    1492:	00 97       	sbiw	r24, 0x00	; 0
    1494:	51 f5       	brne	.+84     	; 0x14ea <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
    1496:	0f b6       	in	r0, 0x3f	; 63
    1498:	f8 94       	cli
    149a:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    149c:	8d 81       	ldd	r24, Y+5	; 0x05
    149e:	9e 81       	ldd	r25, Y+6	; 0x06
    14a0:	fc 01       	movw	r30, r24
    14a2:	80 81       	ld	r24, Z
    14a4:	91 81       	ldd	r25, Z+1	; 0x01
    14a6:	9a 83       	std	Y+2, r25	; 0x02
    14a8:	89 83       	std	Y+1, r24	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    14aa:	2e 85       	ldd	r18, Y+14	; 0x0e
    14ac:	3f 85       	ldd	r19, Y+15	; 0x0f
    14ae:	89 81       	ldd	r24, Y+1	; 0x01
    14b0:	9a 81       	ldd	r25, Y+2	; 0x02
    14b2:	49 89       	ldd	r20, Y+17	; 0x11
    14b4:	b9 01       	movw	r22, r18
    14b6:	0e 94 0a 0c 	call	0x1814	; 0x1814 <prvTestWaitCondition>
    14ba:	88 23       	and	r24, r24
    14bc:	99 f0       	breq	.+38     	; 0x14e4 <xEventGroupWaitBits+0x162>
				{
					if( xClearOnExit != pdFALSE )
    14be:	88 89       	ldd	r24, Y+16	; 0x10
    14c0:	88 23       	and	r24, r24
    14c2:	81 f0       	breq	.+32     	; 0x14e4 <xEventGroupWaitBits+0x162>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    14c4:	8d 81       	ldd	r24, Y+5	; 0x05
    14c6:	9e 81       	ldd	r25, Y+6	; 0x06
    14c8:	fc 01       	movw	r30, r24
    14ca:	20 81       	ld	r18, Z
    14cc:	31 81       	ldd	r19, Z+1	; 0x01
    14ce:	8e 85       	ldd	r24, Y+14	; 0x0e
    14d0:	9f 85       	ldd	r25, Y+15	; 0x0f
    14d2:	80 95       	com	r24
    14d4:	90 95       	com	r25
    14d6:	28 23       	and	r18, r24
    14d8:	39 23       	and	r19, r25
    14da:	8d 81       	ldd	r24, Y+5	; 0x05
    14dc:	9e 81       	ldd	r25, Y+6	; 0x06
    14de:	fc 01       	movw	r30, r24
    14e0:	31 83       	std	Z+1, r19	; 0x01
    14e2:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    14e4:	0f 90       	pop	r0
    14e6:	0f be       	out	0x3f, r0	; 63

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
    14e8:	1f 82       	std	Y+7, r1	; 0x07
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    14ea:	89 81       	ldd	r24, Y+1	; 0x01
    14ec:	9a 81       	ldd	r25, Y+2	; 0x02
    14ee:	99 27       	eor	r25, r25
    14f0:	9a 83       	std	Y+2, r25	; 0x02
    14f2:	89 83       	std	Y+1, r24	; 0x01
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    14f4:	89 81       	ldd	r24, Y+1	; 0x01
    14f6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    14f8:	63 96       	adiw	r28, 0x13	; 19
    14fa:	0f b6       	in	r0, 0x3f	; 63
    14fc:	f8 94       	cli
    14fe:	de bf       	out	0x3e, r29	; 62
    1500:	0f be       	out	0x3f, r0	; 63
    1502:	cd bf       	out	0x3d, r28	; 61
    1504:	df 91       	pop	r29
    1506:	cf 91       	pop	r28
    1508:	1f 91       	pop	r17
    150a:	0f 91       	pop	r16
    150c:	08 95       	ret

0000150e <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    150e:	cf 93       	push	r28
    1510:	df 93       	push	r29
    1512:	cd b7       	in	r28, 0x3d	; 61
    1514:	de b7       	in	r29, 0x3e	; 62
    1516:	28 97       	sbiw	r28, 0x08	; 8
    1518:	0f b6       	in	r0, 0x3f	; 63
    151a:	f8 94       	cli
    151c:	de bf       	out	0x3e, r29	; 62
    151e:	0f be       	out	0x3f, r0	; 63
    1520:	cd bf       	out	0x3d, r28	; 61
    1522:	9e 83       	std	Y+6, r25	; 0x06
    1524:	8d 83       	std	Y+5, r24	; 0x05
    1526:	78 87       	std	Y+8, r23	; 0x08
    1528:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    152a:	8d 81       	ldd	r24, Y+5	; 0x05
    152c:	9e 81       	ldd	r25, Y+6	; 0x06
    152e:	9a 83       	std	Y+2, r25	; 0x02
    1530:	89 83       	std	Y+1, r24	; 0x01
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    1532:	0f b6       	in	r0, 0x3f	; 63
    1534:	f8 94       	cli
    1536:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    1538:	89 81       	ldd	r24, Y+1	; 0x01
    153a:	9a 81       	ldd	r25, Y+2	; 0x02
    153c:	fc 01       	movw	r30, r24
    153e:	80 81       	ld	r24, Z
    1540:	91 81       	ldd	r25, Z+1	; 0x01
    1542:	9c 83       	std	Y+4, r25	; 0x04
    1544:	8b 83       	std	Y+3, r24	; 0x03

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1546:	89 81       	ldd	r24, Y+1	; 0x01
    1548:	9a 81       	ldd	r25, Y+2	; 0x02
    154a:	fc 01       	movw	r30, r24
    154c:	20 81       	ld	r18, Z
    154e:	31 81       	ldd	r19, Z+1	; 0x01
    1550:	8f 81       	ldd	r24, Y+7	; 0x07
    1552:	98 85       	ldd	r25, Y+8	; 0x08
    1554:	80 95       	com	r24
    1556:	90 95       	com	r25
    1558:	28 23       	and	r18, r24
    155a:	39 23       	and	r19, r25
    155c:	89 81       	ldd	r24, Y+1	; 0x01
    155e:	9a 81       	ldd	r25, Y+2	; 0x02
    1560:	fc 01       	movw	r30, r24
    1562:	31 83       	std	Z+1, r19	; 0x01
    1564:	20 83       	st	Z, r18
	}
	taskEXIT_CRITICAL();
    1566:	0f 90       	pop	r0
    1568:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    156a:	8b 81       	ldd	r24, Y+3	; 0x03
    156c:	9c 81       	ldd	r25, Y+4	; 0x04
}
    156e:	28 96       	adiw	r28, 0x08	; 8
    1570:	0f b6       	in	r0, 0x3f	; 63
    1572:	f8 94       	cli
    1574:	de bf       	out	0x3e, r29	; 62
    1576:	0f be       	out	0x3f, r0	; 63
    1578:	cd bf       	out	0x3d, r28	; 61
    157a:	df 91       	pop	r29
    157c:	cf 91       	pop	r28
    157e:	08 95       	ret

00001580 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1580:	cf 93       	push	r28
    1582:	df 93       	push	r29
    1584:	cd b7       	in	r28, 0x3d	; 61
    1586:	de b7       	in	r29, 0x3e	; 62
    1588:	27 97       	sbiw	r28, 0x07	; 7
    158a:	0f b6       	in	r0, 0x3f	; 63
    158c:	f8 94       	cli
    158e:	de bf       	out	0x3e, r29	; 62
    1590:	0f be       	out	0x3f, r0	; 63
    1592:	cd bf       	out	0x3d, r28	; 61
    1594:	9f 83       	std	Y+7, r25	; 0x07
    1596:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1598:	8e 81       	ldd	r24, Y+6	; 0x06
    159a:	9f 81       	ldd	r25, Y+7	; 0x07
    159c:	9a 83       	std	Y+2, r25	; 0x02
    159e:	89 83       	std	Y+1, r24	; 0x01
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    15a0:	1b 82       	std	Y+3, r1	; 0x03
	{
		uxReturn = pxEventBits->uxEventBits;
    15a2:	89 81       	ldd	r24, Y+1	; 0x01
    15a4:	9a 81       	ldd	r25, Y+2	; 0x02
    15a6:	fc 01       	movw	r30, r24
    15a8:	80 81       	ld	r24, Z
    15aa:	91 81       	ldd	r25, Z+1	; 0x01
    15ac:	9d 83       	std	Y+5, r25	; 0x05
    15ae:	8c 83       	std	Y+4, r24	; 0x04
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    15b0:	8c 81       	ldd	r24, Y+4	; 0x04
    15b2:	9d 81       	ldd	r25, Y+5	; 0x05
}
    15b4:	27 96       	adiw	r28, 0x07	; 7
    15b6:	0f b6       	in	r0, 0x3f	; 63
    15b8:	f8 94       	cli
    15ba:	de bf       	out	0x3e, r29	; 62
    15bc:	0f be       	out	0x3f, r0	; 63
    15be:	cd bf       	out	0x3d, r28	; 61
    15c0:	df 91       	pop	r29
    15c2:	cf 91       	pop	r28
    15c4:	08 95       	ret

000015c6 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    15c6:	cf 93       	push	r28
    15c8:	df 93       	push	r29
    15ca:	cd b7       	in	r28, 0x3d	; 61
    15cc:	de b7       	in	r29, 0x3e	; 62
    15ce:	65 97       	sbiw	r28, 0x15	; 21
    15d0:	0f b6       	in	r0, 0x3f	; 63
    15d2:	f8 94       	cli
    15d4:	de bf       	out	0x3e, r29	; 62
    15d6:	0f be       	out	0x3f, r0	; 63
    15d8:	cd bf       	out	0x3d, r28	; 61
    15da:	9b 8b       	std	Y+19, r25	; 0x13
    15dc:	8a 8b       	std	Y+18, r24	; 0x12
    15de:	7d 8b       	std	Y+21, r23	; 0x15
    15e0:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    15e2:	1c 82       	std	Y+4, r1	; 0x04
    15e4:	1b 82       	std	Y+3, r1	; 0x03
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    15e6:	8a 89       	ldd	r24, Y+18	; 0x12
    15e8:	9b 89       	ldd	r25, Y+19	; 0x13
    15ea:	9f 83       	std	Y+7, r25	; 0x07
    15ec:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xMatchFound = pdFALSE;
    15ee:	1d 82       	std	Y+5, r1	; 0x05
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    15f0:	8e 81       	ldd	r24, Y+6	; 0x06
    15f2:	9f 81       	ldd	r25, Y+7	; 0x07
    15f4:	02 96       	adiw	r24, 0x02	; 2
    15f6:	99 87       	std	Y+9, r25	; 0x09
    15f8:	88 87       	std	Y+8, r24	; 0x08
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    15fa:	88 85       	ldd	r24, Y+8	; 0x08
    15fc:	99 85       	ldd	r25, Y+9	; 0x09
    15fe:	03 96       	adiw	r24, 0x03	; 3
    1600:	9b 87       	std	Y+11, r25	; 0x0b
    1602:	8a 87       	std	Y+10, r24	; 0x0a
	vTaskSuspendAll();
    1604:	0e 94 13 20 	call	0x4026	; 0x4026 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    1608:	88 85       	ldd	r24, Y+8	; 0x08
    160a:	99 85       	ldd	r25, Y+9	; 0x09
    160c:	fc 01       	movw	r30, r24
    160e:	85 81       	ldd	r24, Z+5	; 0x05
    1610:	96 81       	ldd	r25, Z+6	; 0x06
    1612:	9a 83       	std	Y+2, r25	; 0x02
    1614:	89 83       	std	Y+1, r24	; 0x01

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    1616:	8e 81       	ldd	r24, Y+6	; 0x06
    1618:	9f 81       	ldd	r25, Y+7	; 0x07
    161a:	fc 01       	movw	r30, r24
    161c:	20 81       	ld	r18, Z
    161e:	31 81       	ldd	r19, Z+1	; 0x01
    1620:	8c 89       	ldd	r24, Y+20	; 0x14
    1622:	9d 89       	ldd	r25, Y+21	; 0x15
    1624:	28 2b       	or	r18, r24
    1626:	39 2b       	or	r19, r25
    1628:	8e 81       	ldd	r24, Y+6	; 0x06
    162a:	9f 81       	ldd	r25, Y+7	; 0x07
    162c:	fc 01       	movw	r30, r24
    162e:	31 83       	std	Z+1, r19	; 0x01
    1630:	20 83       	st	Z, r18

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    1632:	5e c0       	rjmp	.+188    	; 0x16f0 <xEventGroupSetBits+0x12a>
		{
			pxNext = listGET_NEXT( pxListItem );
    1634:	89 81       	ldd	r24, Y+1	; 0x01
    1636:	9a 81       	ldd	r25, Y+2	; 0x02
    1638:	fc 01       	movw	r30, r24
    163a:	82 81       	ldd	r24, Z+2	; 0x02
    163c:	93 81       	ldd	r25, Z+3	; 0x03
    163e:	9d 87       	std	Y+13, r25	; 0x0d
    1640:	8c 87       	std	Y+12, r24	; 0x0c
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1642:	89 81       	ldd	r24, Y+1	; 0x01
    1644:	9a 81       	ldd	r25, Y+2	; 0x02
    1646:	fc 01       	movw	r30, r24
    1648:	80 81       	ld	r24, Z
    164a:	91 81       	ldd	r25, Z+1	; 0x01
    164c:	9f 87       	std	Y+15, r25	; 0x0f
    164e:	8e 87       	std	Y+14, r24	; 0x0e
			xMatchFound = pdFALSE;
    1650:	1d 82       	std	Y+5, r1	; 0x05

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1652:	8e 85       	ldd	r24, Y+14	; 0x0e
    1654:	9f 85       	ldd	r25, Y+15	; 0x0f
    1656:	88 27       	eor	r24, r24
    1658:	99 8b       	std	Y+17, r25	; 0x11
    165a:	88 8b       	std	Y+16, r24	; 0x10
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    165c:	8e 85       	ldd	r24, Y+14	; 0x0e
    165e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1660:	99 27       	eor	r25, r25
    1662:	9f 87       	std	Y+15, r25	; 0x0f
    1664:	8e 87       	std	Y+14, r24	; 0x0e

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1666:	88 89       	ldd	r24, Y+16	; 0x10
    1668:	99 89       	ldd	r25, Y+17	; 0x11
    166a:	88 27       	eor	r24, r24
    166c:	94 70       	andi	r25, 0x04	; 4
    166e:	00 97       	sbiw	r24, 0x00	; 0
    1670:	71 f4       	brne	.+28     	; 0x168e <xEventGroupSetBits+0xc8>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1672:	8e 81       	ldd	r24, Y+6	; 0x06
    1674:	9f 81       	ldd	r25, Y+7	; 0x07
    1676:	fc 01       	movw	r30, r24
    1678:	20 81       	ld	r18, Z
    167a:	31 81       	ldd	r19, Z+1	; 0x01
    167c:	8e 85       	ldd	r24, Y+14	; 0x0e
    167e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1680:	82 23       	and	r24, r18
    1682:	93 23       	and	r25, r19
    1684:	00 97       	sbiw	r24, 0x00	; 0
    1686:	99 f0       	breq	.+38     	; 0x16ae <xEventGroupSetBits+0xe8>
				{
					xMatchFound = pdTRUE;
    1688:	81 e0       	ldi	r24, 0x01	; 1
    168a:	8d 83       	std	Y+5, r24	; 0x05
    168c:	10 c0       	rjmp	.+32     	; 0x16ae <xEventGroupSetBits+0xe8>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    168e:	8e 81       	ldd	r24, Y+6	; 0x06
    1690:	9f 81       	ldd	r25, Y+7	; 0x07
    1692:	fc 01       	movw	r30, r24
    1694:	20 81       	ld	r18, Z
    1696:	31 81       	ldd	r19, Z+1	; 0x01
    1698:	8e 85       	ldd	r24, Y+14	; 0x0e
    169a:	9f 85       	ldd	r25, Y+15	; 0x0f
    169c:	28 23       	and	r18, r24
    169e:	39 23       	and	r19, r25
    16a0:	8e 85       	ldd	r24, Y+14	; 0x0e
    16a2:	9f 85       	ldd	r25, Y+15	; 0x0f
    16a4:	28 17       	cp	r18, r24
    16a6:	39 07       	cpc	r19, r25
    16a8:	11 f4       	brne	.+4      	; 0x16ae <xEventGroupSetBits+0xe8>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    16aa:	81 e0       	ldi	r24, 0x01	; 1
    16ac:	8d 83       	std	Y+5, r24	; 0x05
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    16ae:	8d 81       	ldd	r24, Y+5	; 0x05
    16b0:	88 23       	and	r24, r24
    16b2:	d1 f0       	breq	.+52     	; 0x16e8 <xEventGroupSetBits+0x122>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    16b4:	88 89       	ldd	r24, Y+16	; 0x10
    16b6:	99 89       	ldd	r25, Y+17	; 0x11
    16b8:	88 27       	eor	r24, r24
    16ba:	91 70       	andi	r25, 0x01	; 1
    16bc:	00 97       	sbiw	r24, 0x00	; 0
    16be:	41 f0       	breq	.+16     	; 0x16d0 <xEventGroupSetBits+0x10a>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    16c0:	2b 81       	ldd	r18, Y+3	; 0x03
    16c2:	3c 81       	ldd	r19, Y+4	; 0x04
    16c4:	8e 85       	ldd	r24, Y+14	; 0x0e
    16c6:	9f 85       	ldd	r25, Y+15	; 0x0f
    16c8:	82 2b       	or	r24, r18
    16ca:	93 2b       	or	r25, r19
    16cc:	9c 83       	std	Y+4, r25	; 0x04
    16ce:	8b 83       	std	Y+3, r24	; 0x03
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    16d0:	8e 81       	ldd	r24, Y+6	; 0x06
    16d2:	9f 81       	ldd	r25, Y+7	; 0x07
    16d4:	fc 01       	movw	r30, r24
    16d6:	80 81       	ld	r24, Z
    16d8:	91 81       	ldd	r25, Z+1	; 0x01
    16da:	9c 01       	movw	r18, r24
    16dc:	32 60       	ori	r19, 0x02	; 2
    16de:	89 81       	ldd	r24, Y+1	; 0x01
    16e0:	9a 81       	ldd	r25, Y+2	; 0x02
    16e2:	b9 01       	movw	r22, r18
    16e4:	0e 94 66 23 	call	0x46cc	; 0x46cc <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    16e8:	8c 85       	ldd	r24, Y+12	; 0x0c
    16ea:	9d 85       	ldd	r25, Y+13	; 0x0d
    16ec:	9a 83       	std	Y+2, r25	; 0x02
    16ee:	89 83       	std	Y+1, r24	; 0x01

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    16f0:	29 81       	ldd	r18, Y+1	; 0x01
    16f2:	3a 81       	ldd	r19, Y+2	; 0x02
    16f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    16f6:	9b 85       	ldd	r25, Y+11	; 0x0b
    16f8:	28 17       	cp	r18, r24
    16fa:	39 07       	cpc	r19, r25
    16fc:	09 f0       	breq	.+2      	; 0x1700 <xEventGroupSetBits+0x13a>
    16fe:	9a cf       	rjmp	.-204    	; 0x1634 <xEventGroupSetBits+0x6e>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1700:	8e 81       	ldd	r24, Y+6	; 0x06
    1702:	9f 81       	ldd	r25, Y+7	; 0x07
    1704:	fc 01       	movw	r30, r24
    1706:	20 81       	ld	r18, Z
    1708:	31 81       	ldd	r19, Z+1	; 0x01
    170a:	8b 81       	ldd	r24, Y+3	; 0x03
    170c:	9c 81       	ldd	r25, Y+4	; 0x04
    170e:	80 95       	com	r24
    1710:	90 95       	com	r25
    1712:	28 23       	and	r18, r24
    1714:	39 23       	and	r19, r25
    1716:	8e 81       	ldd	r24, Y+6	; 0x06
    1718:	9f 81       	ldd	r25, Y+7	; 0x07
    171a:	fc 01       	movw	r30, r24
    171c:	31 83       	std	Z+1, r19	; 0x01
    171e:	20 83       	st	Z, r18
	}
	( void ) xTaskResumeAll();
    1720:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    1724:	8e 81       	ldd	r24, Y+6	; 0x06
    1726:	9f 81       	ldd	r25, Y+7	; 0x07
    1728:	fc 01       	movw	r30, r24
    172a:	80 81       	ld	r24, Z
    172c:	91 81       	ldd	r25, Z+1	; 0x01
}
    172e:	65 96       	adiw	r28, 0x15	; 21
    1730:	0f b6       	in	r0, 0x3f	; 63
    1732:	f8 94       	cli
    1734:	de bf       	out	0x3e, r29	; 62
    1736:	0f be       	out	0x3f, r0	; 63
    1738:	cd bf       	out	0x3d, r28	; 61
    173a:	df 91       	pop	r29
    173c:	cf 91       	pop	r28
    173e:	08 95       	ret

00001740 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1740:	cf 93       	push	r28
    1742:	df 93       	push	r29
    1744:	00 d0       	rcall	.+0      	; 0x1746 <vEventGroupDelete+0x6>
    1746:	00 d0       	rcall	.+0      	; 0x1748 <vEventGroupDelete+0x8>
    1748:	cd b7       	in	r28, 0x3d	; 61
    174a:	de b7       	in	r29, 0x3e	; 62
    174c:	9e 83       	std	Y+6, r25	; 0x06
    174e:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1750:	8d 81       	ldd	r24, Y+5	; 0x05
    1752:	9e 81       	ldd	r25, Y+6	; 0x06
    1754:	9a 83       	std	Y+2, r25	; 0x02
    1756:	89 83       	std	Y+1, r24	; 0x01
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1758:	89 81       	ldd	r24, Y+1	; 0x01
    175a:	9a 81       	ldd	r25, Y+2	; 0x02
    175c:	02 96       	adiw	r24, 0x02	; 2
    175e:	9c 83       	std	Y+4, r25	; 0x04
    1760:	8b 83       	std	Y+3, r24	; 0x03

	vTaskSuspendAll();
    1762:	0e 94 13 20 	call	0x4026	; 0x4026 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1766:	09 c0       	rjmp	.+18     	; 0x177a <vEventGroupDelete+0x3a>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1768:	8b 81       	ldd	r24, Y+3	; 0x03
    176a:	9c 81       	ldd	r25, Y+4	; 0x04
    176c:	fc 01       	movw	r30, r24
    176e:	85 81       	ldd	r24, Z+5	; 0x05
    1770:	96 81       	ldd	r25, Z+6	; 0x06
    1772:	60 e0       	ldi	r22, 0x00	; 0
    1774:	72 e0       	ldi	r23, 0x02	; 2
    1776:	0e 94 66 23 	call	0x46cc	; 0x46cc <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    177a:	8b 81       	ldd	r24, Y+3	; 0x03
    177c:	9c 81       	ldd	r25, Y+4	; 0x04
    177e:	fc 01       	movw	r30, r24
    1780:	80 81       	ld	r24, Z
    1782:	88 23       	and	r24, r24
    1784:	89 f7       	brne	.-30     	; 0x1768 <vEventGroupDelete+0x28>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
    1786:	89 81       	ldd	r24, Y+1	; 0x01
    1788:	9a 81       	ldd	r25, Y+2	; 0x02
    178a:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <vPortFree>
	}
	( void ) xTaskResumeAll();
    178e:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>
}
    1792:	26 96       	adiw	r28, 0x06	; 6
    1794:	0f b6       	in	r0, 0x3f	; 63
    1796:	f8 94       	cli
    1798:	de bf       	out	0x3e, r29	; 62
    179a:	0f be       	out	0x3f, r0	; 63
    179c:	cd bf       	out	0x3d, r28	; 61
    179e:	df 91       	pop	r29
    17a0:	cf 91       	pop	r28
    17a2:	08 95       	ret

000017a4 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    17a4:	cf 93       	push	r28
    17a6:	df 93       	push	r29
    17a8:	00 d0       	rcall	.+0      	; 0x17aa <vEventGroupSetBitsCallback+0x6>
    17aa:	00 d0       	rcall	.+0      	; 0x17ac <vEventGroupSetBitsCallback+0x8>
    17ac:	cd b7       	in	r28, 0x3d	; 61
    17ae:	de b7       	in	r29, 0x3e	; 62
    17b0:	9a 83       	std	Y+2, r25	; 0x02
    17b2:	89 83       	std	Y+1, r24	; 0x01
    17b4:	4b 83       	std	Y+3, r20	; 0x03
    17b6:	5c 83       	std	Y+4, r21	; 0x04
    17b8:	6d 83       	std	Y+5, r22	; 0x05
    17ba:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    17bc:	2b 81       	ldd	r18, Y+3	; 0x03
    17be:	3c 81       	ldd	r19, Y+4	; 0x04
    17c0:	89 81       	ldd	r24, Y+1	; 0x01
    17c2:	9a 81       	ldd	r25, Y+2	; 0x02
    17c4:	b9 01       	movw	r22, r18
    17c6:	0e 94 e3 0a 	call	0x15c6	; 0x15c6 <xEventGroupSetBits>
}
    17ca:	26 96       	adiw	r28, 0x06	; 6
    17cc:	0f b6       	in	r0, 0x3f	; 63
    17ce:	f8 94       	cli
    17d0:	de bf       	out	0x3e, r29	; 62
    17d2:	0f be       	out	0x3f, r0	; 63
    17d4:	cd bf       	out	0x3d, r28	; 61
    17d6:	df 91       	pop	r29
    17d8:	cf 91       	pop	r28
    17da:	08 95       	ret

000017dc <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    17dc:	cf 93       	push	r28
    17de:	df 93       	push	r29
    17e0:	00 d0       	rcall	.+0      	; 0x17e2 <vEventGroupClearBitsCallback+0x6>
    17e2:	00 d0       	rcall	.+0      	; 0x17e4 <vEventGroupClearBitsCallback+0x8>
    17e4:	cd b7       	in	r28, 0x3d	; 61
    17e6:	de b7       	in	r29, 0x3e	; 62
    17e8:	9a 83       	std	Y+2, r25	; 0x02
    17ea:	89 83       	std	Y+1, r24	; 0x01
    17ec:	4b 83       	std	Y+3, r20	; 0x03
    17ee:	5c 83       	std	Y+4, r21	; 0x04
    17f0:	6d 83       	std	Y+5, r22	; 0x05
    17f2:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    17f4:	2b 81       	ldd	r18, Y+3	; 0x03
    17f6:	3c 81       	ldd	r19, Y+4	; 0x04
    17f8:	89 81       	ldd	r24, Y+1	; 0x01
    17fa:	9a 81       	ldd	r25, Y+2	; 0x02
    17fc:	b9 01       	movw	r22, r18
    17fe:	0e 94 87 0a 	call	0x150e	; 0x150e <xEventGroupClearBits>
}
    1802:	26 96       	adiw	r28, 0x06	; 6
    1804:	0f b6       	in	r0, 0x3f	; 63
    1806:	f8 94       	cli
    1808:	de bf       	out	0x3e, r29	; 62
    180a:	0f be       	out	0x3f, r0	; 63
    180c:	cd bf       	out	0x3d, r28	; 61
    180e:	df 91       	pop	r29
    1810:	cf 91       	pop	r28
    1812:	08 95       	ret

00001814 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    1814:	cf 93       	push	r28
    1816:	df 93       	push	r29
    1818:	00 d0       	rcall	.+0      	; 0x181a <prvTestWaitCondition+0x6>
    181a:	00 d0       	rcall	.+0      	; 0x181c <prvTestWaitCondition+0x8>
    181c:	cd b7       	in	r28, 0x3d	; 61
    181e:	de b7       	in	r29, 0x3e	; 62
    1820:	9b 83       	std	Y+3, r25	; 0x03
    1822:	8a 83       	std	Y+2, r24	; 0x02
    1824:	7d 83       	std	Y+5, r23	; 0x05
    1826:	6c 83       	std	Y+4, r22	; 0x04
    1828:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    182a:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    182c:	8e 81       	ldd	r24, Y+6	; 0x06
    182e:	88 23       	and	r24, r24
    1830:	59 f4       	brne	.+22     	; 0x1848 <prvTestWaitCondition+0x34>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1832:	2a 81       	ldd	r18, Y+2	; 0x02
    1834:	3b 81       	ldd	r19, Y+3	; 0x03
    1836:	8c 81       	ldd	r24, Y+4	; 0x04
    1838:	9d 81       	ldd	r25, Y+5	; 0x05
    183a:	82 23       	and	r24, r18
    183c:	93 23       	and	r25, r19
    183e:	00 97       	sbiw	r24, 0x00	; 0
    1840:	81 f0       	breq	.+32     	; 0x1862 <prvTestWaitCondition+0x4e>
		{
			xWaitConditionMet = pdTRUE;
    1842:	81 e0       	ldi	r24, 0x01	; 1
    1844:	89 83       	std	Y+1, r24	; 0x01
    1846:	0d c0       	rjmp	.+26     	; 0x1862 <prvTestWaitCondition+0x4e>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1848:	2a 81       	ldd	r18, Y+2	; 0x02
    184a:	3b 81       	ldd	r19, Y+3	; 0x03
    184c:	8c 81       	ldd	r24, Y+4	; 0x04
    184e:	9d 81       	ldd	r25, Y+5	; 0x05
    1850:	28 23       	and	r18, r24
    1852:	39 23       	and	r19, r25
    1854:	8c 81       	ldd	r24, Y+4	; 0x04
    1856:	9d 81       	ldd	r25, Y+5	; 0x05
    1858:	28 17       	cp	r18, r24
    185a:	39 07       	cpc	r19, r25
    185c:	11 f4       	brne	.+4      	; 0x1862 <prvTestWaitCondition+0x4e>
		{
			xWaitConditionMet = pdTRUE;
    185e:	81 e0       	ldi	r24, 0x01	; 1
    1860:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    1862:	89 81       	ldd	r24, Y+1	; 0x01
}
    1864:	26 96       	adiw	r28, 0x06	; 6
    1866:	0f b6       	in	r0, 0x3f	; 63
    1868:	f8 94       	cli
    186a:	de bf       	out	0x3e, r29	; 62
    186c:	0f be       	out	0x3f, r0	; 63
    186e:	cd bf       	out	0x3d, r28	; 61
    1870:	df 91       	pop	r29
    1872:	cf 91       	pop	r28
    1874:	08 95       	ret

00001876 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1876:	cf 93       	push	r28
    1878:	df 93       	push	r29
    187a:	00 d0       	rcall	.+0      	; 0x187c <pvPortMalloc+0x6>
    187c:	1f 92       	push	r1
    187e:	cd b7       	in	r28, 0x3d	; 61
    1880:	de b7       	in	r29, 0x3e	; 62
    1882:	9c 83       	std	Y+4, r25	; 0x04
    1884:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn;

	vTaskSuspendAll();
    1886:	0e 94 13 20 	call	0x4026	; 0x4026 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    188a:	8b 81       	ldd	r24, Y+3	; 0x03
    188c:	9c 81       	ldd	r25, Y+4	; 0x04
    188e:	0e 94 fa 2d 	call	0x5bf4	; 0x5bf4 <malloc>
    1892:	9a 83       	std	Y+2, r25	; 0x02
    1894:	89 83       	std	Y+1, r24	; 0x01
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1896:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
    189a:	89 81       	ldd	r24, Y+1	; 0x01
    189c:	9a 81       	ldd	r25, Y+2	; 0x02
    189e:	00 97       	sbiw	r24, 0x00	; 0
    18a0:	11 f4       	brne	.+4      	; 0x18a6 <pvPortMalloc+0x30>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
    18a2:	0e 94 be 0c 	call	0x197c	; 0x197c <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
    18a6:	89 81       	ldd	r24, Y+1	; 0x01
    18a8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    18aa:	0f 90       	pop	r0
    18ac:	0f 90       	pop	r0
    18ae:	0f 90       	pop	r0
    18b0:	0f 90       	pop	r0
    18b2:	df 91       	pop	r29
    18b4:	cf 91       	pop	r28
    18b6:	08 95       	ret

000018b8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    18b8:	cf 93       	push	r28
    18ba:	df 93       	push	r29
    18bc:	1f 92       	push	r1
    18be:	1f 92       	push	r1
    18c0:	cd b7       	in	r28, 0x3d	; 61
    18c2:	de b7       	in	r29, 0x3e	; 62
    18c4:	9a 83       	std	Y+2, r25	; 0x02
    18c6:	89 83       	std	Y+1, r24	; 0x01
	if( pv )
    18c8:	89 81       	ldd	r24, Y+1	; 0x01
    18ca:	9a 81       	ldd	r25, Y+2	; 0x02
    18cc:	00 97       	sbiw	r24, 0x00	; 0
    18ce:	41 f0       	breq	.+16     	; 0x18e0 <vPortFree+0x28>
	{
		vTaskSuspendAll();
    18d0:	0e 94 13 20 	call	0x4026	; 0x4026 <vTaskSuspendAll>
		{
			free( pv );
    18d4:	89 81       	ldd	r24, Y+1	; 0x01
    18d6:	9a 81       	ldd	r25, Y+2	; 0x02
    18d8:	0e 94 92 2e 	call	0x5d24	; 0x5d24 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    18dc:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>
	}
}
    18e0:	0f 90       	pop	r0
    18e2:	0f 90       	pop	r0
    18e4:	df 91       	pop	r29
    18e6:	cf 91       	pop	r28
    18e8:	08 95       	ret

000018ea <vApplicationIdleHook>:
#if defined( configUSE_IDLE_HOOK )

void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    18ea:	cf 93       	push	r28
    18ec:	df 93       	push	r29
    18ee:	cd b7       	in	r28, 0x3d	; 61
    18f0:	de b7       	in	r29, 0x3e	; 62
	// SLEEP_MODE_PWR_DOWN     _BV(SM1)
	// SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
	// SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
	// SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

	set_sleep_mode( SLEEP_MODE_IDLE );
    18f2:	83 e5       	ldi	r24, 0x53	; 83
    18f4:	90 e0       	ldi	r25, 0x00	; 0
    18f6:	23 e5       	ldi	r18, 0x53	; 83
    18f8:	30 e0       	ldi	r19, 0x00	; 0
    18fa:	f9 01       	movw	r30, r18
    18fc:	20 81       	ld	r18, Z
    18fe:	21 7f       	andi	r18, 0xF1	; 241
    1900:	fc 01       	movw	r30, r24
    1902:	20 83       	st	Z, r18
	// When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
	// This bit can be set at any time to turn off the Analogue Comparator.
	// This will reduce power consumption in Active and Idle mode.
	// When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
	// Otherwise an interrupt can occur when the ACD bit is changed.
	ACSR &= ~_BV(ACIE);
    1904:	80 e5       	ldi	r24, 0x50	; 80
    1906:	90 e0       	ldi	r25, 0x00	; 0
    1908:	20 e5       	ldi	r18, 0x50	; 80
    190a:	30 e0       	ldi	r19, 0x00	; 0
    190c:	f9 01       	movw	r30, r18
    190e:	20 81       	ld	r18, Z
    1910:	27 7f       	andi	r18, 0xF7	; 247
    1912:	fc 01       	movw	r30, r24
    1914:	20 83       	st	Z, r18
	ACSR |=  _BV(ACD);
    1916:	80 e5       	ldi	r24, 0x50	; 80
    1918:	90 e0       	ldi	r25, 0x00	; 0
    191a:	20 e5       	ldi	r18, 0x50	; 80
    191c:	30 e0       	ldi	r19, 0x00	; 0
    191e:	f9 01       	movw	r30, r18
    1920:	20 81       	ld	r18, Z
    1922:	20 68       	ori	r18, 0x80	; 128
    1924:	fc 01       	movw	r30, r24
    1926:	20 83       	st	Z, r18
	// The corresponding PIN Register bit will always read as zero when this bit is set. When an
	// analogue signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this
	// bit should be written logic one to reduce power consumption in the digital input buffer.

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DIDR0 = 0xFF;
    1928:	8e e7       	ldi	r24, 0x7E	; 126
    192a:	90 e0       	ldi	r25, 0x00	; 0
    192c:	2f ef       	ldi	r18, 0xFF	; 255
    192e:	fc 01       	movw	r30, r24
    1930:	20 83       	st	Z, r18
	DIDR1 = 0x03;
    1932:	8f e7       	ldi	r24, 0x7F	; 127
    1934:	90 e0       	ldi	r25, 0x00	; 0
    1936:	23 e0       	ldi	r18, 0x03	; 3
    1938:	fc 01       	movw	r30, r24
    193a:	20 83       	st	Z, r18
	DIDR2 = 0xFF;
    193c:	8d e7       	ldi	r24, 0x7D	; 125
    193e:	90 e0       	ldi	r25, 0x00	; 0
    1940:	2f ef       	ldi	r18, 0xFF	; 255
    1942:	fc 01       	movw	r30, r24
    1944:	20 83       	st	Z, r18
	DIDR1 = 0x01;
	DIDR2 = 0x3F;

#endif

	portENTER_CRITICAL();
    1946:	0f b6       	in	r0, 0x3f	; 63
    1948:	f8 94       	cli
    194a:	0f 92       	push	r0
	sleep_enable();
    194c:	83 e5       	ldi	r24, 0x53	; 83
    194e:	90 e0       	ldi	r25, 0x00	; 0
    1950:	23 e5       	ldi	r18, 0x53	; 83
    1952:	30 e0       	ldi	r19, 0x00	; 0
    1954:	f9 01       	movw	r30, r18
    1956:	20 81       	ld	r18, Z
    1958:	21 60       	ori	r18, 0x01	; 1
    195a:	fc 01       	movw	r30, r24
    195c:	20 83       	st	Z, r18

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
	sleep_bod_disable();
#endif

	portEXIT_CRITICAL();
    195e:	0f 90       	pop	r0
    1960:	0f be       	out	0x3f, r0	; 63
	sleep_cpu();		// good night.
    1962:	88 95       	sleep

	// Uhh. I was woken up, so now disable sleep_mode.
	sleep_disable();
    1964:	83 e5       	ldi	r24, 0x53	; 83
    1966:	90 e0       	ldi	r25, 0x00	; 0
    1968:	23 e5       	ldi	r18, 0x53	; 83
    196a:	30 e0       	ldi	r19, 0x00	; 0
    196c:	f9 01       	movw	r30, r18
    196e:	20 81       	ld	r18, Z
    1970:	2e 7f       	andi	r18, 0xFE	; 254
    1972:	fc 01       	movw	r30, r24
    1974:	20 83       	st	Z, r18
}
    1976:	df 91       	pop	r29
    1978:	cf 91       	pop	r28
    197a:	08 95       	ret

0000197c <vApplicationMallocFailedHook>:
#if defined( configUSE_MALLOC_FAILED_HOOK)

void vApplicationMallocFailedHook( void ) __attribute__((weak));

void vApplicationMallocFailedHook( void )
{
    197c:	cf 93       	push	r28
    197e:	df 93       	push	r29
    1980:	cd b7       	in	r28, 0x3d	; 61
    1982:	de b7       	in	r29, 0x3e	; 62
    1984:	2e 97       	sbiw	r28, 0x0e	; 14
    1986:	0f b6       	in	r0, 0x3f	; 63
    1988:	f8 94       	cli
    198a:	de bf       	out	0x3e, r29	; 62
    198c:	0f be       	out	0x3f, r0	; 63
    198e:	cd bf       	out	0x3d, r28	; 61
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DDRB  |= _BV(DDB7);
    1990:	84 e2       	ldi	r24, 0x24	; 36
    1992:	90 e0       	ldi	r25, 0x00	; 0
    1994:	24 e2       	ldi	r18, 0x24	; 36
    1996:	30 e0       	ldi	r19, 0x00	; 0
    1998:	f9 01       	movw	r30, r18
    199a:	20 81       	ld	r18, Z
    199c:	20 68       	ori	r18, 0x80	; 128
    199e:	fc 01       	movw	r30, r24
    19a0:	20 83       	st	Z, r18
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    19a2:	85 e2       	ldi	r24, 0x25	; 37
    19a4:	90 e0       	ldi	r25, 0x00	; 0
    19a6:	25 e2       	ldi	r18, 0x25	; 37
    19a8:	30 e0       	ldi	r19, 0x00	; 0
    19aa:	f9 01       	movw	r30, r18
    19ac:	20 81       	ld	r18, Z
    19ae:	20 68       	ori	r18, 0x80	; 128
    19b0:	fc 01       	movw	r30, r24
    19b2:	20 83       	st	Z, r18
    19b4:	80 e0       	ldi	r24, 0x00	; 0
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	a8 e4       	ldi	r26, 0x48	; 72
    19ba:	b2 e4       	ldi	r27, 0x42	; 66
    19bc:	89 83       	std	Y+1, r24	; 0x01
    19be:	9a 83       	std	Y+2, r25	; 0x02
    19c0:	ab 83       	std	Y+3, r26	; 0x03
    19c2:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    19c4:	20 e0       	ldi	r18, 0x00	; 0
    19c6:	30 e0       	ldi	r19, 0x00	; 0
    19c8:	4a e7       	ldi	r20, 0x7A	; 122
    19ca:	55 e4       	ldi	r21, 0x45	; 69
    19cc:	69 81       	ldd	r22, Y+1	; 0x01
    19ce:	7a 81       	ldd	r23, Y+2	; 0x02
    19d0:	8b 81       	ldd	r24, Y+3	; 0x03
    19d2:	9c 81       	ldd	r25, Y+4	; 0x04
    19d4:	0e 94 76 2d 	call	0x5aec	; 0x5aec <__mulsf3>
    19d8:	dc 01       	movw	r26, r24
    19da:	cb 01       	movw	r24, r22
    19dc:	8d 83       	std	Y+5, r24	; 0x05
    19de:	9e 83       	std	Y+6, r25	; 0x06
    19e0:	af 83       	std	Y+7, r26	; 0x07
    19e2:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    19e4:	20 e0       	ldi	r18, 0x00	; 0
    19e6:	30 e0       	ldi	r19, 0x00	; 0
    19e8:	40 e8       	ldi	r20, 0x80	; 128
    19ea:	5f e3       	ldi	r21, 0x3F	; 63
    19ec:	6d 81       	ldd	r22, Y+5	; 0x05
    19ee:	7e 81       	ldd	r23, Y+6	; 0x06
    19f0:	8f 81       	ldd	r24, Y+7	; 0x07
    19f2:	98 85       	ldd	r25, Y+8	; 0x08
    19f4:	0e 94 28 2c 	call	0x5850	; 0x5850 <__cmpsf2>
    19f8:	88 23       	and	r24, r24
    19fa:	2c f4       	brge	.+10     	; 0x1a06 <vApplicationMallocFailedHook+0x8a>
		__ticks = 1;
    19fc:	81 e0       	ldi	r24, 0x01	; 1
    19fe:	90 e0       	ldi	r25, 0x00	; 0
    1a00:	9a 87       	std	Y+10, r25	; 0x0a
    1a02:	89 87       	std	Y+9, r24	; 0x09
    1a04:	3f c0       	rjmp	.+126    	; 0x1a84 <vApplicationMallocFailedHook+0x108>
	else if (__tmp > 65535)
    1a06:	20 e0       	ldi	r18, 0x00	; 0
    1a08:	3f ef       	ldi	r19, 0xFF	; 255
    1a0a:	4f e7       	ldi	r20, 0x7F	; 127
    1a0c:	57 e4       	ldi	r21, 0x47	; 71
    1a0e:	6d 81       	ldd	r22, Y+5	; 0x05
    1a10:	7e 81       	ldd	r23, Y+6	; 0x06
    1a12:	8f 81       	ldd	r24, Y+7	; 0x07
    1a14:	98 85       	ldd	r25, Y+8	; 0x08
    1a16:	0e 94 72 2d 	call	0x5ae4	; 0x5ae4 <__gesf2>
    1a1a:	18 16       	cp	r1, r24
    1a1c:	4c f5       	brge	.+82     	; 0x1a70 <vApplicationMallocFailedHook+0xf4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a1e:	20 e0       	ldi	r18, 0x00	; 0
    1a20:	30 e0       	ldi	r19, 0x00	; 0
    1a22:	40 e2       	ldi	r20, 0x20	; 32
    1a24:	51 e4       	ldi	r21, 0x41	; 65
    1a26:	69 81       	ldd	r22, Y+1	; 0x01
    1a28:	7a 81       	ldd	r23, Y+2	; 0x02
    1a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a2c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a2e:	0e 94 76 2d 	call	0x5aec	; 0x5aec <__mulsf3>
    1a32:	dc 01       	movw	r26, r24
    1a34:	cb 01       	movw	r24, r22
    1a36:	bc 01       	movw	r22, r24
    1a38:	cd 01       	movw	r24, r26
    1a3a:	0e 94 94 2c 	call	0x5928	; 0x5928 <__fixunssfsi>
    1a3e:	dc 01       	movw	r26, r24
    1a40:	cb 01       	movw	r24, r22
    1a42:	9a 87       	std	Y+10, r25	; 0x0a
    1a44:	89 87       	std	Y+9, r24	; 0x09
    1a46:	0f c0       	rjmp	.+30     	; 0x1a66 <vApplicationMallocFailedHook+0xea>
    1a48:	80 e9       	ldi	r24, 0x90	; 144
    1a4a:	91 e0       	ldi	r25, 0x01	; 1
    1a4c:	9c 87       	std	Y+12, r25	; 0x0c
    1a4e:	8b 87       	std	Y+11, r24	; 0x0b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1a50:	8b 85       	ldd	r24, Y+11	; 0x0b
    1a52:	9c 85       	ldd	r25, Y+12	; 0x0c
    1a54:	01 97       	sbiw	r24, 0x01	; 1
    1a56:	f1 f7       	brne	.-4      	; 0x1a54 <vApplicationMallocFailedHook+0xd8>
    1a58:	9c 87       	std	Y+12, r25	; 0x0c
    1a5a:	8b 87       	std	Y+11, r24	; 0x0b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a5c:	89 85       	ldd	r24, Y+9	; 0x09
    1a5e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a60:	01 97       	sbiw	r24, 0x01	; 1
    1a62:	9a 87       	std	Y+10, r25	; 0x0a
    1a64:	89 87       	std	Y+9, r24	; 0x09
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a66:	89 85       	ldd	r24, Y+9	; 0x09
    1a68:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a6a:	00 97       	sbiw	r24, 0x00	; 0
    1a6c:	69 f7       	brne	.-38     	; 0x1a48 <vApplicationMallocFailedHook+0xcc>
    1a6e:	14 c0       	rjmp	.+40     	; 0x1a98 <vApplicationMallocFailedHook+0x11c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a70:	6d 81       	ldd	r22, Y+5	; 0x05
    1a72:	7e 81       	ldd	r23, Y+6	; 0x06
    1a74:	8f 81       	ldd	r24, Y+7	; 0x07
    1a76:	98 85       	ldd	r25, Y+8	; 0x08
    1a78:	0e 94 94 2c 	call	0x5928	; 0x5928 <__fixunssfsi>
    1a7c:	dc 01       	movw	r26, r24
    1a7e:	cb 01       	movw	r24, r22
    1a80:	9a 87       	std	Y+10, r25	; 0x0a
    1a82:	89 87       	std	Y+9, r24	; 0x09
    1a84:	89 85       	ldd	r24, Y+9	; 0x09
    1a86:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a88:	9e 87       	std	Y+14, r25	; 0x0e
    1a8a:	8d 87       	std	Y+13, r24	; 0x0d
    1a8c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a8e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a90:	01 97       	sbiw	r24, 0x01	; 1
    1a92:	f1 f7       	brne	.-4      	; 0x1a90 <vApplicationMallocFailedHook+0x114>
    1a94:	9e 87       	std	Y+14, r25	; 0x0e
    1a96:	8d 87       	std	Y+13, r24	; 0x0d

	for(;;)
	{
		_delay_ms(50);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.
    1a98:	83 e2       	ldi	r24, 0x23	; 35
    1a9a:	90 e0       	ldi	r25, 0x00	; 0
    1a9c:	23 e2       	ldi	r18, 0x23	; 35
    1a9e:	30 e0       	ldi	r19, 0x00	; 0
    1aa0:	f9 01       	movw	r30, r18
    1aa2:	20 81       	ld	r18, Z
    1aa4:	20 68       	ori	r18, 0x80	; 128
    1aa6:	fc 01       	movw	r30, r24
    1aa8:	20 83       	st	Z, r18
#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
		PINC  |= _BV(PINC7);       // Main (red PC7) LED toggle. Main LED fast blink.

#endif

	}
    1aaa:	84 cf       	rjmp	.-248    	; 0x19b4 <vApplicationMallocFailedHook+0x38>

00001aac <vApplicationStackOverflowHook>:
#if defined( configCHECK_FOR_STACK_OVERFLOW )

void vApplicationStackOverflowHook( TaskHandle_t xTask, portCHAR *pcTaskName ) __attribute__((weak));

void vApplicationStackOverflowHook( TaskHandle_t xTask __attribute__((unused)), portCHAR *pcTaskName __attribute__((unused)) )
{
    1aac:	cf 93       	push	r28
    1aae:	df 93       	push	r29
    1ab0:	cd b7       	in	r28, 0x3d	; 61
    1ab2:	de b7       	in	r29, 0x3e	; 62
    1ab4:	62 97       	sbiw	r28, 0x12	; 18
    1ab6:	0f b6       	in	r0, 0x3f	; 63
    1ab8:	f8 94       	cli
    1aba:	de bf       	out	0x3e, r29	; 62
    1abc:	0f be       	out	0x3f, r0	; 63
    1abe:	cd bf       	out	0x3d, r28	; 61
    1ac0:	98 8b       	std	Y+16, r25	; 0x10
    1ac2:	8f 87       	std	Y+15, r24	; 0x0f
    1ac4:	7a 8b       	std	Y+18, r23	; 0x12
    1ac6:	69 8b       	std	Y+17, r22	; 0x11
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Mega with 2560
	DDRB  |= _BV(DDB7);
    1ac8:	84 e2       	ldi	r24, 0x24	; 36
    1aca:	90 e0       	ldi	r25, 0x00	; 0
    1acc:	24 e2       	ldi	r18, 0x24	; 36
    1ace:	30 e0       	ldi	r19, 0x00	; 0
    1ad0:	f9 01       	movw	r30, r18
    1ad2:	20 81       	ld	r18, Z
    1ad4:	20 68       	ori	r18, 0x80	; 128
    1ad6:	fc 01       	movw	r30, r24
    1ad8:	20 83       	st	Z, r18
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    1ada:	85 e2       	ldi	r24, 0x25	; 37
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	25 e2       	ldi	r18, 0x25	; 37
    1ae0:	30 e0       	ldi	r19, 0x00	; 0
    1ae2:	f9 01       	movw	r30, r18
    1ae4:	20 81       	ld	r18, Z
    1ae6:	20 68       	ori	r18, 0x80	; 128
    1ae8:	fc 01       	movw	r30, r24
    1aea:	20 83       	st	Z, r18
    1aec:	80 e0       	ldi	r24, 0x00	; 0
    1aee:	90 e0       	ldi	r25, 0x00	; 0
    1af0:	aa ef       	ldi	r26, 0xFA	; 250
    1af2:	b4 e4       	ldi	r27, 0x44	; 68
    1af4:	89 83       	std	Y+1, r24	; 0x01
    1af6:	9a 83       	std	Y+2, r25	; 0x02
    1af8:	ab 83       	std	Y+3, r26	; 0x03
    1afa:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1afc:	20 e0       	ldi	r18, 0x00	; 0
    1afe:	30 e0       	ldi	r19, 0x00	; 0
    1b00:	4a e7       	ldi	r20, 0x7A	; 122
    1b02:	55 e4       	ldi	r21, 0x45	; 69
    1b04:	69 81       	ldd	r22, Y+1	; 0x01
    1b06:	7a 81       	ldd	r23, Y+2	; 0x02
    1b08:	8b 81       	ldd	r24, Y+3	; 0x03
    1b0a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b0c:	0e 94 76 2d 	call	0x5aec	; 0x5aec <__mulsf3>
    1b10:	dc 01       	movw	r26, r24
    1b12:	cb 01       	movw	r24, r22
    1b14:	8d 83       	std	Y+5, r24	; 0x05
    1b16:	9e 83       	std	Y+6, r25	; 0x06
    1b18:	af 83       	std	Y+7, r26	; 0x07
    1b1a:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    1b1c:	20 e0       	ldi	r18, 0x00	; 0
    1b1e:	30 e0       	ldi	r19, 0x00	; 0
    1b20:	40 e8       	ldi	r20, 0x80	; 128
    1b22:	5f e3       	ldi	r21, 0x3F	; 63
    1b24:	6d 81       	ldd	r22, Y+5	; 0x05
    1b26:	7e 81       	ldd	r23, Y+6	; 0x06
    1b28:	8f 81       	ldd	r24, Y+7	; 0x07
    1b2a:	98 85       	ldd	r25, Y+8	; 0x08
    1b2c:	0e 94 28 2c 	call	0x5850	; 0x5850 <__cmpsf2>
    1b30:	88 23       	and	r24, r24
    1b32:	2c f4       	brge	.+10     	; 0x1b3e <vApplicationStackOverflowHook+0x92>
		__ticks = 1;
    1b34:	81 e0       	ldi	r24, 0x01	; 1
    1b36:	90 e0       	ldi	r25, 0x00	; 0
    1b38:	9a 87       	std	Y+10, r25	; 0x0a
    1b3a:	89 87       	std	Y+9, r24	; 0x09
    1b3c:	3f c0       	rjmp	.+126    	; 0x1bbc <vApplicationStackOverflowHook+0x110>
	else if (__tmp > 65535)
    1b3e:	20 e0       	ldi	r18, 0x00	; 0
    1b40:	3f ef       	ldi	r19, 0xFF	; 255
    1b42:	4f e7       	ldi	r20, 0x7F	; 127
    1b44:	57 e4       	ldi	r21, 0x47	; 71
    1b46:	6d 81       	ldd	r22, Y+5	; 0x05
    1b48:	7e 81       	ldd	r23, Y+6	; 0x06
    1b4a:	8f 81       	ldd	r24, Y+7	; 0x07
    1b4c:	98 85       	ldd	r25, Y+8	; 0x08
    1b4e:	0e 94 72 2d 	call	0x5ae4	; 0x5ae4 <__gesf2>
    1b52:	18 16       	cp	r1, r24
    1b54:	4c f5       	brge	.+82     	; 0x1ba8 <vApplicationStackOverflowHook+0xfc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b56:	20 e0       	ldi	r18, 0x00	; 0
    1b58:	30 e0       	ldi	r19, 0x00	; 0
    1b5a:	40 e2       	ldi	r20, 0x20	; 32
    1b5c:	51 e4       	ldi	r21, 0x41	; 65
    1b5e:	69 81       	ldd	r22, Y+1	; 0x01
    1b60:	7a 81       	ldd	r23, Y+2	; 0x02
    1b62:	8b 81       	ldd	r24, Y+3	; 0x03
    1b64:	9c 81       	ldd	r25, Y+4	; 0x04
    1b66:	0e 94 76 2d 	call	0x5aec	; 0x5aec <__mulsf3>
    1b6a:	dc 01       	movw	r26, r24
    1b6c:	cb 01       	movw	r24, r22
    1b6e:	bc 01       	movw	r22, r24
    1b70:	cd 01       	movw	r24, r26
    1b72:	0e 94 94 2c 	call	0x5928	; 0x5928 <__fixunssfsi>
    1b76:	dc 01       	movw	r26, r24
    1b78:	cb 01       	movw	r24, r22
    1b7a:	9a 87       	std	Y+10, r25	; 0x0a
    1b7c:	89 87       	std	Y+9, r24	; 0x09
    1b7e:	0f c0       	rjmp	.+30     	; 0x1b9e <vApplicationStackOverflowHook+0xf2>
    1b80:	80 e9       	ldi	r24, 0x90	; 144
    1b82:	91 e0       	ldi	r25, 0x01	; 1
    1b84:	9c 87       	std	Y+12, r25	; 0x0c
    1b86:	8b 87       	std	Y+11, r24	; 0x0b
    1b88:	8b 85       	ldd	r24, Y+11	; 0x0b
    1b8a:	9c 85       	ldd	r25, Y+12	; 0x0c
    1b8c:	01 97       	sbiw	r24, 0x01	; 1
    1b8e:	f1 f7       	brne	.-4      	; 0x1b8c <vApplicationStackOverflowHook+0xe0>
    1b90:	9c 87       	std	Y+12, r25	; 0x0c
    1b92:	8b 87       	std	Y+11, r24	; 0x0b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b94:	89 85       	ldd	r24, Y+9	; 0x09
    1b96:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b98:	01 97       	sbiw	r24, 0x01	; 1
    1b9a:	9a 87       	std	Y+10, r25	; 0x0a
    1b9c:	89 87       	std	Y+9, r24	; 0x09
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b9e:	89 85       	ldd	r24, Y+9	; 0x09
    1ba0:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ba2:	00 97       	sbiw	r24, 0x00	; 0
    1ba4:	69 f7       	brne	.-38     	; 0x1b80 <vApplicationStackOverflowHook+0xd4>
    1ba6:	14 c0       	rjmp	.+40     	; 0x1bd0 <vApplicationStackOverflowHook+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ba8:	6d 81       	ldd	r22, Y+5	; 0x05
    1baa:	7e 81       	ldd	r23, Y+6	; 0x06
    1bac:	8f 81       	ldd	r24, Y+7	; 0x07
    1bae:	98 85       	ldd	r25, Y+8	; 0x08
    1bb0:	0e 94 94 2c 	call	0x5928	; 0x5928 <__fixunssfsi>
    1bb4:	dc 01       	movw	r26, r24
    1bb6:	cb 01       	movw	r24, r22
    1bb8:	9a 87       	std	Y+10, r25	; 0x0a
    1bba:	89 87       	std	Y+9, r24	; 0x09
    1bbc:	89 85       	ldd	r24, Y+9	; 0x09
    1bbe:	9a 85       	ldd	r25, Y+10	; 0x0a
    1bc0:	9e 87       	std	Y+14, r25	; 0x0e
    1bc2:	8d 87       	std	Y+13, r24	; 0x0d
    1bc4:	8d 85       	ldd	r24, Y+13	; 0x0d
    1bc6:	9e 85       	ldd	r25, Y+14	; 0x0e
    1bc8:	01 97       	sbiw	r24, 0x01	; 1
    1bca:	f1 f7       	brne	.-4      	; 0x1bc8 <vApplicationStackOverflowHook+0x11c>
    1bcc:	9e 87       	std	Y+14, r25	; 0x0e
    1bce:	8d 87       	std	Y+13, r24	; 0x0d

	for(;;)
	{
		_delay_ms(2000);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    1bd0:	83 e2       	ldi	r24, 0x23	; 35
    1bd2:	90 e0       	ldi	r25, 0x00	; 0
    1bd4:	23 e2       	ldi	r18, 0x23	; 35
    1bd6:	30 e0       	ldi	r19, 0x00	; 0
    1bd8:	f9 01       	movw	r30, r18
    1bda:	20 81       	ld	r18, Z
    1bdc:	20 68       	ori	r18, 0x80	; 128
    1bde:	fc 01       	movw	r30, r24
    1be0:	20 83       	st	Z, r18
#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
		PINC  |= _BV(PINC7);       // Main (red PC7) LED toggle. Main LED slow blink.

#endif

	}
    1be2:	84 cf       	rjmp	.-248    	; 0x1aec <vApplicationStackOverflowHook+0x40>

00001be4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1be4:	cf 93       	push	r28
    1be6:	df 93       	push	r29
    1be8:	1f 92       	push	r1
    1bea:	1f 92       	push	r1
    1bec:	cd b7       	in	r28, 0x3d	; 61
    1bee:	de b7       	in	r29, 0x3e	; 62
    1bf0:	9a 83       	std	Y+2, r25	; 0x02
    1bf2:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bf4:	89 81       	ldd	r24, Y+1	; 0x01
    1bf6:	9a 81       	ldd	r25, Y+2	; 0x02
    1bf8:	9c 01       	movw	r18, r24
    1bfa:	2d 5f       	subi	r18, 0xFD	; 253
    1bfc:	3f 4f       	sbci	r19, 0xFF	; 255
    1bfe:	89 81       	ldd	r24, Y+1	; 0x01
    1c00:	9a 81       	ldd	r25, Y+2	; 0x02
    1c02:	fc 01       	movw	r30, r24
    1c04:	32 83       	std	Z+2, r19	; 0x02
    1c06:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1c08:	89 81       	ldd	r24, Y+1	; 0x01
    1c0a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c0c:	2f ef       	ldi	r18, 0xFF	; 255
    1c0e:	3f ef       	ldi	r19, 0xFF	; 255
    1c10:	fc 01       	movw	r30, r24
    1c12:	34 83       	std	Z+4, r19	; 0x04
    1c14:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c16:	89 81       	ldd	r24, Y+1	; 0x01
    1c18:	9a 81       	ldd	r25, Y+2	; 0x02
    1c1a:	9c 01       	movw	r18, r24
    1c1c:	2d 5f       	subi	r18, 0xFD	; 253
    1c1e:	3f 4f       	sbci	r19, 0xFF	; 255
    1c20:	89 81       	ldd	r24, Y+1	; 0x01
    1c22:	9a 81       	ldd	r25, Y+2	; 0x02
    1c24:	fc 01       	movw	r30, r24
    1c26:	36 83       	std	Z+6, r19	; 0x06
    1c28:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c2a:	89 81       	ldd	r24, Y+1	; 0x01
    1c2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c2e:	9c 01       	movw	r18, r24
    1c30:	2d 5f       	subi	r18, 0xFD	; 253
    1c32:	3f 4f       	sbci	r19, 0xFF	; 255
    1c34:	89 81       	ldd	r24, Y+1	; 0x01
    1c36:	9a 81       	ldd	r25, Y+2	; 0x02
    1c38:	fc 01       	movw	r30, r24
    1c3a:	30 87       	std	Z+8, r19	; 0x08
    1c3c:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1c3e:	89 81       	ldd	r24, Y+1	; 0x01
    1c40:	9a 81       	ldd	r25, Y+2	; 0x02
    1c42:	fc 01       	movw	r30, r24
    1c44:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1c46:	0f 90       	pop	r0
    1c48:	0f 90       	pop	r0
    1c4a:	df 91       	pop	r29
    1c4c:	cf 91       	pop	r28
    1c4e:	08 95       	ret

00001c50 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1c50:	cf 93       	push	r28
    1c52:	df 93       	push	r29
    1c54:	1f 92       	push	r1
    1c56:	1f 92       	push	r1
    1c58:	cd b7       	in	r28, 0x3d	; 61
    1c5a:	de b7       	in	r29, 0x3e	; 62
    1c5c:	9a 83       	std	Y+2, r25	; 0x02
    1c5e:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1c60:	89 81       	ldd	r24, Y+1	; 0x01
    1c62:	9a 81       	ldd	r25, Y+2	; 0x02
    1c64:	fc 01       	movw	r30, r24
    1c66:	11 86       	std	Z+9, r1	; 0x09
    1c68:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1c6a:	0f 90       	pop	r0
    1c6c:	0f 90       	pop	r0
    1c6e:	df 91       	pop	r29
    1c70:	cf 91       	pop	r28
    1c72:	08 95       	ret

00001c74 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c74:	cf 93       	push	r28
    1c76:	df 93       	push	r29
    1c78:	00 d0       	rcall	.+0      	; 0x1c7a <vListInsertEnd+0x6>
    1c7a:	00 d0       	rcall	.+0      	; 0x1c7c <vListInsertEnd+0x8>
    1c7c:	cd b7       	in	r28, 0x3d	; 61
    1c7e:	de b7       	in	r29, 0x3e	; 62
    1c80:	9c 83       	std	Y+4, r25	; 0x04
    1c82:	8b 83       	std	Y+3, r24	; 0x03
    1c84:	7e 83       	std	Y+6, r23	; 0x06
    1c86:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    1c88:	8b 81       	ldd	r24, Y+3	; 0x03
    1c8a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c8c:	fc 01       	movw	r30, r24
    1c8e:	81 81       	ldd	r24, Z+1	; 0x01
    1c90:	92 81       	ldd	r25, Z+2	; 0x02
    1c92:	9a 83       	std	Y+2, r25	; 0x02
    1c94:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1c96:	8d 81       	ldd	r24, Y+5	; 0x05
    1c98:	9e 81       	ldd	r25, Y+6	; 0x06
    1c9a:	29 81       	ldd	r18, Y+1	; 0x01
    1c9c:	3a 81       	ldd	r19, Y+2	; 0x02
    1c9e:	fc 01       	movw	r30, r24
    1ca0:	33 83       	std	Z+3, r19	; 0x03
    1ca2:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1ca4:	89 81       	ldd	r24, Y+1	; 0x01
    1ca6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ca8:	fc 01       	movw	r30, r24
    1caa:	24 81       	ldd	r18, Z+4	; 0x04
    1cac:	35 81       	ldd	r19, Z+5	; 0x05
    1cae:	8d 81       	ldd	r24, Y+5	; 0x05
    1cb0:	9e 81       	ldd	r25, Y+6	; 0x06
    1cb2:	fc 01       	movw	r30, r24
    1cb4:	35 83       	std	Z+5, r19	; 0x05
    1cb6:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1cb8:	89 81       	ldd	r24, Y+1	; 0x01
    1cba:	9a 81       	ldd	r25, Y+2	; 0x02
    1cbc:	fc 01       	movw	r30, r24
    1cbe:	84 81       	ldd	r24, Z+4	; 0x04
    1cc0:	95 81       	ldd	r25, Z+5	; 0x05
    1cc2:	2d 81       	ldd	r18, Y+5	; 0x05
    1cc4:	3e 81       	ldd	r19, Y+6	; 0x06
    1cc6:	fc 01       	movw	r30, r24
    1cc8:	33 83       	std	Z+3, r19	; 0x03
    1cca:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1ccc:	89 81       	ldd	r24, Y+1	; 0x01
    1cce:	9a 81       	ldd	r25, Y+2	; 0x02
    1cd0:	2d 81       	ldd	r18, Y+5	; 0x05
    1cd2:	3e 81       	ldd	r19, Y+6	; 0x06
    1cd4:	fc 01       	movw	r30, r24
    1cd6:	35 83       	std	Z+5, r19	; 0x05
    1cd8:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1cda:	8d 81       	ldd	r24, Y+5	; 0x05
    1cdc:	9e 81       	ldd	r25, Y+6	; 0x06
    1cde:	2b 81       	ldd	r18, Y+3	; 0x03
    1ce0:	3c 81       	ldd	r19, Y+4	; 0x04
    1ce2:	fc 01       	movw	r30, r24
    1ce4:	31 87       	std	Z+9, r19	; 0x09
    1ce6:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1ce8:	8b 81       	ldd	r24, Y+3	; 0x03
    1cea:	9c 81       	ldd	r25, Y+4	; 0x04
    1cec:	fc 01       	movw	r30, r24
    1cee:	80 81       	ld	r24, Z
    1cf0:	21 e0       	ldi	r18, 0x01	; 1
    1cf2:	28 0f       	add	r18, r24
    1cf4:	8b 81       	ldd	r24, Y+3	; 0x03
    1cf6:	9c 81       	ldd	r25, Y+4	; 0x04
    1cf8:	fc 01       	movw	r30, r24
    1cfa:	20 83       	st	Z, r18
}
    1cfc:	26 96       	adiw	r28, 0x06	; 6
    1cfe:	0f b6       	in	r0, 0x3f	; 63
    1d00:	f8 94       	cli
    1d02:	de bf       	out	0x3e, r29	; 62
    1d04:	0f be       	out	0x3f, r0	; 63
    1d06:	cd bf       	out	0x3d, r28	; 61
    1d08:	df 91       	pop	r29
    1d0a:	cf 91       	pop	r28
    1d0c:	08 95       	ret

00001d0e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1d0e:	cf 93       	push	r28
    1d10:	df 93       	push	r29
    1d12:	cd b7       	in	r28, 0x3d	; 61
    1d14:	de b7       	in	r29, 0x3e	; 62
    1d16:	28 97       	sbiw	r28, 0x08	; 8
    1d18:	0f b6       	in	r0, 0x3f	; 63
    1d1a:	f8 94       	cli
    1d1c:	de bf       	out	0x3e, r29	; 62
    1d1e:	0f be       	out	0x3f, r0	; 63
    1d20:	cd bf       	out	0x3d, r28	; 61
    1d22:	9e 83       	std	Y+6, r25	; 0x06
    1d24:	8d 83       	std	Y+5, r24	; 0x05
    1d26:	78 87       	std	Y+8, r23	; 0x08
    1d28:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1d2a:	8f 81       	ldd	r24, Y+7	; 0x07
    1d2c:	98 85       	ldd	r25, Y+8	; 0x08
    1d2e:	fc 01       	movw	r30, r24
    1d30:	80 81       	ld	r24, Z
    1d32:	91 81       	ldd	r25, Z+1	; 0x01
    1d34:	9c 83       	std	Y+4, r25	; 0x04
    1d36:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1d38:	8b 81       	ldd	r24, Y+3	; 0x03
    1d3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d3c:	8f 3f       	cpi	r24, 0xFF	; 255
    1d3e:	ff ef       	ldi	r31, 0xFF	; 255
    1d40:	9f 07       	cpc	r25, r31
    1d42:	41 f4       	brne	.+16     	; 0x1d54 <vListInsert+0x46>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1d44:	8d 81       	ldd	r24, Y+5	; 0x05
    1d46:	9e 81       	ldd	r25, Y+6	; 0x06
    1d48:	fc 01       	movw	r30, r24
    1d4a:	87 81       	ldd	r24, Z+7	; 0x07
    1d4c:	90 85       	ldd	r25, Z+8	; 0x08
    1d4e:	9a 83       	std	Y+2, r25	; 0x02
    1d50:	89 83       	std	Y+1, r24	; 0x01
    1d52:	1a c0       	rjmp	.+52     	; 0x1d88 <vListInsert+0x7a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1d54:	8d 81       	ldd	r24, Y+5	; 0x05
    1d56:	9e 81       	ldd	r25, Y+6	; 0x06
    1d58:	03 96       	adiw	r24, 0x03	; 3
    1d5a:	9a 83       	std	Y+2, r25	; 0x02
    1d5c:	89 83       	std	Y+1, r24	; 0x01
    1d5e:	07 c0       	rjmp	.+14     	; 0x1d6e <vListInsert+0x60>
    1d60:	89 81       	ldd	r24, Y+1	; 0x01
    1d62:	9a 81       	ldd	r25, Y+2	; 0x02
    1d64:	fc 01       	movw	r30, r24
    1d66:	82 81       	ldd	r24, Z+2	; 0x02
    1d68:	93 81       	ldd	r25, Z+3	; 0x03
    1d6a:	9a 83       	std	Y+2, r25	; 0x02
    1d6c:	89 83       	std	Y+1, r24	; 0x01
    1d6e:	89 81       	ldd	r24, Y+1	; 0x01
    1d70:	9a 81       	ldd	r25, Y+2	; 0x02
    1d72:	fc 01       	movw	r30, r24
    1d74:	82 81       	ldd	r24, Z+2	; 0x02
    1d76:	93 81       	ldd	r25, Z+3	; 0x03
    1d78:	fc 01       	movw	r30, r24
    1d7a:	20 81       	ld	r18, Z
    1d7c:	31 81       	ldd	r19, Z+1	; 0x01
    1d7e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d80:	9c 81       	ldd	r25, Y+4	; 0x04
    1d82:	82 17       	cp	r24, r18
    1d84:	93 07       	cpc	r25, r19
    1d86:	60 f7       	brcc	.-40     	; 0x1d60 <vListInsert+0x52>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1d88:	89 81       	ldd	r24, Y+1	; 0x01
    1d8a:	9a 81       	ldd	r25, Y+2	; 0x02
    1d8c:	fc 01       	movw	r30, r24
    1d8e:	22 81       	ldd	r18, Z+2	; 0x02
    1d90:	33 81       	ldd	r19, Z+3	; 0x03
    1d92:	8f 81       	ldd	r24, Y+7	; 0x07
    1d94:	98 85       	ldd	r25, Y+8	; 0x08
    1d96:	fc 01       	movw	r30, r24
    1d98:	33 83       	std	Z+3, r19	; 0x03
    1d9a:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1d9c:	8f 81       	ldd	r24, Y+7	; 0x07
    1d9e:	98 85       	ldd	r25, Y+8	; 0x08
    1da0:	fc 01       	movw	r30, r24
    1da2:	82 81       	ldd	r24, Z+2	; 0x02
    1da4:	93 81       	ldd	r25, Z+3	; 0x03
    1da6:	2f 81       	ldd	r18, Y+7	; 0x07
    1da8:	38 85       	ldd	r19, Y+8	; 0x08
    1daa:	fc 01       	movw	r30, r24
    1dac:	35 83       	std	Z+5, r19	; 0x05
    1dae:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1db0:	8f 81       	ldd	r24, Y+7	; 0x07
    1db2:	98 85       	ldd	r25, Y+8	; 0x08
    1db4:	29 81       	ldd	r18, Y+1	; 0x01
    1db6:	3a 81       	ldd	r19, Y+2	; 0x02
    1db8:	fc 01       	movw	r30, r24
    1dba:	35 83       	std	Z+5, r19	; 0x05
    1dbc:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1dbe:	89 81       	ldd	r24, Y+1	; 0x01
    1dc0:	9a 81       	ldd	r25, Y+2	; 0x02
    1dc2:	2f 81       	ldd	r18, Y+7	; 0x07
    1dc4:	38 85       	ldd	r19, Y+8	; 0x08
    1dc6:	fc 01       	movw	r30, r24
    1dc8:	33 83       	std	Z+3, r19	; 0x03
    1dca:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1dcc:	8f 81       	ldd	r24, Y+7	; 0x07
    1dce:	98 85       	ldd	r25, Y+8	; 0x08
    1dd0:	2d 81       	ldd	r18, Y+5	; 0x05
    1dd2:	3e 81       	ldd	r19, Y+6	; 0x06
    1dd4:	fc 01       	movw	r30, r24
    1dd6:	31 87       	std	Z+9, r19	; 0x09
    1dd8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1dda:	8d 81       	ldd	r24, Y+5	; 0x05
    1ddc:	9e 81       	ldd	r25, Y+6	; 0x06
    1dde:	fc 01       	movw	r30, r24
    1de0:	80 81       	ld	r24, Z
    1de2:	21 e0       	ldi	r18, 0x01	; 1
    1de4:	28 0f       	add	r18, r24
    1de6:	8d 81       	ldd	r24, Y+5	; 0x05
    1de8:	9e 81       	ldd	r25, Y+6	; 0x06
    1dea:	fc 01       	movw	r30, r24
    1dec:	20 83       	st	Z, r18
}
    1dee:	28 96       	adiw	r28, 0x08	; 8
    1df0:	0f b6       	in	r0, 0x3f	; 63
    1df2:	f8 94       	cli
    1df4:	de bf       	out	0x3e, r29	; 62
    1df6:	0f be       	out	0x3f, r0	; 63
    1df8:	cd bf       	out	0x3d, r28	; 61
    1dfa:	df 91       	pop	r29
    1dfc:	cf 91       	pop	r28
    1dfe:	08 95       	ret

00001e00 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1e00:	cf 93       	push	r28
    1e02:	df 93       	push	r29
    1e04:	00 d0       	rcall	.+0      	; 0x1e06 <uxListRemove+0x6>
    1e06:	1f 92       	push	r1
    1e08:	cd b7       	in	r28, 0x3d	; 61
    1e0a:	de b7       	in	r29, 0x3e	; 62
    1e0c:	9c 83       	std	Y+4, r25	; 0x04
    1e0e:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1e10:	8b 81       	ldd	r24, Y+3	; 0x03
    1e12:	9c 81       	ldd	r25, Y+4	; 0x04
    1e14:	fc 01       	movw	r30, r24
    1e16:	80 85       	ldd	r24, Z+8	; 0x08
    1e18:	91 85       	ldd	r25, Z+9	; 0x09
    1e1a:	9a 83       	std	Y+2, r25	; 0x02
    1e1c:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1e1e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e20:	9c 81       	ldd	r25, Y+4	; 0x04
    1e22:	fc 01       	movw	r30, r24
    1e24:	82 81       	ldd	r24, Z+2	; 0x02
    1e26:	93 81       	ldd	r25, Z+3	; 0x03
    1e28:	2b 81       	ldd	r18, Y+3	; 0x03
    1e2a:	3c 81       	ldd	r19, Y+4	; 0x04
    1e2c:	f9 01       	movw	r30, r18
    1e2e:	24 81       	ldd	r18, Z+4	; 0x04
    1e30:	35 81       	ldd	r19, Z+5	; 0x05
    1e32:	fc 01       	movw	r30, r24
    1e34:	35 83       	std	Z+5, r19	; 0x05
    1e36:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1e38:	8b 81       	ldd	r24, Y+3	; 0x03
    1e3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e3c:	fc 01       	movw	r30, r24
    1e3e:	84 81       	ldd	r24, Z+4	; 0x04
    1e40:	95 81       	ldd	r25, Z+5	; 0x05
    1e42:	2b 81       	ldd	r18, Y+3	; 0x03
    1e44:	3c 81       	ldd	r19, Y+4	; 0x04
    1e46:	f9 01       	movw	r30, r18
    1e48:	22 81       	ldd	r18, Z+2	; 0x02
    1e4a:	33 81       	ldd	r19, Z+3	; 0x03
    1e4c:	fc 01       	movw	r30, r24
    1e4e:	33 83       	std	Z+3, r19	; 0x03
    1e50:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1e52:	89 81       	ldd	r24, Y+1	; 0x01
    1e54:	9a 81       	ldd	r25, Y+2	; 0x02
    1e56:	fc 01       	movw	r30, r24
    1e58:	21 81       	ldd	r18, Z+1	; 0x01
    1e5a:	32 81       	ldd	r19, Z+2	; 0x02
    1e5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1e60:	28 17       	cp	r18, r24
    1e62:	39 07       	cpc	r19, r25
    1e64:	51 f4       	brne	.+20     	; 0x1e7a <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1e66:	8b 81       	ldd	r24, Y+3	; 0x03
    1e68:	9c 81       	ldd	r25, Y+4	; 0x04
    1e6a:	fc 01       	movw	r30, r24
    1e6c:	24 81       	ldd	r18, Z+4	; 0x04
    1e6e:	35 81       	ldd	r19, Z+5	; 0x05
    1e70:	89 81       	ldd	r24, Y+1	; 0x01
    1e72:	9a 81       	ldd	r25, Y+2	; 0x02
    1e74:	fc 01       	movw	r30, r24
    1e76:	32 83       	std	Z+2, r19	; 0x02
    1e78:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1e7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e7e:	fc 01       	movw	r30, r24
    1e80:	11 86       	std	Z+9, r1	; 0x09
    1e82:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1e84:	89 81       	ldd	r24, Y+1	; 0x01
    1e86:	9a 81       	ldd	r25, Y+2	; 0x02
    1e88:	fc 01       	movw	r30, r24
    1e8a:	80 81       	ld	r24, Z
    1e8c:	2f ef       	ldi	r18, 0xFF	; 255
    1e8e:	28 0f       	add	r18, r24
    1e90:	89 81       	ldd	r24, Y+1	; 0x01
    1e92:	9a 81       	ldd	r25, Y+2	; 0x02
    1e94:	fc 01       	movw	r30, r24
    1e96:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    1e98:	89 81       	ldd	r24, Y+1	; 0x01
    1e9a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e9c:	fc 01       	movw	r30, r24
    1e9e:	80 81       	ld	r24, Z
}
    1ea0:	0f 90       	pop	r0
    1ea2:	0f 90       	pop	r0
    1ea4:	0f 90       	pop	r0
    1ea6:	0f 90       	pop	r0
    1ea8:	df 91       	pop	r29
    1eaa:	cf 91       	pop	r28
    1eac:	08 95       	ret

00001eae <main>:

/* Main program loop */
int main(void) __attribute__((OS_main));

int main(void)
{
    1eae:	cd b7       	in	r28, 0x3d	; 61
    1eb0:	de b7       	in	r29, 0x3e	; 62
	usart_init();
    1eb2:	0e 94 47 01 	call	0x28e	; 0x28e <usart_init>

    xTaskCreate(
    1eb6:	a1 2c       	mov	r10, r1
    1eb8:	b1 2c       	mov	r11, r1
    1eba:	c1 2c       	mov	r12, r1
    1ebc:	d1 2c       	mov	r13, r1
    1ebe:	e1 2c       	mov	r14, r1
    1ec0:	f1 2c       	mov	r15, r1
    1ec2:	03 e0       	ldi	r16, 0x03	; 3
    1ec4:	20 e0       	ldi	r18, 0x00	; 0
    1ec6:	30 e0       	ldi	r19, 0x00	; 0
    1ec8:	40 e0       	ldi	r20, 0x00	; 0
    1eca:	51 e0       	ldi	r21, 0x01	; 1
    1ecc:	68 e0       	ldi	r22, 0x08	; 8
    1ece:	72 e0       	ldi	r23, 0x02	; 2
    1ed0:	81 e7       	ldi	r24, 0x71	; 113
    1ed2:	9f e0       	ldi	r25, 0x0F	; 15
    1ed4:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <xTaskGenericCreate>
		,  NULL
		,  3
		,  NULL ); // */


	vTaskStartScheduler();
    1ed8:	0e 94 ca 1f 	call	0x3f94	; 0x3f94 <vTaskStartScheduler>
    1edc:	80 e0       	ldi	r24, 0x00	; 0
    1ede:	90 e0       	ldi	r25, 0x00	; 0


}
    1ee0:	08 95       	ret

00001ee2 <Led>:

/*-----------------------------------------------------------*/
static void Led(void *pvParameters){
    1ee2:	cf 93       	push	r28
    1ee4:	df 93       	push	r29
    1ee6:	00 d0       	rcall	.+0      	; 0x1ee8 <Led+0x6>
    1ee8:	1f 92       	push	r1
    1eea:	cd b7       	in	r28, 0x3d	; 61
    1eec:	de b7       	in	r29, 0x3e	; 62
    1eee:	9c 83       	std	Y+4, r25	; 0x04
    1ef0:	8b 83       	std	Y+3, r24	; 0x03
    TickType_t xLastWakeTime;
	/* The xLastWakeTime variable needs to be initialised with the current tick
	count.  Note that this is the only time we access this variable.  From this
	point on xLastWakeTime is managed automatically by the vTaskDelayUntil()
	API function. */
	xLastWakeTime = xTaskGetTickCount();
    1ef2:	0e 94 ac 20 	call	0x4158	; 0x4158 <xTaskGetTickCount>
    1ef6:	9a 83       	std	Y+2, r25	; 0x02
    1ef8:	89 83       	std	Y+1, r24	; 0x01

	DDRB |= 0xF0;
    1efa:	84 e2       	ldi	r24, 0x24	; 36
    1efc:	90 e0       	ldi	r25, 0x00	; 0
    1efe:	24 e2       	ldi	r18, 0x24	; 36
    1f00:	30 e0       	ldi	r19, 0x00	; 0
    1f02:	f9 01       	movw	r30, r18
    1f04:	20 81       	ld	r18, Z
    1f06:	20 6f       	ori	r18, 0xF0	; 240
    1f08:	fc 01       	movw	r30, r24
    1f0a:	20 83       	st	Z, r18

    while(1)
    {
    	sei();
    1f0c:	78 94       	sei

		DDRB |= _BV(DDB5);
    1f0e:	84 e2       	ldi	r24, 0x24	; 36
    1f10:	90 e0       	ldi	r25, 0x00	; 0
    1f12:	24 e2       	ldi	r18, 0x24	; 36
    1f14:	30 e0       	ldi	r19, 0x00	; 0
    1f16:	f9 01       	movw	r30, r18
    1f18:	20 81       	ld	r18, Z
    1f1a:	20 62       	ori	r18, 0x20	; 32
    1f1c:	fc 01       	movw	r30, r24
    1f1e:	20 83       	st	Z, r18

		    while(1)
		    {
		    	PORTB |=  _BV(PORTB5);       // main (red PB5) LED on. Arduino LED on
    1f20:	85 e2       	ldi	r24, 0x25	; 37
    1f22:	90 e0       	ldi	r25, 0x00	; 0
    1f24:	25 e2       	ldi	r18, 0x25	; 37
    1f26:	30 e0       	ldi	r19, 0x00	; 0
    1f28:	f9 01       	movw	r30, r18
    1f2a:	20 81       	ld	r18, Z
    1f2c:	20 62       	ori	r18, 0x20	; 32
    1f2e:	fc 01       	movw	r30, r24
    1f30:	20 83       	st	Z, r18

				vTaskDelayUntil( &xLastWakeTime, ( 1000 / portTICK_PERIOD_MS ) );
    1f32:	6e e3       	ldi	r22, 0x3E	; 62
    1f34:	70 e0       	ldi	r23, 0x00	; 0
    1f36:	ce 01       	movw	r24, r28
    1f38:	01 96       	adiw	r24, 0x01	; 1
    1f3a:	0e 94 9d 1c 	call	0x393a	; 0x393a <vTaskDelayUntil>

				PORTB &= ~_BV(PORTB5);       // main (red PB5) LED off. Arduino LED off
    1f3e:	85 e2       	ldi	r24, 0x25	; 37
    1f40:	90 e0       	ldi	r25, 0x00	; 0
    1f42:	25 e2       	ldi	r18, 0x25	; 37
    1f44:	30 e0       	ldi	r19, 0x00	; 0
    1f46:	f9 01       	movw	r30, r18
    1f48:	20 81       	ld	r18, Z
    1f4a:	2f 7d       	andi	r18, 0xDF	; 223
    1f4c:	fc 01       	movw	r30, r24
    1f4e:	20 83       	st	Z, r18

				vTaskDelayUntil( &xLastWakeTime, ( 4000 / portTICK_PERIOD_MS ) );
    1f50:	6a ef       	ldi	r22, 0xFA	; 250
    1f52:	70 e0       	ldi	r23, 0x00	; 0
    1f54:	ce 01       	movw	r24, r28
    1f56:	01 96       	adiw	r24, 0x01	; 1
    1f58:	0e 94 9d 1c 	call	0x393a	; 0x393a <vTaskDelayUntil>

				put_float(2.3);
    1f5c:	63 e3       	ldi	r22, 0x33	; 51
    1f5e:	73 e3       	ldi	r23, 0x33	; 51
    1f60:	83 e1       	ldi	r24, 0x13	; 19
    1f62:	90 e4       	ldi	r25, 0x40	; 64
    1f64:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <put_float>
				put_string("Hola\n");
    1f68:	80 e1       	ldi	r24, 0x10	; 16
    1f6a:	92 e0       	ldi	r25, 0x02	; 2
    1f6c:	0e 94 87 01 	call	0x30e	; 0x30e <put_string>
		    }
    1f70:	d7 cf       	rjmp	.-82     	; 0x1f20 <Led+0x3e>

00001f72 <LecturaMPU6050>:

    }
}

static void LecturaMPU6050(void *pvParameters) // Main Red LED Flash
{
    1f72:	ef 92       	push	r14
    1f74:	ff 92       	push	r15
    1f76:	0f 93       	push	r16
    1f78:	1f 93       	push	r17
    1f7a:	cf 93       	push	r28
    1f7c:	df 93       	push	r29
    1f7e:	00 d0       	rcall	.+0      	; 0x1f80 <LecturaMPU6050+0xe>
    1f80:	1f 92       	push	r1
    1f82:	cd b7       	in	r28, 0x3d	; 61
    1f84:	de b7       	in	r29, 0x3e	; 62
    1f86:	9c 83       	std	Y+4, r25	; 0x04
    1f88:	8b 83       	std	Y+3, r24	; 0x03
    TickType_t xLastWakeTime;
	/* The xLastWakeTime variable needs to be initialised with the current tick
	count.  Note that this is the only time we access this variable.  From this
	point on xLastWakeTime is managed automatically by the vTaskDelayUntil()
	API function. */
	xLastWakeTime = xTaskGetTickCount();
    1f8a:	0e 94 ac 20 	call	0x4158	; 0x4158 <xTaskGetTickCount>
    1f8e:	9a 83       	std	Y+2, r25	; 0x02
    1f90:	89 83       	std	Y+1, r24	; 0x01

	DDRB |= 0xF0;
    1f92:	84 e2       	ldi	r24, 0x24	; 36
    1f94:	90 e0       	ldi	r25, 0x00	; 0
    1f96:	24 e2       	ldi	r18, 0x24	; 36
    1f98:	30 e0       	ldi	r19, 0x00	; 0
    1f9a:	f9 01       	movw	r30, r18
    1f9c:	20 81       	ld	r18, Z
    1f9e:	20 6f       	ori	r18, 0xF0	; 240
    1fa0:	fc 01       	movw	r30, r24
    1fa2:	20 83       	st	Z, r18

    while(1)
    {
    	//init interrupt
		sei();
    1fa4:	78 94       	sei

		//init mpu6050

		mpu6050_init();
    1fa6:	0e 94 b6 08 	call	0x116c	; 0x116c <mpu6050_init>
		//_delay_ms(50);
    	mpu6050_getRawData(&ax, &ay, &az, &gx, &gy, &gz);
    1faa:	0f 2e       	mov	r0, r31
    1fac:	f8 e2       	ldi	r31, 0x28	; 40
    1fae:	ef 2e       	mov	r14, r31
    1fb0:	f2 e0       	ldi	r31, 0x02	; 2
    1fb2:	ff 2e       	mov	r15, r31
    1fb4:	f0 2d       	mov	r31, r0
    1fb6:	06 e2       	ldi	r16, 0x26	; 38
    1fb8:	12 e0       	ldi	r17, 0x02	; 2
    1fba:	24 e2       	ldi	r18, 0x24	; 36
    1fbc:	32 e0       	ldi	r19, 0x02	; 2
    1fbe:	42 e2       	ldi	r20, 0x22	; 34
    1fc0:	52 e0       	ldi	r21, 0x02	; 2
    1fc2:	60 e2       	ldi	r22, 0x20	; 32
    1fc4:	72 e0       	ldi	r23, 0x02	; 2
    1fc6:	8e e1       	ldi	r24, 0x1E	; 30
    1fc8:	92 e0       	ldi	r25, 0x02	; 2
    1fca:	0e 94 2b 07 	call	0xe56	; 0xe56 <mpu6050_getRawData>
    	mpu6050_getConvData(&axg, &ayg, &azg, &gxds, &gyds, &gzds);
    1fce:	0f 2e       	mov	r0, r31
    1fd0:	fe e3       	ldi	r31, 0x3E	; 62
    1fd2:	ef 2e       	mov	r14, r31
    1fd4:	f2 e0       	ldi	r31, 0x02	; 2
    1fd6:	ff 2e       	mov	r15, r31
    1fd8:	f0 2d       	mov	r31, r0
    1fda:	0a e3       	ldi	r16, 0x3A	; 58
    1fdc:	12 e0       	ldi	r17, 0x02	; 2
    1fde:	26 e3       	ldi	r18, 0x36	; 54
    1fe0:	32 e0       	ldi	r19, 0x02	; 2
    1fe2:	42 e3       	ldi	r20, 0x32	; 50
    1fe4:	52 e0       	ldi	r21, 0x02	; 2
    1fe6:	6e e2       	ldi	r22, 0x2E	; 46
    1fe8:	72 e0       	ldi	r23, 0x02	; 2
    1fea:	8a e2       	ldi	r24, 0x2A	; 42
    1fec:	92 e0       	ldi	r25, 0x02	; 2
    1fee:	0e 94 be 07 	call	0xf7c	; 0xf7c <mpu6050_getConvData>

    	put_float(axg);
    1ff2:	80 91 2a 02 	lds	r24, 0x022A
    1ff6:	90 91 2b 02 	lds	r25, 0x022B
    1ffa:	a0 91 2c 02 	lds	r26, 0x022C
    1ffe:	b0 91 2d 02 	lds	r27, 0x022D
    2002:	bc 01       	movw	r22, r24
    2004:	cd 01       	movw	r24, r26
    2006:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <put_float>
    	put_float(ayg);
    200a:	80 91 2e 02 	lds	r24, 0x022E
    200e:	90 91 2f 02 	lds	r25, 0x022F
    2012:	a0 91 30 02 	lds	r26, 0x0230
    2016:	b0 91 31 02 	lds	r27, 0x0231
    201a:	bc 01       	movw	r22, r24
    201c:	cd 01       	movw	r24, r26
    201e:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <put_float>
    	put_float(azg);
    2022:	80 91 32 02 	lds	r24, 0x0232
    2026:	90 91 33 02 	lds	r25, 0x0233
    202a:	a0 91 34 02 	lds	r26, 0x0234
    202e:	b0 91 35 02 	lds	r27, 0x0235
    2032:	bc 01       	movw	r22, r24
    2034:	cd 01       	movw	r24, r26
    2036:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <put_float>
    	put_string("\n");
    203a:	86 e1       	ldi	r24, 0x16	; 22
    203c:	92 e0       	ldi	r25, 0x02	; 2
    203e:	0e 94 87 01 	call	0x30e	; 0x30e <put_string>
    	put_float(2.3);
    2042:	63 e3       	ldi	r22, 0x33	; 51
    2044:	73 e3       	ldi	r23, 0x33	; 51
    2046:	83 e1       	ldi	r24, 0x13	; 19
    2048:	90 e4       	ldi	r25, 0x40	; 64
    204a:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <put_float>

    	if(axg < 0.1) PORTB &= 0x00;
    204e:	80 91 2a 02 	lds	r24, 0x022A
    2052:	90 91 2b 02 	lds	r25, 0x022B
    2056:	a0 91 2c 02 	lds	r26, 0x022C
    205a:	b0 91 2d 02 	lds	r27, 0x022D
    205e:	2d ec       	ldi	r18, 0xCD	; 205
    2060:	3c ec       	ldi	r19, 0xCC	; 204
    2062:	4c ec       	ldi	r20, 0xCC	; 204
    2064:	5d e3       	ldi	r21, 0x3D	; 61
    2066:	bc 01       	movw	r22, r24
    2068:	cd 01       	movw	r24, r26
    206a:	0e 94 28 2c 	call	0x5850	; 0x5850 <__cmpsf2>
    206e:	88 23       	and	r24, r24
    2070:	44 f4       	brge	.+16     	; 0x2082 <LecturaMPU6050+0x110>
    2072:	85 e2       	ldi	r24, 0x25	; 37
    2074:	90 e0       	ldi	r25, 0x00	; 0
    2076:	fc 01       	movw	r30, r24
    2078:	80 81       	ld	r24, Z
    207a:	85 e2       	ldi	r24, 0x25	; 37
    207c:	90 e0       	ldi	r25, 0x00	; 0
    207e:	fc 01       	movw	r30, r24
    2080:	10 82       	st	Z, r1

    	if(axg >= 0.1 && axg < 0.4){
    2082:	80 91 2a 02 	lds	r24, 0x022A
    2086:	90 91 2b 02 	lds	r25, 0x022B
    208a:	a0 91 2c 02 	lds	r26, 0x022C
    208e:	b0 91 2d 02 	lds	r27, 0x022D
    2092:	2d ec       	ldi	r18, 0xCD	; 205
    2094:	3c ec       	ldi	r19, 0xCC	; 204
    2096:	4c ec       	ldi	r20, 0xCC	; 204
    2098:	5d e3       	ldi	r21, 0x3D	; 61
    209a:	bc 01       	movw	r22, r24
    209c:	cd 01       	movw	r24, r26
    209e:	0e 94 72 2d 	call	0x5ae4	; 0x5ae4 <__gesf2>
    20a2:	88 23       	and	r24, r24
    20a4:	1c f1       	brlt	.+70     	; 0x20ec <LecturaMPU6050+0x17a>
    20a6:	80 91 2a 02 	lds	r24, 0x022A
    20aa:	90 91 2b 02 	lds	r25, 0x022B
    20ae:	a0 91 2c 02 	lds	r26, 0x022C
    20b2:	b0 91 2d 02 	lds	r27, 0x022D
    20b6:	2d ec       	ldi	r18, 0xCD	; 205
    20b8:	3c ec       	ldi	r19, 0xCC	; 204
    20ba:	4c ec       	ldi	r20, 0xCC	; 204
    20bc:	5e e3       	ldi	r21, 0x3E	; 62
    20be:	bc 01       	movw	r22, r24
    20c0:	cd 01       	movw	r24, r26
    20c2:	0e 94 28 2c 	call	0x5850	; 0x5850 <__cmpsf2>
    20c6:	88 23       	and	r24, r24
    20c8:	8c f4       	brge	.+34     	; 0x20ec <LecturaMPU6050+0x17a>
    		PORTB &= 0x00;
    20ca:	85 e2       	ldi	r24, 0x25	; 37
    20cc:	90 e0       	ldi	r25, 0x00	; 0
    20ce:	fc 01       	movw	r30, r24
    20d0:	80 81       	ld	r24, Z
    20d2:	85 e2       	ldi	r24, 0x25	; 37
    20d4:	90 e0       	ldi	r25, 0x00	; 0
    20d6:	fc 01       	movw	r30, r24
    20d8:	10 82       	st	Z, r1
    		PORTB |= 0x10;
    20da:	85 e2       	ldi	r24, 0x25	; 37
    20dc:	90 e0       	ldi	r25, 0x00	; 0
    20de:	25 e2       	ldi	r18, 0x25	; 37
    20e0:	30 e0       	ldi	r19, 0x00	; 0
    20e2:	f9 01       	movw	r30, r18
    20e4:	20 81       	ld	r18, Z
    20e6:	20 61       	ori	r18, 0x10	; 16
    20e8:	fc 01       	movw	r30, r24
    20ea:	20 83       	st	Z, r18
    	}

    	if(axg >= 0.4 && axg < 0.6){
    20ec:	80 91 2a 02 	lds	r24, 0x022A
    20f0:	90 91 2b 02 	lds	r25, 0x022B
    20f4:	a0 91 2c 02 	lds	r26, 0x022C
    20f8:	b0 91 2d 02 	lds	r27, 0x022D
    20fc:	2d ec       	ldi	r18, 0xCD	; 205
    20fe:	3c ec       	ldi	r19, 0xCC	; 204
    2100:	4c ec       	ldi	r20, 0xCC	; 204
    2102:	5e e3       	ldi	r21, 0x3E	; 62
    2104:	bc 01       	movw	r22, r24
    2106:	cd 01       	movw	r24, r26
    2108:	0e 94 72 2d 	call	0x5ae4	; 0x5ae4 <__gesf2>
    210c:	88 23       	and	r24, r24
    210e:	1c f1       	brlt	.+70     	; 0x2156 <LecturaMPU6050+0x1e4>
    2110:	80 91 2a 02 	lds	r24, 0x022A
    2114:	90 91 2b 02 	lds	r25, 0x022B
    2118:	a0 91 2c 02 	lds	r26, 0x022C
    211c:	b0 91 2d 02 	lds	r27, 0x022D
    2120:	2a e9       	ldi	r18, 0x9A	; 154
    2122:	39 e9       	ldi	r19, 0x99	; 153
    2124:	49 e1       	ldi	r20, 0x19	; 25
    2126:	5f e3       	ldi	r21, 0x3F	; 63
    2128:	bc 01       	movw	r22, r24
    212a:	cd 01       	movw	r24, r26
    212c:	0e 94 28 2c 	call	0x5850	; 0x5850 <__cmpsf2>
    2130:	88 23       	and	r24, r24
    2132:	8c f4       	brge	.+34     	; 0x2156 <LecturaMPU6050+0x1e4>
    		PORTB &= 0x00;
    2134:	85 e2       	ldi	r24, 0x25	; 37
    2136:	90 e0       	ldi	r25, 0x00	; 0
    2138:	fc 01       	movw	r30, r24
    213a:	80 81       	ld	r24, Z
    213c:	85 e2       	ldi	r24, 0x25	; 37
    213e:	90 e0       	ldi	r25, 0x00	; 0
    2140:	fc 01       	movw	r30, r24
    2142:	10 82       	st	Z, r1
    		PORTB |= 0x30;
    2144:	85 e2       	ldi	r24, 0x25	; 37
    2146:	90 e0       	ldi	r25, 0x00	; 0
    2148:	25 e2       	ldi	r18, 0x25	; 37
    214a:	30 e0       	ldi	r19, 0x00	; 0
    214c:	f9 01       	movw	r30, r18
    214e:	20 81       	ld	r18, Z
    2150:	20 63       	ori	r18, 0x30	; 48
    2152:	fc 01       	movw	r30, r24
    2154:	20 83       	st	Z, r18
    	}
    	if(axg >= 0.6 && axg < 0.9){
    2156:	80 91 2a 02 	lds	r24, 0x022A
    215a:	90 91 2b 02 	lds	r25, 0x022B
    215e:	a0 91 2c 02 	lds	r26, 0x022C
    2162:	b0 91 2d 02 	lds	r27, 0x022D
    2166:	2a e9       	ldi	r18, 0x9A	; 154
    2168:	39 e9       	ldi	r19, 0x99	; 153
    216a:	49 e1       	ldi	r20, 0x19	; 25
    216c:	5f e3       	ldi	r21, 0x3F	; 63
    216e:	bc 01       	movw	r22, r24
    2170:	cd 01       	movw	r24, r26
    2172:	0e 94 72 2d 	call	0x5ae4	; 0x5ae4 <__gesf2>
    2176:	88 23       	and	r24, r24
    2178:	1c f1       	brlt	.+70     	; 0x21c0 <LecturaMPU6050+0x24e>
    217a:	80 91 2a 02 	lds	r24, 0x022A
    217e:	90 91 2b 02 	lds	r25, 0x022B
    2182:	a0 91 2c 02 	lds	r26, 0x022C
    2186:	b0 91 2d 02 	lds	r27, 0x022D
    218a:	26 e6       	ldi	r18, 0x66	; 102
    218c:	36 e6       	ldi	r19, 0x66	; 102
    218e:	46 e6       	ldi	r20, 0x66	; 102
    2190:	5f e3       	ldi	r21, 0x3F	; 63
    2192:	bc 01       	movw	r22, r24
    2194:	cd 01       	movw	r24, r26
    2196:	0e 94 28 2c 	call	0x5850	; 0x5850 <__cmpsf2>
    219a:	88 23       	and	r24, r24
    219c:	8c f4       	brge	.+34     	; 0x21c0 <LecturaMPU6050+0x24e>
    		PORTB &= 0x00;
    219e:	85 e2       	ldi	r24, 0x25	; 37
    21a0:	90 e0       	ldi	r25, 0x00	; 0
    21a2:	fc 01       	movw	r30, r24
    21a4:	80 81       	ld	r24, Z
    21a6:	85 e2       	ldi	r24, 0x25	; 37
    21a8:	90 e0       	ldi	r25, 0x00	; 0
    21aa:	fc 01       	movw	r30, r24
    21ac:	10 82       	st	Z, r1
			PORTB |= 0x70;
    21ae:	85 e2       	ldi	r24, 0x25	; 37
    21b0:	90 e0       	ldi	r25, 0x00	; 0
    21b2:	25 e2       	ldi	r18, 0x25	; 37
    21b4:	30 e0       	ldi	r19, 0x00	; 0
    21b6:	f9 01       	movw	r30, r18
    21b8:	20 81       	ld	r18, Z
    21ba:	20 67       	ori	r18, 0x70	; 112
    21bc:	fc 01       	movw	r30, r24
    21be:	20 83       	st	Z, r18
    	}
    	if(axg >= 0.9){
    21c0:	80 91 2a 02 	lds	r24, 0x022A
    21c4:	90 91 2b 02 	lds	r25, 0x022B
    21c8:	a0 91 2c 02 	lds	r26, 0x022C
    21cc:	b0 91 2d 02 	lds	r27, 0x022D
    21d0:	26 e6       	ldi	r18, 0x66	; 102
    21d2:	36 e6       	ldi	r19, 0x66	; 102
    21d4:	46 e6       	ldi	r20, 0x66	; 102
    21d6:	5f e3       	ldi	r21, 0x3F	; 63
    21d8:	bc 01       	movw	r22, r24
    21da:	cd 01       	movw	r24, r26
    21dc:	0e 94 72 2d 	call	0x5ae4	; 0x5ae4 <__gesf2>
    21e0:	88 23       	and	r24, r24
    21e2:	8c f0       	brlt	.+34     	; 0x2206 <__stack+0x7>
    		PORTB &= 0x00;
    21e4:	85 e2       	ldi	r24, 0x25	; 37
    21e6:	90 e0       	ldi	r25, 0x00	; 0
    21e8:	fc 01       	movw	r30, r24
    21ea:	80 81       	ld	r24, Z
    21ec:	85 e2       	ldi	r24, 0x25	; 37
    21ee:	90 e0       	ldi	r25, 0x00	; 0
    21f0:	fc 01       	movw	r30, r24
    21f2:	10 82       	st	Z, r1
			PORTB |= 0xF0;
    21f4:	85 e2       	ldi	r24, 0x25	; 37
    21f6:	90 e0       	ldi	r25, 0x00	; 0
    21f8:	25 e2       	ldi	r18, 0x25	; 37
    21fa:	30 e0       	ldi	r19, 0x00	; 0
    21fc:	f9 01       	movw	r30, r18
    21fe:	20 81       	ld	r18, Z
    2200:	20 6f       	ori	r18, 0xF0	; 240
    2202:	fc 01       	movw	r30, r24
    2204:	20 83       	st	Z, r18
		}

		vTaskDelayUntil( &xLastWakeTime, ( 10 ) );
    2206:	6a e0       	ldi	r22, 0x0A	; 10
    2208:	70 e0       	ldi	r23, 0x00	; 0
    220a:	ce 01       	movw	r24, r28
    220c:	01 96       	adiw	r24, 0x01	; 1
    220e:	0e 94 9d 1c 	call	0x393a	; 0x393a <vTaskDelayUntil>

    }
    2212:	c8 ce       	rjmp	.-624    	; 0x1fa4 <LecturaMPU6050+0x32>

00002214 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2214:	cf 93       	push	r28
    2216:	df 93       	push	r29
    2218:	cd b7       	in	r28, 0x3d	; 61
    221a:	de b7       	in	r29, 0x3e	; 62
    221c:	28 97       	sbiw	r28, 0x08	; 8
    221e:	0f b6       	in	r0, 0x3f	; 63
    2220:	f8 94       	cli
    2222:	de bf       	out	0x3e, r29	; 62
    2224:	0f be       	out	0x3f, r0	; 63
    2226:	cd bf       	out	0x3d, r28	; 61
    2228:	9c 83       	std	Y+4, r25	; 0x04
    222a:	8b 83       	std	Y+3, r24	; 0x03
    222c:	7e 83       	std	Y+6, r23	; 0x06
    222e:	6d 83       	std	Y+5, r22	; 0x05
    2230:	58 87       	std	Y+8, r21	; 0x08
    2232:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2234:	8b 81       	ldd	r24, Y+3	; 0x03
    2236:	9c 81       	ldd	r25, Y+4	; 0x04
    2238:	21 e1       	ldi	r18, 0x11	; 17
    223a:	fc 01       	movw	r30, r24
    223c:	20 83       	st	Z, r18
	pxTopOfStack--;
    223e:	8b 81       	ldd	r24, Y+3	; 0x03
    2240:	9c 81       	ldd	r25, Y+4	; 0x04
    2242:	01 97       	sbiw	r24, 0x01	; 1
    2244:	9c 83       	std	Y+4, r25	; 0x04
    2246:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2248:	8b 81       	ldd	r24, Y+3	; 0x03
    224a:	9c 81       	ldd	r25, Y+4	; 0x04
    224c:	22 e2       	ldi	r18, 0x22	; 34
    224e:	fc 01       	movw	r30, r24
    2250:	20 83       	st	Z, r18
	pxTopOfStack--;
    2252:	8b 81       	ldd	r24, Y+3	; 0x03
    2254:	9c 81       	ldd	r25, Y+4	; 0x04
    2256:	01 97       	sbiw	r24, 0x01	; 1
    2258:	9c 83       	std	Y+4, r25	; 0x04
    225a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    225c:	8b 81       	ldd	r24, Y+3	; 0x03
    225e:	9c 81       	ldd	r25, Y+4	; 0x04
    2260:	23 e3       	ldi	r18, 0x33	; 51
    2262:	fc 01       	movw	r30, r24
    2264:	20 83       	st	Z, r18
	pxTopOfStack--;
    2266:	8b 81       	ldd	r24, Y+3	; 0x03
    2268:	9c 81       	ldd	r25, Y+4	; 0x04
    226a:	01 97       	sbiw	r24, 0x01	; 1
    226c:	9c 83       	std	Y+4, r25	; 0x04
    226e:	8b 83       	std	Y+3, r24	; 0x03
	 * of flash. We do this by using the .lowtext label in the linker script.
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( uint16_t ) pxCode;
    2270:	8d 81       	ldd	r24, Y+5	; 0x05
    2272:	9e 81       	ldd	r25, Y+6	; 0x06
    2274:	9a 83       	std	Y+2, r25	; 0x02
    2276:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2278:	29 81       	ldd	r18, Y+1	; 0x01
    227a:	8b 81       	ldd	r24, Y+3	; 0x03
    227c:	9c 81       	ldd	r25, Y+4	; 0x04
    227e:	fc 01       	movw	r30, r24
    2280:	20 83       	st	Z, r18
	pxTopOfStack--;
    2282:	8b 81       	ldd	r24, Y+3	; 0x03
    2284:	9c 81       	ldd	r25, Y+4	; 0x04
    2286:	01 97       	sbiw	r24, 0x01	; 1
    2288:	9c 83       	std	Y+4, r25	; 0x04
    228a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    228c:	89 81       	ldd	r24, Y+1	; 0x01
    228e:	9a 81       	ldd	r25, Y+2	; 0x02
    2290:	89 2f       	mov	r24, r25
    2292:	99 27       	eor	r25, r25
    2294:	9a 83       	std	Y+2, r25	; 0x02
    2296:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2298:	29 81       	ldd	r18, Y+1	; 0x01
    229a:	8b 81       	ldd	r24, Y+3	; 0x03
    229c:	9c 81       	ldd	r25, Y+4	; 0x04
    229e:	fc 01       	movw	r30, r24
    22a0:	20 83       	st	Z, r18
	pxTopOfStack--;
    22a2:	8b 81       	ldd	r24, Y+3	; 0x03
    22a4:	9c 81       	ldd	r25, Y+4	; 0x04
    22a6:	01 97       	sbiw	r24, 0x01	; 1
    22a8:	9c 83       	std	Y+4, r25	; 0x04
    22aa:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = 0;
    22ac:	8b 81       	ldd	r24, Y+3	; 0x03
    22ae:	9c 81       	ldd	r25, Y+4	; 0x04
    22b0:	fc 01       	movw	r30, r24
    22b2:	10 82       	st	Z, r1
	pxTopOfStack--;
    22b4:	8b 81       	ldd	r24, Y+3	; 0x03
    22b6:	9c 81       	ldd	r25, Y+4	; 0x04
    22b8:	01 97       	sbiw	r24, 0x01	; 1
    22ba:	9c 83       	std	Y+4, r25	; 0x04
    22bc:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    22be:	8b 81       	ldd	r24, Y+3	; 0x03
    22c0:	9c 81       	ldd	r25, Y+4	; 0x04
    22c2:	fc 01       	movw	r30, r24
    22c4:	10 82       	st	Z, r1
	pxTopOfStack--;
    22c6:	8b 81       	ldd	r24, Y+3	; 0x03
    22c8:	9c 81       	ldd	r25, Y+4	; 0x04
    22ca:	01 97       	sbiw	r24, 0x01	; 1
    22cc:	9c 83       	std	Y+4, r25	; 0x04
    22ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    22d0:	8b 81       	ldd	r24, Y+3	; 0x03
    22d2:	9c 81       	ldd	r25, Y+4	; 0x04
    22d4:	20 e8       	ldi	r18, 0x80	; 128
    22d6:	fc 01       	movw	r30, r24
    22d8:	20 83       	st	Z, r18
	pxTopOfStack--;
    22da:	8b 81       	ldd	r24, Y+3	; 0x03
    22dc:	9c 81       	ldd	r25, Y+4	; 0x04
    22de:	01 97       	sbiw	r24, 0x01	; 1
    22e0:	9c 83       	std	Y+4, r25	; 0x04
    22e2:	8b 83       	std	Y+3, r24	; 0x03
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* EIND */
    22e4:	8b 81       	ldd	r24, Y+3	; 0x03
    22e6:	9c 81       	ldd	r25, Y+4	; 0x04
    22e8:	fc 01       	movw	r30, r24
    22ea:	10 82       	st	Z, r1
	pxTopOfStack--;
    22ec:	8b 81       	ldd	r24, Y+3	; 0x03
    22ee:	9c 81       	ldd	r25, Y+4	; 0x04
    22f0:	01 97       	sbiw	r24, 0x01	; 1
    22f2:	9c 83       	std	Y+4, r25	; 0x04
    22f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x00;	/* RAMPZ */
    22f6:	8b 81       	ldd	r24, Y+3	; 0x03
    22f8:	9c 81       	ldd	r25, Y+4	; 0x04
    22fa:	fc 01       	movw	r30, r24
    22fc:	10 82       	st	Z, r1
	pxTopOfStack--;
    22fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2300:	9c 81       	ldd	r25, Y+4	; 0x04
    2302:	01 97       	sbiw	r24, 0x01	; 1
    2304:	9c 83       	std	Y+4, r25	; 0x04
    2306:	8b 83       	std	Y+3, r24	; 0x03

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2308:	8b 81       	ldd	r24, Y+3	; 0x03
    230a:	9c 81       	ldd	r25, Y+4	; 0x04
    230c:	fc 01       	movw	r30, r24
    230e:	10 82       	st	Z, r1
	pxTopOfStack--;
    2310:	8b 81       	ldd	r24, Y+3	; 0x03
    2312:	9c 81       	ldd	r25, Y+4	; 0x04
    2314:	01 97       	sbiw	r24, 0x01	; 1
    2316:	9c 83       	std	Y+4, r25	; 0x04
    2318:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    231a:	8b 81       	ldd	r24, Y+3	; 0x03
    231c:	9c 81       	ldd	r25, Y+4	; 0x04
    231e:	22 e0       	ldi	r18, 0x02	; 2
    2320:	fc 01       	movw	r30, r24
    2322:	20 83       	st	Z, r18
	pxTopOfStack--;
    2324:	8b 81       	ldd	r24, Y+3	; 0x03
    2326:	9c 81       	ldd	r25, Y+4	; 0x04
    2328:	01 97       	sbiw	r24, 0x01	; 1
    232a:	9c 83       	std	Y+4, r25	; 0x04
    232c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    232e:	8b 81       	ldd	r24, Y+3	; 0x03
    2330:	9c 81       	ldd	r25, Y+4	; 0x04
    2332:	23 e0       	ldi	r18, 0x03	; 3
    2334:	fc 01       	movw	r30, r24
    2336:	20 83       	st	Z, r18
	pxTopOfStack--;
    2338:	8b 81       	ldd	r24, Y+3	; 0x03
    233a:	9c 81       	ldd	r25, Y+4	; 0x04
    233c:	01 97       	sbiw	r24, 0x01	; 1
    233e:	9c 83       	std	Y+4, r25	; 0x04
    2340:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2342:	8b 81       	ldd	r24, Y+3	; 0x03
    2344:	9c 81       	ldd	r25, Y+4	; 0x04
    2346:	24 e0       	ldi	r18, 0x04	; 4
    2348:	fc 01       	movw	r30, r24
    234a:	20 83       	st	Z, r18
	pxTopOfStack--;
    234c:	8b 81       	ldd	r24, Y+3	; 0x03
    234e:	9c 81       	ldd	r25, Y+4	; 0x04
    2350:	01 97       	sbiw	r24, 0x01	; 1
    2352:	9c 83       	std	Y+4, r25	; 0x04
    2354:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2356:	8b 81       	ldd	r24, Y+3	; 0x03
    2358:	9c 81       	ldd	r25, Y+4	; 0x04
    235a:	25 e0       	ldi	r18, 0x05	; 5
    235c:	fc 01       	movw	r30, r24
    235e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2360:	8b 81       	ldd	r24, Y+3	; 0x03
    2362:	9c 81       	ldd	r25, Y+4	; 0x04
    2364:	01 97       	sbiw	r24, 0x01	; 1
    2366:	9c 83       	std	Y+4, r25	; 0x04
    2368:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    236a:	8b 81       	ldd	r24, Y+3	; 0x03
    236c:	9c 81       	ldd	r25, Y+4	; 0x04
    236e:	26 e0       	ldi	r18, 0x06	; 6
    2370:	fc 01       	movw	r30, r24
    2372:	20 83       	st	Z, r18
	pxTopOfStack--;
    2374:	8b 81       	ldd	r24, Y+3	; 0x03
    2376:	9c 81       	ldd	r25, Y+4	; 0x04
    2378:	01 97       	sbiw	r24, 0x01	; 1
    237a:	9c 83       	std	Y+4, r25	; 0x04
    237c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    237e:	8b 81       	ldd	r24, Y+3	; 0x03
    2380:	9c 81       	ldd	r25, Y+4	; 0x04
    2382:	27 e0       	ldi	r18, 0x07	; 7
    2384:	fc 01       	movw	r30, r24
    2386:	20 83       	st	Z, r18
	pxTopOfStack--;
    2388:	8b 81       	ldd	r24, Y+3	; 0x03
    238a:	9c 81       	ldd	r25, Y+4	; 0x04
    238c:	01 97       	sbiw	r24, 0x01	; 1
    238e:	9c 83       	std	Y+4, r25	; 0x04
    2390:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2392:	8b 81       	ldd	r24, Y+3	; 0x03
    2394:	9c 81       	ldd	r25, Y+4	; 0x04
    2396:	28 e0       	ldi	r18, 0x08	; 8
    2398:	fc 01       	movw	r30, r24
    239a:	20 83       	st	Z, r18
	pxTopOfStack--;
    239c:	8b 81       	ldd	r24, Y+3	; 0x03
    239e:	9c 81       	ldd	r25, Y+4	; 0x04
    23a0:	01 97       	sbiw	r24, 0x01	; 1
    23a2:	9c 83       	std	Y+4, r25	; 0x04
    23a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    23a6:	8b 81       	ldd	r24, Y+3	; 0x03
    23a8:	9c 81       	ldd	r25, Y+4	; 0x04
    23aa:	29 e0       	ldi	r18, 0x09	; 9
    23ac:	fc 01       	movw	r30, r24
    23ae:	20 83       	st	Z, r18
	pxTopOfStack--;
    23b0:	8b 81       	ldd	r24, Y+3	; 0x03
    23b2:	9c 81       	ldd	r25, Y+4	; 0x04
    23b4:	01 97       	sbiw	r24, 0x01	; 1
    23b6:	9c 83       	std	Y+4, r25	; 0x04
    23b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    23ba:	8b 81       	ldd	r24, Y+3	; 0x03
    23bc:	9c 81       	ldd	r25, Y+4	; 0x04
    23be:	20 e1       	ldi	r18, 0x10	; 16
    23c0:	fc 01       	movw	r30, r24
    23c2:	20 83       	st	Z, r18
	pxTopOfStack--;
    23c4:	8b 81       	ldd	r24, Y+3	; 0x03
    23c6:	9c 81       	ldd	r25, Y+4	; 0x04
    23c8:	01 97       	sbiw	r24, 0x01	; 1
    23ca:	9c 83       	std	Y+4, r25	; 0x04
    23cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    23ce:	8b 81       	ldd	r24, Y+3	; 0x03
    23d0:	9c 81       	ldd	r25, Y+4	; 0x04
    23d2:	21 e1       	ldi	r18, 0x11	; 17
    23d4:	fc 01       	movw	r30, r24
    23d6:	20 83       	st	Z, r18
	pxTopOfStack--;
    23d8:	8b 81       	ldd	r24, Y+3	; 0x03
    23da:	9c 81       	ldd	r25, Y+4	; 0x04
    23dc:	01 97       	sbiw	r24, 0x01	; 1
    23de:	9c 83       	std	Y+4, r25	; 0x04
    23e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    23e2:	8b 81       	ldd	r24, Y+3	; 0x03
    23e4:	9c 81       	ldd	r25, Y+4	; 0x04
    23e6:	22 e1       	ldi	r18, 0x12	; 18
    23e8:	fc 01       	movw	r30, r24
    23ea:	20 83       	st	Z, r18
	pxTopOfStack--;
    23ec:	8b 81       	ldd	r24, Y+3	; 0x03
    23ee:	9c 81       	ldd	r25, Y+4	; 0x04
    23f0:	01 97       	sbiw	r24, 0x01	; 1
    23f2:	9c 83       	std	Y+4, r25	; 0x04
    23f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    23f6:	8b 81       	ldd	r24, Y+3	; 0x03
    23f8:	9c 81       	ldd	r25, Y+4	; 0x04
    23fa:	23 e1       	ldi	r18, 0x13	; 19
    23fc:	fc 01       	movw	r30, r24
    23fe:	20 83       	st	Z, r18
	pxTopOfStack--;
    2400:	8b 81       	ldd	r24, Y+3	; 0x03
    2402:	9c 81       	ldd	r25, Y+4	; 0x04
    2404:	01 97       	sbiw	r24, 0x01	; 1
    2406:	9c 83       	std	Y+4, r25	; 0x04
    2408:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    240a:	8b 81       	ldd	r24, Y+3	; 0x03
    240c:	9c 81       	ldd	r25, Y+4	; 0x04
    240e:	24 e1       	ldi	r18, 0x14	; 20
    2410:	fc 01       	movw	r30, r24
    2412:	20 83       	st	Z, r18
	pxTopOfStack--;
    2414:	8b 81       	ldd	r24, Y+3	; 0x03
    2416:	9c 81       	ldd	r25, Y+4	; 0x04
    2418:	01 97       	sbiw	r24, 0x01	; 1
    241a:	9c 83       	std	Y+4, r25	; 0x04
    241c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    241e:	8b 81       	ldd	r24, Y+3	; 0x03
    2420:	9c 81       	ldd	r25, Y+4	; 0x04
    2422:	25 e1       	ldi	r18, 0x15	; 21
    2424:	fc 01       	movw	r30, r24
    2426:	20 83       	st	Z, r18
	pxTopOfStack--;
    2428:	8b 81       	ldd	r24, Y+3	; 0x03
    242a:	9c 81       	ldd	r25, Y+4	; 0x04
    242c:	01 97       	sbiw	r24, 0x01	; 1
    242e:	9c 83       	std	Y+4, r25	; 0x04
    2430:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2432:	8b 81       	ldd	r24, Y+3	; 0x03
    2434:	9c 81       	ldd	r25, Y+4	; 0x04
    2436:	26 e1       	ldi	r18, 0x16	; 22
    2438:	fc 01       	movw	r30, r24
    243a:	20 83       	st	Z, r18
	pxTopOfStack--;
    243c:	8b 81       	ldd	r24, Y+3	; 0x03
    243e:	9c 81       	ldd	r25, Y+4	; 0x04
    2440:	01 97       	sbiw	r24, 0x01	; 1
    2442:	9c 83       	std	Y+4, r25	; 0x04
    2444:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2446:	8b 81       	ldd	r24, Y+3	; 0x03
    2448:	9c 81       	ldd	r25, Y+4	; 0x04
    244a:	27 e1       	ldi	r18, 0x17	; 23
    244c:	fc 01       	movw	r30, r24
    244e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2450:	8b 81       	ldd	r24, Y+3	; 0x03
    2452:	9c 81       	ldd	r25, Y+4	; 0x04
    2454:	01 97       	sbiw	r24, 0x01	; 1
    2456:	9c 83       	std	Y+4, r25	; 0x04
    2458:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    245a:	8b 81       	ldd	r24, Y+3	; 0x03
    245c:	9c 81       	ldd	r25, Y+4	; 0x04
    245e:	28 e1       	ldi	r18, 0x18	; 24
    2460:	fc 01       	movw	r30, r24
    2462:	20 83       	st	Z, r18
	pxTopOfStack--;
    2464:	8b 81       	ldd	r24, Y+3	; 0x03
    2466:	9c 81       	ldd	r25, Y+4	; 0x04
    2468:	01 97       	sbiw	r24, 0x01	; 1
    246a:	9c 83       	std	Y+4, r25	; 0x04
    246c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    246e:	8b 81       	ldd	r24, Y+3	; 0x03
    2470:	9c 81       	ldd	r25, Y+4	; 0x04
    2472:	29 e1       	ldi	r18, 0x19	; 25
    2474:	fc 01       	movw	r30, r24
    2476:	20 83       	st	Z, r18
	pxTopOfStack--;
    2478:	8b 81       	ldd	r24, Y+3	; 0x03
    247a:	9c 81       	ldd	r25, Y+4	; 0x04
    247c:	01 97       	sbiw	r24, 0x01	; 1
    247e:	9c 83       	std	Y+4, r25	; 0x04
    2480:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2482:	8b 81       	ldd	r24, Y+3	; 0x03
    2484:	9c 81       	ldd	r25, Y+4	; 0x04
    2486:	20 e2       	ldi	r18, 0x20	; 32
    2488:	fc 01       	movw	r30, r24
    248a:	20 83       	st	Z, r18
	pxTopOfStack--;
    248c:	8b 81       	ldd	r24, Y+3	; 0x03
    248e:	9c 81       	ldd	r25, Y+4	; 0x04
    2490:	01 97       	sbiw	r24, 0x01	; 1
    2492:	9c 83       	std	Y+4, r25	; 0x04
    2494:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2496:	8b 81       	ldd	r24, Y+3	; 0x03
    2498:	9c 81       	ldd	r25, Y+4	; 0x04
    249a:	21 e2       	ldi	r18, 0x21	; 33
    249c:	fc 01       	movw	r30, r24
    249e:	20 83       	st	Z, r18
	pxTopOfStack--;
    24a0:	8b 81       	ldd	r24, Y+3	; 0x03
    24a2:	9c 81       	ldd	r25, Y+4	; 0x04
    24a4:	01 97       	sbiw	r24, 0x01	; 1
    24a6:	9c 83       	std	Y+4, r25	; 0x04
    24a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    24aa:	8b 81       	ldd	r24, Y+3	; 0x03
    24ac:	9c 81       	ldd	r25, Y+4	; 0x04
    24ae:	22 e2       	ldi	r18, 0x22	; 34
    24b0:	fc 01       	movw	r30, r24
    24b2:	20 83       	st	Z, r18
	pxTopOfStack--;
    24b4:	8b 81       	ldd	r24, Y+3	; 0x03
    24b6:	9c 81       	ldd	r25, Y+4	; 0x04
    24b8:	01 97       	sbiw	r24, 0x01	; 1
    24ba:	9c 83       	std	Y+4, r25	; 0x04
    24bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    24be:	8b 81       	ldd	r24, Y+3	; 0x03
    24c0:	9c 81       	ldd	r25, Y+4	; 0x04
    24c2:	23 e2       	ldi	r18, 0x23	; 35
    24c4:	fc 01       	movw	r30, r24
    24c6:	20 83       	st	Z, r18
	pxTopOfStack--;
    24c8:	8b 81       	ldd	r24, Y+3	; 0x03
    24ca:	9c 81       	ldd	r25, Y+4	; 0x04
    24cc:	01 97       	sbiw	r24, 0x01	; 1
    24ce:	9c 83       	std	Y+4, r25	; 0x04
    24d0:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    24d2:	8f 81       	ldd	r24, Y+7	; 0x07
    24d4:	98 85       	ldd	r25, Y+8	; 0x08
    24d6:	9a 83       	std	Y+2, r25	; 0x02
    24d8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    24da:	29 81       	ldd	r18, Y+1	; 0x01
    24dc:	8b 81       	ldd	r24, Y+3	; 0x03
    24de:	9c 81       	ldd	r25, Y+4	; 0x04
    24e0:	fc 01       	movw	r30, r24
    24e2:	20 83       	st	Z, r18
	pxTopOfStack--;
    24e4:	8b 81       	ldd	r24, Y+3	; 0x03
    24e6:	9c 81       	ldd	r25, Y+4	; 0x04
    24e8:	01 97       	sbiw	r24, 0x01	; 1
    24ea:	9c 83       	std	Y+4, r25	; 0x04
    24ec:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    24ee:	89 81       	ldd	r24, Y+1	; 0x01
    24f0:	9a 81       	ldd	r25, Y+2	; 0x02
    24f2:	89 2f       	mov	r24, r25
    24f4:	99 27       	eor	r25, r25
    24f6:	9a 83       	std	Y+2, r25	; 0x02
    24f8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    24fa:	29 81       	ldd	r18, Y+1	; 0x01
    24fc:	8b 81       	ldd	r24, Y+3	; 0x03
    24fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2500:	fc 01       	movw	r30, r24
    2502:	20 83       	st	Z, r18
	pxTopOfStack--;
    2504:	8b 81       	ldd	r24, Y+3	; 0x03
    2506:	9c 81       	ldd	r25, Y+4	; 0x04
    2508:	01 97       	sbiw	r24, 0x01	; 1
    250a:	9c 83       	std	Y+4, r25	; 0x04
    250c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    250e:	8b 81       	ldd	r24, Y+3	; 0x03
    2510:	9c 81       	ldd	r25, Y+4	; 0x04
    2512:	26 e2       	ldi	r18, 0x26	; 38
    2514:	fc 01       	movw	r30, r24
    2516:	20 83       	st	Z, r18
	pxTopOfStack--;
    2518:	8b 81       	ldd	r24, Y+3	; 0x03
    251a:	9c 81       	ldd	r25, Y+4	; 0x04
    251c:	01 97       	sbiw	r24, 0x01	; 1
    251e:	9c 83       	std	Y+4, r25	; 0x04
    2520:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2522:	8b 81       	ldd	r24, Y+3	; 0x03
    2524:	9c 81       	ldd	r25, Y+4	; 0x04
    2526:	27 e2       	ldi	r18, 0x27	; 39
    2528:	fc 01       	movw	r30, r24
    252a:	20 83       	st	Z, r18
	pxTopOfStack--;
    252c:	8b 81       	ldd	r24, Y+3	; 0x03
    252e:	9c 81       	ldd	r25, Y+4	; 0x04
    2530:	01 97       	sbiw	r24, 0x01	; 1
    2532:	9c 83       	std	Y+4, r25	; 0x04
    2534:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2536:	8b 81       	ldd	r24, Y+3	; 0x03
    2538:	9c 81       	ldd	r25, Y+4	; 0x04
    253a:	28 e2       	ldi	r18, 0x28	; 40
    253c:	fc 01       	movw	r30, r24
    253e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2540:	8b 81       	ldd	r24, Y+3	; 0x03
    2542:	9c 81       	ldd	r25, Y+4	; 0x04
    2544:	01 97       	sbiw	r24, 0x01	; 1
    2546:	9c 83       	std	Y+4, r25	; 0x04
    2548:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    254a:	8b 81       	ldd	r24, Y+3	; 0x03
    254c:	9c 81       	ldd	r25, Y+4	; 0x04
    254e:	29 e2       	ldi	r18, 0x29	; 41
    2550:	fc 01       	movw	r30, r24
    2552:	20 83       	st	Z, r18
	pxTopOfStack--;
    2554:	8b 81       	ldd	r24, Y+3	; 0x03
    2556:	9c 81       	ldd	r25, Y+4	; 0x04
    2558:	01 97       	sbiw	r24, 0x01	; 1
    255a:	9c 83       	std	Y+4, r25	; 0x04
    255c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    255e:	8b 81       	ldd	r24, Y+3	; 0x03
    2560:	9c 81       	ldd	r25, Y+4	; 0x04
    2562:	20 e3       	ldi	r18, 0x30	; 48
    2564:	fc 01       	movw	r30, r24
    2566:	20 83       	st	Z, r18
	pxTopOfStack--;
    2568:	8b 81       	ldd	r24, Y+3	; 0x03
    256a:	9c 81       	ldd	r25, Y+4	; 0x04
    256c:	01 97       	sbiw	r24, 0x01	; 1
    256e:	9c 83       	std	Y+4, r25	; 0x04
    2570:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2572:	8b 81       	ldd	r24, Y+3	; 0x03
    2574:	9c 81       	ldd	r25, Y+4	; 0x04
    2576:	21 e3       	ldi	r18, 0x31	; 49
    2578:	fc 01       	movw	r30, r24
    257a:	20 83       	st	Z, r18
	pxTopOfStack--;
    257c:	8b 81       	ldd	r24, Y+3	; 0x03
    257e:	9c 81       	ldd	r25, Y+4	; 0x04
    2580:	01 97       	sbiw	r24, 0x01	; 1
    2582:	9c 83       	std	Y+4, r25	; 0x04
    2584:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2586:	8b 81       	ldd	r24, Y+3	; 0x03
    2588:	9c 81       	ldd	r25, Y+4	; 0x04
}
    258a:	28 96       	adiw	r28, 0x08	; 8
    258c:	0f b6       	in	r0, 0x3f	; 63
    258e:	f8 94       	cli
    2590:	de bf       	out	0x3e, r29	; 62
    2592:	0f be       	out	0x3f, r0	; 63
    2594:	cd bf       	out	0x3d, r28	; 61
    2596:	df 91       	pop	r29
    2598:	cf 91       	pop	r28
    259a:	08 95       	ret

0000259c <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    259c:	cf 93       	push	r28
    259e:	df 93       	push	r29
    25a0:	cd b7       	in	r28, 0x3d	; 61
    25a2:	de b7       	in	r29, 0x3e	; 62

	/* Setup the relevant timer hardware to generate the tick. */
	prvSetupTimerInterrupt();
    25a4:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    25a8:	a0 91 42 02 	lds	r26, 0x0242
    25ac:	b0 91 43 02 	lds	r27, 0x0243
    25b0:	cd 91       	ld	r28, X+
    25b2:	cd bf       	out	0x3d, r28	; 61
    25b4:	dd 91       	ld	r29, X+
    25b6:	de bf       	out	0x3e, r29	; 62
    25b8:	ff 91       	pop	r31
    25ba:	ef 91       	pop	r30
    25bc:	df 91       	pop	r29
    25be:	cf 91       	pop	r28
    25c0:	bf 91       	pop	r27
    25c2:	af 91       	pop	r26
    25c4:	9f 91       	pop	r25
    25c6:	8f 91       	pop	r24
    25c8:	7f 91       	pop	r23
    25ca:	6f 91       	pop	r22
    25cc:	5f 91       	pop	r21
    25ce:	4f 91       	pop	r20
    25d0:	3f 91       	pop	r19
    25d2:	2f 91       	pop	r18
    25d4:	1f 91       	pop	r17
    25d6:	0f 91       	pop	r16
    25d8:	ff 90       	pop	r15
    25da:	ef 90       	pop	r14
    25dc:	df 90       	pop	r13
    25de:	cf 90       	pop	r12
    25e0:	bf 90       	pop	r11
    25e2:	af 90       	pop	r10
    25e4:	9f 90       	pop	r9
    25e6:	8f 90       	pop	r8
    25e8:	7f 90       	pop	r7
    25ea:	6f 90       	pop	r6
    25ec:	5f 90       	pop	r5
    25ee:	4f 90       	pop	r4
    25f0:	3f 90       	pop	r3
    25f2:	2f 90       	pop	r2
    25f4:	1f 90       	pop	r1
    25f6:	0f 90       	pop	r0
    25f8:	0c be       	out	0x3c, r0	; 60
    25fa:	0f 90       	pop	r0
    25fc:	0b be       	out	0x3b, r0	; 59
    25fe:	0f 90       	pop	r0
    2600:	0f be       	out	0x3f, r0	; 63
    2602:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	__asm__ __volatile__ ( "ret" );
    2604:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2606:	81 e0       	ldi	r24, 0x01	; 1
}
    2608:	df 91       	pop	r29
    260a:	cf 91       	pop	r28
    260c:	08 95       	ret

0000260e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    260e:	cf 93       	push	r28
    2610:	df 93       	push	r29
    2612:	cd b7       	in	r28, 0x3d	; 61
    2614:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */

	wdt_disable();											// disable Watchdog Timer
    2616:	88 e1       	ldi	r24, 0x18	; 24
    2618:	0f b6       	in	r0, 0x3f	; 63
    261a:	f8 94       	cli
    261c:	80 93 60 00 	sts	0x0060, r24
    2620:	10 92 60 00 	sts	0x0060, r1
    2624:	0f be       	out	0x3f, r0	; 63
}
    2626:	df 91       	pop	r29
    2628:	cf 91       	pop	r28
    262a:	08 95       	ret

0000262c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    262c:	0f 92       	push	r0
    262e:	0f b6       	in	r0, 0x3f	; 63
    2630:	f8 94       	cli
    2632:	0f 92       	push	r0
    2634:	0b b6       	in	r0, 0x3b	; 59
    2636:	0f 92       	push	r0
    2638:	0c b6       	in	r0, 0x3c	; 60
    263a:	0f 92       	push	r0
    263c:	1f 92       	push	r1
    263e:	11 24       	eor	r1, r1
    2640:	2f 92       	push	r2
    2642:	3f 92       	push	r3
    2644:	4f 92       	push	r4
    2646:	5f 92       	push	r5
    2648:	6f 92       	push	r6
    264a:	7f 92       	push	r7
    264c:	8f 92       	push	r8
    264e:	9f 92       	push	r9
    2650:	af 92       	push	r10
    2652:	bf 92       	push	r11
    2654:	cf 92       	push	r12
    2656:	df 92       	push	r13
    2658:	ef 92       	push	r14
    265a:	ff 92       	push	r15
    265c:	0f 93       	push	r16
    265e:	1f 93       	push	r17
    2660:	2f 93       	push	r18
    2662:	3f 93       	push	r19
    2664:	4f 93       	push	r20
    2666:	5f 93       	push	r21
    2668:	6f 93       	push	r22
    266a:	7f 93       	push	r23
    266c:	8f 93       	push	r24
    266e:	9f 93       	push	r25
    2670:	af 93       	push	r26
    2672:	bf 93       	push	r27
    2674:	cf 93       	push	r28
    2676:	df 93       	push	r29
    2678:	ef 93       	push	r30
    267a:	ff 93       	push	r31
    267c:	a0 91 42 02 	lds	r26, 0x0242
    2680:	b0 91 43 02 	lds	r27, 0x0243
    2684:	0d b6       	in	r0, 0x3d	; 61
    2686:	0d 92       	st	X+, r0
    2688:	0e b6       	in	r0, 0x3e	; 62
    268a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    268c:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2690:	a0 91 42 02 	lds	r26, 0x0242
    2694:	b0 91 43 02 	lds	r27, 0x0243
    2698:	cd 91       	ld	r28, X+
    269a:	cd bf       	out	0x3d, r28	; 61
    269c:	dd 91       	ld	r29, X+
    269e:	de bf       	out	0x3e, r29	; 62
    26a0:	ff 91       	pop	r31
    26a2:	ef 91       	pop	r30
    26a4:	df 91       	pop	r29
    26a6:	cf 91       	pop	r28
    26a8:	bf 91       	pop	r27
    26aa:	af 91       	pop	r26
    26ac:	9f 91       	pop	r25
    26ae:	8f 91       	pop	r24
    26b0:	7f 91       	pop	r23
    26b2:	6f 91       	pop	r22
    26b4:	5f 91       	pop	r21
    26b6:	4f 91       	pop	r20
    26b8:	3f 91       	pop	r19
    26ba:	2f 91       	pop	r18
    26bc:	1f 91       	pop	r17
    26be:	0f 91       	pop	r16
    26c0:	ff 90       	pop	r15
    26c2:	ef 90       	pop	r14
    26c4:	df 90       	pop	r13
    26c6:	cf 90       	pop	r12
    26c8:	bf 90       	pop	r11
    26ca:	af 90       	pop	r10
    26cc:	9f 90       	pop	r9
    26ce:	8f 90       	pop	r8
    26d0:	7f 90       	pop	r7
    26d2:	6f 90       	pop	r6
    26d4:	5f 90       	pop	r5
    26d6:	4f 90       	pop	r4
    26d8:	3f 90       	pop	r3
    26da:	2f 90       	pop	r2
    26dc:	1f 90       	pop	r1
    26de:	0f 90       	pop	r0
    26e0:	0c be       	out	0x3c, r0	; 60
    26e2:	0f 90       	pop	r0
    26e4:	0b be       	out	0x3b, r0	; 59
    26e6:	0f 90       	pop	r0
    26e8:	0f be       	out	0x3f, r0	; 63
    26ea:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    26ec:	08 95       	ret

000026ee <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    26ee:	0f 92       	push	r0
    26f0:	0f b6       	in	r0, 0x3f	; 63
    26f2:	f8 94       	cli
    26f4:	0f 92       	push	r0
    26f6:	0b b6       	in	r0, 0x3b	; 59
    26f8:	0f 92       	push	r0
    26fa:	0c b6       	in	r0, 0x3c	; 60
    26fc:	0f 92       	push	r0
    26fe:	1f 92       	push	r1
    2700:	11 24       	eor	r1, r1
    2702:	2f 92       	push	r2
    2704:	3f 92       	push	r3
    2706:	4f 92       	push	r4
    2708:	5f 92       	push	r5
    270a:	6f 92       	push	r6
    270c:	7f 92       	push	r7
    270e:	8f 92       	push	r8
    2710:	9f 92       	push	r9
    2712:	af 92       	push	r10
    2714:	bf 92       	push	r11
    2716:	cf 92       	push	r12
    2718:	df 92       	push	r13
    271a:	ef 92       	push	r14
    271c:	ff 92       	push	r15
    271e:	0f 93       	push	r16
    2720:	1f 93       	push	r17
    2722:	2f 93       	push	r18
    2724:	3f 93       	push	r19
    2726:	4f 93       	push	r20
    2728:	5f 93       	push	r21
    272a:	6f 93       	push	r22
    272c:	7f 93       	push	r23
    272e:	8f 93       	push	r24
    2730:	9f 93       	push	r25
    2732:	af 93       	push	r26
    2734:	bf 93       	push	r27
    2736:	cf 93       	push	r28
    2738:	df 93       	push	r29
    273a:	ef 93       	push	r30
    273c:	ff 93       	push	r31
    273e:	a0 91 42 02 	lds	r26, 0x0242
    2742:	b0 91 43 02 	lds	r27, 0x0243
    2746:	0d b6       	in	r0, 0x3d	; 61
    2748:	0d 92       	st	X+, r0
    274a:	0e b6       	in	r0, 0x3e	; 62
    274c:	0d 92       	st	X+, r0

	if( xTaskIncrementTick() != pdFALSE )
    274e:	0e 94 e1 20 	call	0x41c2	; 0x41c2 <xTaskIncrementTick>
    2752:	88 23       	and	r24, r24
    2754:	11 f0       	breq	.+4      	; 0x275a <vPortYieldFromTick+0x6c>
	{
		vTaskSwitchContext();
    2756:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
    275a:	a0 91 42 02 	lds	r26, 0x0242
    275e:	b0 91 43 02 	lds	r27, 0x0243
    2762:	cd 91       	ld	r28, X+
    2764:	cd bf       	out	0x3d, r28	; 61
    2766:	dd 91       	ld	r29, X+
    2768:	de bf       	out	0x3e, r29	; 62
    276a:	ff 91       	pop	r31
    276c:	ef 91       	pop	r30
    276e:	df 91       	pop	r29
    2770:	cf 91       	pop	r28
    2772:	bf 91       	pop	r27
    2774:	af 91       	pop	r26
    2776:	9f 91       	pop	r25
    2778:	8f 91       	pop	r24
    277a:	7f 91       	pop	r23
    277c:	6f 91       	pop	r22
    277e:	5f 91       	pop	r21
    2780:	4f 91       	pop	r20
    2782:	3f 91       	pop	r19
    2784:	2f 91       	pop	r18
    2786:	1f 91       	pop	r17
    2788:	0f 91       	pop	r16
    278a:	ff 90       	pop	r15
    278c:	ef 90       	pop	r14
    278e:	df 90       	pop	r13
    2790:	cf 90       	pop	r12
    2792:	bf 90       	pop	r11
    2794:	af 90       	pop	r10
    2796:	9f 90       	pop	r9
    2798:	8f 90       	pop	r8
    279a:	7f 90       	pop	r7
    279c:	6f 90       	pop	r6
    279e:	5f 90       	pop	r5
    27a0:	4f 90       	pop	r4
    27a2:	3f 90       	pop	r3
    27a4:	2f 90       	pop	r2
    27a6:	1f 90       	pop	r1
    27a8:	0f 90       	pop	r0
    27aa:	0c be       	out	0x3c, r0	; 60
    27ac:	0f 90       	pop	r0
    27ae:	0b be       	out	0x3b, r0	; 59
    27b0:	0f 90       	pop	r0
    27b2:	0f be       	out	0x3f, r0	; 63
    27b4:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    27b6:	08 95       	ret

000027b8 <prvSetupTimerInterrupt>:
}
/*-----------------------------------------------------------*/

//initialize watchdog
void prvSetupTimerInterrupt( void )
{
    27b8:	cf 93       	push	r28
    27ba:	df 93       	push	r29
    27bc:	cd b7       	in	r28, 0x3d	; 61
    27be:	de b7       	in	r29, 0x3e	; 62
	//reset watchdog
	wdt_reset();
    27c0:	a8 95       	wdr

	//set up WDT Interrupt (rather than the WDT Reset).
	wdt_interrupt_enable( portUSE_WDTO );
    27c2:	88 e1       	ldi	r24, 0x18	; 24
    27c4:	90 e0       	ldi	r25, 0x00	; 0
    27c6:	20 ec       	ldi	r18, 0xC0	; 192
    27c8:	0f b6       	in	r0, 0x3f	; 63
    27ca:	f8 94       	cli
    27cc:	a8 95       	wdr
    27ce:	80 93 60 00 	sts	0x0060, r24
    27d2:	0f be       	out	0x3f, r0	; 63
    27d4:	20 93 60 00 	sts	0x0060, r18
}
    27d8:	df 91       	pop	r29
    27da:	cf 91       	pop	r28
    27dc:	08 95       	ret

000027de <__vector_12>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED)
	{
		vPortYieldFromTick();
    27de:	0e 94 77 13 	call	0x26ee	; 0x26ee <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    27e2:	18 95       	reti

000027e4 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    27e4:	cf 93       	push	r28
    27e6:	df 93       	push	r29
    27e8:	00 d0       	rcall	.+0      	; 0x27ea <xQueueGenericReset+0x6>
    27ea:	1f 92       	push	r1
    27ec:	1f 92       	push	r1
    27ee:	cd b7       	in	r28, 0x3d	; 61
    27f0:	de b7       	in	r29, 0x3e	; 62
    27f2:	9c 83       	std	Y+4, r25	; 0x04
    27f4:	8b 83       	std	Y+3, r24	; 0x03
    27f6:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    27f8:	8b 81       	ldd	r24, Y+3	; 0x03
    27fa:	9c 81       	ldd	r25, Y+4	; 0x04
    27fc:	9a 83       	std	Y+2, r25	; 0x02
    27fe:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2800:	0f b6       	in	r0, 0x3f	; 63
    2802:	f8 94       	cli
    2804:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    2806:	89 81       	ldd	r24, Y+1	; 0x01
    2808:	9a 81       	ldd	r25, Y+2	; 0x02
    280a:	fc 01       	movw	r30, r24
    280c:	20 81       	ld	r18, Z
    280e:	31 81       	ldd	r19, Z+1	; 0x01
    2810:	89 81       	ldd	r24, Y+1	; 0x01
    2812:	9a 81       	ldd	r25, Y+2	; 0x02
    2814:	fc 01       	movw	r30, r24
    2816:	83 8d       	ldd	r24, Z+27	; 0x1b
    2818:	68 2f       	mov	r22, r24
    281a:	70 e0       	ldi	r23, 0x00	; 0
    281c:	89 81       	ldd	r24, Y+1	; 0x01
    281e:	9a 81       	ldd	r25, Y+2	; 0x02
    2820:	fc 01       	movw	r30, r24
    2822:	84 8d       	ldd	r24, Z+28	; 0x1c
    2824:	48 2f       	mov	r20, r24
    2826:	50 e0       	ldi	r21, 0x00	; 0
    2828:	64 9f       	mul	r22, r20
    282a:	c0 01       	movw	r24, r0
    282c:	65 9f       	mul	r22, r21
    282e:	90 0d       	add	r25, r0
    2830:	74 9f       	mul	r23, r20
    2832:	90 0d       	add	r25, r0
    2834:	11 24       	eor	r1, r1
    2836:	28 0f       	add	r18, r24
    2838:	39 1f       	adc	r19, r25
    283a:	89 81       	ldd	r24, Y+1	; 0x01
    283c:	9a 81       	ldd	r25, Y+2	; 0x02
    283e:	fc 01       	movw	r30, r24
    2840:	33 83       	std	Z+3, r19	; 0x03
    2842:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2844:	89 81       	ldd	r24, Y+1	; 0x01
    2846:	9a 81       	ldd	r25, Y+2	; 0x02
    2848:	fc 01       	movw	r30, r24
    284a:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    284c:	89 81       	ldd	r24, Y+1	; 0x01
    284e:	9a 81       	ldd	r25, Y+2	; 0x02
    2850:	fc 01       	movw	r30, r24
    2852:	20 81       	ld	r18, Z
    2854:	31 81       	ldd	r19, Z+1	; 0x01
    2856:	89 81       	ldd	r24, Y+1	; 0x01
    2858:	9a 81       	ldd	r25, Y+2	; 0x02
    285a:	fc 01       	movw	r30, r24
    285c:	35 83       	std	Z+5, r19	; 0x05
    285e:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    2860:	89 81       	ldd	r24, Y+1	; 0x01
    2862:	9a 81       	ldd	r25, Y+2	; 0x02
    2864:	fc 01       	movw	r30, r24
    2866:	20 81       	ld	r18, Z
    2868:	31 81       	ldd	r19, Z+1	; 0x01
    286a:	89 81       	ldd	r24, Y+1	; 0x01
    286c:	9a 81       	ldd	r25, Y+2	; 0x02
    286e:	fc 01       	movw	r30, r24
    2870:	83 8d       	ldd	r24, Z+27	; 0x1b
    2872:	88 2f       	mov	r24, r24
    2874:	90 e0       	ldi	r25, 0x00	; 0
    2876:	bc 01       	movw	r22, r24
    2878:	61 50       	subi	r22, 0x01	; 1
    287a:	71 09       	sbc	r23, r1
    287c:	89 81       	ldd	r24, Y+1	; 0x01
    287e:	9a 81       	ldd	r25, Y+2	; 0x02
    2880:	fc 01       	movw	r30, r24
    2882:	84 8d       	ldd	r24, Z+28	; 0x1c
    2884:	48 2f       	mov	r20, r24
    2886:	50 e0       	ldi	r21, 0x00	; 0
    2888:	64 9f       	mul	r22, r20
    288a:	c0 01       	movw	r24, r0
    288c:	65 9f       	mul	r22, r21
    288e:	90 0d       	add	r25, r0
    2890:	74 9f       	mul	r23, r20
    2892:	90 0d       	add	r25, r0
    2894:	11 24       	eor	r1, r1
    2896:	28 0f       	add	r18, r24
    2898:	39 1f       	adc	r19, r25
    289a:	89 81       	ldd	r24, Y+1	; 0x01
    289c:	9a 81       	ldd	r25, Y+2	; 0x02
    289e:	fc 01       	movw	r30, r24
    28a0:	37 83       	std	Z+7, r19	; 0x07
    28a2:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    28a4:	89 81       	ldd	r24, Y+1	; 0x01
    28a6:	9a 81       	ldd	r25, Y+2	; 0x02
    28a8:	2f ef       	ldi	r18, 0xFF	; 255
    28aa:	fc 01       	movw	r30, r24
    28ac:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    28ae:	89 81       	ldd	r24, Y+1	; 0x01
    28b0:	9a 81       	ldd	r25, Y+2	; 0x02
    28b2:	2f ef       	ldi	r18, 0xFF	; 255
    28b4:	fc 01       	movw	r30, r24
    28b6:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    28b8:	8d 81       	ldd	r24, Y+5	; 0x05
    28ba:	88 23       	and	r24, r24
    28bc:	81 f4       	brne	.+32     	; 0x28de <xQueueGenericReset+0xfa>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    28be:	89 81       	ldd	r24, Y+1	; 0x01
    28c0:	9a 81       	ldd	r25, Y+2	; 0x02
    28c2:	fc 01       	movw	r30, r24
    28c4:	80 85       	ldd	r24, Z+8	; 0x08
    28c6:	88 23       	and	r24, r24
    28c8:	a1 f0       	breq	.+40     	; 0x28f2 <xQueueGenericReset+0x10e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    28ca:	89 81       	ldd	r24, Y+1	; 0x01
    28cc:	9a 81       	ldd	r25, Y+2	; 0x02
    28ce:	08 96       	adiw	r24, 0x08	; 8
    28d0:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <xTaskRemoveFromEventList>
    28d4:	81 30       	cpi	r24, 0x01	; 1
    28d6:	69 f4       	brne	.+26     	; 0x28f2 <xQueueGenericReset+0x10e>
				{
					queueYIELD_IF_USING_PREEMPTION();
    28d8:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
    28dc:	0a c0       	rjmp	.+20     	; 0x28f2 <xQueueGenericReset+0x10e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    28de:	89 81       	ldd	r24, Y+1	; 0x01
    28e0:	9a 81       	ldd	r25, Y+2	; 0x02
    28e2:	08 96       	adiw	r24, 0x08	; 8
    28e4:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    28e8:	89 81       	ldd	r24, Y+1	; 0x01
    28ea:	9a 81       	ldd	r25, Y+2	; 0x02
    28ec:	41 96       	adiw	r24, 0x11	; 17
    28ee:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    28f2:	0f 90       	pop	r0
    28f4:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    28f6:	81 e0       	ldi	r24, 0x01	; 1
}
    28f8:	0f 90       	pop	r0
    28fa:	0f 90       	pop	r0
    28fc:	0f 90       	pop	r0
    28fe:	0f 90       	pop	r0
    2900:	0f 90       	pop	r0
    2902:	df 91       	pop	r29
    2904:	cf 91       	pop	r28
    2906:	08 95       	ret

00002908 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    2908:	cf 93       	push	r28
    290a:	df 93       	push	r29
    290c:	cd b7       	in	r28, 0x3d	; 61
    290e:	de b7       	in	r29, 0x3e	; 62
    2910:	29 97       	sbiw	r28, 0x09	; 9
    2912:	0f b6       	in	r0, 0x3f	; 63
    2914:	f8 94       	cli
    2916:	de bf       	out	0x3e, r29	; 62
    2918:	0f be       	out	0x3f, r0	; 63
    291a:	cd bf       	out	0x3d, r28	; 61
    291c:	8f 83       	std	Y+7, r24	; 0x07
    291e:	68 87       	std	Y+8, r22	; 0x08
    2920:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    2922:	1c 82       	std	Y+4, r1	; 0x04
    2924:	1b 82       	std	Y+3, r1	; 0x03
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
    2926:	88 85       	ldd	r24, Y+8	; 0x08
    2928:	88 23       	and	r24, r24
    292a:	19 f4       	brne	.+6      	; 0x2932 <xQueueGenericCreate+0x2a>
	{
		/* There is not going to be a queue storage area. */
		xQueueSizeInBytes = ( size_t ) 0;
    292c:	1a 82       	std	Y+2, r1	; 0x02
    292e:	19 82       	std	Y+1, r1	; 0x01
    2930:	10 c0       	rjmp	.+32     	; 0x2952 <xQueueGenericCreate+0x4a>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    2932:	8f 81       	ldd	r24, Y+7	; 0x07
    2934:	48 2f       	mov	r20, r24
    2936:	50 e0       	ldi	r21, 0x00	; 0
    2938:	88 85       	ldd	r24, Y+8	; 0x08
    293a:	28 2f       	mov	r18, r24
    293c:	30 e0       	ldi	r19, 0x00	; 0
    293e:	42 9f       	mul	r20, r18
    2940:	c0 01       	movw	r24, r0
    2942:	43 9f       	mul	r20, r19
    2944:	90 0d       	add	r25, r0
    2946:	52 9f       	mul	r21, r18
    2948:	90 0d       	add	r25, r0
    294a:	11 24       	eor	r1, r1
    294c:	01 96       	adiw	r24, 0x01	; 1
    294e:	9a 83       	std	Y+2, r25	; 0x02
    2950:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    2952:	89 81       	ldd	r24, Y+1	; 0x01
    2954:	9a 81       	ldd	r25, Y+2	; 0x02
    2956:	4f 96       	adiw	r24, 0x1f	; 31
    2958:	0e 94 3b 0c 	call	0x1876	; 0x1876 <pvPortMalloc>
    295c:	9e 83       	std	Y+6, r25	; 0x06
    295e:	8d 83       	std	Y+5, r24	; 0x05

	if( pxNewQueue != NULL )
    2960:	8d 81       	ldd	r24, Y+5	; 0x05
    2962:	9e 81       	ldd	r25, Y+6	; 0x06
    2964:	00 97       	sbiw	r24, 0x00	; 0
    2966:	41 f1       	breq	.+80     	; 0x29b8 <xQueueGenericCreate+0xb0>
	{
		if( uxItemSize == ( UBaseType_t ) 0 )
    2968:	88 85       	ldd	r24, Y+8	; 0x08
    296a:	88 23       	and	r24, r24
    296c:	41 f4       	brne	.+16     	; 0x297e <xQueueGenericCreate+0x76>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    296e:	8d 81       	ldd	r24, Y+5	; 0x05
    2970:	9e 81       	ldd	r25, Y+6	; 0x06
    2972:	2d 81       	ldd	r18, Y+5	; 0x05
    2974:	3e 81       	ldd	r19, Y+6	; 0x06
    2976:	fc 01       	movw	r30, r24
    2978:	31 83       	std	Z+1, r19	; 0x01
    297a:	20 83       	st	Z, r18
    297c:	0a c0       	rjmp	.+20     	; 0x2992 <xQueueGenericCreate+0x8a>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
    297e:	8d 81       	ldd	r24, Y+5	; 0x05
    2980:	9e 81       	ldd	r25, Y+6	; 0x06
    2982:	9c 01       	movw	r18, r24
    2984:	21 5e       	subi	r18, 0xE1	; 225
    2986:	3f 4f       	sbci	r19, 0xFF	; 255
    2988:	8d 81       	ldd	r24, Y+5	; 0x05
    298a:	9e 81       	ldd	r25, Y+6	; 0x06
    298c:	fc 01       	movw	r30, r24
    298e:	31 83       	std	Z+1, r19	; 0x01
    2990:	20 83       	st	Z, r18
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
    2992:	8d 81       	ldd	r24, Y+5	; 0x05
    2994:	9e 81       	ldd	r25, Y+6	; 0x06
    2996:	2f 81       	ldd	r18, Y+7	; 0x07
    2998:	fc 01       	movw	r30, r24
    299a:	23 8f       	std	Z+27, r18	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
    299c:	8d 81       	ldd	r24, Y+5	; 0x05
    299e:	9e 81       	ldd	r25, Y+6	; 0x06
    29a0:	28 85       	ldd	r18, Y+8	; 0x08
    29a2:	fc 01       	movw	r30, r24
    29a4:	24 8f       	std	Z+28, r18	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    29a6:	8d 81       	ldd	r24, Y+5	; 0x05
    29a8:	9e 81       	ldd	r25, Y+6	; 0x06
    29aa:	61 e0       	ldi	r22, 0x01	; 1
    29ac:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <xQueueGenericReset>
			pxNewQueue->pxQueueSetContainer = NULL;
		}
		#endif /* configUSE_QUEUE_SETS */

		traceQUEUE_CREATE( pxNewQueue );
		xReturn = pxNewQueue;
    29b0:	8d 81       	ldd	r24, Y+5	; 0x05
    29b2:	9e 81       	ldd	r25, Y+6	; 0x06
    29b4:	9c 83       	std	Y+4, r25	; 0x04
    29b6:	8b 83       	std	Y+3, r24	; 0x03
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    29b8:	8b 81       	ldd	r24, Y+3	; 0x03
    29ba:	9c 81       	ldd	r25, Y+4	; 0x04
}
    29bc:	29 96       	adiw	r28, 0x09	; 9
    29be:	0f b6       	in	r0, 0x3f	; 63
    29c0:	f8 94       	cli
    29c2:	de bf       	out	0x3e, r29	; 62
    29c4:	0f be       	out	0x3f, r0	; 63
    29c6:	cd bf       	out	0x3d, r28	; 61
    29c8:	df 91       	pop	r29
    29ca:	cf 91       	pop	r28
    29cc:	08 95       	ret

000029ce <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    29ce:	cf 93       	push	r28
    29d0:	df 93       	push	r29
    29d2:	00 d0       	rcall	.+0      	; 0x29d4 <xQueueCreateMutex+0x6>
    29d4:	cd b7       	in	r28, 0x3d	; 61
    29d6:	de b7       	in	r29, 0x3e	; 62
    29d8:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    29da:	8f e1       	ldi	r24, 0x1F	; 31
    29dc:	90 e0       	ldi	r25, 0x00	; 0
    29de:	0e 94 3b 0c 	call	0x1876	; 0x1876 <pvPortMalloc>
    29e2:	9a 83       	std	Y+2, r25	; 0x02
    29e4:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    29e6:	89 81       	ldd	r24, Y+1	; 0x01
    29e8:	9a 81       	ldd	r25, Y+2	; 0x02
    29ea:	00 97       	sbiw	r24, 0x00	; 0
    29ec:	d9 f1       	breq	.+118    	; 0x2a64 <xQueueCreateMutex+0x96>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    29ee:	89 81       	ldd	r24, Y+1	; 0x01
    29f0:	9a 81       	ldd	r25, Y+2	; 0x02
    29f2:	fc 01       	movw	r30, r24
    29f4:	13 82       	std	Z+3, r1	; 0x03
    29f6:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    29f8:	89 81       	ldd	r24, Y+1	; 0x01
    29fa:	9a 81       	ldd	r25, Y+2	; 0x02
    29fc:	fc 01       	movw	r30, r24
    29fe:	11 82       	std	Z+1, r1	; 0x01
    2a00:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    2a02:	89 81       	ldd	r24, Y+1	; 0x01
    2a04:	9a 81       	ldd	r25, Y+2	; 0x02
    2a06:	fc 01       	movw	r30, r24
    2a08:	15 82       	std	Z+5, r1	; 0x05
    2a0a:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    2a0c:	89 81       	ldd	r24, Y+1	; 0x01
    2a0e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a10:	fc 01       	movw	r30, r24
    2a12:	17 82       	std	Z+7, r1	; 0x07
    2a14:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2a16:	89 81       	ldd	r24, Y+1	; 0x01
    2a18:	9a 81       	ldd	r25, Y+2	; 0x02
    2a1a:	fc 01       	movw	r30, r24
    2a1c:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    2a1e:	89 81       	ldd	r24, Y+1	; 0x01
    2a20:	9a 81       	ldd	r25, Y+2	; 0x02
    2a22:	21 e0       	ldi	r18, 0x01	; 1
    2a24:	fc 01       	movw	r30, r24
    2a26:	23 8f       	std	Z+27, r18	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    2a28:	89 81       	ldd	r24, Y+1	; 0x01
    2a2a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a2c:	fc 01       	movw	r30, r24
    2a2e:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    2a30:	89 81       	ldd	r24, Y+1	; 0x01
    2a32:	9a 81       	ldd	r25, Y+2	; 0x02
    2a34:	2f ef       	ldi	r18, 0xFF	; 255
    2a36:	fc 01       	movw	r30, r24
    2a38:	25 8f       	std	Z+29, r18	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    2a3a:	89 81       	ldd	r24, Y+1	; 0x01
    2a3c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a3e:	2f ef       	ldi	r18, 0xFF	; 255
    2a40:	fc 01       	movw	r30, r24
    2a42:	26 8f       	std	Z+30, r18	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2a44:	89 81       	ldd	r24, Y+1	; 0x01
    2a46:	9a 81       	ldd	r25, Y+2	; 0x02
    2a48:	08 96       	adiw	r24, 0x08	; 8
    2a4a:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    2a4e:	89 81       	ldd	r24, Y+1	; 0x01
    2a50:	9a 81       	ldd	r25, Y+2	; 0x02
    2a52:	41 96       	adiw	r24, 0x11	; 17
    2a54:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			//( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
			( void ) xQueueGive( pxNewQueue, ( TickType_t ) 0U ); // xxx feilipu adjusted this.
    2a58:	89 81       	ldd	r24, Y+1	; 0x01
    2a5a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a5c:	60 e0       	ldi	r22, 0x00	; 0
    2a5e:	70 e0       	ldi	r23, 0x00	; 0
    2a60:	0e 94 ec 15 	call	0x2bd8	; 0x2bd8 <xQueueGive>
		else
		{
			traceCREATE_MUTEX_FAILED();
		}

		return pxNewQueue;
    2a64:	89 81       	ldd	r24, Y+1	; 0x01
    2a66:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    2a68:	0f 90       	pop	r0
    2a6a:	0f 90       	pop	r0
    2a6c:	0f 90       	pop	r0
    2a6e:	df 91       	pop	r29
    2a70:	cf 91       	pop	r28
    2a72:	08 95       	ret

00002a74 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2a74:	cf 93       	push	r28
    2a76:	df 93       	push	r29
    2a78:	cd b7       	in	r28, 0x3d	; 61
    2a7a:	de b7       	in	r29, 0x3e	; 62
    2a7c:	2e 97       	sbiw	r28, 0x0e	; 14
    2a7e:	0f b6       	in	r0, 0x3f	; 63
    2a80:	f8 94       	cli
    2a82:	de bf       	out	0x3e, r29	; 62
    2a84:	0f be       	out	0x3f, r0	; 63
    2a86:	cd bf       	out	0x3d, r28	; 61
    2a88:	99 87       	std	Y+9, r25	; 0x09
    2a8a:	88 87       	std	Y+8, r24	; 0x08
    2a8c:	7b 87       	std	Y+11, r23	; 0x0b
    2a8e:	6a 87       	std	Y+10, r22	; 0x0a
    2a90:	5d 87       	std	Y+13, r21	; 0x0d
    2a92:	4c 87       	std	Y+12, r20	; 0x0c
    2a94:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2a96:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2a98:	88 85       	ldd	r24, Y+8	; 0x08
    2a9a:	99 85       	ldd	r25, Y+9	; 0x09
    2a9c:	9b 83       	std	Y+3, r25	; 0x03
    2a9e:	8a 83       	std	Y+2, r24	; 0x02
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2aa0:	0f b6       	in	r0, 0x3f	; 63
    2aa2:	f8 94       	cli
    2aa4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2aa6:	8a 81       	ldd	r24, Y+2	; 0x02
    2aa8:	9b 81       	ldd	r25, Y+3	; 0x03
    2aaa:	fc 01       	movw	r30, r24
    2aac:	22 8d       	ldd	r18, Z+26	; 0x1a
    2aae:	8a 81       	ldd	r24, Y+2	; 0x02
    2ab0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ab2:	fc 01       	movw	r30, r24
    2ab4:	83 8d       	ldd	r24, Z+27	; 0x1b
    2ab6:	28 17       	cp	r18, r24
    2ab8:	18 f0       	brcs	.+6      	; 0x2ac0 <xQueueGenericSend+0x4c>
    2aba:	8e 85       	ldd	r24, Y+14	; 0x0e
    2abc:	82 30       	cpi	r24, 0x02	; 2
    2abe:	11 f5       	brne	.+68     	; 0x2b04 <xQueueGenericSend+0x90>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2ac0:	2a 85       	ldd	r18, Y+10	; 0x0a
    2ac2:	3b 85       	ldd	r19, Y+11	; 0x0b
    2ac4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ac6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ac8:	4e 85       	ldd	r20, Y+14	; 0x0e
    2aca:	b9 01       	movw	r22, r18
    2acc:	0e 94 61 19 	call	0x32c2	; 0x32c2 <prvCopyDataToQueue>
    2ad0:	8c 83       	std	Y+4, r24	; 0x04
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2ad2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ad4:	9b 81       	ldd	r25, Y+3	; 0x03
    2ad6:	fc 01       	movw	r30, r24
    2ad8:	81 89       	ldd	r24, Z+17	; 0x11
    2ada:	88 23       	and	r24, r24
    2adc:	51 f0       	breq	.+20     	; 0x2af2 <xQueueGenericSend+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2ade:	8a 81       	ldd	r24, Y+2	; 0x02
    2ae0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ae2:	41 96       	adiw	r24, 0x11	; 17
    2ae4:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <xTaskRemoveFromEventList>
    2ae8:	81 30       	cpi	r24, 0x01	; 1
    2aea:	41 f4       	brne	.+16     	; 0x2afc <xQueueGenericSend+0x88>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2aec:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
    2af0:	05 c0       	rjmp	.+10     	; 0x2afc <xQueueGenericSend+0x88>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2af2:	8c 81       	ldd	r24, Y+4	; 0x04
    2af4:	88 23       	and	r24, r24
    2af6:	11 f0       	breq	.+4      	; 0x2afc <xQueueGenericSend+0x88>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2af8:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2afc:	0f 90       	pop	r0
    2afe:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2b00:	81 e0       	ldi	r24, 0x01	; 1
    2b02:	61 c0       	rjmp	.+194    	; 0x2bc6 <xQueueGenericSend+0x152>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2b04:	8c 85       	ldd	r24, Y+12	; 0x0c
    2b06:	9d 85       	ldd	r25, Y+13	; 0x0d
    2b08:	00 97       	sbiw	r24, 0x00	; 0
    2b0a:	21 f4       	brne	.+8      	; 0x2b14 <xQueueGenericSend+0xa0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2b0c:	0f 90       	pop	r0
    2b0e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2b10:	80 e0       	ldi	r24, 0x00	; 0
    2b12:	59 c0       	rjmp	.+178    	; 0x2bc6 <xQueueGenericSend+0x152>
				}
				else if( xEntryTimeSet == pdFALSE )
    2b14:	89 81       	ldd	r24, Y+1	; 0x01
    2b16:	88 23       	and	r24, r24
    2b18:	31 f4       	brne	.+12     	; 0x2b26 <xQueueGenericSend+0xb2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2b1a:	ce 01       	movw	r24, r28
    2b1c:	05 96       	adiw	r24, 0x05	; 5
    2b1e:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2b22:	81 e0       	ldi	r24, 0x01	; 1
    2b24:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2b26:	0f 90       	pop	r0
    2b28:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2b2a:	0e 94 13 20 	call	0x4026	; 0x4026 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2b2e:	0f b6       	in	r0, 0x3f	; 63
    2b30:	f8 94       	cli
    2b32:	0f 92       	push	r0
    2b34:	8a 81       	ldd	r24, Y+2	; 0x02
    2b36:	9b 81       	ldd	r25, Y+3	; 0x03
    2b38:	fc 01       	movw	r30, r24
    2b3a:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b3c:	8f 3f       	cpi	r24, 0xFF	; 255
    2b3e:	21 f4       	brne	.+8      	; 0x2b48 <xQueueGenericSend+0xd4>
    2b40:	8a 81       	ldd	r24, Y+2	; 0x02
    2b42:	9b 81       	ldd	r25, Y+3	; 0x03
    2b44:	fc 01       	movw	r30, r24
    2b46:	15 8e       	std	Z+29, r1	; 0x1d
    2b48:	8a 81       	ldd	r24, Y+2	; 0x02
    2b4a:	9b 81       	ldd	r25, Y+3	; 0x03
    2b4c:	fc 01       	movw	r30, r24
    2b4e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b50:	8f 3f       	cpi	r24, 0xFF	; 255
    2b52:	21 f4       	brne	.+8      	; 0x2b5c <xQueueGenericSend+0xe8>
    2b54:	8a 81       	ldd	r24, Y+2	; 0x02
    2b56:	9b 81       	ldd	r25, Y+3	; 0x03
    2b58:	fc 01       	movw	r30, r24
    2b5a:	16 8e       	std	Z+30, r1	; 0x1e
    2b5c:	0f 90       	pop	r0
    2b5e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2b60:	9e 01       	movw	r18, r28
    2b62:	24 5f       	subi	r18, 0xF4	; 244
    2b64:	3f 4f       	sbci	r19, 0xFF	; 255
    2b66:	ce 01       	movw	r24, r28
    2b68:	05 96       	adiw	r24, 0x05	; 5
    2b6a:	b9 01       	movw	r22, r18
    2b6c:	0e 94 ed 23 	call	0x47da	; 0x47da <xTaskCheckForTimeOut>
    2b70:	88 23       	and	r24, r24
    2b72:	01 f5       	brne	.+64     	; 0x2bb4 <xQueueGenericSend+0x140>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2b74:	8a 81       	ldd	r24, Y+2	; 0x02
    2b76:	9b 81       	ldd	r25, Y+3	; 0x03
    2b78:	0e 94 1f 1b 	call	0x363e	; 0x363e <prvIsQueueFull>
    2b7c:	88 23       	and	r24, r24
    2b7e:	99 f0       	breq	.+38     	; 0x2ba6 <xQueueGenericSend+0x132>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2b80:	2c 85       	ldd	r18, Y+12	; 0x0c
    2b82:	3d 85       	ldd	r19, Y+13	; 0x0d
    2b84:	8a 81       	ldd	r24, Y+2	; 0x02
    2b86:	9b 81       	ldd	r25, Y+3	; 0x03
    2b88:	08 96       	adiw	r24, 0x08	; 8
    2b8a:	b9 01       	movw	r22, r18
    2b8c:	0e 94 5f 22 	call	0x44be	; 0x44be <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2b90:	8a 81       	ldd	r24, Y+2	; 0x02
    2b92:	9b 81       	ldd	r25, Y+3	; 0x03
    2b94:	0e 94 85 1a 	call	0x350a	; 0x350a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2b98:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>
    2b9c:	88 23       	and	r24, r24
    2b9e:	91 f4       	brne	.+36     	; 0x2bc4 <xQueueGenericSend+0x150>
				{
					portYIELD_WITHIN_API();
    2ba0:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
    2ba4:	0f c0       	rjmp	.+30     	; 0x2bc4 <xQueueGenericSend+0x150>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2ba6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ba8:	9b 81       	ldd	r25, Y+3	; 0x03
    2baa:	0e 94 85 1a 	call	0x350a	; 0x350a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2bae:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    2bb2:	76 cf       	rjmp	.-276    	; 0x2aa0 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2bb4:	8a 81       	ldd	r24, Y+2	; 0x02
    2bb6:	9b 81       	ldd	r25, Y+3	; 0x03
    2bb8:	0e 94 85 1a 	call	0x350a	; 0x350a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2bbc:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2bc0:	80 e0       	ldi	r24, 0x00	; 0
    2bc2:	01 c0       	rjmp	.+2      	; 0x2bc6 <xQueueGenericSend+0x152>
		}
	}
    2bc4:	6d cf       	rjmp	.-294    	; 0x2aa0 <xQueueGenericSend+0x2c>
}
    2bc6:	2e 96       	adiw	r28, 0x0e	; 14
    2bc8:	0f b6       	in	r0, 0x3f	; 63
    2bca:	f8 94       	cli
    2bcc:	de bf       	out	0x3e, r29	; 62
    2bce:	0f be       	out	0x3f, r0	; 63
    2bd0:	cd bf       	out	0x3d, r28	; 61
    2bd2:	df 91       	pop	r29
    2bd4:	cf 91       	pop	r28
    2bd6:	08 95       	ret

00002bd8 <xQueueGive>:
/*-----------------------------------------------------------*/

// xxx feilipu created xQueueGive() to parallel the xQueueGiveFromISR() function, new in v8.2.0
// Seems to work as expected. And has same performance improvement as quoted for xQueueGiveFromISR
BaseType_t xQueueGive( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    2bd8:	cf 93       	push	r28
    2bda:	df 93       	push	r29
    2bdc:	cd b7       	in	r28, 0x3d	; 61
    2bde:	de b7       	in	r29, 0x3e	; 62
    2be0:	2b 97       	sbiw	r28, 0x0b	; 11
    2be2:	0f b6       	in	r0, 0x3f	; 63
    2be4:	f8 94       	cli
    2be6:	de bf       	out	0x3e, r29	; 62
    2be8:	0f be       	out	0x3f, r0	; 63
    2bea:	cd bf       	out	0x3d, r28	; 61
    2bec:	99 87       	std	Y+9, r25	; 0x09
    2bee:	88 87       	std	Y+8, r24	; 0x08
    2bf0:	7b 87       	std	Y+11, r23	; 0x0b
    2bf2:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired = pdFALSE;
    2bf4:	19 82       	std	Y+1, r1	; 0x01
    2bf6:	1a 82       	std	Y+2, r1	; 0x02
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2bf8:	88 85       	ldd	r24, Y+8	; 0x08
    2bfa:	99 85       	ldd	r25, Y+9	; 0x09
    2bfc:	9c 83       	std	Y+4, r25	; 0x04
    2bfe:	8b 83       	std	Y+3, r24	; 0x03
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2c00:	0f b6       	in	r0, 0x3f	; 63
    2c02:	f8 94       	cli
    2c04:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2c06:	8b 81       	ldd	r24, Y+3	; 0x03
    2c08:	9c 81       	ldd	r25, Y+4	; 0x04
    2c0a:	fc 01       	movw	r30, r24
    2c0c:	22 8d       	ldd	r18, Z+26	; 0x1a
    2c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c10:	9c 81       	ldd	r25, Y+4	; 0x04
    2c12:	fc 01       	movw	r30, r24
    2c14:	83 8d       	ldd	r24, Z+27	; 0x1b
    2c16:	28 17       	cp	r18, r24
    2c18:	b8 f5       	brcc	.+110    	; 0x2c88 <xQueueGive+0xb0>
			{
				traceQUEUE_SEND( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2c1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c1c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c1e:	fc 01       	movw	r30, r24
    2c20:	80 81       	ld	r24, Z
    2c22:	91 81       	ldd	r25, Z+1	; 0x01
    2c24:	00 97       	sbiw	r24, 0x00	; 0
    2c26:	69 f4       	brne	.+26     	; 0x2c42 <xQueueGive+0x6a>
					{
						/* The mutex is no longer being held. */
						xYieldRequired = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    2c28:	8b 81       	ldd	r24, Y+3	; 0x03
    2c2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c2c:	fc 01       	movw	r30, r24
    2c2e:	82 81       	ldd	r24, Z+2	; 0x02
    2c30:	93 81       	ldd	r25, Z+3	; 0x03
    2c32:	0e 94 63 27 	call	0x4ec6	; 0x4ec6 <xTaskPriorityDisinherit>
    2c36:	8a 83       	std	Y+2, r24	; 0x02
						pxQueue->pxMutexHolder = NULL;
    2c38:	8b 81       	ldd	r24, Y+3	; 0x03
    2c3a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c3c:	fc 01       	movw	r30, r24
    2c3e:	13 82       	std	Z+3, r1	; 0x03
    2c40:	12 82       	std	Z+2, r1	; 0x02
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_MUTEXES */
				
				++( pxQueue->uxMessagesWaiting );
    2c42:	8b 81       	ldd	r24, Y+3	; 0x03
    2c44:	9c 81       	ldd	r25, Y+4	; 0x04
    2c46:	fc 01       	movw	r30, r24
    2c48:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c4a:	21 e0       	ldi	r18, 0x01	; 1
    2c4c:	28 0f       	add	r18, r24
    2c4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c50:	9c 81       	ldd	r25, Y+4	; 0x04
    2c52:	fc 01       	movw	r30, r24
    2c54:	22 8f       	std	Z+26, r18	; 0x1a
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2c56:	8b 81       	ldd	r24, Y+3	; 0x03
    2c58:	9c 81       	ldd	r25, Y+4	; 0x04
    2c5a:	fc 01       	movw	r30, r24
    2c5c:	81 89       	ldd	r24, Z+17	; 0x11
    2c5e:	88 23       	and	r24, r24
    2c60:	51 f0       	breq	.+20     	; 0x2c76 <xQueueGive+0x9e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2c62:	8b 81       	ldd	r24, Y+3	; 0x03
    2c64:	9c 81       	ldd	r25, Y+4	; 0x04
    2c66:	41 96       	adiw	r24, 0x11	; 17
    2c68:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <xTaskRemoveFromEventList>
    2c6c:	81 30       	cpi	r24, 0x01	; 1
    2c6e:	41 f4       	brne	.+16     	; 0x2c80 <xQueueGive+0xa8>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2c70:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
    2c74:	05 c0       	rjmp	.+10     	; 0x2c80 <xQueueGive+0xa8>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2c76:	8a 81       	ldd	r24, Y+2	; 0x02
    2c78:	88 23       	and	r24, r24
    2c7a:	11 f0       	breq	.+4      	; 0x2c80 <xQueueGive+0xa8>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2c7c:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2c80:	0f 90       	pop	r0
    2c82:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2c84:	81 e0       	ldi	r24, 0x01	; 1
    2c86:	61 c0       	rjmp	.+194    	; 0x2d4a <xQueueGive+0x172>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2c88:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c8a:	9b 85       	ldd	r25, Y+11	; 0x0b
    2c8c:	00 97       	sbiw	r24, 0x00	; 0
    2c8e:	21 f4       	brne	.+8      	; 0x2c98 <xQueueGive+0xc0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2c90:	0f 90       	pop	r0
    2c92:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2c94:	80 e0       	ldi	r24, 0x00	; 0
    2c96:	59 c0       	rjmp	.+178    	; 0x2d4a <xQueueGive+0x172>
				}
				else if( xEntryTimeSet == pdFALSE )
    2c98:	89 81       	ldd	r24, Y+1	; 0x01
    2c9a:	88 23       	and	r24, r24
    2c9c:	31 f4       	brne	.+12     	; 0x2caa <xQueueGive+0xd2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2c9e:	ce 01       	movw	r24, r28
    2ca0:	05 96       	adiw	r24, 0x05	; 5
    2ca2:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2ca6:	81 e0       	ldi	r24, 0x01	; 1
    2ca8:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2caa:	0f 90       	pop	r0
    2cac:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2cae:	0e 94 13 20 	call	0x4026	; 0x4026 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2cb2:	0f b6       	in	r0, 0x3f	; 63
    2cb4:	f8 94       	cli
    2cb6:	0f 92       	push	r0
    2cb8:	8b 81       	ldd	r24, Y+3	; 0x03
    2cba:	9c 81       	ldd	r25, Y+4	; 0x04
    2cbc:	fc 01       	movw	r30, r24
    2cbe:	85 8d       	ldd	r24, Z+29	; 0x1d
    2cc0:	8f 3f       	cpi	r24, 0xFF	; 255
    2cc2:	21 f4       	brne	.+8      	; 0x2ccc <xQueueGive+0xf4>
    2cc4:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc6:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc8:	fc 01       	movw	r30, r24
    2cca:	15 8e       	std	Z+29, r1	; 0x1d
    2ccc:	8b 81       	ldd	r24, Y+3	; 0x03
    2cce:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd0:	fc 01       	movw	r30, r24
    2cd2:	86 8d       	ldd	r24, Z+30	; 0x1e
    2cd4:	8f 3f       	cpi	r24, 0xFF	; 255
    2cd6:	21 f4       	brne	.+8      	; 0x2ce0 <xQueueGive+0x108>
    2cd8:	8b 81       	ldd	r24, Y+3	; 0x03
    2cda:	9c 81       	ldd	r25, Y+4	; 0x04
    2cdc:	fc 01       	movw	r30, r24
    2cde:	16 8e       	std	Z+30, r1	; 0x1e
    2ce0:	0f 90       	pop	r0
    2ce2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2ce4:	9e 01       	movw	r18, r28
    2ce6:	26 5f       	subi	r18, 0xF6	; 246
    2ce8:	3f 4f       	sbci	r19, 0xFF	; 255
    2cea:	ce 01       	movw	r24, r28
    2cec:	05 96       	adiw	r24, 0x05	; 5
    2cee:	b9 01       	movw	r22, r18
    2cf0:	0e 94 ed 23 	call	0x47da	; 0x47da <xTaskCheckForTimeOut>
    2cf4:	88 23       	and	r24, r24
    2cf6:	01 f5       	brne	.+64     	; 0x2d38 <xQueueGive+0x160>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2cf8:	8b 81       	ldd	r24, Y+3	; 0x03
    2cfa:	9c 81       	ldd	r25, Y+4	; 0x04
    2cfc:	0e 94 1f 1b 	call	0x363e	; 0x363e <prvIsQueueFull>
    2d00:	88 23       	and	r24, r24
    2d02:	99 f0       	breq	.+38     	; 0x2d2a <xQueueGive+0x152>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2d04:	2a 85       	ldd	r18, Y+10	; 0x0a
    2d06:	3b 85       	ldd	r19, Y+11	; 0x0b
    2d08:	8b 81       	ldd	r24, Y+3	; 0x03
    2d0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d0c:	08 96       	adiw	r24, 0x08	; 8
    2d0e:	b9 01       	movw	r22, r18
    2d10:	0e 94 5f 22 	call	0x44be	; 0x44be <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2d14:	8b 81       	ldd	r24, Y+3	; 0x03
    2d16:	9c 81       	ldd	r25, Y+4	; 0x04
    2d18:	0e 94 85 1a 	call	0x350a	; 0x350a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2d1c:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>
    2d20:	88 23       	and	r24, r24
    2d22:	91 f4       	brne	.+36     	; 0x2d48 <xQueueGive+0x170>
				{
					portYIELD_WITHIN_API();
    2d24:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
    2d28:	0f c0       	rjmp	.+30     	; 0x2d48 <xQueueGive+0x170>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2d2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d2e:	0e 94 85 1a 	call	0x350a	; 0x350a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2d32:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    2d36:	64 cf       	rjmp	.-312    	; 0x2c00 <xQueueGive+0x28>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2d38:	8b 81       	ldd	r24, Y+3	; 0x03
    2d3a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d3c:	0e 94 85 1a 	call	0x350a	; 0x350a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2d40:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2d44:	80 e0       	ldi	r24, 0x00	; 0
    2d46:	01 c0       	rjmp	.+2      	; 0x2d4a <xQueueGive+0x172>
		}
	}
    2d48:	5b cf       	rjmp	.-330    	; 0x2c00 <xQueueGive+0x28>
}
    2d4a:	2b 96       	adiw	r28, 0x0b	; 11
    2d4c:	0f b6       	in	r0, 0x3f	; 63
    2d4e:	f8 94       	cli
    2d50:	de bf       	out	0x3e, r29	; 62
    2d52:	0f be       	out	0x3f, r0	; 63
    2d54:	cd bf       	out	0x3d, r28	; 61
    2d56:	df 91       	pop	r29
    2d58:	cf 91       	pop	r28
    2d5a:	08 95       	ret

00002d5c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    2d5c:	cf 93       	push	r28
    2d5e:	df 93       	push	r29
    2d60:	cd b7       	in	r28, 0x3d	; 61
    2d62:	de b7       	in	r29, 0x3e	; 62
    2d64:	2b 97       	sbiw	r28, 0x0b	; 11
    2d66:	0f b6       	in	r0, 0x3f	; 63
    2d68:	f8 94       	cli
    2d6a:	de bf       	out	0x3e, r29	; 62
    2d6c:	0f be       	out	0x3f, r0	; 63
    2d6e:	cd bf       	out	0x3d, r28	; 61
    2d70:	9e 83       	std	Y+6, r25	; 0x06
    2d72:	8d 83       	std	Y+5, r24	; 0x05
    2d74:	78 87       	std	Y+8, r23	; 0x08
    2d76:	6f 83       	std	Y+7, r22	; 0x07
    2d78:	5a 87       	std	Y+10, r21	; 0x0a
    2d7a:	49 87       	std	Y+9, r20	; 0x09
    2d7c:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2d7e:	8d 81       	ldd	r24, Y+5	; 0x05
    2d80:	9e 81       	ldd	r25, Y+6	; 0x06
    2d82:	9b 83       	std	Y+3, r25	; 0x03
    2d84:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2d86:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2d88:	8a 81       	ldd	r24, Y+2	; 0x02
    2d8a:	9b 81       	ldd	r25, Y+3	; 0x03
    2d8c:	fc 01       	movw	r30, r24
    2d8e:	22 8d       	ldd	r18, Z+26	; 0x1a
    2d90:	8a 81       	ldd	r24, Y+2	; 0x02
    2d92:	9b 81       	ldd	r25, Y+3	; 0x03
    2d94:	fc 01       	movw	r30, r24
    2d96:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d98:	28 17       	cp	r18, r24
    2d9a:	18 f0       	brcs	.+6      	; 0x2da2 <xQueueGenericSendFromISR+0x46>
    2d9c:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d9e:	82 30       	cpi	r24, 0x02	; 2
    2da0:	91 f5       	brne	.+100    	; 0x2e06 <xQueueGenericSendFromISR+0xaa>
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2da2:	2f 81       	ldd	r18, Y+7	; 0x07
    2da4:	38 85       	ldd	r19, Y+8	; 0x08
    2da6:	8a 81       	ldd	r24, Y+2	; 0x02
    2da8:	9b 81       	ldd	r25, Y+3	; 0x03
    2daa:	4b 85       	ldd	r20, Y+11	; 0x0b
    2dac:	b9 01       	movw	r22, r18
    2dae:	0e 94 61 19 	call	0x32c2	; 0x32c2 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2db2:	8a 81       	ldd	r24, Y+2	; 0x02
    2db4:	9b 81       	ldd	r25, Y+3	; 0x03
    2db6:	fc 01       	movw	r30, r24
    2db8:	86 8d       	ldd	r24, Z+30	; 0x1e
    2dba:	8f 3f       	cpi	r24, 0xFF	; 255
    2dbc:	b9 f4       	brne	.+46     	; 0x2dec <xQueueGenericSendFromISR+0x90>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2dbe:	8a 81       	ldd	r24, Y+2	; 0x02
    2dc0:	9b 81       	ldd	r25, Y+3	; 0x03
    2dc2:	fc 01       	movw	r30, r24
    2dc4:	81 89       	ldd	r24, Z+17	; 0x11
    2dc6:	88 23       	and	r24, r24
    2dc8:	d9 f0       	breq	.+54     	; 0x2e00 <xQueueGenericSendFromISR+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2dca:	8a 81       	ldd	r24, Y+2	; 0x02
    2dcc:	9b 81       	ldd	r25, Y+3	; 0x03
    2dce:	41 96       	adiw	r24, 0x11	; 17
    2dd0:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <xTaskRemoveFromEventList>
    2dd4:	88 23       	and	r24, r24
    2dd6:	a1 f0       	breq	.+40     	; 0x2e00 <xQueueGenericSendFromISR+0xa4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2dd8:	89 85       	ldd	r24, Y+9	; 0x09
    2dda:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ddc:	00 97       	sbiw	r24, 0x00	; 0
    2dde:	81 f0       	breq	.+32     	; 0x2e00 <xQueueGenericSendFromISR+0xa4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2de0:	89 85       	ldd	r24, Y+9	; 0x09
    2de2:	9a 85       	ldd	r25, Y+10	; 0x0a
    2de4:	21 e0       	ldi	r18, 0x01	; 1
    2de6:	fc 01       	movw	r30, r24
    2de8:	20 83       	st	Z, r18
    2dea:	0a c0       	rjmp	.+20     	; 0x2e00 <xQueueGenericSendFromISR+0xa4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2dec:	8a 81       	ldd	r24, Y+2	; 0x02
    2dee:	9b 81       	ldd	r25, Y+3	; 0x03
    2df0:	fc 01       	movw	r30, r24
    2df2:	86 8d       	ldd	r24, Z+30	; 0x1e
    2df4:	21 e0       	ldi	r18, 0x01	; 1
    2df6:	28 0f       	add	r18, r24
    2df8:	8a 81       	ldd	r24, Y+2	; 0x02
    2dfa:	9b 81       	ldd	r25, Y+3	; 0x03
    2dfc:	fc 01       	movw	r30, r24
    2dfe:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    2e00:	81 e0       	ldi	r24, 0x01	; 1
    2e02:	89 83       	std	Y+1, r24	; 0x01
    2e04:	01 c0       	rjmp	.+2      	; 0x2e08 <xQueueGenericSendFromISR+0xac>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2e06:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2e08:	89 81       	ldd	r24, Y+1	; 0x01
}
    2e0a:	2b 96       	adiw	r28, 0x0b	; 11
    2e0c:	0f b6       	in	r0, 0x3f	; 63
    2e0e:	f8 94       	cli
    2e10:	de bf       	out	0x3e, r29	; 62
    2e12:	0f be       	out	0x3f, r0	; 63
    2e14:	cd bf       	out	0x3d, r28	; 61
    2e16:	df 91       	pop	r29
    2e18:	cf 91       	pop	r28
    2e1a:	08 95       	ret

00002e1c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2e1c:	cf 93       	push	r28
    2e1e:	df 93       	push	r29
    2e20:	cd b7       	in	r28, 0x3d	; 61
    2e22:	de b7       	in	r29, 0x3e	; 62
    2e24:	28 97       	sbiw	r28, 0x08	; 8
    2e26:	0f b6       	in	r0, 0x3f	; 63
    2e28:	f8 94       	cli
    2e2a:	de bf       	out	0x3e, r29	; 62
    2e2c:	0f be       	out	0x3f, r0	; 63
    2e2e:	cd bf       	out	0x3d, r28	; 61
    2e30:	9e 83       	std	Y+6, r25	; 0x06
    2e32:	8d 83       	std	Y+5, r24	; 0x05
    2e34:	78 87       	std	Y+8, r23	; 0x08
    2e36:	6f 83       	std	Y+7, r22	; 0x07
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2e38:	8d 81       	ldd	r24, Y+5	; 0x05
    2e3a:	9e 81       	ldd	r25, Y+6	; 0x06
    2e3c:	9b 83       	std	Y+3, r25	; 0x03
    2e3e:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2e40:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2e42:	8a 81       	ldd	r24, Y+2	; 0x02
    2e44:	9b 81       	ldd	r25, Y+3	; 0x03
    2e46:	fc 01       	movw	r30, r24
    2e48:	22 8d       	ldd	r18, Z+26	; 0x1a
    2e4a:	8a 81       	ldd	r24, Y+2	; 0x02
    2e4c:	9b 81       	ldd	r25, Y+3	; 0x03
    2e4e:	fc 01       	movw	r30, r24
    2e50:	83 8d       	ldd	r24, Z+27	; 0x1b
    2e52:	28 17       	cp	r18, r24
    2e54:	a0 f5       	brcc	.+104    	; 0x2ebe <xQueueGiveFromISR+0xa2>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    2e56:	8a 81       	ldd	r24, Y+2	; 0x02
    2e58:	9b 81       	ldd	r25, Y+3	; 0x03
    2e5a:	fc 01       	movw	r30, r24
    2e5c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e5e:	21 e0       	ldi	r18, 0x01	; 1
    2e60:	28 0f       	add	r18, r24
    2e62:	8a 81       	ldd	r24, Y+2	; 0x02
    2e64:	9b 81       	ldd	r25, Y+3	; 0x03
    2e66:	fc 01       	movw	r30, r24
    2e68:	22 8f       	std	Z+26, r18	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2e6a:	8a 81       	ldd	r24, Y+2	; 0x02
    2e6c:	9b 81       	ldd	r25, Y+3	; 0x03
    2e6e:	fc 01       	movw	r30, r24
    2e70:	86 8d       	ldd	r24, Z+30	; 0x1e
    2e72:	8f 3f       	cpi	r24, 0xFF	; 255
    2e74:	b9 f4       	brne	.+46     	; 0x2ea4 <xQueueGiveFromISR+0x88>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2e76:	8a 81       	ldd	r24, Y+2	; 0x02
    2e78:	9b 81       	ldd	r25, Y+3	; 0x03
    2e7a:	fc 01       	movw	r30, r24
    2e7c:	81 89       	ldd	r24, Z+17	; 0x11
    2e7e:	88 23       	and	r24, r24
    2e80:	d9 f0       	breq	.+54     	; 0x2eb8 <xQueueGiveFromISR+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2e82:	8a 81       	ldd	r24, Y+2	; 0x02
    2e84:	9b 81       	ldd	r25, Y+3	; 0x03
    2e86:	41 96       	adiw	r24, 0x11	; 17
    2e88:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <xTaskRemoveFromEventList>
    2e8c:	88 23       	and	r24, r24
    2e8e:	a1 f0       	breq	.+40     	; 0x2eb8 <xQueueGiveFromISR+0x9c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2e90:	8f 81       	ldd	r24, Y+7	; 0x07
    2e92:	98 85       	ldd	r25, Y+8	; 0x08
    2e94:	00 97       	sbiw	r24, 0x00	; 0
    2e96:	81 f0       	breq	.+32     	; 0x2eb8 <xQueueGiveFromISR+0x9c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2e98:	8f 81       	ldd	r24, Y+7	; 0x07
    2e9a:	98 85       	ldd	r25, Y+8	; 0x08
    2e9c:	21 e0       	ldi	r18, 0x01	; 1
    2e9e:	fc 01       	movw	r30, r24
    2ea0:	20 83       	st	Z, r18
    2ea2:	0a c0       	rjmp	.+20     	; 0x2eb8 <xQueueGiveFromISR+0x9c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2ea4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ea8:	fc 01       	movw	r30, r24
    2eaa:	86 8d       	ldd	r24, Z+30	; 0x1e
    2eac:	21 e0       	ldi	r18, 0x01	; 1
    2eae:	28 0f       	add	r18, r24
    2eb0:	8a 81       	ldd	r24, Y+2	; 0x02
    2eb2:	9b 81       	ldd	r25, Y+3	; 0x03
    2eb4:	fc 01       	movw	r30, r24
    2eb6:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    2eb8:	81 e0       	ldi	r24, 0x01	; 1
    2eba:	89 83       	std	Y+1, r24	; 0x01
    2ebc:	01 c0       	rjmp	.+2      	; 0x2ec0 <xQueueGiveFromISR+0xa4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2ebe:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2ec0:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ec2:	28 96       	adiw	r28, 0x08	; 8
    2ec4:	0f b6       	in	r0, 0x3f	; 63
    2ec6:	f8 94       	cli
    2ec8:	de bf       	out	0x3e, r29	; 62
    2eca:	0f be       	out	0x3f, r0	; 63
    2ecc:	cd bf       	out	0x3d, r28	; 61
    2ece:	df 91       	pop	r29
    2ed0:	cf 91       	pop	r28
    2ed2:	08 95       	ret

00002ed4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    2ed4:	cf 93       	push	r28
    2ed6:	df 93       	push	r29
    2ed8:	cd b7       	in	r28, 0x3d	; 61
    2eda:	de b7       	in	r29, 0x3e	; 62
    2edc:	2f 97       	sbiw	r28, 0x0f	; 15
    2ede:	0f b6       	in	r0, 0x3f	; 63
    2ee0:	f8 94       	cli
    2ee2:	de bf       	out	0x3e, r29	; 62
    2ee4:	0f be       	out	0x3f, r0	; 63
    2ee6:	cd bf       	out	0x3d, r28	; 61
    2ee8:	9a 87       	std	Y+10, r25	; 0x0a
    2eea:	89 87       	std	Y+9, r24	; 0x09
    2eec:	7c 87       	std	Y+12, r23	; 0x0c
    2eee:	6b 87       	std	Y+11, r22	; 0x0b
    2ef0:	5e 87       	std	Y+14, r21	; 0x0e
    2ef2:	4d 87       	std	Y+13, r20	; 0x0d
    2ef4:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    2ef6:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2ef8:	89 85       	ldd	r24, Y+9	; 0x09
    2efa:	9a 85       	ldd	r25, Y+10	; 0x0a
    2efc:	9b 83       	std	Y+3, r25	; 0x03
    2efe:	8a 83       	std	Y+2, r24	; 0x02
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2f00:	0f b6       	in	r0, 0x3f	; 63
    2f02:	f8 94       	cli
    2f04:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2f06:	8a 81       	ldd	r24, Y+2	; 0x02
    2f08:	9b 81       	ldd	r25, Y+3	; 0x03
    2f0a:	fc 01       	movw	r30, r24
    2f0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f0e:	88 23       	and	r24, r24
    2f10:	09 f4       	brne	.+2      	; 0x2f14 <xQueueGenericReceive+0x40>
    2f12:	54 c0       	rjmp	.+168    	; 0x2fbc <xQueueGenericReceive+0xe8>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2f14:	8a 81       	ldd	r24, Y+2	; 0x02
    2f16:	9b 81       	ldd	r25, Y+3	; 0x03
    2f18:	fc 01       	movw	r30, r24
    2f1a:	86 81       	ldd	r24, Z+6	; 0x06
    2f1c:	97 81       	ldd	r25, Z+7	; 0x07
    2f1e:	9d 83       	std	Y+5, r25	; 0x05
    2f20:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2f22:	2b 85       	ldd	r18, Y+11	; 0x0b
    2f24:	3c 85       	ldd	r19, Y+12	; 0x0c
    2f26:	8a 81       	ldd	r24, Y+2	; 0x02
    2f28:	9b 81       	ldd	r25, Y+3	; 0x03
    2f2a:	b9 01       	movw	r22, r18
    2f2c:	0e 94 35 1a 	call	0x346a	; 0x346a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2f30:	8f 85       	ldd	r24, Y+15	; 0x0f
    2f32:	88 23       	and	r24, r24
    2f34:	49 f5       	brne	.+82     	; 0x2f88 <xQueueGenericReceive+0xb4>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    2f36:	8a 81       	ldd	r24, Y+2	; 0x02
    2f38:	9b 81       	ldd	r25, Y+3	; 0x03
    2f3a:	fc 01       	movw	r30, r24
    2f3c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f3e:	2f ef       	ldi	r18, 0xFF	; 255
    2f40:	28 0f       	add	r18, r24
    2f42:	8a 81       	ldd	r24, Y+2	; 0x02
    2f44:	9b 81       	ldd	r25, Y+3	; 0x03
    2f46:	fc 01       	movw	r30, r24
    2f48:	22 8f       	std	Z+26, r18	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2f4a:	8a 81       	ldd	r24, Y+2	; 0x02
    2f4c:	9b 81       	ldd	r25, Y+3	; 0x03
    2f4e:	fc 01       	movw	r30, r24
    2f50:	80 81       	ld	r24, Z
    2f52:	91 81       	ldd	r25, Z+1	; 0x01
    2f54:	00 97       	sbiw	r24, 0x00	; 0
    2f56:	41 f4       	brne	.+16     	; 0x2f68 <xQueueGenericReceive+0x94>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    2f58:	0e 94 0b 28 	call	0x5016	; 0x5016 <pvTaskIncrementMutexHeldCount>
    2f5c:	9c 01       	movw	r18, r24
    2f5e:	8a 81       	ldd	r24, Y+2	; 0x02
    2f60:	9b 81       	ldd	r25, Y+3	; 0x03
    2f62:	fc 01       	movw	r30, r24
    2f64:	33 83       	std	Z+3, r19	; 0x03
    2f66:	22 83       	std	Z+2, r18	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2f68:	8a 81       	ldd	r24, Y+2	; 0x02
    2f6a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f6c:	fc 01       	movw	r30, r24
    2f6e:	80 85       	ldd	r24, Z+8	; 0x08
    2f70:	88 23       	and	r24, r24
    2f72:	01 f1       	breq	.+64     	; 0x2fb4 <xQueueGenericReceive+0xe0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2f74:	8a 81       	ldd	r24, Y+2	; 0x02
    2f76:	9b 81       	ldd	r25, Y+3	; 0x03
    2f78:	08 96       	adiw	r24, 0x08	; 8
    2f7a:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <xTaskRemoveFromEventList>
    2f7e:	81 30       	cpi	r24, 0x01	; 1
    2f80:	c9 f4       	brne	.+50     	; 0x2fb4 <xQueueGenericReceive+0xe0>
						{
							queueYIELD_IF_USING_PREEMPTION();
    2f82:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
    2f86:	16 c0       	rjmp	.+44     	; 0x2fb4 <xQueueGenericReceive+0xe0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2f88:	8a 81       	ldd	r24, Y+2	; 0x02
    2f8a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f8c:	2c 81       	ldd	r18, Y+4	; 0x04
    2f8e:	3d 81       	ldd	r19, Y+5	; 0x05
    2f90:	fc 01       	movw	r30, r24
    2f92:	37 83       	std	Z+7, r19	; 0x07
    2f94:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2f96:	8a 81       	ldd	r24, Y+2	; 0x02
    2f98:	9b 81       	ldd	r25, Y+3	; 0x03
    2f9a:	fc 01       	movw	r30, r24
    2f9c:	81 89       	ldd	r24, Z+17	; 0x11
    2f9e:	88 23       	and	r24, r24
    2fa0:	49 f0       	breq	.+18     	; 0x2fb4 <xQueueGenericReceive+0xe0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2fa2:	8a 81       	ldd	r24, Y+2	; 0x02
    2fa4:	9b 81       	ldd	r25, Y+3	; 0x03
    2fa6:	41 96       	adiw	r24, 0x11	; 17
    2fa8:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <xTaskRemoveFromEventList>
    2fac:	88 23       	and	r24, r24
    2fae:	11 f0       	breq	.+4      	; 0x2fb4 <xQueueGenericReceive+0xe0>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    2fb0:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    2fb4:	0f 90       	pop	r0
    2fb6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2fb8:	81 e0       	ldi	r24, 0x01	; 1
    2fba:	74 c0       	rjmp	.+232    	; 0x30a4 <xQueueGenericReceive+0x1d0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2fbc:	8d 85       	ldd	r24, Y+13	; 0x0d
    2fbe:	9e 85       	ldd	r25, Y+14	; 0x0e
    2fc0:	00 97       	sbiw	r24, 0x00	; 0
    2fc2:	21 f4       	brne	.+8      	; 0x2fcc <xQueueGenericReceive+0xf8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2fc4:	0f 90       	pop	r0
    2fc6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2fc8:	80 e0       	ldi	r24, 0x00	; 0
    2fca:	6c c0       	rjmp	.+216    	; 0x30a4 <xQueueGenericReceive+0x1d0>
				}
				else if( xEntryTimeSet == pdFALSE )
    2fcc:	89 81       	ldd	r24, Y+1	; 0x01
    2fce:	88 23       	and	r24, r24
    2fd0:	31 f4       	brne	.+12     	; 0x2fde <xQueueGenericReceive+0x10a>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2fd2:	ce 01       	movw	r24, r28
    2fd4:	06 96       	adiw	r24, 0x06	; 6
    2fd6:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2fda:	81 e0       	ldi	r24, 0x01	; 1
    2fdc:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2fde:	0f 90       	pop	r0
    2fe0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2fe2:	0e 94 13 20 	call	0x4026	; 0x4026 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2fe6:	0f b6       	in	r0, 0x3f	; 63
    2fe8:	f8 94       	cli
    2fea:	0f 92       	push	r0
    2fec:	8a 81       	ldd	r24, Y+2	; 0x02
    2fee:	9b 81       	ldd	r25, Y+3	; 0x03
    2ff0:	fc 01       	movw	r30, r24
    2ff2:	85 8d       	ldd	r24, Z+29	; 0x1d
    2ff4:	8f 3f       	cpi	r24, 0xFF	; 255
    2ff6:	21 f4       	brne	.+8      	; 0x3000 <xQueueGenericReceive+0x12c>
    2ff8:	8a 81       	ldd	r24, Y+2	; 0x02
    2ffa:	9b 81       	ldd	r25, Y+3	; 0x03
    2ffc:	fc 01       	movw	r30, r24
    2ffe:	15 8e       	std	Z+29, r1	; 0x1d
    3000:	8a 81       	ldd	r24, Y+2	; 0x02
    3002:	9b 81       	ldd	r25, Y+3	; 0x03
    3004:	fc 01       	movw	r30, r24
    3006:	86 8d       	ldd	r24, Z+30	; 0x1e
    3008:	8f 3f       	cpi	r24, 0xFF	; 255
    300a:	21 f4       	brne	.+8      	; 0x3014 <xQueueGenericReceive+0x140>
    300c:	8a 81       	ldd	r24, Y+2	; 0x02
    300e:	9b 81       	ldd	r25, Y+3	; 0x03
    3010:	fc 01       	movw	r30, r24
    3012:	16 8e       	std	Z+30, r1	; 0x1e
    3014:	0f 90       	pop	r0
    3016:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3018:	9e 01       	movw	r18, r28
    301a:	23 5f       	subi	r18, 0xF3	; 243
    301c:	3f 4f       	sbci	r19, 0xFF	; 255
    301e:	ce 01       	movw	r24, r28
    3020:	06 96       	adiw	r24, 0x06	; 6
    3022:	b9 01       	movw	r22, r18
    3024:	0e 94 ed 23 	call	0x47da	; 0x47da <xTaskCheckForTimeOut>
    3028:	88 23       	and	r24, r24
    302a:	99 f5       	brne	.+102    	; 0x3092 <xQueueGenericReceive+0x1be>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    302c:	8a 81       	ldd	r24, Y+2	; 0x02
    302e:	9b 81       	ldd	r25, Y+3	; 0x03
    3030:	0e 94 ea 1a 	call	0x35d4	; 0x35d4 <prvIsQueueEmpty>
    3034:	88 23       	and	r24, r24
    3036:	31 f1       	breq	.+76     	; 0x3084 <xQueueGenericReceive+0x1b0>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3038:	8a 81       	ldd	r24, Y+2	; 0x02
    303a:	9b 81       	ldd	r25, Y+3	; 0x03
    303c:	fc 01       	movw	r30, r24
    303e:	80 81       	ld	r24, Z
    3040:	91 81       	ldd	r25, Z+1	; 0x01
    3042:	00 97       	sbiw	r24, 0x00	; 0
    3044:	61 f4       	brne	.+24     	; 0x305e <xQueueGenericReceive+0x18a>
					{
						taskENTER_CRITICAL();
    3046:	0f b6       	in	r0, 0x3f	; 63
    3048:	f8 94       	cli
    304a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    304c:	8a 81       	ldd	r24, Y+2	; 0x02
    304e:	9b 81       	ldd	r25, Y+3	; 0x03
    3050:	fc 01       	movw	r30, r24
    3052:	82 81       	ldd	r24, Z+2	; 0x02
    3054:	93 81       	ldd	r25, Z+3	; 0x03
    3056:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    305a:	0f 90       	pop	r0
    305c:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    305e:	2d 85       	ldd	r18, Y+13	; 0x0d
    3060:	3e 85       	ldd	r19, Y+14	; 0x0e
    3062:	8a 81       	ldd	r24, Y+2	; 0x02
    3064:	9b 81       	ldd	r25, Y+3	; 0x03
    3066:	41 96       	adiw	r24, 0x11	; 17
    3068:	b9 01       	movw	r22, r18
    306a:	0e 94 5f 22 	call	0x44be	; 0x44be <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    306e:	8a 81       	ldd	r24, Y+2	; 0x02
    3070:	9b 81       	ldd	r25, Y+3	; 0x03
    3072:	0e 94 85 1a 	call	0x350a	; 0x350a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3076:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>
    307a:	88 23       	and	r24, r24
    307c:	91 f4       	brne	.+36     	; 0x30a2 <xQueueGenericReceive+0x1ce>
				{
					portYIELD_WITHIN_API();
    307e:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
    3082:	0f c0       	rjmp	.+30     	; 0x30a2 <xQueueGenericReceive+0x1ce>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3084:	8a 81       	ldd	r24, Y+2	; 0x02
    3086:	9b 81       	ldd	r25, Y+3	; 0x03
    3088:	0e 94 85 1a 	call	0x350a	; 0x350a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    308c:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    3090:	37 cf       	rjmp	.-402    	; 0x2f00 <xQueueGenericReceive+0x2c>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3092:	8a 81       	ldd	r24, Y+2	; 0x02
    3094:	9b 81       	ldd	r25, Y+3	; 0x03
    3096:	0e 94 85 1a 	call	0x350a	; 0x350a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    309a:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    309e:	80 e0       	ldi	r24, 0x00	; 0
    30a0:	01 c0       	rjmp	.+2      	; 0x30a4 <xQueueGenericReceive+0x1d0>
		}
	}
    30a2:	2e cf       	rjmp	.-420    	; 0x2f00 <xQueueGenericReceive+0x2c>
}
    30a4:	2f 96       	adiw	r28, 0x0f	; 15
    30a6:	0f b6       	in	r0, 0x3f	; 63
    30a8:	f8 94       	cli
    30aa:	de bf       	out	0x3e, r29	; 62
    30ac:	0f be       	out	0x3f, r0	; 63
    30ae:	cd bf       	out	0x3d, r28	; 61
    30b0:	df 91       	pop	r29
    30b2:	cf 91       	pop	r28
    30b4:	08 95       	ret

000030b6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    30b6:	cf 93       	push	r28
    30b8:	df 93       	push	r29
    30ba:	cd b7       	in	r28, 0x3d	; 61
    30bc:	de b7       	in	r29, 0x3e	; 62
    30be:	2a 97       	sbiw	r28, 0x0a	; 10
    30c0:	0f b6       	in	r0, 0x3f	; 63
    30c2:	f8 94       	cli
    30c4:	de bf       	out	0x3e, r29	; 62
    30c6:	0f be       	out	0x3f, r0	; 63
    30c8:	cd bf       	out	0x3d, r28	; 61
    30ca:	9e 83       	std	Y+6, r25	; 0x06
    30cc:	8d 83       	std	Y+5, r24	; 0x05
    30ce:	78 87       	std	Y+8, r23	; 0x08
    30d0:	6f 83       	std	Y+7, r22	; 0x07
    30d2:	5a 87       	std	Y+10, r21	; 0x0a
    30d4:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    30d6:	8d 81       	ldd	r24, Y+5	; 0x05
    30d8:	9e 81       	ldd	r25, Y+6	; 0x06
    30da:	9b 83       	std	Y+3, r25	; 0x03
    30dc:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    30de:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    30e0:	8a 81       	ldd	r24, Y+2	; 0x02
    30e2:	9b 81       	ldd	r25, Y+3	; 0x03
    30e4:	fc 01       	movw	r30, r24
    30e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    30e8:	88 23       	and	r24, r24
    30ea:	d9 f1       	breq	.+118    	; 0x3162 <xQueueReceiveFromISR+0xac>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    30ec:	2f 81       	ldd	r18, Y+7	; 0x07
    30ee:	38 85       	ldd	r19, Y+8	; 0x08
    30f0:	8a 81       	ldd	r24, Y+2	; 0x02
    30f2:	9b 81       	ldd	r25, Y+3	; 0x03
    30f4:	b9 01       	movw	r22, r18
    30f6:	0e 94 35 1a 	call	0x346a	; 0x346a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    30fa:	8a 81       	ldd	r24, Y+2	; 0x02
    30fc:	9b 81       	ldd	r25, Y+3	; 0x03
    30fe:	fc 01       	movw	r30, r24
    3100:	82 8d       	ldd	r24, Z+26	; 0x1a
    3102:	2f ef       	ldi	r18, 0xFF	; 255
    3104:	28 0f       	add	r18, r24
    3106:	8a 81       	ldd	r24, Y+2	; 0x02
    3108:	9b 81       	ldd	r25, Y+3	; 0x03
    310a:	fc 01       	movw	r30, r24
    310c:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    310e:	8a 81       	ldd	r24, Y+2	; 0x02
    3110:	9b 81       	ldd	r25, Y+3	; 0x03
    3112:	fc 01       	movw	r30, r24
    3114:	85 8d       	ldd	r24, Z+29	; 0x1d
    3116:	8f 3f       	cpi	r24, 0xFF	; 255
    3118:	b9 f4       	brne	.+46     	; 0x3148 <xQueueReceiveFromISR+0x92>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    311a:	8a 81       	ldd	r24, Y+2	; 0x02
    311c:	9b 81       	ldd	r25, Y+3	; 0x03
    311e:	fc 01       	movw	r30, r24
    3120:	80 85       	ldd	r24, Z+8	; 0x08
    3122:	88 23       	and	r24, r24
    3124:	d9 f0       	breq	.+54     	; 0x315c <xQueueReceiveFromISR+0xa6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3126:	8a 81       	ldd	r24, Y+2	; 0x02
    3128:	9b 81       	ldd	r25, Y+3	; 0x03
    312a:	08 96       	adiw	r24, 0x08	; 8
    312c:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <xTaskRemoveFromEventList>
    3130:	88 23       	and	r24, r24
    3132:	a1 f0       	breq	.+40     	; 0x315c <xQueueReceiveFromISR+0xa6>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    3134:	89 85       	ldd	r24, Y+9	; 0x09
    3136:	9a 85       	ldd	r25, Y+10	; 0x0a
    3138:	00 97       	sbiw	r24, 0x00	; 0
    313a:	81 f0       	breq	.+32     	; 0x315c <xQueueReceiveFromISR+0xa6>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    313c:	89 85       	ldd	r24, Y+9	; 0x09
    313e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3140:	21 e0       	ldi	r18, 0x01	; 1
    3142:	fc 01       	movw	r30, r24
    3144:	20 83       	st	Z, r18
    3146:	0a c0       	rjmp	.+20     	; 0x315c <xQueueReceiveFromISR+0xa6>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    3148:	8a 81       	ldd	r24, Y+2	; 0x02
    314a:	9b 81       	ldd	r25, Y+3	; 0x03
    314c:	fc 01       	movw	r30, r24
    314e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3150:	21 e0       	ldi	r18, 0x01	; 1
    3152:	28 0f       	add	r18, r24
    3154:	8a 81       	ldd	r24, Y+2	; 0x02
    3156:	9b 81       	ldd	r25, Y+3	; 0x03
    3158:	fc 01       	movw	r30, r24
    315a:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    315c:	81 e0       	ldi	r24, 0x01	; 1
    315e:	89 83       	std	Y+1, r24	; 0x01
    3160:	01 c0       	rjmp	.+2      	; 0x3164 <xQueueReceiveFromISR+0xae>
		}
		else
		{
			xReturn = pdFAIL;
    3162:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3164:	89 81       	ldd	r24, Y+1	; 0x01
}
    3166:	2a 96       	adiw	r28, 0x0a	; 10
    3168:	0f b6       	in	r0, 0x3f	; 63
    316a:	f8 94       	cli
    316c:	de bf       	out	0x3e, r29	; 62
    316e:	0f be       	out	0x3f, r0	; 63
    3170:	cd bf       	out	0x3d, r28	; 61
    3172:	df 91       	pop	r29
    3174:	cf 91       	pop	r28
    3176:	08 95       	ret

00003178 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3178:	cf 93       	push	r28
    317a:	df 93       	push	r29
    317c:	cd b7       	in	r28, 0x3d	; 61
    317e:	de b7       	in	r29, 0x3e	; 62
    3180:	2a 97       	sbiw	r28, 0x0a	; 10
    3182:	0f b6       	in	r0, 0x3f	; 63
    3184:	f8 94       	cli
    3186:	de bf       	out	0x3e, r29	; 62
    3188:	0f be       	out	0x3f, r0	; 63
    318a:	cd bf       	out	0x3d, r28	; 61
    318c:	98 87       	std	Y+8, r25	; 0x08
    318e:	8f 83       	std	Y+7, r24	; 0x07
    3190:	7a 87       	std	Y+10, r23	; 0x0a
    3192:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3194:	8f 81       	ldd	r24, Y+7	; 0x07
    3196:	98 85       	ldd	r25, Y+8	; 0x08
    3198:	9b 83       	std	Y+3, r25	; 0x03
    319a:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    319c:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    319e:	8a 81       	ldd	r24, Y+2	; 0x02
    31a0:	9b 81       	ldd	r25, Y+3	; 0x03
    31a2:	fc 01       	movw	r30, r24
    31a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    31a6:	88 23       	and	r24, r24
    31a8:	c1 f0       	breq	.+48     	; 0x31da <xQueuePeekFromISR+0x62>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    31aa:	8a 81       	ldd	r24, Y+2	; 0x02
    31ac:	9b 81       	ldd	r25, Y+3	; 0x03
    31ae:	fc 01       	movw	r30, r24
    31b0:	86 81       	ldd	r24, Z+6	; 0x06
    31b2:	97 81       	ldd	r25, Z+7	; 0x07
    31b4:	9e 83       	std	Y+6, r25	; 0x06
    31b6:	8d 83       	std	Y+5, r24	; 0x05
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    31b8:	29 85       	ldd	r18, Y+9	; 0x09
    31ba:	3a 85       	ldd	r19, Y+10	; 0x0a
    31bc:	8a 81       	ldd	r24, Y+2	; 0x02
    31be:	9b 81       	ldd	r25, Y+3	; 0x03
    31c0:	b9 01       	movw	r22, r18
    31c2:	0e 94 35 1a 	call	0x346a	; 0x346a <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    31c6:	8a 81       	ldd	r24, Y+2	; 0x02
    31c8:	9b 81       	ldd	r25, Y+3	; 0x03
    31ca:	2d 81       	ldd	r18, Y+5	; 0x05
    31cc:	3e 81       	ldd	r19, Y+6	; 0x06
    31ce:	fc 01       	movw	r30, r24
    31d0:	37 83       	std	Z+7, r19	; 0x07
    31d2:	26 83       	std	Z+6, r18	; 0x06

			xReturn = pdPASS;
    31d4:	81 e0       	ldi	r24, 0x01	; 1
    31d6:	89 83       	std	Y+1, r24	; 0x01
    31d8:	01 c0       	rjmp	.+2      	; 0x31dc <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
    31da:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    31dc:	89 81       	ldd	r24, Y+1	; 0x01
}
    31de:	2a 96       	adiw	r28, 0x0a	; 10
    31e0:	0f b6       	in	r0, 0x3f	; 63
    31e2:	f8 94       	cli
    31e4:	de bf       	out	0x3e, r29	; 62
    31e6:	0f be       	out	0x3f, r0	; 63
    31e8:	cd bf       	out	0x3d, r28	; 61
    31ea:	df 91       	pop	r29
    31ec:	cf 91       	pop	r28
    31ee:	08 95       	ret

000031f0 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    31f0:	cf 93       	push	r28
    31f2:	df 93       	push	r29
    31f4:	00 d0       	rcall	.+0      	; 0x31f6 <uxQueueMessagesWaiting+0x6>
    31f6:	cd b7       	in	r28, 0x3d	; 61
    31f8:	de b7       	in	r29, 0x3e	; 62
    31fa:	9b 83       	std	Y+3, r25	; 0x03
    31fc:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    31fe:	0f b6       	in	r0, 0x3f	; 63
    3200:	f8 94       	cli
    3202:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3204:	8a 81       	ldd	r24, Y+2	; 0x02
    3206:	9b 81       	ldd	r25, Y+3	; 0x03
    3208:	fc 01       	movw	r30, r24
    320a:	82 8d       	ldd	r24, Z+26	; 0x1a
    320c:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    320e:	0f 90       	pop	r0
    3210:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3212:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3214:	0f 90       	pop	r0
    3216:	0f 90       	pop	r0
    3218:	0f 90       	pop	r0
    321a:	df 91       	pop	r29
    321c:	cf 91       	pop	r28
    321e:	08 95       	ret

00003220 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3220:	cf 93       	push	r28
    3222:	df 93       	push	r29
    3224:	00 d0       	rcall	.+0      	; 0x3226 <uxQueueSpacesAvailable+0x6>
    3226:	1f 92       	push	r1
    3228:	1f 92       	push	r1
    322a:	cd b7       	in	r28, 0x3d	; 61
    322c:	de b7       	in	r29, 0x3e	; 62
    322e:	9d 83       	std	Y+5, r25	; 0x05
    3230:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    3232:	8c 81       	ldd	r24, Y+4	; 0x04
    3234:	9d 81       	ldd	r25, Y+5	; 0x05
    3236:	9a 83       	std	Y+2, r25	; 0x02
    3238:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    323a:	0f b6       	in	r0, 0x3f	; 63
    323c:	f8 94       	cli
    323e:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3240:	89 81       	ldd	r24, Y+1	; 0x01
    3242:	9a 81       	ldd	r25, Y+2	; 0x02
    3244:	fc 01       	movw	r30, r24
    3246:	23 8d       	ldd	r18, Z+27	; 0x1b
    3248:	89 81       	ldd	r24, Y+1	; 0x01
    324a:	9a 81       	ldd	r25, Y+2	; 0x02
    324c:	fc 01       	movw	r30, r24
    324e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3250:	f2 2f       	mov	r31, r18
    3252:	f8 1b       	sub	r31, r24
    3254:	8f 2f       	mov	r24, r31
    3256:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    3258:	0f 90       	pop	r0
    325a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    325c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    325e:	0f 90       	pop	r0
    3260:	0f 90       	pop	r0
    3262:	0f 90       	pop	r0
    3264:	0f 90       	pop	r0
    3266:	0f 90       	pop	r0
    3268:	df 91       	pop	r29
    326a:	cf 91       	pop	r28
    326c:	08 95       	ret

0000326e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    326e:	cf 93       	push	r28
    3270:	df 93       	push	r29
    3272:	00 d0       	rcall	.+0      	; 0x3274 <uxQueueMessagesWaitingFromISR+0x6>
    3274:	cd b7       	in	r28, 0x3d	; 61
    3276:	de b7       	in	r29, 0x3e	; 62
    3278:	9b 83       	std	Y+3, r25	; 0x03
    327a:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    327c:	8a 81       	ldd	r24, Y+2	; 0x02
    327e:	9b 81       	ldd	r25, Y+3	; 0x03
    3280:	fc 01       	movw	r30, r24
    3282:	82 8d       	ldd	r24, Z+26	; 0x1a
    3284:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    3286:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3288:	0f 90       	pop	r0
    328a:	0f 90       	pop	r0
    328c:	0f 90       	pop	r0
    328e:	df 91       	pop	r29
    3290:	cf 91       	pop	r28
    3292:	08 95       	ret

00003294 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3294:	cf 93       	push	r28
    3296:	df 93       	push	r29
    3298:	00 d0       	rcall	.+0      	; 0x329a <vQueueDelete+0x6>
    329a:	1f 92       	push	r1
    329c:	cd b7       	in	r28, 0x3d	; 61
    329e:	de b7       	in	r29, 0x3e	; 62
    32a0:	9c 83       	std	Y+4, r25	; 0x04
    32a2:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    32a4:	8b 81       	ldd	r24, Y+3	; 0x03
    32a6:	9c 81       	ldd	r25, Y+4	; 0x04
    32a8:	9a 83       	std	Y+2, r25	; 0x02
    32aa:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
    32ac:	89 81       	ldd	r24, Y+1	; 0x01
    32ae:	9a 81       	ldd	r25, Y+2	; 0x02
    32b0:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <vPortFree>
}
    32b4:	0f 90       	pop	r0
    32b6:	0f 90       	pop	r0
    32b8:	0f 90       	pop	r0
    32ba:	0f 90       	pop	r0
    32bc:	df 91       	pop	r29
    32be:	cf 91       	pop	r28
    32c0:	08 95       	ret

000032c2 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    32c2:	cf 93       	push	r28
    32c4:	df 93       	push	r29
    32c6:	00 d0       	rcall	.+0      	; 0x32c8 <prvCopyDataToQueue+0x6>
    32c8:	00 d0       	rcall	.+0      	; 0x32ca <prvCopyDataToQueue+0x8>
    32ca:	cd b7       	in	r28, 0x3d	; 61
    32cc:	de b7       	in	r29, 0x3e	; 62
    32ce:	9b 83       	std	Y+3, r25	; 0x03
    32d0:	8a 83       	std	Y+2, r24	; 0x02
    32d2:	7d 83       	std	Y+5, r23	; 0x05
    32d4:	6c 83       	std	Y+4, r22	; 0x04
    32d6:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    32d8:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    32da:	8a 81       	ldd	r24, Y+2	; 0x02
    32dc:	9b 81       	ldd	r25, Y+3	; 0x03
    32de:	fc 01       	movw	r30, r24
    32e0:	84 8d       	ldd	r24, Z+28	; 0x1c
    32e2:	88 23       	and	r24, r24
    32e4:	b1 f4       	brne	.+44     	; 0x3312 <prvCopyDataToQueue+0x50>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    32e6:	8a 81       	ldd	r24, Y+2	; 0x02
    32e8:	9b 81       	ldd	r25, Y+3	; 0x03
    32ea:	fc 01       	movw	r30, r24
    32ec:	80 81       	ld	r24, Z
    32ee:	91 81       	ldd	r25, Z+1	; 0x01
    32f0:	00 97       	sbiw	r24, 0x00	; 0
    32f2:	09 f0       	breq	.+2      	; 0x32f6 <prvCopyDataToQueue+0x34>
    32f4:	a6 c0       	rjmp	.+332    	; 0x3442 <prvCopyDataToQueue+0x180>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    32f6:	8a 81       	ldd	r24, Y+2	; 0x02
    32f8:	9b 81       	ldd	r25, Y+3	; 0x03
    32fa:	fc 01       	movw	r30, r24
    32fc:	82 81       	ldd	r24, Z+2	; 0x02
    32fe:	93 81       	ldd	r25, Z+3	; 0x03
    3300:	0e 94 63 27 	call	0x4ec6	; 0x4ec6 <xTaskPriorityDisinherit>
    3304:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->pxMutexHolder = NULL;
    3306:	8a 81       	ldd	r24, Y+2	; 0x02
    3308:	9b 81       	ldd	r25, Y+3	; 0x03
    330a:	fc 01       	movw	r30, r24
    330c:	13 82       	std	Z+3, r1	; 0x03
    330e:	12 82       	std	Z+2, r1	; 0x02
    3310:	98 c0       	rjmp	.+304    	; 0x3442 <prvCopyDataToQueue+0x180>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    3312:	8e 81       	ldd	r24, Y+6	; 0x06
    3314:	88 23       	and	r24, r24
    3316:	d9 f5       	brne	.+118    	; 0x338e <prvCopyDataToQueue+0xcc>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
    3318:	8a 81       	ldd	r24, Y+2	; 0x02
    331a:	9b 81       	ldd	r25, Y+3	; 0x03
    331c:	fc 01       	movw	r30, r24
    331e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3320:	48 2f       	mov	r20, r24
    3322:	50 e0       	ldi	r21, 0x00	; 0
    3324:	8a 81       	ldd	r24, Y+2	; 0x02
    3326:	9b 81       	ldd	r25, Y+3	; 0x03
    3328:	fc 01       	movw	r30, r24
    332a:	84 81       	ldd	r24, Z+4	; 0x04
    332c:	95 81       	ldd	r25, Z+5	; 0x05
    332e:	2c 81       	ldd	r18, Y+4	; 0x04
    3330:	3d 81       	ldd	r19, Y+5	; 0x05
    3332:	b9 01       	movw	r22, r18
    3334:	0e 94 43 2f 	call	0x5e86	; 0x5e86 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3338:	8a 81       	ldd	r24, Y+2	; 0x02
    333a:	9b 81       	ldd	r25, Y+3	; 0x03
    333c:	fc 01       	movw	r30, r24
    333e:	24 81       	ldd	r18, Z+4	; 0x04
    3340:	35 81       	ldd	r19, Z+5	; 0x05
    3342:	8a 81       	ldd	r24, Y+2	; 0x02
    3344:	9b 81       	ldd	r25, Y+3	; 0x03
    3346:	fc 01       	movw	r30, r24
    3348:	84 8d       	ldd	r24, Z+28	; 0x1c
    334a:	88 2f       	mov	r24, r24
    334c:	90 e0       	ldi	r25, 0x00	; 0
    334e:	28 0f       	add	r18, r24
    3350:	39 1f       	adc	r19, r25
    3352:	8a 81       	ldd	r24, Y+2	; 0x02
    3354:	9b 81       	ldd	r25, Y+3	; 0x03
    3356:	fc 01       	movw	r30, r24
    3358:	35 83       	std	Z+5, r19	; 0x05
    335a:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    335c:	8a 81       	ldd	r24, Y+2	; 0x02
    335e:	9b 81       	ldd	r25, Y+3	; 0x03
    3360:	fc 01       	movw	r30, r24
    3362:	24 81       	ldd	r18, Z+4	; 0x04
    3364:	35 81       	ldd	r19, Z+5	; 0x05
    3366:	8a 81       	ldd	r24, Y+2	; 0x02
    3368:	9b 81       	ldd	r25, Y+3	; 0x03
    336a:	fc 01       	movw	r30, r24
    336c:	82 81       	ldd	r24, Z+2	; 0x02
    336e:	93 81       	ldd	r25, Z+3	; 0x03
    3370:	28 17       	cp	r18, r24
    3372:	39 07       	cpc	r19, r25
    3374:	08 f4       	brcc	.+2      	; 0x3378 <prvCopyDataToQueue+0xb6>
    3376:	65 c0       	rjmp	.+202    	; 0x3442 <prvCopyDataToQueue+0x180>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3378:	8a 81       	ldd	r24, Y+2	; 0x02
    337a:	9b 81       	ldd	r25, Y+3	; 0x03
    337c:	fc 01       	movw	r30, r24
    337e:	20 81       	ld	r18, Z
    3380:	31 81       	ldd	r19, Z+1	; 0x01
    3382:	8a 81       	ldd	r24, Y+2	; 0x02
    3384:	9b 81       	ldd	r25, Y+3	; 0x03
    3386:	fc 01       	movw	r30, r24
    3388:	35 83       	std	Z+5, r19	; 0x05
    338a:	24 83       	std	Z+4, r18	; 0x04
    338c:	5a c0       	rjmp	.+180    	; 0x3442 <prvCopyDataToQueue+0x180>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
    338e:	8a 81       	ldd	r24, Y+2	; 0x02
    3390:	9b 81       	ldd	r25, Y+3	; 0x03
    3392:	fc 01       	movw	r30, r24
    3394:	84 8d       	ldd	r24, Z+28	; 0x1c
    3396:	48 2f       	mov	r20, r24
    3398:	50 e0       	ldi	r21, 0x00	; 0
    339a:	8a 81       	ldd	r24, Y+2	; 0x02
    339c:	9b 81       	ldd	r25, Y+3	; 0x03
    339e:	fc 01       	movw	r30, r24
    33a0:	86 81       	ldd	r24, Z+6	; 0x06
    33a2:	97 81       	ldd	r25, Z+7	; 0x07
    33a4:	2c 81       	ldd	r18, Y+4	; 0x04
    33a6:	3d 81       	ldd	r19, Y+5	; 0x05
    33a8:	b9 01       	movw	r22, r18
    33aa:	0e 94 43 2f 	call	0x5e86	; 0x5e86 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    33ae:	8a 81       	ldd	r24, Y+2	; 0x02
    33b0:	9b 81       	ldd	r25, Y+3	; 0x03
    33b2:	fc 01       	movw	r30, r24
    33b4:	26 81       	ldd	r18, Z+6	; 0x06
    33b6:	37 81       	ldd	r19, Z+7	; 0x07
    33b8:	8a 81       	ldd	r24, Y+2	; 0x02
    33ba:	9b 81       	ldd	r25, Y+3	; 0x03
    33bc:	fc 01       	movw	r30, r24
    33be:	84 8d       	ldd	r24, Z+28	; 0x1c
    33c0:	88 2f       	mov	r24, r24
    33c2:	90 e0       	ldi	r25, 0x00	; 0
    33c4:	91 95       	neg	r25
    33c6:	81 95       	neg	r24
    33c8:	91 09       	sbc	r25, r1
    33ca:	28 0f       	add	r18, r24
    33cc:	39 1f       	adc	r19, r25
    33ce:	8a 81       	ldd	r24, Y+2	; 0x02
    33d0:	9b 81       	ldd	r25, Y+3	; 0x03
    33d2:	fc 01       	movw	r30, r24
    33d4:	37 83       	std	Z+7, r19	; 0x07
    33d6:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead )
    33d8:	8a 81       	ldd	r24, Y+2	; 0x02
    33da:	9b 81       	ldd	r25, Y+3	; 0x03
    33dc:	fc 01       	movw	r30, r24
    33de:	26 81       	ldd	r18, Z+6	; 0x06
    33e0:	37 81       	ldd	r19, Z+7	; 0x07
    33e2:	8a 81       	ldd	r24, Y+2	; 0x02
    33e4:	9b 81       	ldd	r25, Y+3	; 0x03
    33e6:	fc 01       	movw	r30, r24
    33e8:	80 81       	ld	r24, Z
    33ea:	91 81       	ldd	r25, Z+1	; 0x01
    33ec:	28 17       	cp	r18, r24
    33ee:	39 07       	cpc	r19, r25
    33f0:	a8 f4       	brcc	.+42     	; 0x341c <prvCopyDataToQueue+0x15a>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    33f2:	8a 81       	ldd	r24, Y+2	; 0x02
    33f4:	9b 81       	ldd	r25, Y+3	; 0x03
    33f6:	fc 01       	movw	r30, r24
    33f8:	22 81       	ldd	r18, Z+2	; 0x02
    33fa:	33 81       	ldd	r19, Z+3	; 0x03
    33fc:	8a 81       	ldd	r24, Y+2	; 0x02
    33fe:	9b 81       	ldd	r25, Y+3	; 0x03
    3400:	fc 01       	movw	r30, r24
    3402:	84 8d       	ldd	r24, Z+28	; 0x1c
    3404:	88 2f       	mov	r24, r24
    3406:	90 e0       	ldi	r25, 0x00	; 0
    3408:	91 95       	neg	r25
    340a:	81 95       	neg	r24
    340c:	91 09       	sbc	r25, r1
    340e:	28 0f       	add	r18, r24
    3410:	39 1f       	adc	r19, r25
    3412:	8a 81       	ldd	r24, Y+2	; 0x02
    3414:	9b 81       	ldd	r25, Y+3	; 0x03
    3416:	fc 01       	movw	r30, r24
    3418:	37 83       	std	Z+7, r19	; 0x07
    341a:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    341c:	8e 81       	ldd	r24, Y+6	; 0x06
    341e:	82 30       	cpi	r24, 0x02	; 2
    3420:	81 f4       	brne	.+32     	; 0x3442 <prvCopyDataToQueue+0x180>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3422:	8a 81       	ldd	r24, Y+2	; 0x02
    3424:	9b 81       	ldd	r25, Y+3	; 0x03
    3426:	fc 01       	movw	r30, r24
    3428:	82 8d       	ldd	r24, Z+26	; 0x1a
    342a:	88 23       	and	r24, r24
    342c:	51 f0       	breq	.+20     	; 0x3442 <prvCopyDataToQueue+0x180>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    342e:	8a 81       	ldd	r24, Y+2	; 0x02
    3430:	9b 81       	ldd	r25, Y+3	; 0x03
    3432:	fc 01       	movw	r30, r24
    3434:	82 8d       	ldd	r24, Z+26	; 0x1a
    3436:	2f ef       	ldi	r18, 0xFF	; 255
    3438:	28 0f       	add	r18, r24
    343a:	8a 81       	ldd	r24, Y+2	; 0x02
    343c:	9b 81       	ldd	r25, Y+3	; 0x03
    343e:	fc 01       	movw	r30, r24
    3440:	22 8f       	std	Z+26, r18	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    3442:	8a 81       	ldd	r24, Y+2	; 0x02
    3444:	9b 81       	ldd	r25, Y+3	; 0x03
    3446:	fc 01       	movw	r30, r24
    3448:	82 8d       	ldd	r24, Z+26	; 0x1a
    344a:	21 e0       	ldi	r18, 0x01	; 1
    344c:	28 0f       	add	r18, r24
    344e:	8a 81       	ldd	r24, Y+2	; 0x02
    3450:	9b 81       	ldd	r25, Y+3	; 0x03
    3452:	fc 01       	movw	r30, r24
    3454:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
    3456:	89 81       	ldd	r24, Y+1	; 0x01
}
    3458:	26 96       	adiw	r28, 0x06	; 6
    345a:	0f b6       	in	r0, 0x3f	; 63
    345c:	f8 94       	cli
    345e:	de bf       	out	0x3e, r29	; 62
    3460:	0f be       	out	0x3f, r0	; 63
    3462:	cd bf       	out	0x3d, r28	; 61
    3464:	df 91       	pop	r29
    3466:	cf 91       	pop	r28
    3468:	08 95       	ret

0000346a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    346a:	cf 93       	push	r28
    346c:	df 93       	push	r29
    346e:	00 d0       	rcall	.+0      	; 0x3470 <prvCopyDataFromQueue+0x6>
    3470:	1f 92       	push	r1
    3472:	cd b7       	in	r28, 0x3d	; 61
    3474:	de b7       	in	r29, 0x3e	; 62
    3476:	9a 83       	std	Y+2, r25	; 0x02
    3478:	89 83       	std	Y+1, r24	; 0x01
    347a:	7c 83       	std	Y+4, r23	; 0x04
    347c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    347e:	89 81       	ldd	r24, Y+1	; 0x01
    3480:	9a 81       	ldd	r25, Y+2	; 0x02
    3482:	fc 01       	movw	r30, r24
    3484:	84 8d       	ldd	r24, Z+28	; 0x1c
    3486:	88 23       	and	r24, r24
    3488:	c9 f1       	breq	.+114    	; 0x34fc <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    348a:	89 81       	ldd	r24, Y+1	; 0x01
    348c:	9a 81       	ldd	r25, Y+2	; 0x02
    348e:	fc 01       	movw	r30, r24
    3490:	26 81       	ldd	r18, Z+6	; 0x06
    3492:	37 81       	ldd	r19, Z+7	; 0x07
    3494:	89 81       	ldd	r24, Y+1	; 0x01
    3496:	9a 81       	ldd	r25, Y+2	; 0x02
    3498:	fc 01       	movw	r30, r24
    349a:	84 8d       	ldd	r24, Z+28	; 0x1c
    349c:	88 2f       	mov	r24, r24
    349e:	90 e0       	ldi	r25, 0x00	; 0
    34a0:	28 0f       	add	r18, r24
    34a2:	39 1f       	adc	r19, r25
    34a4:	89 81       	ldd	r24, Y+1	; 0x01
    34a6:	9a 81       	ldd	r25, Y+2	; 0x02
    34a8:	fc 01       	movw	r30, r24
    34aa:	37 83       	std	Z+7, r19	; 0x07
    34ac:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    34ae:	89 81       	ldd	r24, Y+1	; 0x01
    34b0:	9a 81       	ldd	r25, Y+2	; 0x02
    34b2:	fc 01       	movw	r30, r24
    34b4:	26 81       	ldd	r18, Z+6	; 0x06
    34b6:	37 81       	ldd	r19, Z+7	; 0x07
    34b8:	89 81       	ldd	r24, Y+1	; 0x01
    34ba:	9a 81       	ldd	r25, Y+2	; 0x02
    34bc:	fc 01       	movw	r30, r24
    34be:	82 81       	ldd	r24, Z+2	; 0x02
    34c0:	93 81       	ldd	r25, Z+3	; 0x03
    34c2:	28 17       	cp	r18, r24
    34c4:	39 07       	cpc	r19, r25
    34c6:	50 f0       	brcs	.+20     	; 0x34dc <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    34c8:	89 81       	ldd	r24, Y+1	; 0x01
    34ca:	9a 81       	ldd	r25, Y+2	; 0x02
    34cc:	fc 01       	movw	r30, r24
    34ce:	20 81       	ld	r18, Z
    34d0:	31 81       	ldd	r19, Z+1	; 0x01
    34d2:	89 81       	ldd	r24, Y+1	; 0x01
    34d4:	9a 81       	ldd	r25, Y+2	; 0x02
    34d6:	fc 01       	movw	r30, r24
    34d8:	37 83       	std	Z+7, r19	; 0x07
    34da:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    34dc:	89 81       	ldd	r24, Y+1	; 0x01
    34de:	9a 81       	ldd	r25, Y+2	; 0x02
    34e0:	fc 01       	movw	r30, r24
    34e2:	84 8d       	ldd	r24, Z+28	; 0x1c
    34e4:	48 2f       	mov	r20, r24
    34e6:	50 e0       	ldi	r21, 0x00	; 0
    34e8:	89 81       	ldd	r24, Y+1	; 0x01
    34ea:	9a 81       	ldd	r25, Y+2	; 0x02
    34ec:	fc 01       	movw	r30, r24
    34ee:	26 81       	ldd	r18, Z+6	; 0x06
    34f0:	37 81       	ldd	r19, Z+7	; 0x07
    34f2:	8b 81       	ldd	r24, Y+3	; 0x03
    34f4:	9c 81       	ldd	r25, Y+4	; 0x04
    34f6:	b9 01       	movw	r22, r18
    34f8:	0e 94 43 2f 	call	0x5e86	; 0x5e86 <memcpy>
	}
}
    34fc:	0f 90       	pop	r0
    34fe:	0f 90       	pop	r0
    3500:	0f 90       	pop	r0
    3502:	0f 90       	pop	r0
    3504:	df 91       	pop	r29
    3506:	cf 91       	pop	r28
    3508:	08 95       	ret

0000350a <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    350a:	cf 93       	push	r28
    350c:	df 93       	push	r29
    350e:	1f 92       	push	r1
    3510:	1f 92       	push	r1
    3512:	cd b7       	in	r28, 0x3d	; 61
    3514:	de b7       	in	r29, 0x3e	; 62
    3516:	9a 83       	std	Y+2, r25	; 0x02
    3518:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    351a:	0f b6       	in	r0, 0x3f	; 63
    351c:	f8 94       	cli
    351e:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3520:	1b c0       	rjmp	.+54     	; 0x3558 <prvUnlockQueue+0x4e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3522:	89 81       	ldd	r24, Y+1	; 0x01
    3524:	9a 81       	ldd	r25, Y+2	; 0x02
    3526:	fc 01       	movw	r30, r24
    3528:	81 89       	ldd	r24, Z+17	; 0x11
    352a:	88 23       	and	r24, r24
    352c:	51 f0       	breq	.+20     	; 0x3542 <prvUnlockQueue+0x38>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    352e:	89 81       	ldd	r24, Y+1	; 0x01
    3530:	9a 81       	ldd	r25, Y+2	; 0x02
    3532:	41 96       	adiw	r24, 0x11	; 17
    3534:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <xTaskRemoveFromEventList>
    3538:	88 23       	and	r24, r24
    353a:	21 f0       	breq	.+8      	; 0x3544 <prvUnlockQueue+0x3a>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    353c:	0e 94 60 24 	call	0x48c0	; 0x48c0 <vTaskMissedYield>
    3540:	01 c0       	rjmp	.+2      	; 0x3544 <prvUnlockQueue+0x3a>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    3542:	10 c0       	rjmp	.+32     	; 0x3564 <prvUnlockQueue+0x5a>
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    3544:	89 81       	ldd	r24, Y+1	; 0x01
    3546:	9a 81       	ldd	r25, Y+2	; 0x02
    3548:	fc 01       	movw	r30, r24
    354a:	86 8d       	ldd	r24, Z+30	; 0x1e
    354c:	2f ef       	ldi	r18, 0xFF	; 255
    354e:	28 0f       	add	r18, r24
    3550:	89 81       	ldd	r24, Y+1	; 0x01
    3552:	9a 81       	ldd	r25, Y+2	; 0x02
    3554:	fc 01       	movw	r30, r24
    3556:	26 8f       	std	Z+30, r18	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3558:	89 81       	ldd	r24, Y+1	; 0x01
    355a:	9a 81       	ldd	r25, Y+2	; 0x02
    355c:	fc 01       	movw	r30, r24
    355e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3560:	18 16       	cp	r1, r24
    3562:	fc f2       	brlt	.-66     	; 0x3522 <prvUnlockQueue+0x18>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3564:	89 81       	ldd	r24, Y+1	; 0x01
    3566:	9a 81       	ldd	r25, Y+2	; 0x02
    3568:	2f ef       	ldi	r18, 0xFF	; 255
    356a:	fc 01       	movw	r30, r24
    356c:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    356e:	0f 90       	pop	r0
    3570:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3572:	0f b6       	in	r0, 0x3f	; 63
    3574:	f8 94       	cli
    3576:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3578:	1b c0       	rjmp	.+54     	; 0x35b0 <prvUnlockQueue+0xa6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    357a:	89 81       	ldd	r24, Y+1	; 0x01
    357c:	9a 81       	ldd	r25, Y+2	; 0x02
    357e:	fc 01       	movw	r30, r24
    3580:	80 85       	ldd	r24, Z+8	; 0x08
    3582:	88 23       	and	r24, r24
    3584:	a1 f0       	breq	.+40     	; 0x35ae <prvUnlockQueue+0xa4>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3586:	89 81       	ldd	r24, Y+1	; 0x01
    3588:	9a 81       	ldd	r25, Y+2	; 0x02
    358a:	08 96       	adiw	r24, 0x08	; 8
    358c:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <xTaskRemoveFromEventList>
    3590:	88 23       	and	r24, r24
    3592:	11 f0       	breq	.+4      	; 0x3598 <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    3594:	0e 94 60 24 	call	0x48c0	; 0x48c0 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    3598:	89 81       	ldd	r24, Y+1	; 0x01
    359a:	9a 81       	ldd	r25, Y+2	; 0x02
    359c:	fc 01       	movw	r30, r24
    359e:	85 8d       	ldd	r24, Z+29	; 0x1d
    35a0:	2f ef       	ldi	r18, 0xFF	; 255
    35a2:	28 0f       	add	r18, r24
    35a4:	89 81       	ldd	r24, Y+1	; 0x01
    35a6:	9a 81       	ldd	r25, Y+2	; 0x02
    35a8:	fc 01       	movw	r30, r24
    35aa:	25 8f       	std	Z+29, r18	; 0x1d
    35ac:	01 c0       	rjmp	.+2      	; 0x35b0 <prvUnlockQueue+0xa6>
			}
			else
			{
				break;
    35ae:	06 c0       	rjmp	.+12     	; 0x35bc <prvUnlockQueue+0xb2>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    35b0:	89 81       	ldd	r24, Y+1	; 0x01
    35b2:	9a 81       	ldd	r25, Y+2	; 0x02
    35b4:	fc 01       	movw	r30, r24
    35b6:	85 8d       	ldd	r24, Z+29	; 0x1d
    35b8:	18 16       	cp	r1, r24
    35ba:	fc f2       	brlt	.-66     	; 0x357a <prvUnlockQueue+0x70>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    35bc:	89 81       	ldd	r24, Y+1	; 0x01
    35be:	9a 81       	ldd	r25, Y+2	; 0x02
    35c0:	2f ef       	ldi	r18, 0xFF	; 255
    35c2:	fc 01       	movw	r30, r24
    35c4:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    35c6:	0f 90       	pop	r0
    35c8:	0f be       	out	0x3f, r0	; 63
}
    35ca:	0f 90       	pop	r0
    35cc:	0f 90       	pop	r0
    35ce:	df 91       	pop	r29
    35d0:	cf 91       	pop	r28
    35d2:	08 95       	ret

000035d4 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    35d4:	cf 93       	push	r28
    35d6:	df 93       	push	r29
    35d8:	00 d0       	rcall	.+0      	; 0x35da <prvIsQueueEmpty+0x6>
    35da:	cd b7       	in	r28, 0x3d	; 61
    35dc:	de b7       	in	r29, 0x3e	; 62
    35de:	9b 83       	std	Y+3, r25	; 0x03
    35e0:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    35e2:	0f b6       	in	r0, 0x3f	; 63
    35e4:	f8 94       	cli
    35e6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    35e8:	8a 81       	ldd	r24, Y+2	; 0x02
    35ea:	9b 81       	ldd	r25, Y+3	; 0x03
    35ec:	fc 01       	movw	r30, r24
    35ee:	82 8d       	ldd	r24, Z+26	; 0x1a
    35f0:	88 23       	and	r24, r24
    35f2:	19 f4       	brne	.+6      	; 0x35fa <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    35f4:	81 e0       	ldi	r24, 0x01	; 1
    35f6:	89 83       	std	Y+1, r24	; 0x01
    35f8:	01 c0       	rjmp	.+2      	; 0x35fc <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    35fa:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    35fc:	0f 90       	pop	r0
    35fe:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3600:	89 81       	ldd	r24, Y+1	; 0x01
}
    3602:	0f 90       	pop	r0
    3604:	0f 90       	pop	r0
    3606:	0f 90       	pop	r0
    3608:	df 91       	pop	r29
    360a:	cf 91       	pop	r28
    360c:	08 95       	ret

0000360e <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    360e:	cf 93       	push	r28
    3610:	df 93       	push	r29
    3612:	00 d0       	rcall	.+0      	; 0x3614 <xQueueIsQueueEmptyFromISR+0x6>
    3614:	cd b7       	in	r28, 0x3d	; 61
    3616:	de b7       	in	r29, 0x3e	; 62
    3618:	9b 83       	std	Y+3, r25	; 0x03
    361a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    361c:	8a 81       	ldd	r24, Y+2	; 0x02
    361e:	9b 81       	ldd	r25, Y+3	; 0x03
    3620:	fc 01       	movw	r30, r24
    3622:	82 8d       	ldd	r24, Z+26	; 0x1a
    3624:	88 23       	and	r24, r24
    3626:	19 f4       	brne	.+6      	; 0x362e <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    3628:	81 e0       	ldi	r24, 0x01	; 1
    362a:	89 83       	std	Y+1, r24	; 0x01
    362c:	01 c0       	rjmp	.+2      	; 0x3630 <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    362e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3630:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3632:	0f 90       	pop	r0
    3634:	0f 90       	pop	r0
    3636:	0f 90       	pop	r0
    3638:	df 91       	pop	r29
    363a:	cf 91       	pop	r28
    363c:	08 95       	ret

0000363e <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    363e:	cf 93       	push	r28
    3640:	df 93       	push	r29
    3642:	00 d0       	rcall	.+0      	; 0x3644 <prvIsQueueFull+0x6>
    3644:	cd b7       	in	r28, 0x3d	; 61
    3646:	de b7       	in	r29, 0x3e	; 62
    3648:	9b 83       	std	Y+3, r25	; 0x03
    364a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    364c:	0f b6       	in	r0, 0x3f	; 63
    364e:	f8 94       	cli
    3650:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3652:	8a 81       	ldd	r24, Y+2	; 0x02
    3654:	9b 81       	ldd	r25, Y+3	; 0x03
    3656:	fc 01       	movw	r30, r24
    3658:	22 8d       	ldd	r18, Z+26	; 0x1a
    365a:	8a 81       	ldd	r24, Y+2	; 0x02
    365c:	9b 81       	ldd	r25, Y+3	; 0x03
    365e:	fc 01       	movw	r30, r24
    3660:	83 8d       	ldd	r24, Z+27	; 0x1b
    3662:	28 17       	cp	r18, r24
    3664:	19 f4       	brne	.+6      	; 0x366c <prvIsQueueFull+0x2e>
		{
			xReturn = pdTRUE;
    3666:	81 e0       	ldi	r24, 0x01	; 1
    3668:	89 83       	std	Y+1, r24	; 0x01
    366a:	01 c0       	rjmp	.+2      	; 0x366e <prvIsQueueFull+0x30>
		}
		else
		{
			xReturn = pdFALSE;
    366c:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    366e:	0f 90       	pop	r0
    3670:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3672:	89 81       	ldd	r24, Y+1	; 0x01
}
    3674:	0f 90       	pop	r0
    3676:	0f 90       	pop	r0
    3678:	0f 90       	pop	r0
    367a:	df 91       	pop	r29
    367c:	cf 91       	pop	r28
    367e:	08 95       	ret

00003680 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    3680:	cf 93       	push	r28
    3682:	df 93       	push	r29
    3684:	00 d0       	rcall	.+0      	; 0x3686 <xQueueIsQueueFullFromISR+0x6>
    3686:	cd b7       	in	r28, 0x3d	; 61
    3688:	de b7       	in	r29, 0x3e	; 62
    368a:	9b 83       	std	Y+3, r25	; 0x03
    368c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    368e:	8a 81       	ldd	r24, Y+2	; 0x02
    3690:	9b 81       	ldd	r25, Y+3	; 0x03
    3692:	fc 01       	movw	r30, r24
    3694:	22 8d       	ldd	r18, Z+26	; 0x1a
    3696:	8a 81       	ldd	r24, Y+2	; 0x02
    3698:	9b 81       	ldd	r25, Y+3	; 0x03
    369a:	fc 01       	movw	r30, r24
    369c:	83 8d       	ldd	r24, Z+27	; 0x1b
    369e:	28 17       	cp	r18, r24
    36a0:	19 f4       	brne	.+6      	; 0x36a8 <xQueueIsQueueFullFromISR+0x28>
	{
		xReturn = pdTRUE;
    36a2:	81 e0       	ldi	r24, 0x01	; 1
    36a4:	89 83       	std	Y+1, r24	; 0x01
    36a6:	01 c0       	rjmp	.+2      	; 0x36aa <xQueueIsQueueFullFromISR+0x2a>
	}
	else
	{
		xReturn = pdFALSE;
    36a8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    36aa:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    36ac:	0f 90       	pop	r0
    36ae:	0f 90       	pop	r0
    36b0:	0f 90       	pop	r0
    36b2:	df 91       	pop	r29
    36b4:	cf 91       	pop	r28
    36b6:	08 95       	ret

000036b8 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    36b8:	af 92       	push	r10
    36ba:	bf 92       	push	r11
    36bc:	cf 92       	push	r12
    36be:	df 92       	push	r13
    36c0:	ef 92       	push	r14
    36c2:	ff 92       	push	r15
    36c4:	0f 93       	push	r16
    36c6:	1f 93       	push	r17
    36c8:	cf 93       	push	r28
    36ca:	df 93       	push	r29
    36cc:	cd b7       	in	r28, 0x3d	; 61
    36ce:	de b7       	in	r29, 0x3e	; 62
    36d0:	64 97       	sbiw	r28, 0x14	; 20
    36d2:	0f b6       	in	r0, 0x3f	; 63
    36d4:	f8 94       	cli
    36d6:	de bf       	out	0x3e, r29	; 62
    36d8:	0f be       	out	0x3f, r0	; 63
    36da:	cd bf       	out	0x3d, r28	; 61
    36dc:	9f 83       	std	Y+7, r25	; 0x07
    36de:	8e 83       	std	Y+6, r24	; 0x06
    36e0:	79 87       	std	Y+9, r23	; 0x09
    36e2:	68 87       	std	Y+8, r22	; 0x08
    36e4:	5b 87       	std	Y+11, r21	; 0x0b
    36e6:	4a 87       	std	Y+10, r20	; 0x0a
    36e8:	3d 87       	std	Y+13, r19	; 0x0d
    36ea:	2c 87       	std	Y+12, r18	; 0x0c
    36ec:	0e 87       	std	Y+14, r16	; 0x0e
    36ee:	f8 8a       	std	Y+16, r15	; 0x10
    36f0:	ef 86       	std	Y+15, r14	; 0x0f
    36f2:	da 8a       	std	Y+18, r13	; 0x12
    36f4:	c9 8a       	std	Y+17, r12	; 0x11
    36f6:	bc 8a       	std	Y+20, r11	; 0x14
    36f8:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    36fa:	29 89       	ldd	r18, Y+17	; 0x11
    36fc:	3a 89       	ldd	r19, Y+18	; 0x12
    36fe:	8a 85       	ldd	r24, Y+10	; 0x0a
    3700:	9b 85       	ldd	r25, Y+11	; 0x0b
    3702:	b9 01       	movw	r22, r18
    3704:	0e 94 c2 25 	call	0x4b84	; 0x4b84 <prvAllocateTCBAndStack>
    3708:	9b 83       	std	Y+3, r25	; 0x03
    370a:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
    370c:	8a 81       	ldd	r24, Y+2	; 0x02
    370e:	9b 81       	ldd	r25, Y+3	; 0x03
    3710:	00 97       	sbiw	r24, 0x00	; 0
    3712:	09 f4       	brne	.+2      	; 0x3716 <xTaskGenericCreate+0x5e>
    3714:	91 c0       	rjmp	.+290    	; 0x3838 <xTaskGenericCreate+0x180>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    3716:	8a 81       	ldd	r24, Y+2	; 0x02
    3718:	9b 81       	ldd	r25, Y+3	; 0x03
    371a:	fc 01       	movw	r30, r24
    371c:	27 89       	ldd	r18, Z+23	; 0x17
    371e:	30 8d       	ldd	r19, Z+24	; 0x18
    3720:	8a 85       	ldd	r24, Y+10	; 0x0a
    3722:	9b 85       	ldd	r25, Y+11	; 0x0b
    3724:	01 97       	sbiw	r24, 0x01	; 1
    3726:	82 0f       	add	r24, r18
    3728:	93 1f       	adc	r25, r19
    372a:	9d 83       	std	Y+5, r25	; 0x05
    372c:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    372e:	4a 85       	ldd	r20, Y+10	; 0x0a
    3730:	5b 85       	ldd	r21, Y+11	; 0x0b
    3732:	2b 89       	ldd	r18, Y+19	; 0x13
    3734:	3c 89       	ldd	r19, Y+20	; 0x14
    3736:	68 85       	ldd	r22, Y+8	; 0x08
    3738:	79 85       	ldd	r23, Y+9	; 0x09
    373a:	8a 81       	ldd	r24, Y+2	; 0x02
    373c:	9b 81       	ldd	r25, Y+3	; 0x03
    373e:	8a 01       	movw	r16, r20
    3740:	4e 85       	ldd	r20, Y+14	; 0x0e
    3742:	0e 94 6a 24 	call	0x48d4	; 0x48d4 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3746:	4c 85       	ldd	r20, Y+12	; 0x0c
    3748:	5d 85       	ldd	r21, Y+13	; 0x0d
    374a:	2e 81       	ldd	r18, Y+6	; 0x06
    374c:	3f 81       	ldd	r19, Y+7	; 0x07
    374e:	8c 81       	ldd	r24, Y+4	; 0x04
    3750:	9d 81       	ldd	r25, Y+5	; 0x05
    3752:	b9 01       	movw	r22, r18
    3754:	0e 94 0a 11 	call	0x2214	; 0x2214 <pxPortInitialiseStack>
    3758:	9c 01       	movw	r18, r24
    375a:	8a 81       	ldd	r24, Y+2	; 0x02
    375c:	9b 81       	ldd	r25, Y+3	; 0x03
    375e:	fc 01       	movw	r30, r24
    3760:	31 83       	std	Z+1, r19	; 0x01
    3762:	20 83       	st	Z, r18
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    3764:	8f 85       	ldd	r24, Y+15	; 0x0f
    3766:	98 89       	ldd	r25, Y+16	; 0x10
    3768:	00 97       	sbiw	r24, 0x00	; 0
    376a:	39 f0       	breq	.+14     	; 0x377a <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    376c:	8f 85       	ldd	r24, Y+15	; 0x0f
    376e:	98 89       	ldd	r25, Y+16	; 0x10
    3770:	2a 81       	ldd	r18, Y+2	; 0x02
    3772:	3b 81       	ldd	r19, Y+3	; 0x03
    3774:	fc 01       	movw	r30, r24
    3776:	31 83       	std	Z+1, r19	; 0x01
    3778:	20 83       	st	Z, r18
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    377a:	0f b6       	in	r0, 0x3f	; 63
    377c:	f8 94       	cli
    377e:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    3780:	80 91 9a 02 	lds	r24, 0x029A
    3784:	8f 5f       	subi	r24, 0xFF	; 255
    3786:	80 93 9a 02 	sts	0x029A, r24
			if( pxCurrentTCB == NULL )
    378a:	80 91 42 02 	lds	r24, 0x0242
    378e:	90 91 43 02 	lds	r25, 0x0243
    3792:	00 97       	sbiw	r24, 0x00	; 0
    3794:	69 f4       	brne	.+26     	; 0x37b0 <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    3796:	8a 81       	ldd	r24, Y+2	; 0x02
    3798:	9b 81       	ldd	r25, Y+3	; 0x03
    379a:	90 93 43 02 	sts	0x0243, r25
    379e:	80 93 42 02 	sts	0x0242, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    37a2:	80 91 9a 02 	lds	r24, 0x029A
    37a6:	81 30       	cpi	r24, 0x01	; 1
    37a8:	b1 f4       	brne	.+44     	; 0x37d6 <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    37aa:	0e 94 f7 24 	call	0x49ee	; 0x49ee <prvInitialiseTaskLists>
    37ae:	13 c0       	rjmp	.+38     	; 0x37d6 <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    37b0:	80 91 9e 02 	lds	r24, 0x029E
    37b4:	88 23       	and	r24, r24
    37b6:	79 f4       	brne	.+30     	; 0x37d6 <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    37b8:	80 91 42 02 	lds	r24, 0x0242
    37bc:	90 91 43 02 	lds	r25, 0x0243
    37c0:	fc 01       	movw	r30, r24
    37c2:	96 89       	ldd	r25, Z+22	; 0x16
    37c4:	8e 85       	ldd	r24, Y+14	; 0x0e
    37c6:	89 17       	cp	r24, r25
    37c8:	30 f0       	brcs	.+12     	; 0x37d6 <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
    37ca:	8a 81       	ldd	r24, Y+2	; 0x02
    37cc:	9b 81       	ldd	r25, Y+3	; 0x03
    37ce:	90 93 43 02 	sts	0x0243, r25
    37d2:	80 93 42 02 	sts	0x0242, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    37d6:	80 91 a2 02 	lds	r24, 0x02A2
    37da:	8f 5f       	subi	r24, 0xFF	; 255
    37dc:	80 93 a2 02 	sts	0x02A2, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    37e0:	8a 81       	ldd	r24, Y+2	; 0x02
    37e2:	9b 81       	ldd	r25, Y+3	; 0x03
    37e4:	fc 01       	movw	r30, r24
    37e6:	96 89       	ldd	r25, Z+22	; 0x16
    37e8:	80 91 9d 02 	lds	r24, 0x029D
    37ec:	89 17       	cp	r24, r25
    37ee:	30 f4       	brcc	.+12     	; 0x37fc <xTaskGenericCreate+0x144>
    37f0:	8a 81       	ldd	r24, Y+2	; 0x02
    37f2:	9b 81       	ldd	r25, Y+3	; 0x03
    37f4:	fc 01       	movw	r30, r24
    37f6:	86 89       	ldd	r24, Z+22	; 0x16
    37f8:	80 93 9d 02 	sts	0x029D, r24
    37fc:	8a 81       	ldd	r24, Y+2	; 0x02
    37fe:	9b 81       	ldd	r25, Y+3	; 0x03
    3800:	ac 01       	movw	r20, r24
    3802:	4e 5f       	subi	r20, 0xFE	; 254
    3804:	5f 4f       	sbci	r21, 0xFF	; 255
    3806:	8a 81       	ldd	r24, Y+2	; 0x02
    3808:	9b 81       	ldd	r25, Y+3	; 0x03
    380a:	fc 01       	movw	r30, r24
    380c:	86 89       	ldd	r24, Z+22	; 0x16
    380e:	28 2f       	mov	r18, r24
    3810:	30 e0       	ldi	r19, 0x00	; 0
    3812:	c9 01       	movw	r24, r18
    3814:	88 0f       	add	r24, r24
    3816:	99 1f       	adc	r25, r25
    3818:	88 0f       	add	r24, r24
    381a:	99 1f       	adc	r25, r25
    381c:	88 0f       	add	r24, r24
    381e:	99 1f       	adc	r25, r25
    3820:	82 0f       	add	r24, r18
    3822:	93 1f       	adc	r25, r19
    3824:	8c 5b       	subi	r24, 0xBC	; 188
    3826:	9d 4f       	sbci	r25, 0xFD	; 253
    3828:	ba 01       	movw	r22, r20
    382a:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>

			xReturn = pdPASS;
    382e:	81 e0       	ldi	r24, 0x01	; 1
    3830:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    3832:	0f 90       	pop	r0
    3834:	0f be       	out	0x3f, r0	; 63
    3836:	02 c0       	rjmp	.+4      	; 0x383c <xTaskGenericCreate+0x184>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3838:	8f ef       	ldi	r24, 0xFF	; 255
    383a:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    383c:	89 81       	ldd	r24, Y+1	; 0x01
    383e:	81 30       	cpi	r24, 0x01	; 1
    3840:	79 f4       	brne	.+30     	; 0x3860 <xTaskGenericCreate+0x1a8>
	{
		if( xSchedulerRunning != pdFALSE )
    3842:	80 91 9e 02 	lds	r24, 0x029E
    3846:	88 23       	and	r24, r24
    3848:	59 f0       	breq	.+22     	; 0x3860 <xTaskGenericCreate+0x1a8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    384a:	80 91 42 02 	lds	r24, 0x0242
    384e:	90 91 43 02 	lds	r25, 0x0243
    3852:	fc 01       	movw	r30, r24
    3854:	96 89       	ldd	r25, Z+22	; 0x16
    3856:	8e 85       	ldd	r24, Y+14	; 0x0e
    3858:	98 17       	cp	r25, r24
    385a:	10 f4       	brcc	.+4      	; 0x3860 <xTaskGenericCreate+0x1a8>
			{
				taskYIELD_IF_USING_PREEMPTION();
    385c:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    3860:	89 81       	ldd	r24, Y+1	; 0x01
}
    3862:	64 96       	adiw	r28, 0x14	; 20
    3864:	0f b6       	in	r0, 0x3f	; 63
    3866:	f8 94       	cli
    3868:	de bf       	out	0x3e, r29	; 62
    386a:	0f be       	out	0x3f, r0	; 63
    386c:	cd bf       	out	0x3d, r28	; 61
    386e:	df 91       	pop	r29
    3870:	cf 91       	pop	r28
    3872:	1f 91       	pop	r17
    3874:	0f 91       	pop	r16
    3876:	ff 90       	pop	r15
    3878:	ef 90       	pop	r14
    387a:	df 90       	pop	r13
    387c:	cf 90       	pop	r12
    387e:	bf 90       	pop	r11
    3880:	af 90       	pop	r10
    3882:	08 95       	ret

00003884 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3884:	cf 93       	push	r28
    3886:	df 93       	push	r29
    3888:	00 d0       	rcall	.+0      	; 0x388a <vTaskDelete+0x6>
    388a:	1f 92       	push	r1
    388c:	cd b7       	in	r28, 0x3d	; 61
    388e:	de b7       	in	r29, 0x3e	; 62
    3890:	9c 83       	std	Y+4, r25	; 0x04
    3892:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3894:	0f b6       	in	r0, 0x3f	; 63
    3896:	f8 94       	cli
    3898:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    389a:	8b 81       	ldd	r24, Y+3	; 0x03
    389c:	9c 81       	ldd	r25, Y+4	; 0x04
    389e:	00 97       	sbiw	r24, 0x00	; 0
    38a0:	29 f4       	brne	.+10     	; 0x38ac <vTaskDelete+0x28>
    38a2:	80 91 42 02 	lds	r24, 0x0242
    38a6:	90 91 43 02 	lds	r25, 0x0243
    38aa:	02 c0       	rjmp	.+4      	; 0x38b0 <vTaskDelete+0x2c>
    38ac:	8b 81       	ldd	r24, Y+3	; 0x03
    38ae:	9c 81       	ldd	r25, Y+4	; 0x04
    38b0:	9a 83       	std	Y+2, r25	; 0x02
    38b2:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    38b4:	89 81       	ldd	r24, Y+1	; 0x01
    38b6:	9a 81       	ldd	r25, Y+2	; 0x02
    38b8:	02 96       	adiw	r24, 0x02	; 2
    38ba:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    38be:	89 81       	ldd	r24, Y+1	; 0x01
    38c0:	9a 81       	ldd	r25, Y+2	; 0x02
    38c2:	fc 01       	movw	r30, r24
    38c4:	84 89       	ldd	r24, Z+20	; 0x14
    38c6:	95 89       	ldd	r25, Z+21	; 0x15
    38c8:	00 97       	sbiw	r24, 0x00	; 0
    38ca:	29 f0       	breq	.+10     	; 0x38d6 <vTaskDelete+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    38cc:	89 81       	ldd	r24, Y+1	; 0x01
    38ce:	9a 81       	ldd	r25, Y+2	; 0x02
    38d0:	0c 96       	adiw	r24, 0x0c	; 12
    38d2:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    38d6:	89 81       	ldd	r24, Y+1	; 0x01
    38d8:	9a 81       	ldd	r25, Y+2	; 0x02
    38da:	02 96       	adiw	r24, 0x02	; 2
    38dc:	bc 01       	movw	r22, r24
    38de:	87 e8       	ldi	r24, 0x87	; 135
    38e0:	92 e0       	ldi	r25, 0x02	; 2
    38e2:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    38e6:	80 91 90 02 	lds	r24, 0x0290
    38ea:	8f 5f       	subi	r24, 0xFF	; 255
    38ec:	80 93 90 02 	sts	0x0290, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    38f0:	80 91 a2 02 	lds	r24, 0x02A2
    38f4:	8f 5f       	subi	r24, 0xFF	; 255
    38f6:	80 93 a2 02 	sts	0x02A2, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    38fa:	0f 90       	pop	r0
    38fc:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    38fe:	80 91 9e 02 	lds	r24, 0x029E
    3902:	88 23       	and	r24, r24
    3904:	99 f0       	breq	.+38     	; 0x392c <vTaskDelete+0xa8>
		{
			if( pxTCB == pxCurrentTCB )
    3906:	80 91 42 02 	lds	r24, 0x0242
    390a:	90 91 43 02 	lds	r25, 0x0243
    390e:	29 81       	ldd	r18, Y+1	; 0x01
    3910:	3a 81       	ldd	r19, Y+2	; 0x02
    3912:	28 17       	cp	r18, r24
    3914:	39 07       	cpc	r19, r25
    3916:	19 f4       	brne	.+6      	; 0x391e <vTaskDelete+0x9a>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    3918:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
    391c:	07 c0       	rjmp	.+14     	; 0x392c <vTaskDelete+0xa8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    391e:	0f b6       	in	r0, 0x3f	; 63
    3920:	f8 94       	cli
    3922:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    3924:	0e 94 8a 26 	call	0x4d14	; 0x4d14 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    3928:	0f 90       	pop	r0
    392a:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    392c:	0f 90       	pop	r0
    392e:	0f 90       	pop	r0
    3930:	0f 90       	pop	r0
    3932:	0f 90       	pop	r0
    3934:	df 91       	pop	r29
    3936:	cf 91       	pop	r28
    3938:	08 95       	ret

0000393a <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    393a:	cf 93       	push	r28
    393c:	df 93       	push	r29
    393e:	cd b7       	in	r28, 0x3d	; 61
    3940:	de b7       	in	r29, 0x3e	; 62
    3942:	2a 97       	sbiw	r28, 0x0a	; 10
    3944:	0f b6       	in	r0, 0x3f	; 63
    3946:	f8 94       	cli
    3948:	de bf       	out	0x3e, r29	; 62
    394a:	0f be       	out	0x3f, r0	; 63
    394c:	cd bf       	out	0x3d, r28	; 61
    394e:	98 87       	std	Y+8, r25	; 0x08
    3950:	8f 83       	std	Y+7, r24	; 0x07
    3952:	7a 87       	std	Y+10, r23	; 0x0a
    3954:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3956:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    3958:	0e 94 13 20 	call	0x4026	; 0x4026 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    395c:	80 91 9b 02 	lds	r24, 0x029B
    3960:	90 91 9c 02 	lds	r25, 0x029C
    3964:	9b 83       	std	Y+3, r25	; 0x03
    3966:	8a 83       	std	Y+2, r24	; 0x02

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3968:	8f 81       	ldd	r24, Y+7	; 0x07
    396a:	98 85       	ldd	r25, Y+8	; 0x08
    396c:	fc 01       	movw	r30, r24
    396e:	20 81       	ld	r18, Z
    3970:	31 81       	ldd	r19, Z+1	; 0x01
    3972:	89 85       	ldd	r24, Y+9	; 0x09
    3974:	9a 85       	ldd	r25, Y+10	; 0x0a
    3976:	82 0f       	add	r24, r18
    3978:	93 1f       	adc	r25, r19
    397a:	9d 83       	std	Y+5, r25	; 0x05
    397c:	8c 83       	std	Y+4, r24	; 0x04

			if( xConstTickCount < *pxPreviousWakeTime )
    397e:	8f 81       	ldd	r24, Y+7	; 0x07
    3980:	98 85       	ldd	r25, Y+8	; 0x08
    3982:	fc 01       	movw	r30, r24
    3984:	20 81       	ld	r18, Z
    3986:	31 81       	ldd	r19, Z+1	; 0x01
    3988:	8a 81       	ldd	r24, Y+2	; 0x02
    398a:	9b 81       	ldd	r25, Y+3	; 0x03
    398c:	82 17       	cp	r24, r18
    398e:	93 07       	cpc	r25, r19
    3990:	a0 f4       	brcc	.+40     	; 0x39ba <vTaskDelayUntil+0x80>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3992:	8f 81       	ldd	r24, Y+7	; 0x07
    3994:	98 85       	ldd	r25, Y+8	; 0x08
    3996:	fc 01       	movw	r30, r24
    3998:	20 81       	ld	r18, Z
    399a:	31 81       	ldd	r19, Z+1	; 0x01
    399c:	8c 81       	ldd	r24, Y+4	; 0x04
    399e:	9d 81       	ldd	r25, Y+5	; 0x05
    39a0:	82 17       	cp	r24, r18
    39a2:	93 07       	cpc	r25, r19
    39a4:	e8 f4       	brcc	.+58     	; 0x39e0 <vTaskDelayUntil+0xa6>
    39a6:	2c 81       	ldd	r18, Y+4	; 0x04
    39a8:	3d 81       	ldd	r19, Y+5	; 0x05
    39aa:	8a 81       	ldd	r24, Y+2	; 0x02
    39ac:	9b 81       	ldd	r25, Y+3	; 0x03
    39ae:	82 17       	cp	r24, r18
    39b0:	93 07       	cpc	r25, r19
    39b2:	b0 f4       	brcc	.+44     	; 0x39e0 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    39b4:	81 e0       	ldi	r24, 0x01	; 1
    39b6:	89 83       	std	Y+1, r24	; 0x01
    39b8:	13 c0       	rjmp	.+38     	; 0x39e0 <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    39ba:	8f 81       	ldd	r24, Y+7	; 0x07
    39bc:	98 85       	ldd	r25, Y+8	; 0x08
    39be:	fc 01       	movw	r30, r24
    39c0:	20 81       	ld	r18, Z
    39c2:	31 81       	ldd	r19, Z+1	; 0x01
    39c4:	8c 81       	ldd	r24, Y+4	; 0x04
    39c6:	9d 81       	ldd	r25, Y+5	; 0x05
    39c8:	82 17       	cp	r24, r18
    39ca:	93 07       	cpc	r25, r19
    39cc:	38 f0       	brcs	.+14     	; 0x39dc <vTaskDelayUntil+0xa2>
    39ce:	2c 81       	ldd	r18, Y+4	; 0x04
    39d0:	3d 81       	ldd	r19, Y+5	; 0x05
    39d2:	8a 81       	ldd	r24, Y+2	; 0x02
    39d4:	9b 81       	ldd	r25, Y+3	; 0x03
    39d6:	82 17       	cp	r24, r18
    39d8:	93 07       	cpc	r25, r19
    39da:	10 f4       	brcc	.+4      	; 0x39e0 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    39dc:	81 e0       	ldi	r24, 0x01	; 1
    39de:	89 83       	std	Y+1, r24	; 0x01
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    39e0:	8f 81       	ldd	r24, Y+7	; 0x07
    39e2:	98 85       	ldd	r25, Y+8	; 0x08
    39e4:	2c 81       	ldd	r18, Y+4	; 0x04
    39e6:	3d 81       	ldd	r19, Y+5	; 0x05
    39e8:	fc 01       	movw	r30, r24
    39ea:	31 83       	std	Z+1, r19	; 0x01
    39ec:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
    39ee:	89 81       	ldd	r24, Y+1	; 0x01
    39f0:	88 23       	and	r24, r24
    39f2:	59 f0       	breq	.+22     	; 0x3a0a <vTaskDelayUntil+0xd0>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    39f4:	80 91 42 02 	lds	r24, 0x0242
    39f8:	90 91 43 02 	lds	r25, 0x0243
    39fc:	02 96       	adiw	r24, 0x02	; 2
    39fe:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3a02:	8c 81       	ldd	r24, Y+4	; 0x04
    3a04:	9d 81       	ldd	r25, Y+5	; 0x05
    3a06:	0e 94 77 25 	call	0x4aee	; 0x4aee <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    3a0a:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>
    3a0e:	8e 83       	std	Y+6, r24	; 0x06

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3a10:	8e 81       	ldd	r24, Y+6	; 0x06
    3a12:	88 23       	and	r24, r24
    3a14:	11 f4       	brne	.+4      	; 0x3a1a <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
    3a16:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3a1a:	2a 96       	adiw	r28, 0x0a	; 10
    3a1c:	0f b6       	in	r0, 0x3f	; 63
    3a1e:	f8 94       	cli
    3a20:	de bf       	out	0x3e, r29	; 62
    3a22:	0f be       	out	0x3f, r0	; 63
    3a24:	cd bf       	out	0x3d, r28	; 61
    3a26:	df 91       	pop	r29
    3a28:	cf 91       	pop	r28
    3a2a:	08 95       	ret

00003a2c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3a2c:	cf 93       	push	r28
    3a2e:	df 93       	push	r29
    3a30:	00 d0       	rcall	.+0      	; 0x3a32 <vTaskDelay+0x6>
    3a32:	1f 92       	push	r1
    3a34:	1f 92       	push	r1
    3a36:	cd b7       	in	r28, 0x3d	; 61
    3a38:	de b7       	in	r29, 0x3e	; 62
    3a3a:	9d 83       	std	Y+5, r25	; 0x05
    3a3c:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    3a3e:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3a40:	8c 81       	ldd	r24, Y+4	; 0x04
    3a42:	9d 81       	ldd	r25, Y+5	; 0x05
    3a44:	00 97       	sbiw	r24, 0x00	; 0
    3a46:	d1 f0       	breq	.+52     	; 0x3a7c <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    3a48:	0e 94 13 20 	call	0x4026	; 0x4026 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    3a4c:	20 91 9b 02 	lds	r18, 0x029B
    3a50:	30 91 9c 02 	lds	r19, 0x029C
    3a54:	8c 81       	ldd	r24, Y+4	; 0x04
    3a56:	9d 81       	ldd	r25, Y+5	; 0x05
    3a58:	82 0f       	add	r24, r18
    3a5a:	93 1f       	adc	r25, r19
    3a5c:	9b 83       	std	Y+3, r25	; 0x03
    3a5e:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3a60:	80 91 42 02 	lds	r24, 0x0242
    3a64:	90 91 43 02 	lds	r25, 0x0243
    3a68:	02 96       	adiw	r24, 0x02	; 2
    3a6a:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3a6e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a70:	9b 81       	ldd	r25, Y+3	; 0x03
    3a72:	0e 94 77 25 	call	0x4aee	; 0x4aee <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3a76:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>
    3a7a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3a7c:	89 81       	ldd	r24, Y+1	; 0x01
    3a7e:	88 23       	and	r24, r24
    3a80:	11 f4       	brne	.+4      	; 0x3a86 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    3a82:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3a86:	0f 90       	pop	r0
    3a88:	0f 90       	pop	r0
    3a8a:	0f 90       	pop	r0
    3a8c:	0f 90       	pop	r0
    3a8e:	0f 90       	pop	r0
    3a90:	df 91       	pop	r29
    3a92:	cf 91       	pop	r28
    3a94:	08 95       	ret

00003a96 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
    3a96:	cf 93       	push	r28
    3a98:	df 93       	push	r29
    3a9a:	00 d0       	rcall	.+0      	; 0x3a9c <uxTaskPriorityGet+0x6>
    3a9c:	1f 92       	push	r1
    3a9e:	1f 92       	push	r1
    3aa0:	cd b7       	in	r28, 0x3d	; 61
    3aa2:	de b7       	in	r29, 0x3e	; 62
    3aa4:	9d 83       	std	Y+5, r25	; 0x05
    3aa6:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    3aa8:	0f b6       	in	r0, 0x3f	; 63
    3aaa:	f8 94       	cli
    3aac:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    3aae:	8c 81       	ldd	r24, Y+4	; 0x04
    3ab0:	9d 81       	ldd	r25, Y+5	; 0x05
    3ab2:	00 97       	sbiw	r24, 0x00	; 0
    3ab4:	29 f4       	brne	.+10     	; 0x3ac0 <uxTaskPriorityGet+0x2a>
    3ab6:	80 91 42 02 	lds	r24, 0x0242
    3aba:	90 91 43 02 	lds	r25, 0x0243
    3abe:	02 c0       	rjmp	.+4      	; 0x3ac4 <uxTaskPriorityGet+0x2e>
    3ac0:	8c 81       	ldd	r24, Y+4	; 0x04
    3ac2:	9d 81       	ldd	r25, Y+5	; 0x05
    3ac4:	9a 83       	std	Y+2, r25	; 0x02
    3ac6:	89 83       	std	Y+1, r24	; 0x01
			uxReturn = pxTCB->uxPriority;
    3ac8:	89 81       	ldd	r24, Y+1	; 0x01
    3aca:	9a 81       	ldd	r25, Y+2	; 0x02
    3acc:	fc 01       	movw	r30, r24
    3ace:	86 89       	ldd	r24, Z+22	; 0x16
    3ad0:	8b 83       	std	Y+3, r24	; 0x03
		}
		taskEXIT_CRITICAL();
    3ad2:	0f 90       	pop	r0
    3ad4:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    3ad6:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3ad8:	0f 90       	pop	r0
    3ada:	0f 90       	pop	r0
    3adc:	0f 90       	pop	r0
    3ade:	0f 90       	pop	r0
    3ae0:	0f 90       	pop	r0
    3ae2:	df 91       	pop	r29
    3ae4:	cf 91       	pop	r28
    3ae6:	08 95       	ret

00003ae8 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
	{
    3ae8:	cf 93       	push	r28
    3aea:	df 93       	push	r29
    3aec:	00 d0       	rcall	.+0      	; 0x3aee <uxTaskPriorityGetFromISR+0x6>
    3aee:	00 d0       	rcall	.+0      	; 0x3af0 <uxTaskPriorityGetFromISR+0x8>
    3af0:	cd b7       	in	r28, 0x3d	; 61
    3af2:	de b7       	in	r29, 0x3e	; 62
    3af4:	9e 83       	std	Y+6, r25	; 0x06
    3af6:	8d 83       	std	Y+5, r24	; 0x05
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
    3af8:	19 82       	std	Y+1, r1	; 0x01
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    3afa:	8d 81       	ldd	r24, Y+5	; 0x05
    3afc:	9e 81       	ldd	r25, Y+6	; 0x06
    3afe:	00 97       	sbiw	r24, 0x00	; 0
    3b00:	29 f4       	brne	.+10     	; 0x3b0c <uxTaskPriorityGetFromISR+0x24>
    3b02:	80 91 42 02 	lds	r24, 0x0242
    3b06:	90 91 43 02 	lds	r25, 0x0243
    3b0a:	02 c0       	rjmp	.+4      	; 0x3b10 <uxTaskPriorityGetFromISR+0x28>
    3b0c:	8d 81       	ldd	r24, Y+5	; 0x05
    3b0e:	9e 81       	ldd	r25, Y+6	; 0x06
    3b10:	9b 83       	std	Y+3, r25	; 0x03
    3b12:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    3b14:	8a 81       	ldd	r24, Y+2	; 0x02
    3b16:	9b 81       	ldd	r25, Y+3	; 0x03
    3b18:	fc 01       	movw	r30, r24
    3b1a:	86 89       	ldd	r24, Z+22	; 0x16
    3b1c:	8c 83       	std	Y+4, r24	; 0x04
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
    3b1e:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    3b20:	26 96       	adiw	r28, 0x06	; 6
    3b22:	0f b6       	in	r0, 0x3f	; 63
    3b24:	f8 94       	cli
    3b26:	de bf       	out	0x3e, r29	; 62
    3b28:	0f be       	out	0x3f, r0	; 63
    3b2a:	cd bf       	out	0x3d, r28	; 61
    3b2c:	df 91       	pop	r29
    3b2e:	cf 91       	pop	r28
    3b30:	08 95       	ret

00003b32 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    3b32:	cf 93       	push	r28
    3b34:	df 93       	push	r29
    3b36:	cd b7       	in	r28, 0x3d	; 61
    3b38:	de b7       	in	r29, 0x3e	; 62
    3b3a:	28 97       	sbiw	r28, 0x08	; 8
    3b3c:	0f b6       	in	r0, 0x3f	; 63
    3b3e:	f8 94       	cli
    3b40:	de bf       	out	0x3e, r29	; 62
    3b42:	0f be       	out	0x3f, r0	; 63
    3b44:	cd bf       	out	0x3d, r28	; 61
    3b46:	9f 83       	std	Y+7, r25	; 0x07
    3b48:	8e 83       	std	Y+6, r24	; 0x06
    3b4a:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    3b4c:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3b4e:	88 85       	ldd	r24, Y+8	; 0x08
    3b50:	84 30       	cpi	r24, 0x04	; 4
    3b52:	10 f0       	brcs	.+4      	; 0x3b58 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3b54:	83 e0       	ldi	r24, 0x03	; 3
    3b56:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    3b58:	0f b6       	in	r0, 0x3f	; 63
    3b5a:	f8 94       	cli
    3b5c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    3b5e:	8e 81       	ldd	r24, Y+6	; 0x06
    3b60:	9f 81       	ldd	r25, Y+7	; 0x07
    3b62:	00 97       	sbiw	r24, 0x00	; 0
    3b64:	29 f4       	brne	.+10     	; 0x3b70 <vTaskPrioritySet+0x3e>
    3b66:	80 91 42 02 	lds	r24, 0x0242
    3b6a:	90 91 43 02 	lds	r25, 0x0243
    3b6e:	02 c0       	rjmp	.+4      	; 0x3b74 <vTaskPrioritySet+0x42>
    3b70:	8e 81       	ldd	r24, Y+6	; 0x06
    3b72:	9f 81       	ldd	r25, Y+7	; 0x07
    3b74:	9b 83       	std	Y+3, r25	; 0x03
    3b76:	8a 83       	std	Y+2, r24	; 0x02

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    3b78:	8a 81       	ldd	r24, Y+2	; 0x02
    3b7a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b7c:	fc 01       	movw	r30, r24
    3b7e:	81 a1       	ldd	r24, Z+33	; 0x21
    3b80:	8c 83       	std	Y+4, r24	; 0x04
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    3b82:	9c 81       	ldd	r25, Y+4	; 0x04
    3b84:	88 85       	ldd	r24, Y+8	; 0x08
    3b86:	98 17       	cp	r25, r24
    3b88:	09 f4       	brne	.+2      	; 0x3b8c <vTaskPrioritySet+0x5a>
    3b8a:	97 c0       	rjmp	.+302    	; 0x3cba <vTaskPrioritySet+0x188>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    3b8c:	98 85       	ldd	r25, Y+8	; 0x08
    3b8e:	8c 81       	ldd	r24, Y+4	; 0x04
    3b90:	89 17       	cp	r24, r25
    3b92:	a8 f4       	brcc	.+42     	; 0x3bbe <vTaskPrioritySet+0x8c>
				{
					if( pxTCB != pxCurrentTCB )
    3b94:	80 91 42 02 	lds	r24, 0x0242
    3b98:	90 91 43 02 	lds	r25, 0x0243
    3b9c:	2a 81       	ldd	r18, Y+2	; 0x02
    3b9e:	3b 81       	ldd	r19, Y+3	; 0x03
    3ba0:	28 17       	cp	r18, r24
    3ba2:	39 07       	cpc	r19, r25
    3ba4:	b9 f0       	breq	.+46     	; 0x3bd4 <vTaskPrioritySet+0xa2>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    3ba6:	80 91 42 02 	lds	r24, 0x0242
    3baa:	90 91 43 02 	lds	r25, 0x0243
    3bae:	fc 01       	movw	r30, r24
    3bb0:	96 89       	ldd	r25, Z+22	; 0x16
    3bb2:	88 85       	ldd	r24, Y+8	; 0x08
    3bb4:	89 17       	cp	r24, r25
    3bb6:	70 f0       	brcs	.+28     	; 0x3bd4 <vTaskPrioritySet+0xa2>
						{
							xYieldRequired = pdTRUE;
    3bb8:	81 e0       	ldi	r24, 0x01	; 1
    3bba:	89 83       	std	Y+1, r24	; 0x01
    3bbc:	0b c0       	rjmp	.+22     	; 0x3bd4 <vTaskPrioritySet+0xa2>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    3bbe:	80 91 42 02 	lds	r24, 0x0242
    3bc2:	90 91 43 02 	lds	r25, 0x0243
    3bc6:	2a 81       	ldd	r18, Y+2	; 0x02
    3bc8:	3b 81       	ldd	r19, Y+3	; 0x03
    3bca:	28 17       	cp	r18, r24
    3bcc:	39 07       	cpc	r19, r25
    3bce:	11 f4       	brne	.+4      	; 0x3bd4 <vTaskPrioritySet+0xa2>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    3bd0:	81 e0       	ldi	r24, 0x01	; 1
    3bd2:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    3bd4:	8a 81       	ldd	r24, Y+2	; 0x02
    3bd6:	9b 81       	ldd	r25, Y+3	; 0x03
    3bd8:	fc 01       	movw	r30, r24
    3bda:	86 89       	ldd	r24, Z+22	; 0x16
    3bdc:	8d 83       	std	Y+5, r24	; 0x05

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    3bde:	8a 81       	ldd	r24, Y+2	; 0x02
    3be0:	9b 81       	ldd	r25, Y+3	; 0x03
    3be2:	fc 01       	movw	r30, r24
    3be4:	21 a1       	ldd	r18, Z+33	; 0x21
    3be6:	8a 81       	ldd	r24, Y+2	; 0x02
    3be8:	9b 81       	ldd	r25, Y+3	; 0x03
    3bea:	fc 01       	movw	r30, r24
    3bec:	86 89       	ldd	r24, Z+22	; 0x16
    3bee:	28 17       	cp	r18, r24
    3bf0:	29 f4       	brne	.+10     	; 0x3bfc <vTaskPrioritySet+0xca>
					{
						pxTCB->uxPriority = uxNewPriority;
    3bf2:	8a 81       	ldd	r24, Y+2	; 0x02
    3bf4:	9b 81       	ldd	r25, Y+3	; 0x03
    3bf6:	28 85       	ldd	r18, Y+8	; 0x08
    3bf8:	fc 01       	movw	r30, r24
    3bfa:	26 8b       	std	Z+22, r18	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    3bfc:	8a 81       	ldd	r24, Y+2	; 0x02
    3bfe:	9b 81       	ldd	r25, Y+3	; 0x03
    3c00:	28 85       	ldd	r18, Y+8	; 0x08
    3c02:	fc 01       	movw	r30, r24
    3c04:	21 a3       	std	Z+33, r18	; 0x21
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    3c06:	8a 81       	ldd	r24, Y+2	; 0x02
    3c08:	9b 81       	ldd	r25, Y+3	; 0x03
    3c0a:	fc 01       	movw	r30, r24
    3c0c:	84 85       	ldd	r24, Z+12	; 0x0c
    3c0e:	95 85       	ldd	r25, Z+13	; 0x0d
    3c10:	99 23       	and	r25, r25
    3c12:	64 f0       	brlt	.+24     	; 0x3c2c <vTaskPrioritySet+0xfa>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3c14:	88 85       	ldd	r24, Y+8	; 0x08
    3c16:	88 2f       	mov	r24, r24
    3c18:	90 e0       	ldi	r25, 0x00	; 0
    3c1a:	24 e0       	ldi	r18, 0x04	; 4
    3c1c:	30 e0       	ldi	r19, 0x00	; 0
    3c1e:	28 1b       	sub	r18, r24
    3c20:	39 0b       	sbc	r19, r25
    3c22:	8a 81       	ldd	r24, Y+2	; 0x02
    3c24:	9b 81       	ldd	r25, Y+3	; 0x03
    3c26:	fc 01       	movw	r30, r24
    3c28:	35 87       	std	Z+13, r19	; 0x0d
    3c2a:	24 87       	std	Z+12, r18	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3c2c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c2e:	9b 81       	ldd	r25, Y+3	; 0x03
    3c30:	fc 01       	movw	r30, r24
    3c32:	42 85       	ldd	r20, Z+10	; 0x0a
    3c34:	53 85       	ldd	r21, Z+11	; 0x0b
    3c36:	8d 81       	ldd	r24, Y+5	; 0x05
    3c38:	28 2f       	mov	r18, r24
    3c3a:	30 e0       	ldi	r19, 0x00	; 0
    3c3c:	c9 01       	movw	r24, r18
    3c3e:	88 0f       	add	r24, r24
    3c40:	99 1f       	adc	r25, r25
    3c42:	88 0f       	add	r24, r24
    3c44:	99 1f       	adc	r25, r25
    3c46:	88 0f       	add	r24, r24
    3c48:	99 1f       	adc	r25, r25
    3c4a:	82 0f       	add	r24, r18
    3c4c:	93 1f       	adc	r25, r19
    3c4e:	8c 5b       	subi	r24, 0xBC	; 188
    3c50:	9d 4f       	sbci	r25, 0xFD	; 253
    3c52:	48 17       	cp	r20, r24
    3c54:	59 07       	cpc	r21, r25
    3c56:	61 f5       	brne	.+88     	; 0x3cb0 <vTaskPrioritySet+0x17e>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3c58:	8a 81       	ldd	r24, Y+2	; 0x02
    3c5a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c5c:	02 96       	adiw	r24, 0x02	; 2
    3c5e:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    3c62:	8a 81       	ldd	r24, Y+2	; 0x02
    3c64:	9b 81       	ldd	r25, Y+3	; 0x03
    3c66:	fc 01       	movw	r30, r24
    3c68:	96 89       	ldd	r25, Z+22	; 0x16
    3c6a:	80 91 9d 02 	lds	r24, 0x029D
    3c6e:	89 17       	cp	r24, r25
    3c70:	30 f4       	brcc	.+12     	; 0x3c7e <vTaskPrioritySet+0x14c>
    3c72:	8a 81       	ldd	r24, Y+2	; 0x02
    3c74:	9b 81       	ldd	r25, Y+3	; 0x03
    3c76:	fc 01       	movw	r30, r24
    3c78:	86 89       	ldd	r24, Z+22	; 0x16
    3c7a:	80 93 9d 02 	sts	0x029D, r24
    3c7e:	8a 81       	ldd	r24, Y+2	; 0x02
    3c80:	9b 81       	ldd	r25, Y+3	; 0x03
    3c82:	ac 01       	movw	r20, r24
    3c84:	4e 5f       	subi	r20, 0xFE	; 254
    3c86:	5f 4f       	sbci	r21, 0xFF	; 255
    3c88:	8a 81       	ldd	r24, Y+2	; 0x02
    3c8a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c8c:	fc 01       	movw	r30, r24
    3c8e:	86 89       	ldd	r24, Z+22	; 0x16
    3c90:	28 2f       	mov	r18, r24
    3c92:	30 e0       	ldi	r19, 0x00	; 0
    3c94:	c9 01       	movw	r24, r18
    3c96:	88 0f       	add	r24, r24
    3c98:	99 1f       	adc	r25, r25
    3c9a:	88 0f       	add	r24, r24
    3c9c:	99 1f       	adc	r25, r25
    3c9e:	88 0f       	add	r24, r24
    3ca0:	99 1f       	adc	r25, r25
    3ca2:	82 0f       	add	r24, r18
    3ca4:	93 1f       	adc	r25, r19
    3ca6:	8c 5b       	subi	r24, 0xBC	; 188
    3ca8:	9d 4f       	sbci	r25, 0xFD	; 253
    3caa:	ba 01       	movw	r22, r20
    3cac:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired == pdTRUE )
    3cb0:	89 81       	ldd	r24, Y+1	; 0x01
    3cb2:	81 30       	cpi	r24, 0x01	; 1
    3cb4:	11 f4       	brne	.+4      	; 0x3cba <vTaskPrioritySet+0x188>
				{
					taskYIELD_IF_USING_PREEMPTION();
    3cb6:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    3cba:	0f 90       	pop	r0
    3cbc:	0f be       	out	0x3f, r0	; 63
	}
    3cbe:	28 96       	adiw	r28, 0x08	; 8
    3cc0:	0f b6       	in	r0, 0x3f	; 63
    3cc2:	f8 94       	cli
    3cc4:	de bf       	out	0x3e, r29	; 62
    3cc6:	0f be       	out	0x3f, r0	; 63
    3cc8:	cd bf       	out	0x3d, r28	; 61
    3cca:	df 91       	pop	r29
    3ccc:	cf 91       	pop	r28
    3cce:	08 95       	ret

00003cd0 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    3cd0:	cf 93       	push	r28
    3cd2:	df 93       	push	r29
    3cd4:	00 d0       	rcall	.+0      	; 0x3cd6 <vTaskSuspend+0x6>
    3cd6:	1f 92       	push	r1
    3cd8:	cd b7       	in	r28, 0x3d	; 61
    3cda:	de b7       	in	r29, 0x3e	; 62
    3cdc:	9c 83       	std	Y+4, r25	; 0x04
    3cde:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3ce0:	0f b6       	in	r0, 0x3f	; 63
    3ce2:	f8 94       	cli
    3ce4:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    3ce6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ce8:	9c 81       	ldd	r25, Y+4	; 0x04
    3cea:	00 97       	sbiw	r24, 0x00	; 0
    3cec:	29 f4       	brne	.+10     	; 0x3cf8 <vTaskSuspend+0x28>
    3cee:	80 91 42 02 	lds	r24, 0x0242
    3cf2:	90 91 43 02 	lds	r25, 0x0243
    3cf6:	02 c0       	rjmp	.+4      	; 0x3cfc <vTaskSuspend+0x2c>
    3cf8:	8b 81       	ldd	r24, Y+3	; 0x03
    3cfa:	9c 81       	ldd	r25, Y+4	; 0x04
    3cfc:	9a 83       	std	Y+2, r25	; 0x02
    3cfe:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3d00:	89 81       	ldd	r24, Y+1	; 0x01
    3d02:	9a 81       	ldd	r25, Y+2	; 0x02
    3d04:	02 96       	adiw	r24, 0x02	; 2
    3d06:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3d0a:	89 81       	ldd	r24, Y+1	; 0x01
    3d0c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d0e:	fc 01       	movw	r30, r24
    3d10:	84 89       	ldd	r24, Z+20	; 0x14
    3d12:	95 89       	ldd	r25, Z+21	; 0x15
    3d14:	00 97       	sbiw	r24, 0x00	; 0
    3d16:	29 f0       	breq	.+10     	; 0x3d22 <vTaskSuspend+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3d18:	89 81       	ldd	r24, Y+1	; 0x01
    3d1a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d1c:	0c 96       	adiw	r24, 0x0c	; 12
    3d1e:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    3d22:	89 81       	ldd	r24, Y+1	; 0x01
    3d24:	9a 81       	ldd	r25, Y+2	; 0x02
    3d26:	02 96       	adiw	r24, 0x02	; 2
    3d28:	bc 01       	movw	r22, r24
    3d2a:	81 e9       	ldi	r24, 0x91	; 145
    3d2c:	92 e0       	ldi	r25, 0x02	; 2
    3d2e:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    3d32:	0f 90       	pop	r0
    3d34:	0f be       	out	0x3f, r0	; 63

		if( pxTCB == pxCurrentTCB )
    3d36:	80 91 42 02 	lds	r24, 0x0242
    3d3a:	90 91 43 02 	lds	r25, 0x0243
    3d3e:	29 81       	ldd	r18, Y+1	; 0x01
    3d40:	3a 81       	ldd	r19, Y+2	; 0x02
    3d42:	28 17       	cp	r18, r24
    3d44:	39 07       	cpc	r19, r25
    3d46:	a9 f4       	brne	.+42     	; 0x3d72 <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
    3d48:	80 91 9e 02 	lds	r24, 0x029E
    3d4c:	88 23       	and	r24, r24
    3d4e:	19 f0       	breq	.+6      	; 0x3d56 <vTaskSuspend+0x86>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3d50:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
    3d54:	19 c0       	rjmp	.+50     	; 0x3d88 <vTaskSuspend+0xb8>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    3d56:	90 91 91 02 	lds	r25, 0x0291
    3d5a:	80 91 9a 02 	lds	r24, 0x029A
    3d5e:	98 17       	cp	r25, r24
    3d60:	29 f4       	brne	.+10     	; 0x3d6c <vTaskSuspend+0x9c>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3d62:	10 92 43 02 	sts	0x0243, r1
    3d66:	10 92 42 02 	sts	0x0242, r1
    3d6a:	0e c0       	rjmp	.+28     	; 0x3d88 <vTaskSuspend+0xb8>
				}
				else
				{
					vTaskSwitchContext();
    3d6c:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSwitchContext>
    3d70:	0b c0       	rjmp	.+22     	; 0x3d88 <vTaskSuspend+0xb8>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
    3d72:	80 91 9e 02 	lds	r24, 0x029E
    3d76:	88 23       	and	r24, r24
    3d78:	39 f0       	breq	.+14     	; 0x3d88 <vTaskSuspend+0xb8>
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
    3d7a:	0f b6       	in	r0, 0x3f	; 63
    3d7c:	f8 94       	cli
    3d7e:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    3d80:	0e 94 8a 26 	call	0x4d14	; 0x4d14 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    3d84:	0f 90       	pop	r0
    3d86:	0f be       	out	0x3f, r0	; 63
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    3d88:	0f 90       	pop	r0
    3d8a:	0f 90       	pop	r0
    3d8c:	0f 90       	pop	r0
    3d8e:	0f 90       	pop	r0
    3d90:	df 91       	pop	r29
    3d92:	cf 91       	pop	r28
    3d94:	08 95       	ret

00003d96 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    3d96:	cf 93       	push	r28
    3d98:	df 93       	push	r29
    3d9a:	00 d0       	rcall	.+0      	; 0x3d9c <prvTaskIsTaskSuspended+0x6>
    3d9c:	1f 92       	push	r1
    3d9e:	1f 92       	push	r1
    3da0:	cd b7       	in	r28, 0x3d	; 61
    3da2:	de b7       	in	r29, 0x3e	; 62
    3da4:	9d 83       	std	Y+5, r25	; 0x05
    3da6:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    3da8:	19 82       	std	Y+1, r1	; 0x01
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    3daa:	8c 81       	ldd	r24, Y+4	; 0x04
    3dac:	9d 81       	ldd	r25, Y+5	; 0x05
    3dae:	9b 83       	std	Y+3, r25	; 0x03
    3db0:	8a 83       	std	Y+2, r24	; 0x02

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3db2:	8a 81       	ldd	r24, Y+2	; 0x02
    3db4:	9b 81       	ldd	r25, Y+3	; 0x03
    3db6:	fc 01       	movw	r30, r24
    3db8:	82 85       	ldd	r24, Z+10	; 0x0a
    3dba:	93 85       	ldd	r25, Z+11	; 0x0b
    3dbc:	f2 e0       	ldi	r31, 0x02	; 2
    3dbe:	81 39       	cpi	r24, 0x91	; 145
    3dc0:	9f 07       	cpc	r25, r31
    3dc2:	91 f4       	brne	.+36     	; 0x3de8 <prvTaskIsTaskSuspended+0x52>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    3dc4:	8a 81       	ldd	r24, Y+2	; 0x02
    3dc6:	9b 81       	ldd	r25, Y+3	; 0x03
    3dc8:	fc 01       	movw	r30, r24
    3dca:	84 89       	ldd	r24, Z+20	; 0x14
    3dcc:	95 89       	ldd	r25, Z+21	; 0x15
    3dce:	f2 e0       	ldi	r31, 0x02	; 2
    3dd0:	8e 37       	cpi	r24, 0x7E	; 126
    3dd2:	9f 07       	cpc	r25, r31
    3dd4:	49 f0       	breq	.+18     	; 0x3de8 <prvTaskIsTaskSuspended+0x52>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    3dd6:	8a 81       	ldd	r24, Y+2	; 0x02
    3dd8:	9b 81       	ldd	r25, Y+3	; 0x03
    3dda:	fc 01       	movw	r30, r24
    3ddc:	84 89       	ldd	r24, Z+20	; 0x14
    3dde:	95 89       	ldd	r25, Z+21	; 0x15
    3de0:	00 97       	sbiw	r24, 0x00	; 0
    3de2:	11 f4       	brne	.+4      	; 0x3de8 <prvTaskIsTaskSuspended+0x52>
				{
					xReturn = pdTRUE;
    3de4:	81 e0       	ldi	r24, 0x01	; 1
    3de6:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3de8:	89 81       	ldd	r24, Y+1	; 0x01
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    3dea:	0f 90       	pop	r0
    3dec:	0f 90       	pop	r0
    3dee:	0f 90       	pop	r0
    3df0:	0f 90       	pop	r0
    3df2:	0f 90       	pop	r0
    3df4:	df 91       	pop	r29
    3df6:	cf 91       	pop	r28
    3df8:	08 95       	ret

00003dfa <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    3dfa:	cf 93       	push	r28
    3dfc:	df 93       	push	r29
    3dfe:	00 d0       	rcall	.+0      	; 0x3e00 <vTaskResume+0x6>
    3e00:	1f 92       	push	r1
    3e02:	cd b7       	in	r28, 0x3d	; 61
    3e04:	de b7       	in	r29, 0x3e	; 62
    3e06:	9c 83       	std	Y+4, r25	; 0x04
    3e08:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    3e0a:	8b 81       	ldd	r24, Y+3	; 0x03
    3e0c:	9c 81       	ldd	r25, Y+4	; 0x04
    3e0e:	9a 83       	std	Y+2, r25	; 0x02
    3e10:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    3e12:	89 81       	ldd	r24, Y+1	; 0x01
    3e14:	9a 81       	ldd	r25, Y+2	; 0x02
    3e16:	00 97       	sbiw	r24, 0x00	; 0
    3e18:	09 f4       	brne	.+2      	; 0x3e1c <vTaskResume+0x22>
    3e1a:	4f c0       	rjmp	.+158    	; 0x3eba <vTaskResume+0xc0>
    3e1c:	80 91 42 02 	lds	r24, 0x0242
    3e20:	90 91 43 02 	lds	r25, 0x0243
    3e24:	29 81       	ldd	r18, Y+1	; 0x01
    3e26:	3a 81       	ldd	r19, Y+2	; 0x02
    3e28:	28 17       	cp	r18, r24
    3e2a:	39 07       	cpc	r19, r25
    3e2c:	09 f4       	brne	.+2      	; 0x3e30 <vTaskResume+0x36>
    3e2e:	45 c0       	rjmp	.+138    	; 0x3eba <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
    3e30:	0f b6       	in	r0, 0x3f	; 63
    3e32:	f8 94       	cli
    3e34:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    3e36:	89 81       	ldd	r24, Y+1	; 0x01
    3e38:	9a 81       	ldd	r25, Y+2	; 0x02
    3e3a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <prvTaskIsTaskSuspended>
    3e3e:	81 30       	cpi	r24, 0x01	; 1
    3e40:	d1 f5       	brne	.+116    	; 0x3eb6 <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    3e42:	89 81       	ldd	r24, Y+1	; 0x01
    3e44:	9a 81       	ldd	r25, Y+2	; 0x02
    3e46:	02 96       	adiw	r24, 0x02	; 2
    3e48:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3e4c:	89 81       	ldd	r24, Y+1	; 0x01
    3e4e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e50:	fc 01       	movw	r30, r24
    3e52:	96 89       	ldd	r25, Z+22	; 0x16
    3e54:	80 91 9d 02 	lds	r24, 0x029D
    3e58:	89 17       	cp	r24, r25
    3e5a:	30 f4       	brcc	.+12     	; 0x3e68 <vTaskResume+0x6e>
    3e5c:	89 81       	ldd	r24, Y+1	; 0x01
    3e5e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e60:	fc 01       	movw	r30, r24
    3e62:	86 89       	ldd	r24, Z+22	; 0x16
    3e64:	80 93 9d 02 	sts	0x029D, r24
    3e68:	89 81       	ldd	r24, Y+1	; 0x01
    3e6a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e6c:	ac 01       	movw	r20, r24
    3e6e:	4e 5f       	subi	r20, 0xFE	; 254
    3e70:	5f 4f       	sbci	r21, 0xFF	; 255
    3e72:	89 81       	ldd	r24, Y+1	; 0x01
    3e74:	9a 81       	ldd	r25, Y+2	; 0x02
    3e76:	fc 01       	movw	r30, r24
    3e78:	86 89       	ldd	r24, Z+22	; 0x16
    3e7a:	28 2f       	mov	r18, r24
    3e7c:	30 e0       	ldi	r19, 0x00	; 0
    3e7e:	c9 01       	movw	r24, r18
    3e80:	88 0f       	add	r24, r24
    3e82:	99 1f       	adc	r25, r25
    3e84:	88 0f       	add	r24, r24
    3e86:	99 1f       	adc	r25, r25
    3e88:	88 0f       	add	r24, r24
    3e8a:	99 1f       	adc	r25, r25
    3e8c:	82 0f       	add	r24, r18
    3e8e:	93 1f       	adc	r25, r19
    3e90:	8c 5b       	subi	r24, 0xBC	; 188
    3e92:	9d 4f       	sbci	r25, 0xFD	; 253
    3e94:	ba 01       	movw	r22, r20
    3e96:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3e9a:	89 81       	ldd	r24, Y+1	; 0x01
    3e9c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e9e:	fc 01       	movw	r30, r24
    3ea0:	26 89       	ldd	r18, Z+22	; 0x16
    3ea2:	80 91 42 02 	lds	r24, 0x0242
    3ea6:	90 91 43 02 	lds	r25, 0x0243
    3eaa:	fc 01       	movw	r30, r24
    3eac:	86 89       	ldd	r24, Z+22	; 0x16
    3eae:	28 17       	cp	r18, r24
    3eb0:	10 f0       	brcs	.+4      	; 0x3eb6 <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    3eb2:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    3eb6:	0f 90       	pop	r0
    3eb8:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3eba:	0f 90       	pop	r0
    3ebc:	0f 90       	pop	r0
    3ebe:	0f 90       	pop	r0
    3ec0:	0f 90       	pop	r0
    3ec2:	df 91       	pop	r29
    3ec4:	cf 91       	pop	r28
    3ec6:	08 95       	ret

00003ec8 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    3ec8:	cf 93       	push	r28
    3eca:	df 93       	push	r29
    3ecc:	00 d0       	rcall	.+0      	; 0x3ece <xTaskResumeFromISR+0x6>
    3ece:	00 d0       	rcall	.+0      	; 0x3ed0 <xTaskResumeFromISR+0x8>
    3ed0:	cd b7       	in	r28, 0x3d	; 61
    3ed2:	de b7       	in	r29, 0x3e	; 62
    3ed4:	9e 83       	std	Y+6, r25	; 0x06
    3ed6:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    3ed8:	19 82       	std	Y+1, r1	; 0x01
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    3eda:	8d 81       	ldd	r24, Y+5	; 0x05
    3edc:	9e 81       	ldd	r25, Y+6	; 0x06
    3ede:	9b 83       	std	Y+3, r25	; 0x03
    3ee0:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3ee2:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    3ee4:	8a 81       	ldd	r24, Y+2	; 0x02
    3ee6:	9b 81       	ldd	r25, Y+3	; 0x03
    3ee8:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <prvTaskIsTaskSuspended>
    3eec:	81 30       	cpi	r24, 0x01	; 1
    3eee:	09 f0       	breq	.+2      	; 0x3ef2 <xTaskResumeFromISR+0x2a>
    3ef0:	47 c0       	rjmp	.+142    	; 0x3f80 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3ef2:	80 91 a5 02 	lds	r24, 0x02A5
    3ef6:	88 23       	and	r24, r24
    3ef8:	d9 f5       	brne	.+118    	; 0x3f70 <xTaskResumeFromISR+0xa8>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3efa:	8a 81       	ldd	r24, Y+2	; 0x02
    3efc:	9b 81       	ldd	r25, Y+3	; 0x03
    3efe:	fc 01       	movw	r30, r24
    3f00:	26 89       	ldd	r18, Z+22	; 0x16
    3f02:	80 91 42 02 	lds	r24, 0x0242
    3f06:	90 91 43 02 	lds	r25, 0x0243
    3f0a:	fc 01       	movw	r30, r24
    3f0c:	86 89       	ldd	r24, Z+22	; 0x16
    3f0e:	28 17       	cp	r18, r24
    3f10:	10 f0       	brcs	.+4      	; 0x3f16 <xTaskResumeFromISR+0x4e>
					{
						xYieldRequired = pdTRUE;
    3f12:	81 e0       	ldi	r24, 0x01	; 1
    3f14:	89 83       	std	Y+1, r24	; 0x01
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    3f16:	8a 81       	ldd	r24, Y+2	; 0x02
    3f18:	9b 81       	ldd	r25, Y+3	; 0x03
    3f1a:	02 96       	adiw	r24, 0x02	; 2
    3f1c:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3f20:	8a 81       	ldd	r24, Y+2	; 0x02
    3f22:	9b 81       	ldd	r25, Y+3	; 0x03
    3f24:	fc 01       	movw	r30, r24
    3f26:	96 89       	ldd	r25, Z+22	; 0x16
    3f28:	80 91 9d 02 	lds	r24, 0x029D
    3f2c:	89 17       	cp	r24, r25
    3f2e:	30 f4       	brcc	.+12     	; 0x3f3c <xTaskResumeFromISR+0x74>
    3f30:	8a 81       	ldd	r24, Y+2	; 0x02
    3f32:	9b 81       	ldd	r25, Y+3	; 0x03
    3f34:	fc 01       	movw	r30, r24
    3f36:	86 89       	ldd	r24, Z+22	; 0x16
    3f38:	80 93 9d 02 	sts	0x029D, r24
    3f3c:	8a 81       	ldd	r24, Y+2	; 0x02
    3f3e:	9b 81       	ldd	r25, Y+3	; 0x03
    3f40:	ac 01       	movw	r20, r24
    3f42:	4e 5f       	subi	r20, 0xFE	; 254
    3f44:	5f 4f       	sbci	r21, 0xFF	; 255
    3f46:	8a 81       	ldd	r24, Y+2	; 0x02
    3f48:	9b 81       	ldd	r25, Y+3	; 0x03
    3f4a:	fc 01       	movw	r30, r24
    3f4c:	86 89       	ldd	r24, Z+22	; 0x16
    3f4e:	28 2f       	mov	r18, r24
    3f50:	30 e0       	ldi	r19, 0x00	; 0
    3f52:	c9 01       	movw	r24, r18
    3f54:	88 0f       	add	r24, r24
    3f56:	99 1f       	adc	r25, r25
    3f58:	88 0f       	add	r24, r24
    3f5a:	99 1f       	adc	r25, r25
    3f5c:	88 0f       	add	r24, r24
    3f5e:	99 1f       	adc	r25, r25
    3f60:	82 0f       	add	r24, r18
    3f62:	93 1f       	adc	r25, r19
    3f64:	8c 5b       	subi	r24, 0xBC	; 188
    3f66:	9d 4f       	sbci	r25, 0xFD	; 253
    3f68:	ba 01       	movw	r22, r20
    3f6a:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
    3f6e:	08 c0       	rjmp	.+16     	; 0x3f80 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3f70:	8a 81       	ldd	r24, Y+2	; 0x02
    3f72:	9b 81       	ldd	r25, Y+3	; 0x03
    3f74:	0c 96       	adiw	r24, 0x0c	; 12
    3f76:	bc 01       	movw	r22, r24
    3f78:	8e e7       	ldi	r24, 0x7E	; 126
    3f7a:	92 e0       	ldi	r25, 0x02	; 2
    3f7c:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    3f80:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3f82:	26 96       	adiw	r28, 0x06	; 6
    3f84:	0f b6       	in	r0, 0x3f	; 63
    3f86:	f8 94       	cli
    3f88:	de bf       	out	0x3e, r29	; 62
    3f8a:	0f be       	out	0x3f, r0	; 63
    3f8c:	cd bf       	out	0x3d, r28	; 61
    3f8e:	df 91       	pop	r29
    3f90:	cf 91       	pop	r28
    3f92:	08 95       	ret

00003f94 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3f94:	af 92       	push	r10
    3f96:	bf 92       	push	r11
    3f98:	cf 92       	push	r12
    3f9a:	df 92       	push	r13
    3f9c:	ef 92       	push	r14
    3f9e:	ff 92       	push	r15
    3fa0:	0f 93       	push	r16
    3fa2:	cf 93       	push	r28
    3fa4:	df 93       	push	r29
    3fa6:	1f 92       	push	r1
    3fa8:	cd b7       	in	r28, 0x3d	; 61
    3faa:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    3fac:	a1 2c       	mov	r10, r1
    3fae:	b1 2c       	mov	r11, r1
    3fb0:	c1 2c       	mov	r12, r1
    3fb2:	d1 2c       	mov	r13, r1
    3fb4:	e1 2c       	mov	r14, r1
    3fb6:	f1 2c       	mov	r15, r1
    3fb8:	00 e0       	ldi	r16, 0x00	; 0
    3fba:	20 e0       	ldi	r18, 0x00	; 0
    3fbc:	30 e0       	ldi	r19, 0x00	; 0
    3fbe:	45 e5       	ldi	r20, 0x55	; 85
    3fc0:	50 e0       	ldi	r21, 0x00	; 0
    3fc2:	68 e1       	ldi	r22, 0x18	; 24
    3fc4:	72 e0       	ldi	r23, 0x02	; 2
    3fc6:	81 e1       	ldi	r24, 0x11	; 17
    3fc8:	91 e0       	ldi	r25, 0x01	; 1
    3fca:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <xTaskGenericCreate>
    3fce:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    3fd0:	89 81       	ldd	r24, Y+1	; 0x01
    3fd2:	81 30       	cpi	r24, 0x01	; 1
    3fd4:	81 f4       	brne	.+32     	; 0x3ff6 <vTaskStartScheduler+0x62>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    3fd6:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    3fd8:	8f ef       	ldi	r24, 0xFF	; 255
    3fda:	9f ef       	ldi	r25, 0xFF	; 255
    3fdc:	90 93 a4 02 	sts	0x02A4, r25
    3fe0:	80 93 a3 02 	sts	0x02A3, r24
		xSchedulerRunning = pdTRUE;
    3fe4:	81 e0       	ldi	r24, 0x01	; 1
    3fe6:	80 93 9e 02 	sts	0x029E, r24
		xTickCount = ( TickType_t ) 0U;
    3fea:	10 92 9c 02 	sts	0x029C, r1
    3fee:	10 92 9b 02 	sts	0x029B, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3ff2:	0e 94 ce 12 	call	0x259c	; 0x259c <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    3ff6:	0f 90       	pop	r0
    3ff8:	df 91       	pop	r29
    3ffa:	cf 91       	pop	r28
    3ffc:	0f 91       	pop	r16
    3ffe:	ff 90       	pop	r15
    4000:	ef 90       	pop	r14
    4002:	df 90       	pop	r13
    4004:	cf 90       	pop	r12
    4006:	bf 90       	pop	r11
    4008:	af 90       	pop	r10
    400a:	08 95       	ret

0000400c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    400c:	cf 93       	push	r28
    400e:	df 93       	push	r29
    4010:	cd b7       	in	r28, 0x3d	; 61
    4012:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4014:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4016:	10 92 9e 02 	sts	0x029E, r1
	vPortEndScheduler();
    401a:	0e 94 07 13 	call	0x260e	; 0x260e <vPortEndScheduler>
	portENABLE_INTERRUPTS(); /* As per comment, enable interrupts. */
    401e:	78 94       	sei
}
    4020:	df 91       	pop	r29
    4022:	cf 91       	pop	r28
    4024:	08 95       	ret

00004026 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4026:	cf 93       	push	r28
    4028:	df 93       	push	r29
    402a:	cd b7       	in	r28, 0x3d	; 61
    402c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    402e:	80 91 a5 02 	lds	r24, 0x02A5
    4032:	8f 5f       	subi	r24, 0xFF	; 255
    4034:	80 93 a5 02 	sts	0x02A5, r24
}
    4038:	df 91       	pop	r29
    403a:	cf 91       	pop	r28
    403c:	08 95       	ret

0000403e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    403e:	cf 93       	push	r28
    4040:	df 93       	push	r29
    4042:	00 d0       	rcall	.+0      	; 0x4044 <xTaskResumeAll+0x6>
    4044:	cd b7       	in	r28, 0x3d	; 61
    4046:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    4048:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    404a:	0f b6       	in	r0, 0x3f	; 63
    404c:	f8 94       	cli
    404e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4050:	80 91 a5 02 	lds	r24, 0x02A5
    4054:	81 50       	subi	r24, 0x01	; 1
    4056:	80 93 a5 02 	sts	0x02A5, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    405a:	80 91 a5 02 	lds	r24, 0x02A5
    405e:	88 23       	and	r24, r24
    4060:	09 f0       	breq	.+2      	; 0x4064 <xTaskResumeAll+0x26>
    4062:	71 c0       	rjmp	.+226    	; 0x4146 <xTaskResumeAll+0x108>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4064:	80 91 9a 02 	lds	r24, 0x029A
    4068:	88 23       	and	r24, r24
    406a:	09 f4       	brne	.+2      	; 0x406e <xTaskResumeAll+0x30>
    406c:	6c c0       	rjmp	.+216    	; 0x4146 <xTaskResumeAll+0x108>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    406e:	49 c0       	rjmp	.+146    	; 0x4102 <xTaskResumeAll+0xc4>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    4070:	80 91 83 02 	lds	r24, 0x0283
    4074:	90 91 84 02 	lds	r25, 0x0284
    4078:	fc 01       	movw	r30, r24
    407a:	86 81       	ldd	r24, Z+6	; 0x06
    407c:	97 81       	ldd	r25, Z+7	; 0x07
    407e:	9b 83       	std	Y+3, r25	; 0x03
    4080:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4082:	8a 81       	ldd	r24, Y+2	; 0x02
    4084:	9b 81       	ldd	r25, Y+3	; 0x03
    4086:	0c 96       	adiw	r24, 0x0c	; 12
    4088:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    408c:	8a 81       	ldd	r24, Y+2	; 0x02
    408e:	9b 81       	ldd	r25, Y+3	; 0x03
    4090:	02 96       	adiw	r24, 0x02	; 2
    4092:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4096:	8a 81       	ldd	r24, Y+2	; 0x02
    4098:	9b 81       	ldd	r25, Y+3	; 0x03
    409a:	fc 01       	movw	r30, r24
    409c:	96 89       	ldd	r25, Z+22	; 0x16
    409e:	80 91 9d 02 	lds	r24, 0x029D
    40a2:	89 17       	cp	r24, r25
    40a4:	30 f4       	brcc	.+12     	; 0x40b2 <xTaskResumeAll+0x74>
    40a6:	8a 81       	ldd	r24, Y+2	; 0x02
    40a8:	9b 81       	ldd	r25, Y+3	; 0x03
    40aa:	fc 01       	movw	r30, r24
    40ac:	86 89       	ldd	r24, Z+22	; 0x16
    40ae:	80 93 9d 02 	sts	0x029D, r24
    40b2:	8a 81       	ldd	r24, Y+2	; 0x02
    40b4:	9b 81       	ldd	r25, Y+3	; 0x03
    40b6:	ac 01       	movw	r20, r24
    40b8:	4e 5f       	subi	r20, 0xFE	; 254
    40ba:	5f 4f       	sbci	r21, 0xFF	; 255
    40bc:	8a 81       	ldd	r24, Y+2	; 0x02
    40be:	9b 81       	ldd	r25, Y+3	; 0x03
    40c0:	fc 01       	movw	r30, r24
    40c2:	86 89       	ldd	r24, Z+22	; 0x16
    40c4:	28 2f       	mov	r18, r24
    40c6:	30 e0       	ldi	r19, 0x00	; 0
    40c8:	c9 01       	movw	r24, r18
    40ca:	88 0f       	add	r24, r24
    40cc:	99 1f       	adc	r25, r25
    40ce:	88 0f       	add	r24, r24
    40d0:	99 1f       	adc	r25, r25
    40d2:	88 0f       	add	r24, r24
    40d4:	99 1f       	adc	r25, r25
    40d6:	82 0f       	add	r24, r18
    40d8:	93 1f       	adc	r25, r19
    40da:	8c 5b       	subi	r24, 0xBC	; 188
    40dc:	9d 4f       	sbci	r25, 0xFD	; 253
    40de:	ba 01       	movw	r22, r20
    40e0:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    40e4:	8a 81       	ldd	r24, Y+2	; 0x02
    40e6:	9b 81       	ldd	r25, Y+3	; 0x03
    40e8:	fc 01       	movw	r30, r24
    40ea:	26 89       	ldd	r18, Z+22	; 0x16
    40ec:	80 91 42 02 	lds	r24, 0x0242
    40f0:	90 91 43 02 	lds	r25, 0x0243
    40f4:	fc 01       	movw	r30, r24
    40f6:	86 89       	ldd	r24, Z+22	; 0x16
    40f8:	28 17       	cp	r18, r24
    40fa:	18 f0       	brcs	.+6      	; 0x4102 <xTaskResumeAll+0xc4>
					{
						xYieldPending = pdTRUE;
    40fc:	81 e0       	ldi	r24, 0x01	; 1
    40fe:	80 93 a0 02 	sts	0x02A0, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4102:	80 91 7e 02 	lds	r24, 0x027E
    4106:	88 23       	and	r24, r24
    4108:	09 f0       	breq	.+2      	; 0x410c <xTaskResumeAll+0xce>
    410a:	b2 cf       	rjmp	.-156    	; 0x4070 <xTaskResumeAll+0x32>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    410c:	80 91 9f 02 	lds	r24, 0x029F
    4110:	88 23       	and	r24, r24
    4112:	89 f0       	breq	.+34     	; 0x4136 <xTaskResumeAll+0xf8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    4114:	0c c0       	rjmp	.+24     	; 0x412e <xTaskResumeAll+0xf0>
					{
						if( xTaskIncrementTick() != pdFALSE )
    4116:	0e 94 e1 20 	call	0x41c2	; 0x41c2 <xTaskIncrementTick>
    411a:	88 23       	and	r24, r24
    411c:	19 f0       	breq	.+6      	; 0x4124 <xTaskResumeAll+0xe6>
						{
							xYieldPending = pdTRUE;
    411e:	81 e0       	ldi	r24, 0x01	; 1
    4120:	80 93 a0 02 	sts	0x02A0, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    4124:	80 91 9f 02 	lds	r24, 0x029F
    4128:	81 50       	subi	r24, 0x01	; 1
    412a:	80 93 9f 02 	sts	0x029F, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    412e:	80 91 9f 02 	lds	r24, 0x029F
    4132:	88 23       	and	r24, r24
    4134:	81 f7       	brne	.-32     	; 0x4116 <xTaskResumeAll+0xd8>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    4136:	80 91 a0 02 	lds	r24, 0x02A0
    413a:	81 30       	cpi	r24, 0x01	; 1
    413c:	21 f4       	brne	.+8      	; 0x4146 <xTaskResumeAll+0x108>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    413e:	81 e0       	ldi	r24, 0x01	; 1
    4140:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4142:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4146:	0f 90       	pop	r0
    4148:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    414a:	89 81       	ldd	r24, Y+1	; 0x01
}
    414c:	0f 90       	pop	r0
    414e:	0f 90       	pop	r0
    4150:	0f 90       	pop	r0
    4152:	df 91       	pop	r29
    4154:	cf 91       	pop	r28
    4156:	08 95       	ret

00004158 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4158:	cf 93       	push	r28
    415a:	df 93       	push	r29
    415c:	1f 92       	push	r1
    415e:	1f 92       	push	r1
    4160:	cd b7       	in	r28, 0x3d	; 61
    4162:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4164:	0f b6       	in	r0, 0x3f	; 63
    4166:	f8 94       	cli
    4168:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    416a:	80 91 9b 02 	lds	r24, 0x029B
    416e:	90 91 9c 02 	lds	r25, 0x029C
    4172:	9a 83       	std	Y+2, r25	; 0x02
    4174:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    4176:	0f 90       	pop	r0
    4178:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    417a:	89 81       	ldd	r24, Y+1	; 0x01
    417c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    417e:	0f 90       	pop	r0
    4180:	0f 90       	pop	r0
    4182:	df 91       	pop	r29
    4184:	cf 91       	pop	r28
    4186:	08 95       	ret

00004188 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4188:	cf 93       	push	r28
    418a:	df 93       	push	r29
    418c:	00 d0       	rcall	.+0      	; 0x418e <xTaskGetTickCountFromISR+0x6>
    418e:	cd b7       	in	r28, 0x3d	; 61
    4190:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4192:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    4194:	80 91 9b 02 	lds	r24, 0x029B
    4198:	90 91 9c 02 	lds	r25, 0x029C
    419c:	9b 83       	std	Y+3, r25	; 0x03
    419e:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    41a0:	8a 81       	ldd	r24, Y+2	; 0x02
    41a2:	9b 81       	ldd	r25, Y+3	; 0x03
}
    41a4:	0f 90       	pop	r0
    41a6:	0f 90       	pop	r0
    41a8:	0f 90       	pop	r0
    41aa:	df 91       	pop	r29
    41ac:	cf 91       	pop	r28
    41ae:	08 95       	ret

000041b0 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    41b0:	cf 93       	push	r28
    41b2:	df 93       	push	r29
    41b4:	cd b7       	in	r28, 0x3d	; 61
    41b6:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    41b8:	80 91 9a 02 	lds	r24, 0x029A
}
    41bc:	df 91       	pop	r29
    41be:	cf 91       	pop	r28
    41c0:	08 95       	ret

000041c2 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    41c2:	cf 93       	push	r28
    41c4:	df 93       	push	r29
    41c6:	cd b7       	in	r28, 0x3d	; 61
    41c8:	de b7       	in	r29, 0x3e	; 62
    41ca:	29 97       	sbiw	r28, 0x09	; 9
    41cc:	0f b6       	in	r0, 0x3f	; 63
    41ce:	f8 94       	cli
    41d0:	de bf       	out	0x3e, r29	; 62
    41d2:	0f be       	out	0x3f, r0	; 63
    41d4:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    41d6:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    41d8:	80 91 a5 02 	lds	r24, 0x02A5
    41dc:	88 23       	and	r24, r24
    41de:	09 f0       	breq	.+2      	; 0x41e2 <xTaskIncrementTick+0x20>
    41e0:	c9 c0       	rjmp	.+402    	; 0x4374 <xTaskIncrementTick+0x1b2>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    41e2:	80 91 9b 02 	lds	r24, 0x029B
    41e6:	90 91 9c 02 	lds	r25, 0x029C
    41ea:	01 96       	adiw	r24, 0x01	; 1
    41ec:	90 93 9c 02 	sts	0x029C, r25
    41f0:	80 93 9b 02 	sts	0x029B, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    41f4:	80 91 9b 02 	lds	r24, 0x029B
    41f8:	90 91 9c 02 	lds	r25, 0x029C
    41fc:	9b 83       	std	Y+3, r25	; 0x03
    41fe:	8a 83       	std	Y+2, r24	; 0x02

			if( xConstTickCount == ( TickType_t ) 0U )
    4200:	8a 81       	ldd	r24, Y+2	; 0x02
    4202:	9b 81       	ldd	r25, Y+3	; 0x03
    4204:	00 97       	sbiw	r24, 0x00	; 0
    4206:	d9 f4       	brne	.+54     	; 0x423e <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    4208:	80 91 7a 02 	lds	r24, 0x027A
    420c:	90 91 7b 02 	lds	r25, 0x027B
    4210:	9d 83       	std	Y+5, r25	; 0x05
    4212:	8c 83       	std	Y+4, r24	; 0x04
    4214:	80 91 7c 02 	lds	r24, 0x027C
    4218:	90 91 7d 02 	lds	r25, 0x027D
    421c:	90 93 7b 02 	sts	0x027B, r25
    4220:	80 93 7a 02 	sts	0x027A, r24
    4224:	8c 81       	ldd	r24, Y+4	; 0x04
    4226:	9d 81       	ldd	r25, Y+5	; 0x05
    4228:	90 93 7d 02 	sts	0x027D, r25
    422c:	80 93 7c 02 	sts	0x027C, r24
    4230:	80 91 a1 02 	lds	r24, 0x02A1
    4234:	8f 5f       	subi	r24, 0xFF	; 255
    4236:	80 93 a1 02 	sts	0x02A1, r24
    423a:	0e 94 8a 26 	call	0x4d14	; 0x4d14 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    423e:	80 91 a3 02 	lds	r24, 0x02A3
    4242:	90 91 a4 02 	lds	r25, 0x02A4
    4246:	2a 81       	ldd	r18, Y+2	; 0x02
    4248:	3b 81       	ldd	r19, Y+3	; 0x03
    424a:	28 17       	cp	r18, r24
    424c:	39 07       	cpc	r19, r25
    424e:	08 f4       	brcc	.+2      	; 0x4252 <xTaskIncrementTick+0x90>
    4250:	77 c0       	rjmp	.+238    	; 0x4340 <xTaskIncrementTick+0x17e>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4252:	80 91 7a 02 	lds	r24, 0x027A
    4256:	90 91 7b 02 	lds	r25, 0x027B
    425a:	fc 01       	movw	r30, r24
    425c:	80 81       	ld	r24, Z
    425e:	88 23       	and	r24, r24
    4260:	39 f4       	brne	.+14     	; 0x4270 <xTaskIncrementTick+0xae>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    4262:	8f ef       	ldi	r24, 0xFF	; 255
    4264:	9f ef       	ldi	r25, 0xFF	; 255
    4266:	90 93 a4 02 	sts	0x02A4, r25
    426a:	80 93 a3 02 	sts	0x02A3, r24
						break;
    426e:	68 c0       	rjmp	.+208    	; 0x4340 <xTaskIncrementTick+0x17e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4270:	80 91 7a 02 	lds	r24, 0x027A
    4274:	90 91 7b 02 	lds	r25, 0x027B
    4278:	fc 01       	movw	r30, r24
    427a:	85 81       	ldd	r24, Z+5	; 0x05
    427c:	96 81       	ldd	r25, Z+6	; 0x06
    427e:	fc 01       	movw	r30, r24
    4280:	86 81       	ldd	r24, Z+6	; 0x06
    4282:	97 81       	ldd	r25, Z+7	; 0x07
    4284:	9f 83       	std	Y+7, r25	; 0x07
    4286:	8e 83       	std	Y+6, r24	; 0x06
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    4288:	8e 81       	ldd	r24, Y+6	; 0x06
    428a:	9f 81       	ldd	r25, Y+7	; 0x07
    428c:	fc 01       	movw	r30, r24
    428e:	82 81       	ldd	r24, Z+2	; 0x02
    4290:	93 81       	ldd	r25, Z+3	; 0x03
    4292:	99 87       	std	Y+9, r25	; 0x09
    4294:	88 87       	std	Y+8, r24	; 0x08

						if( xConstTickCount < xItemValue )
    4296:	2a 81       	ldd	r18, Y+2	; 0x02
    4298:	3b 81       	ldd	r19, Y+3	; 0x03
    429a:	88 85       	ldd	r24, Y+8	; 0x08
    429c:	99 85       	ldd	r25, Y+9	; 0x09
    429e:	28 17       	cp	r18, r24
    42a0:	39 07       	cpc	r19, r25
    42a2:	38 f4       	brcc	.+14     	; 0x42b2 <xTaskIncrementTick+0xf0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    42a4:	88 85       	ldd	r24, Y+8	; 0x08
    42a6:	99 85       	ldd	r25, Y+9	; 0x09
    42a8:	90 93 a4 02 	sts	0x02A4, r25
    42ac:	80 93 a3 02 	sts	0x02A3, r24
							break;
    42b0:	47 c0       	rjmp	.+142    	; 0x4340 <xTaskIncrementTick+0x17e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    42b2:	8e 81       	ldd	r24, Y+6	; 0x06
    42b4:	9f 81       	ldd	r25, Y+7	; 0x07
    42b6:	02 96       	adiw	r24, 0x02	; 2
    42b8:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    42bc:	8e 81       	ldd	r24, Y+6	; 0x06
    42be:	9f 81       	ldd	r25, Y+7	; 0x07
    42c0:	fc 01       	movw	r30, r24
    42c2:	84 89       	ldd	r24, Z+20	; 0x14
    42c4:	95 89       	ldd	r25, Z+21	; 0x15
    42c6:	00 97       	sbiw	r24, 0x00	; 0
    42c8:	29 f0       	breq	.+10     	; 0x42d4 <xTaskIncrementTick+0x112>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    42ca:	8e 81       	ldd	r24, Y+6	; 0x06
    42cc:	9f 81       	ldd	r25, Y+7	; 0x07
    42ce:	0c 96       	adiw	r24, 0x0c	; 12
    42d0:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    42d4:	8e 81       	ldd	r24, Y+6	; 0x06
    42d6:	9f 81       	ldd	r25, Y+7	; 0x07
    42d8:	fc 01       	movw	r30, r24
    42da:	96 89       	ldd	r25, Z+22	; 0x16
    42dc:	80 91 9d 02 	lds	r24, 0x029D
    42e0:	89 17       	cp	r24, r25
    42e2:	30 f4       	brcc	.+12     	; 0x42f0 <xTaskIncrementTick+0x12e>
    42e4:	8e 81       	ldd	r24, Y+6	; 0x06
    42e6:	9f 81       	ldd	r25, Y+7	; 0x07
    42e8:	fc 01       	movw	r30, r24
    42ea:	86 89       	ldd	r24, Z+22	; 0x16
    42ec:	80 93 9d 02 	sts	0x029D, r24
    42f0:	8e 81       	ldd	r24, Y+6	; 0x06
    42f2:	9f 81       	ldd	r25, Y+7	; 0x07
    42f4:	ac 01       	movw	r20, r24
    42f6:	4e 5f       	subi	r20, 0xFE	; 254
    42f8:	5f 4f       	sbci	r21, 0xFF	; 255
    42fa:	8e 81       	ldd	r24, Y+6	; 0x06
    42fc:	9f 81       	ldd	r25, Y+7	; 0x07
    42fe:	fc 01       	movw	r30, r24
    4300:	86 89       	ldd	r24, Z+22	; 0x16
    4302:	28 2f       	mov	r18, r24
    4304:	30 e0       	ldi	r19, 0x00	; 0
    4306:	c9 01       	movw	r24, r18
    4308:	88 0f       	add	r24, r24
    430a:	99 1f       	adc	r25, r25
    430c:	88 0f       	add	r24, r24
    430e:	99 1f       	adc	r25, r25
    4310:	88 0f       	add	r24, r24
    4312:	99 1f       	adc	r25, r25
    4314:	82 0f       	add	r24, r18
    4316:	93 1f       	adc	r25, r19
    4318:	8c 5b       	subi	r24, 0xBC	; 188
    431a:	9d 4f       	sbci	r25, 0xFD	; 253
    431c:	ba 01       	movw	r22, r20
    431e:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4322:	8e 81       	ldd	r24, Y+6	; 0x06
    4324:	9f 81       	ldd	r25, Y+7	; 0x07
    4326:	fc 01       	movw	r30, r24
    4328:	26 89       	ldd	r18, Z+22	; 0x16
    432a:	80 91 42 02 	lds	r24, 0x0242
    432e:	90 91 43 02 	lds	r25, 0x0243
    4332:	fc 01       	movw	r30, r24
    4334:	86 89       	ldd	r24, Z+22	; 0x16
    4336:	28 17       	cp	r18, r24
    4338:	10 f0       	brcs	.+4      	; 0x433e <xTaskIncrementTick+0x17c>
							{
								xSwitchRequired = pdTRUE;
    433a:	81 e0       	ldi	r24, 0x01	; 1
    433c:	89 83       	std	Y+1, r24	; 0x01
								mtCOVERAGE_TEST_MARKER();
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
    433e:	89 cf       	rjmp	.-238    	; 0x4252 <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4340:	80 91 42 02 	lds	r24, 0x0242
    4344:	90 91 43 02 	lds	r25, 0x0243
    4348:	fc 01       	movw	r30, r24
    434a:	86 89       	ldd	r24, Z+22	; 0x16
    434c:	28 2f       	mov	r18, r24
    434e:	30 e0       	ldi	r19, 0x00	; 0
    4350:	c9 01       	movw	r24, r18
    4352:	88 0f       	add	r24, r24
    4354:	99 1f       	adc	r25, r25
    4356:	88 0f       	add	r24, r24
    4358:	99 1f       	adc	r25, r25
    435a:	88 0f       	add	r24, r24
    435c:	99 1f       	adc	r25, r25
    435e:	82 0f       	add	r24, r18
    4360:	93 1f       	adc	r25, r19
    4362:	8c 5b       	subi	r24, 0xBC	; 188
    4364:	9d 4f       	sbci	r25, 0xFD	; 253
    4366:	fc 01       	movw	r30, r24
    4368:	80 81       	ld	r24, Z
    436a:	82 30       	cpi	r24, 0x02	; 2
    436c:	40 f0       	brcs	.+16     	; 0x437e <xTaskIncrementTick+0x1bc>
			{
				xSwitchRequired = pdTRUE;
    436e:	81 e0       	ldi	r24, 0x01	; 1
    4370:	89 83       	std	Y+1, r24	; 0x01
    4372:	05 c0       	rjmp	.+10     	; 0x437e <xTaskIncrementTick+0x1bc>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    4374:	80 91 9f 02 	lds	r24, 0x029F
    4378:	8f 5f       	subi	r24, 0xFF	; 255
    437a:	80 93 9f 02 	sts	0x029F, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    437e:	80 91 a0 02 	lds	r24, 0x02A0
    4382:	88 23       	and	r24, r24
    4384:	11 f0       	breq	.+4      	; 0x438a <xTaskIncrementTick+0x1c8>
		{
			xSwitchRequired = pdTRUE;
    4386:	81 e0       	ldi	r24, 0x01	; 1
    4388:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    438a:	89 81       	ldd	r24, Y+1	; 0x01
}
    438c:	29 96       	adiw	r28, 0x09	; 9
    438e:	0f b6       	in	r0, 0x3f	; 63
    4390:	f8 94       	cli
    4392:	de bf       	out	0x3e, r29	; 62
    4394:	0f be       	out	0x3f, r0	; 63
    4396:	cd bf       	out	0x3d, r28	; 61
    4398:	df 91       	pop	r29
    439a:	cf 91       	pop	r28
    439c:	08 95       	ret

0000439e <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    439e:	cf 93       	push	r28
    43a0:	df 93       	push	r29
    43a2:	1f 92       	push	r1
    43a4:	1f 92       	push	r1
    43a6:	cd b7       	in	r28, 0x3d	; 61
    43a8:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    43aa:	80 91 a5 02 	lds	r24, 0x02A5
    43ae:	88 23       	and	r24, r24
    43b0:	21 f0       	breq	.+8      	; 0x43ba <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    43b2:	81 e0       	ldi	r24, 0x01	; 1
    43b4:	80 93 a0 02 	sts	0x02A0, r24
    43b8:	7d c0       	rjmp	.+250    	; 0x44b4 <vTaskSwitchContext+0x116>
	}
	else
	{
		xYieldPending = pdFALSE;
    43ba:	10 92 a0 02 	sts	0x02A0, r1
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
    43be:	80 91 42 02 	lds	r24, 0x0242
    43c2:	90 91 43 02 	lds	r25, 0x0243
    43c6:	fc 01       	movw	r30, r24
    43c8:	20 81       	ld	r18, Z
    43ca:	31 81       	ldd	r19, Z+1	; 0x01
    43cc:	80 91 42 02 	lds	r24, 0x0242
    43d0:	90 91 43 02 	lds	r25, 0x0243
    43d4:	fc 01       	movw	r30, r24
    43d6:	87 89       	ldd	r24, Z+23	; 0x17
    43d8:	90 8d       	ldd	r25, Z+24	; 0x18
    43da:	82 17       	cp	r24, r18
    43dc:	93 07       	cpc	r25, r19
    43de:	78 f0       	brcs	.+30     	; 0x43fe <vTaskSwitchContext+0x60>
    43e0:	80 91 42 02 	lds	r24, 0x0242
    43e4:	90 91 43 02 	lds	r25, 0x0243
    43e8:	9c 01       	movw	r18, r24
    43ea:	27 5e       	subi	r18, 0xE7	; 231
    43ec:	3f 4f       	sbci	r19, 0xFF	; 255
    43ee:	80 91 42 02 	lds	r24, 0x0242
    43f2:	90 91 43 02 	lds	r25, 0x0243
    43f6:	b9 01       	movw	r22, r18
    43f8:	0e 94 56 0d 	call	0x1aac	; 0x1aac <vApplicationStackOverflowHook>

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    43fc:	06 c0       	rjmp	.+12     	; 0x440a <vTaskSwitchContext+0x6c>
    43fe:	05 c0       	rjmp	.+10     	; 0x440a <vTaskSwitchContext+0x6c>
    4400:	80 91 9d 02 	lds	r24, 0x029D
    4404:	81 50       	subi	r24, 0x01	; 1
    4406:	80 93 9d 02 	sts	0x029D, r24
    440a:	80 91 9d 02 	lds	r24, 0x029D
    440e:	28 2f       	mov	r18, r24
    4410:	30 e0       	ldi	r19, 0x00	; 0
    4412:	c9 01       	movw	r24, r18
    4414:	88 0f       	add	r24, r24
    4416:	99 1f       	adc	r25, r25
    4418:	88 0f       	add	r24, r24
    441a:	99 1f       	adc	r25, r25
    441c:	88 0f       	add	r24, r24
    441e:	99 1f       	adc	r25, r25
    4420:	82 0f       	add	r24, r18
    4422:	93 1f       	adc	r25, r19
    4424:	8c 5b       	subi	r24, 0xBC	; 188
    4426:	9d 4f       	sbci	r25, 0xFD	; 253
    4428:	fc 01       	movw	r30, r24
    442a:	80 81       	ld	r24, Z
    442c:	88 23       	and	r24, r24
    442e:	41 f3       	breq	.-48     	; 0x4400 <vTaskSwitchContext+0x62>
    4430:	80 91 9d 02 	lds	r24, 0x029D
    4434:	28 2f       	mov	r18, r24
    4436:	30 e0       	ldi	r19, 0x00	; 0
    4438:	c9 01       	movw	r24, r18
    443a:	88 0f       	add	r24, r24
    443c:	99 1f       	adc	r25, r25
    443e:	88 0f       	add	r24, r24
    4440:	99 1f       	adc	r25, r25
    4442:	88 0f       	add	r24, r24
    4444:	99 1f       	adc	r25, r25
    4446:	82 0f       	add	r24, r18
    4448:	93 1f       	adc	r25, r19
    444a:	8c 5b       	subi	r24, 0xBC	; 188
    444c:	9d 4f       	sbci	r25, 0xFD	; 253
    444e:	9a 83       	std	Y+2, r25	; 0x02
    4450:	89 83       	std	Y+1, r24	; 0x01
    4452:	89 81       	ldd	r24, Y+1	; 0x01
    4454:	9a 81       	ldd	r25, Y+2	; 0x02
    4456:	fc 01       	movw	r30, r24
    4458:	81 81       	ldd	r24, Z+1	; 0x01
    445a:	92 81       	ldd	r25, Z+2	; 0x02
    445c:	fc 01       	movw	r30, r24
    445e:	22 81       	ldd	r18, Z+2	; 0x02
    4460:	33 81       	ldd	r19, Z+3	; 0x03
    4462:	89 81       	ldd	r24, Y+1	; 0x01
    4464:	9a 81       	ldd	r25, Y+2	; 0x02
    4466:	fc 01       	movw	r30, r24
    4468:	32 83       	std	Z+2, r19	; 0x02
    446a:	21 83       	std	Z+1, r18	; 0x01
    446c:	89 81       	ldd	r24, Y+1	; 0x01
    446e:	9a 81       	ldd	r25, Y+2	; 0x02
    4470:	fc 01       	movw	r30, r24
    4472:	21 81       	ldd	r18, Z+1	; 0x01
    4474:	32 81       	ldd	r19, Z+2	; 0x02
    4476:	89 81       	ldd	r24, Y+1	; 0x01
    4478:	9a 81       	ldd	r25, Y+2	; 0x02
    447a:	03 96       	adiw	r24, 0x03	; 3
    447c:	28 17       	cp	r18, r24
    447e:	39 07       	cpc	r19, r25
    4480:	69 f4       	brne	.+26     	; 0x449c <vTaskSwitchContext+0xfe>
    4482:	89 81       	ldd	r24, Y+1	; 0x01
    4484:	9a 81       	ldd	r25, Y+2	; 0x02
    4486:	fc 01       	movw	r30, r24
    4488:	81 81       	ldd	r24, Z+1	; 0x01
    448a:	92 81       	ldd	r25, Z+2	; 0x02
    448c:	fc 01       	movw	r30, r24
    448e:	22 81       	ldd	r18, Z+2	; 0x02
    4490:	33 81       	ldd	r19, Z+3	; 0x03
    4492:	89 81       	ldd	r24, Y+1	; 0x01
    4494:	9a 81       	ldd	r25, Y+2	; 0x02
    4496:	fc 01       	movw	r30, r24
    4498:	32 83       	std	Z+2, r19	; 0x02
    449a:	21 83       	std	Z+1, r18	; 0x01
    449c:	89 81       	ldd	r24, Y+1	; 0x01
    449e:	9a 81       	ldd	r25, Y+2	; 0x02
    44a0:	fc 01       	movw	r30, r24
    44a2:	81 81       	ldd	r24, Z+1	; 0x01
    44a4:	92 81       	ldd	r25, Z+2	; 0x02
    44a6:	fc 01       	movw	r30, r24
    44a8:	86 81       	ldd	r24, Z+6	; 0x06
    44aa:	97 81       	ldd	r25, Z+7	; 0x07
    44ac:	90 93 43 02 	sts	0x0243, r25
    44b0:	80 93 42 02 	sts	0x0242, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    44b4:	0f 90       	pop	r0
    44b6:	0f 90       	pop	r0
    44b8:	df 91       	pop	r29
    44ba:	cf 91       	pop	r28
    44bc:	08 95       	ret

000044be <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    44be:	cf 93       	push	r28
    44c0:	df 93       	push	r29
    44c2:	00 d0       	rcall	.+0      	; 0x44c4 <vTaskPlaceOnEventList+0x6>
    44c4:	00 d0       	rcall	.+0      	; 0x44c6 <vTaskPlaceOnEventList+0x8>
    44c6:	cd b7       	in	r28, 0x3d	; 61
    44c8:	de b7       	in	r29, 0x3e	; 62
    44ca:	9c 83       	std	Y+4, r25	; 0x04
    44cc:	8b 83       	std	Y+3, r24	; 0x03
    44ce:	7e 83       	std	Y+6, r23	; 0x06
    44d0:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    44d2:	80 91 42 02 	lds	r24, 0x0242
    44d6:	90 91 43 02 	lds	r25, 0x0243
    44da:	9c 01       	movw	r18, r24
    44dc:	24 5f       	subi	r18, 0xF4	; 244
    44de:	3f 4f       	sbci	r19, 0xFF	; 255
    44e0:	8b 81       	ldd	r24, Y+3	; 0x03
    44e2:	9c 81       	ldd	r25, Y+4	; 0x04
    44e4:	b9 01       	movw	r22, r18
    44e6:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    44ea:	80 91 42 02 	lds	r24, 0x0242
    44ee:	90 91 43 02 	lds	r25, 0x0243
    44f2:	02 96       	adiw	r24, 0x02	; 2
    44f4:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    44f8:	8d 81       	ldd	r24, Y+5	; 0x05
    44fa:	9e 81       	ldd	r25, Y+6	; 0x06
    44fc:	8f 3f       	cpi	r24, 0xFF	; 255
    44fe:	2f ef       	ldi	r18, 0xFF	; 255
    4500:	92 07       	cpc	r25, r18
    4502:	59 f4       	brne	.+22     	; 0x451a <vTaskPlaceOnEventList+0x5c>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    4504:	80 91 42 02 	lds	r24, 0x0242
    4508:	90 91 43 02 	lds	r25, 0x0243
    450c:	02 96       	adiw	r24, 0x02	; 2
    450e:	bc 01       	movw	r22, r24
    4510:	81 e9       	ldi	r24, 0x91	; 145
    4512:	92 e0       	ldi	r25, 0x02	; 2
    4514:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
    4518:	0e c0       	rjmp	.+28     	; 0x4536 <vTaskPlaceOnEventList+0x78>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    451a:	20 91 9b 02 	lds	r18, 0x029B
    451e:	30 91 9c 02 	lds	r19, 0x029C
    4522:	8d 81       	ldd	r24, Y+5	; 0x05
    4524:	9e 81       	ldd	r25, Y+6	; 0x06
    4526:	82 0f       	add	r24, r18
    4528:	93 1f       	adc	r25, r19
    452a:	9a 83       	std	Y+2, r25	; 0x02
    452c:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    452e:	89 81       	ldd	r24, Y+1	; 0x01
    4530:	9a 81       	ldd	r25, Y+2	; 0x02
    4532:	0e 94 77 25 	call	0x4aee	; 0x4aee <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    4536:	26 96       	adiw	r28, 0x06	; 6
    4538:	0f b6       	in	r0, 0x3f	; 63
    453a:	f8 94       	cli
    453c:	de bf       	out	0x3e, r29	; 62
    453e:	0f be       	out	0x3f, r0	; 63
    4540:	cd bf       	out	0x3d, r28	; 61
    4542:	df 91       	pop	r29
    4544:	cf 91       	pop	r28
    4546:	08 95       	ret

00004548 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    4548:	cf 93       	push	r28
    454a:	df 93       	push	r29
    454c:	cd b7       	in	r28, 0x3d	; 61
    454e:	de b7       	in	r29, 0x3e	; 62
    4550:	28 97       	sbiw	r28, 0x08	; 8
    4552:	0f b6       	in	r0, 0x3f	; 63
    4554:	f8 94       	cli
    4556:	de bf       	out	0x3e, r29	; 62
    4558:	0f be       	out	0x3f, r0	; 63
    455a:	cd bf       	out	0x3d, r28	; 61
    455c:	9c 83       	std	Y+4, r25	; 0x04
    455e:	8b 83       	std	Y+3, r24	; 0x03
    4560:	7e 83       	std	Y+6, r23	; 0x06
    4562:	6d 83       	std	Y+5, r22	; 0x05
    4564:	58 87       	std	Y+8, r21	; 0x08
    4566:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4568:	80 91 42 02 	lds	r24, 0x0242
    456c:	90 91 43 02 	lds	r25, 0x0243
    4570:	2d 81       	ldd	r18, Y+5	; 0x05
    4572:	3e 81       	ldd	r19, Y+6	; 0x06
    4574:	30 68       	ori	r19, 0x80	; 128
    4576:	fc 01       	movw	r30, r24
    4578:	35 87       	std	Z+13, r19	; 0x0d
    457a:	24 87       	std	Z+12, r18	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    457c:	80 91 42 02 	lds	r24, 0x0242
    4580:	90 91 43 02 	lds	r25, 0x0243
    4584:	9c 01       	movw	r18, r24
    4586:	24 5f       	subi	r18, 0xF4	; 244
    4588:	3f 4f       	sbci	r19, 0xFF	; 255
    458a:	8b 81       	ldd	r24, Y+3	; 0x03
    458c:	9c 81       	ldd	r25, Y+4	; 0x04
    458e:	b9 01       	movw	r22, r18
    4590:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4594:	80 91 42 02 	lds	r24, 0x0242
    4598:	90 91 43 02 	lds	r25, 0x0243
    459c:	02 96       	adiw	r24, 0x02	; 2
    459e:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    45a2:	8f 81       	ldd	r24, Y+7	; 0x07
    45a4:	98 85       	ldd	r25, Y+8	; 0x08
    45a6:	8f 3f       	cpi	r24, 0xFF	; 255
    45a8:	ff ef       	ldi	r31, 0xFF	; 255
    45aa:	9f 07       	cpc	r25, r31
    45ac:	59 f4       	brne	.+22     	; 0x45c4 <vTaskPlaceOnUnorderedEventList+0x7c>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    45ae:	80 91 42 02 	lds	r24, 0x0242
    45b2:	90 91 43 02 	lds	r25, 0x0243
    45b6:	02 96       	adiw	r24, 0x02	; 2
    45b8:	bc 01       	movw	r22, r24
    45ba:	81 e9       	ldi	r24, 0x91	; 145
    45bc:	92 e0       	ldi	r25, 0x02	; 2
    45be:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
    45c2:	0e c0       	rjmp	.+28     	; 0x45e0 <vTaskPlaceOnUnorderedEventList+0x98>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    45c4:	20 91 9b 02 	lds	r18, 0x029B
    45c8:	30 91 9c 02 	lds	r19, 0x029C
    45cc:	8f 81       	ldd	r24, Y+7	; 0x07
    45ce:	98 85       	ldd	r25, Y+8	; 0x08
    45d0:	82 0f       	add	r24, r18
    45d2:	93 1f       	adc	r25, r19
    45d4:	9a 83       	std	Y+2, r25	; 0x02
    45d6:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    45d8:	89 81       	ldd	r24, Y+1	; 0x01
    45da:	9a 81       	ldd	r25, Y+2	; 0x02
    45dc:	0e 94 77 25 	call	0x4aee	; 0x4aee <prvAddCurrentTaskToDelayedList>
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    45e0:	28 96       	adiw	r28, 0x08	; 8
    45e2:	0f b6       	in	r0, 0x3f	; 63
    45e4:	f8 94       	cli
    45e6:	de bf       	out	0x3e, r29	; 62
    45e8:	0f be       	out	0x3f, r0	; 63
    45ea:	cd bf       	out	0x3d, r28	; 61
    45ec:	df 91       	pop	r29
    45ee:	cf 91       	pop	r28
    45f0:	08 95       	ret

000045f2 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    45f2:	cf 93       	push	r28
    45f4:	df 93       	push	r29
    45f6:	00 d0       	rcall	.+0      	; 0x45f8 <xTaskRemoveFromEventList+0x6>
    45f8:	1f 92       	push	r1
    45fa:	1f 92       	push	r1
    45fc:	cd b7       	in	r28, 0x3d	; 61
    45fe:	de b7       	in	r29, 0x3e	; 62
    4600:	9d 83       	std	Y+5, r25	; 0x05
    4602:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4604:	8c 81       	ldd	r24, Y+4	; 0x04
    4606:	9d 81       	ldd	r25, Y+5	; 0x05
    4608:	fc 01       	movw	r30, r24
    460a:	85 81       	ldd	r24, Z+5	; 0x05
    460c:	96 81       	ldd	r25, Z+6	; 0x06
    460e:	fc 01       	movw	r30, r24
    4610:	86 81       	ldd	r24, Z+6	; 0x06
    4612:	97 81       	ldd	r25, Z+7	; 0x07
    4614:	9b 83       	std	Y+3, r25	; 0x03
    4616:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4618:	8a 81       	ldd	r24, Y+2	; 0x02
    461a:	9b 81       	ldd	r25, Y+3	; 0x03
    461c:	0c 96       	adiw	r24, 0x0c	; 12
    461e:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4622:	80 91 a5 02 	lds	r24, 0x02A5
    4626:	88 23       	and	r24, r24
    4628:	69 f5       	brne	.+90     	; 0x4684 <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    462a:	8a 81       	ldd	r24, Y+2	; 0x02
    462c:	9b 81       	ldd	r25, Y+3	; 0x03
    462e:	02 96       	adiw	r24, 0x02	; 2
    4630:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4634:	8a 81       	ldd	r24, Y+2	; 0x02
    4636:	9b 81       	ldd	r25, Y+3	; 0x03
    4638:	fc 01       	movw	r30, r24
    463a:	96 89       	ldd	r25, Z+22	; 0x16
    463c:	80 91 9d 02 	lds	r24, 0x029D
    4640:	89 17       	cp	r24, r25
    4642:	30 f4       	brcc	.+12     	; 0x4650 <xTaskRemoveFromEventList+0x5e>
    4644:	8a 81       	ldd	r24, Y+2	; 0x02
    4646:	9b 81       	ldd	r25, Y+3	; 0x03
    4648:	fc 01       	movw	r30, r24
    464a:	86 89       	ldd	r24, Z+22	; 0x16
    464c:	80 93 9d 02 	sts	0x029D, r24
    4650:	8a 81       	ldd	r24, Y+2	; 0x02
    4652:	9b 81       	ldd	r25, Y+3	; 0x03
    4654:	ac 01       	movw	r20, r24
    4656:	4e 5f       	subi	r20, 0xFE	; 254
    4658:	5f 4f       	sbci	r21, 0xFF	; 255
    465a:	8a 81       	ldd	r24, Y+2	; 0x02
    465c:	9b 81       	ldd	r25, Y+3	; 0x03
    465e:	fc 01       	movw	r30, r24
    4660:	86 89       	ldd	r24, Z+22	; 0x16
    4662:	28 2f       	mov	r18, r24
    4664:	30 e0       	ldi	r19, 0x00	; 0
    4666:	c9 01       	movw	r24, r18
    4668:	88 0f       	add	r24, r24
    466a:	99 1f       	adc	r25, r25
    466c:	88 0f       	add	r24, r24
    466e:	99 1f       	adc	r25, r25
    4670:	88 0f       	add	r24, r24
    4672:	99 1f       	adc	r25, r25
    4674:	82 0f       	add	r24, r18
    4676:	93 1f       	adc	r25, r19
    4678:	8c 5b       	subi	r24, 0xBC	; 188
    467a:	9d 4f       	sbci	r25, 0xFD	; 253
    467c:	ba 01       	movw	r22, r20
    467e:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
    4682:	08 c0       	rjmp	.+16     	; 0x4694 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4684:	8a 81       	ldd	r24, Y+2	; 0x02
    4686:	9b 81       	ldd	r25, Y+3	; 0x03
    4688:	0c 96       	adiw	r24, 0x0c	; 12
    468a:	bc 01       	movw	r22, r24
    468c:	8e e7       	ldi	r24, 0x7E	; 126
    468e:	92 e0       	ldi	r25, 0x02	; 2
    4690:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4694:	8a 81       	ldd	r24, Y+2	; 0x02
    4696:	9b 81       	ldd	r25, Y+3	; 0x03
    4698:	fc 01       	movw	r30, r24
    469a:	26 89       	ldd	r18, Z+22	; 0x16
    469c:	80 91 42 02 	lds	r24, 0x0242
    46a0:	90 91 43 02 	lds	r25, 0x0243
    46a4:	fc 01       	movw	r30, r24
    46a6:	86 89       	ldd	r24, Z+22	; 0x16
    46a8:	82 17       	cp	r24, r18
    46aa:	30 f4       	brcc	.+12     	; 0x46b8 <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    46ac:	81 e0       	ldi	r24, 0x01	; 1
    46ae:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    46b0:	81 e0       	ldi	r24, 0x01	; 1
    46b2:	80 93 a0 02 	sts	0x02A0, r24
    46b6:	01 c0       	rjmp	.+2      	; 0x46ba <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    46b8:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    46ba:	89 81       	ldd	r24, Y+1	; 0x01
}
    46bc:	0f 90       	pop	r0
    46be:	0f 90       	pop	r0
    46c0:	0f 90       	pop	r0
    46c2:	0f 90       	pop	r0
    46c4:	0f 90       	pop	r0
    46c6:	df 91       	pop	r29
    46c8:	cf 91       	pop	r28
    46ca:	08 95       	ret

000046cc <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    46cc:	cf 93       	push	r28
    46ce:	df 93       	push	r29
    46d0:	cd b7       	in	r28, 0x3d	; 61
    46d2:	de b7       	in	r29, 0x3e	; 62
    46d4:	27 97       	sbiw	r28, 0x07	; 7
    46d6:	0f b6       	in	r0, 0x3f	; 63
    46d8:	f8 94       	cli
    46da:	de bf       	out	0x3e, r29	; 62
    46dc:	0f be       	out	0x3f, r0	; 63
    46de:	cd bf       	out	0x3d, r28	; 61
    46e0:	9d 83       	std	Y+5, r25	; 0x05
    46e2:	8c 83       	std	Y+4, r24	; 0x04
    46e4:	7f 83       	std	Y+7, r23	; 0x07
    46e6:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    46e8:	8e 81       	ldd	r24, Y+6	; 0x06
    46ea:	9f 81       	ldd	r25, Y+7	; 0x07
    46ec:	9c 01       	movw	r18, r24
    46ee:	30 68       	ori	r19, 0x80	; 128
    46f0:	8c 81       	ldd	r24, Y+4	; 0x04
    46f2:	9d 81       	ldd	r25, Y+5	; 0x05
    46f4:	fc 01       	movw	r30, r24
    46f6:	31 83       	std	Z+1, r19	; 0x01
    46f8:	20 83       	st	Z, r18

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    46fa:	8c 81       	ldd	r24, Y+4	; 0x04
    46fc:	9d 81       	ldd	r25, Y+5	; 0x05
    46fe:	fc 01       	movw	r30, r24
    4700:	86 81       	ldd	r24, Z+6	; 0x06
    4702:	97 81       	ldd	r25, Z+7	; 0x07
    4704:	9b 83       	std	Y+3, r25	; 0x03
    4706:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4708:	8c 81       	ldd	r24, Y+4	; 0x04
    470a:	9d 81       	ldd	r25, Y+5	; 0x05
    470c:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4710:	8a 81       	ldd	r24, Y+2	; 0x02
    4712:	9b 81       	ldd	r25, Y+3	; 0x03
    4714:	02 96       	adiw	r24, 0x02	; 2
    4716:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    471a:	8a 81       	ldd	r24, Y+2	; 0x02
    471c:	9b 81       	ldd	r25, Y+3	; 0x03
    471e:	fc 01       	movw	r30, r24
    4720:	96 89       	ldd	r25, Z+22	; 0x16
    4722:	80 91 9d 02 	lds	r24, 0x029D
    4726:	89 17       	cp	r24, r25
    4728:	30 f4       	brcc	.+12     	; 0x4736 <xTaskRemoveFromUnorderedEventList+0x6a>
    472a:	8a 81       	ldd	r24, Y+2	; 0x02
    472c:	9b 81       	ldd	r25, Y+3	; 0x03
    472e:	fc 01       	movw	r30, r24
    4730:	86 89       	ldd	r24, Z+22	; 0x16
    4732:	80 93 9d 02 	sts	0x029D, r24
    4736:	8a 81       	ldd	r24, Y+2	; 0x02
    4738:	9b 81       	ldd	r25, Y+3	; 0x03
    473a:	ac 01       	movw	r20, r24
    473c:	4e 5f       	subi	r20, 0xFE	; 254
    473e:	5f 4f       	sbci	r21, 0xFF	; 255
    4740:	8a 81       	ldd	r24, Y+2	; 0x02
    4742:	9b 81       	ldd	r25, Y+3	; 0x03
    4744:	fc 01       	movw	r30, r24
    4746:	86 89       	ldd	r24, Z+22	; 0x16
    4748:	28 2f       	mov	r18, r24
    474a:	30 e0       	ldi	r19, 0x00	; 0
    474c:	c9 01       	movw	r24, r18
    474e:	88 0f       	add	r24, r24
    4750:	99 1f       	adc	r25, r25
    4752:	88 0f       	add	r24, r24
    4754:	99 1f       	adc	r25, r25
    4756:	88 0f       	add	r24, r24
    4758:	99 1f       	adc	r25, r25
    475a:	82 0f       	add	r24, r18
    475c:	93 1f       	adc	r25, r19
    475e:	8c 5b       	subi	r24, 0xBC	; 188
    4760:	9d 4f       	sbci	r25, 0xFD	; 253
    4762:	ba 01       	movw	r22, r20
    4764:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4768:	8a 81       	ldd	r24, Y+2	; 0x02
    476a:	9b 81       	ldd	r25, Y+3	; 0x03
    476c:	fc 01       	movw	r30, r24
    476e:	26 89       	ldd	r18, Z+22	; 0x16
    4770:	80 91 42 02 	lds	r24, 0x0242
    4774:	90 91 43 02 	lds	r25, 0x0243
    4778:	fc 01       	movw	r30, r24
    477a:	86 89       	ldd	r24, Z+22	; 0x16
    477c:	82 17       	cp	r24, r18
    477e:	30 f4       	brcc	.+12     	; 0x478c <xTaskRemoveFromUnorderedEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4780:	81 e0       	ldi	r24, 0x01	; 1
    4782:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4784:	81 e0       	ldi	r24, 0x01	; 1
    4786:	80 93 a0 02 	sts	0x02A0, r24
    478a:	01 c0       	rjmp	.+2      	; 0x478e <xTaskRemoveFromUnorderedEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
    478c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    478e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4790:	27 96       	adiw	r28, 0x07	; 7
    4792:	0f b6       	in	r0, 0x3f	; 63
    4794:	f8 94       	cli
    4796:	de bf       	out	0x3e, r29	; 62
    4798:	0f be       	out	0x3f, r0	; 63
    479a:	cd bf       	out	0x3d, r28	; 61
    479c:	df 91       	pop	r29
    479e:	cf 91       	pop	r28
    47a0:	08 95       	ret

000047a2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    47a2:	cf 93       	push	r28
    47a4:	df 93       	push	r29
    47a6:	1f 92       	push	r1
    47a8:	1f 92       	push	r1
    47aa:	cd b7       	in	r28, 0x3d	; 61
    47ac:	de b7       	in	r29, 0x3e	; 62
    47ae:	9a 83       	std	Y+2, r25	; 0x02
    47b0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    47b2:	20 91 a1 02 	lds	r18, 0x02A1
    47b6:	89 81       	ldd	r24, Y+1	; 0x01
    47b8:	9a 81       	ldd	r25, Y+2	; 0x02
    47ba:	fc 01       	movw	r30, r24
    47bc:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    47be:	20 91 9b 02 	lds	r18, 0x029B
    47c2:	30 91 9c 02 	lds	r19, 0x029C
    47c6:	89 81       	ldd	r24, Y+1	; 0x01
    47c8:	9a 81       	ldd	r25, Y+2	; 0x02
    47ca:	fc 01       	movw	r30, r24
    47cc:	32 83       	std	Z+2, r19	; 0x02
    47ce:	21 83       	std	Z+1, r18	; 0x01
}
    47d0:	0f 90       	pop	r0
    47d2:	0f 90       	pop	r0
    47d4:	df 91       	pop	r29
    47d6:	cf 91       	pop	r28
    47d8:	08 95       	ret

000047da <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    47da:	cf 93       	push	r28
    47dc:	df 93       	push	r29
    47de:	cd b7       	in	r28, 0x3d	; 61
    47e0:	de b7       	in	r29, 0x3e	; 62
    47e2:	27 97       	sbiw	r28, 0x07	; 7
    47e4:	0f b6       	in	r0, 0x3f	; 63
    47e6:	f8 94       	cli
    47e8:	de bf       	out	0x3e, r29	; 62
    47ea:	0f be       	out	0x3f, r0	; 63
    47ec:	cd bf       	out	0x3d, r28	; 61
    47ee:	9d 83       	std	Y+5, r25	; 0x05
    47f0:	8c 83       	std	Y+4, r24	; 0x04
    47f2:	7f 83       	std	Y+7, r23	; 0x07
    47f4:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    47f6:	0f b6       	in	r0, 0x3f	; 63
    47f8:	f8 94       	cli
    47fa:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    47fc:	80 91 9b 02 	lds	r24, 0x029B
    4800:	90 91 9c 02 	lds	r25, 0x029C
    4804:	9b 83       	std	Y+3, r25	; 0x03
    4806:	8a 83       	std	Y+2, r24	; 0x02

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    4808:	8e 81       	ldd	r24, Y+6	; 0x06
    480a:	9f 81       	ldd	r25, Y+7	; 0x07
    480c:	fc 01       	movw	r30, r24
    480e:	80 81       	ld	r24, Z
    4810:	91 81       	ldd	r25, Z+1	; 0x01
    4812:	8f 3f       	cpi	r24, 0xFF	; 255
    4814:	ff ef       	ldi	r31, 0xFF	; 255
    4816:	9f 07       	cpc	r25, r31
    4818:	11 f4       	brne	.+4      	; 0x481e <xTaskCheckForTimeOut+0x44>
			{
				xReturn = pdFALSE;
    481a:	19 82       	std	Y+1, r1	; 0x01
    481c:	45 c0       	rjmp	.+138    	; 0x48a8 <xTaskCheckForTimeOut+0xce>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    481e:	8c 81       	ldd	r24, Y+4	; 0x04
    4820:	9d 81       	ldd	r25, Y+5	; 0x05
    4822:	fc 01       	movw	r30, r24
    4824:	90 81       	ld	r25, Z
    4826:	80 91 a1 02 	lds	r24, 0x02A1
    482a:	98 17       	cp	r25, r24
    482c:	69 f0       	breq	.+26     	; 0x4848 <xTaskCheckForTimeOut+0x6e>
    482e:	8c 81       	ldd	r24, Y+4	; 0x04
    4830:	9d 81       	ldd	r25, Y+5	; 0x05
    4832:	fc 01       	movw	r30, r24
    4834:	21 81       	ldd	r18, Z+1	; 0x01
    4836:	32 81       	ldd	r19, Z+2	; 0x02
    4838:	8a 81       	ldd	r24, Y+2	; 0x02
    483a:	9b 81       	ldd	r25, Y+3	; 0x03
    483c:	82 17       	cp	r24, r18
    483e:	93 07       	cpc	r25, r19
    4840:	18 f0       	brcs	.+6      	; 0x4848 <xTaskCheckForTimeOut+0x6e>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4842:	81 e0       	ldi	r24, 0x01	; 1
    4844:	89 83       	std	Y+1, r24	; 0x01
    4846:	30 c0       	rjmp	.+96     	; 0x48a8 <xTaskCheckForTimeOut+0xce>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    4848:	8c 81       	ldd	r24, Y+4	; 0x04
    484a:	9d 81       	ldd	r25, Y+5	; 0x05
    484c:	fc 01       	movw	r30, r24
    484e:	81 81       	ldd	r24, Z+1	; 0x01
    4850:	92 81       	ldd	r25, Z+2	; 0x02
    4852:	2a 81       	ldd	r18, Y+2	; 0x02
    4854:	3b 81       	ldd	r19, Y+3	; 0x03
    4856:	28 1b       	sub	r18, r24
    4858:	39 0b       	sbc	r19, r25
    485a:	8e 81       	ldd	r24, Y+6	; 0x06
    485c:	9f 81       	ldd	r25, Y+7	; 0x07
    485e:	fc 01       	movw	r30, r24
    4860:	80 81       	ld	r24, Z
    4862:	91 81       	ldd	r25, Z+1	; 0x01
    4864:	28 17       	cp	r18, r24
    4866:	39 07       	cpc	r19, r25
    4868:	e8 f4       	brcc	.+58     	; 0x48a4 <xTaskCheckForTimeOut+0xca>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    486a:	8e 81       	ldd	r24, Y+6	; 0x06
    486c:	9f 81       	ldd	r25, Y+7	; 0x07
    486e:	fc 01       	movw	r30, r24
    4870:	20 81       	ld	r18, Z
    4872:	31 81       	ldd	r19, Z+1	; 0x01
    4874:	8c 81       	ldd	r24, Y+4	; 0x04
    4876:	9d 81       	ldd	r25, Y+5	; 0x05
    4878:	fc 01       	movw	r30, r24
    487a:	41 81       	ldd	r20, Z+1	; 0x01
    487c:	52 81       	ldd	r21, Z+2	; 0x02
    487e:	8a 81       	ldd	r24, Y+2	; 0x02
    4880:	9b 81       	ldd	r25, Y+3	; 0x03
    4882:	ba 01       	movw	r22, r20
    4884:	68 1b       	sub	r22, r24
    4886:	79 0b       	sbc	r23, r25
    4888:	cb 01       	movw	r24, r22
    488a:	28 0f       	add	r18, r24
    488c:	39 1f       	adc	r19, r25
    488e:	8e 81       	ldd	r24, Y+6	; 0x06
    4890:	9f 81       	ldd	r25, Y+7	; 0x07
    4892:	fc 01       	movw	r30, r24
    4894:	31 83       	std	Z+1, r19	; 0x01
    4896:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    4898:	8c 81       	ldd	r24, Y+4	; 0x04
    489a:	9d 81       	ldd	r25, Y+5	; 0x05
    489c:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    48a0:	19 82       	std	Y+1, r1	; 0x01
    48a2:	02 c0       	rjmp	.+4      	; 0x48a8 <xTaskCheckForTimeOut+0xce>
		}
		else
		{
			xReturn = pdTRUE;
    48a4:	81 e0       	ldi	r24, 0x01	; 1
    48a6:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    48a8:	0f 90       	pop	r0
    48aa:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    48ac:	89 81       	ldd	r24, Y+1	; 0x01
}
    48ae:	27 96       	adiw	r28, 0x07	; 7
    48b0:	0f b6       	in	r0, 0x3f	; 63
    48b2:	f8 94       	cli
    48b4:	de bf       	out	0x3e, r29	; 62
    48b6:	0f be       	out	0x3f, r0	; 63
    48b8:	cd bf       	out	0x3d, r28	; 61
    48ba:	df 91       	pop	r29
    48bc:	cf 91       	pop	r28
    48be:	08 95       	ret

000048c0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    48c0:	cf 93       	push	r28
    48c2:	df 93       	push	r29
    48c4:	cd b7       	in	r28, 0x3d	; 61
    48c6:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    48c8:	81 e0       	ldi	r24, 0x01	; 1
    48ca:	80 93 a0 02 	sts	0x02A0, r24
}
    48ce:	df 91       	pop	r29
    48d0:	cf 91       	pop	r28
    48d2:	08 95       	ret

000048d4 <prvInitialiseTCBVariables>:

#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    48d4:	0f 93       	push	r16
    48d6:	1f 93       	push	r17
    48d8:	cf 93       	push	r28
    48da:	df 93       	push	r29
    48dc:	cd b7       	in	r28, 0x3d	; 61
    48de:	de b7       	in	r29, 0x3e	; 62
    48e0:	2a 97       	sbiw	r28, 0x0a	; 10
    48e2:	0f b6       	in	r0, 0x3f	; 63
    48e4:	f8 94       	cli
    48e6:	de bf       	out	0x3e, r29	; 62
    48e8:	0f be       	out	0x3f, r0	; 63
    48ea:	cd bf       	out	0x3d, r28	; 61
    48ec:	9b 83       	std	Y+3, r25	; 0x03
    48ee:	8a 83       	std	Y+2, r24	; 0x02
    48f0:	7d 83       	std	Y+5, r23	; 0x05
    48f2:	6c 83       	std	Y+4, r22	; 0x04
    48f4:	4e 83       	std	Y+6, r20	; 0x06
    48f6:	38 87       	std	Y+8, r19	; 0x08
    48f8:	2f 83       	std	Y+7, r18	; 0x07
    48fa:	1a 87       	std	Y+10, r17	; 0x0a
    48fc:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    48fe:	19 82       	std	Y+1, r1	; 0x01
    4900:	22 c0       	rjmp	.+68     	; 0x4946 <prvInitialiseTCBVariables+0x72>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    4902:	89 81       	ldd	r24, Y+1	; 0x01
    4904:	88 2f       	mov	r24, r24
    4906:	90 e0       	ldi	r25, 0x00	; 0
    4908:	29 81       	ldd	r18, Y+1	; 0x01
    490a:	22 2f       	mov	r18, r18
    490c:	30 e0       	ldi	r19, 0x00	; 0
    490e:	4c 81       	ldd	r20, Y+4	; 0x04
    4910:	5d 81       	ldd	r21, Y+5	; 0x05
    4912:	24 0f       	add	r18, r20
    4914:	35 1f       	adc	r19, r21
    4916:	f9 01       	movw	r30, r18
    4918:	40 81       	ld	r20, Z
    491a:	2a 81       	ldd	r18, Y+2	; 0x02
    491c:	3b 81       	ldd	r19, Y+3	; 0x03
    491e:	82 0f       	add	r24, r18
    4920:	93 1f       	adc	r25, r19
    4922:	49 96       	adiw	r24, 0x19	; 25
    4924:	fc 01       	movw	r30, r24
    4926:	40 83       	st	Z, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    4928:	89 81       	ldd	r24, Y+1	; 0x01
    492a:	88 2f       	mov	r24, r24
    492c:	90 e0       	ldi	r25, 0x00	; 0
    492e:	2c 81       	ldd	r18, Y+4	; 0x04
    4930:	3d 81       	ldd	r19, Y+5	; 0x05
    4932:	82 0f       	add	r24, r18
    4934:	93 1f       	adc	r25, r19
    4936:	fc 01       	movw	r30, r24
    4938:	80 81       	ld	r24, Z
    493a:	88 23       	and	r24, r24
    493c:	09 f4       	brne	.+2      	; 0x4940 <prvInitialiseTCBVariables+0x6c>
		{
			break;
    493e:	06 c0       	rjmp	.+12     	; 0x494c <prvInitialiseTCBVariables+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4940:	89 81       	ldd	r24, Y+1	; 0x01
    4942:	8f 5f       	subi	r24, 0xFF	; 255
    4944:	89 83       	std	Y+1, r24	; 0x01
    4946:	89 81       	ldd	r24, Y+1	; 0x01
    4948:	88 30       	cpi	r24, 0x08	; 8
    494a:	d8 f2       	brcs	.-74     	; 0x4902 <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    494c:	8a 81       	ldd	r24, Y+2	; 0x02
    494e:	9b 81       	ldd	r25, Y+3	; 0x03
    4950:	fc 01       	movw	r30, r24
    4952:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4954:	8e 81       	ldd	r24, Y+6	; 0x06
    4956:	84 30       	cpi	r24, 0x04	; 4
    4958:	10 f0       	brcs	.+4      	; 0x495e <prvInitialiseTCBVariables+0x8a>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    495a:	83 e0       	ldi	r24, 0x03	; 3
    495c:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    495e:	8a 81       	ldd	r24, Y+2	; 0x02
    4960:	9b 81       	ldd	r25, Y+3	; 0x03
    4962:	2e 81       	ldd	r18, Y+6	; 0x06
    4964:	fc 01       	movw	r30, r24
    4966:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    4968:	8a 81       	ldd	r24, Y+2	; 0x02
    496a:	9b 81       	ldd	r25, Y+3	; 0x03
    496c:	2e 81       	ldd	r18, Y+6	; 0x06
    496e:	fc 01       	movw	r30, r24
    4970:	21 a3       	std	Z+33, r18	; 0x21
		pxTCB->uxMutexesHeld = 0;
    4972:	8a 81       	ldd	r24, Y+2	; 0x02
    4974:	9b 81       	ldd	r25, Y+3	; 0x03
    4976:	fc 01       	movw	r30, r24
    4978:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    497a:	8a 81       	ldd	r24, Y+2	; 0x02
    497c:	9b 81       	ldd	r25, Y+3	; 0x03
    497e:	02 96       	adiw	r24, 0x02	; 2
    4980:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4984:	8a 81       	ldd	r24, Y+2	; 0x02
    4986:	9b 81       	ldd	r25, Y+3	; 0x03
    4988:	0c 96       	adiw	r24, 0x0c	; 12
    498a:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    498e:	8a 81       	ldd	r24, Y+2	; 0x02
    4990:	9b 81       	ldd	r25, Y+3	; 0x03
    4992:	2a 81       	ldd	r18, Y+2	; 0x02
    4994:	3b 81       	ldd	r19, Y+3	; 0x03
    4996:	fc 01       	movw	r30, r24
    4998:	31 87       	std	Z+9, r19	; 0x09
    499a:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    499c:	8e 81       	ldd	r24, Y+6	; 0x06
    499e:	88 2f       	mov	r24, r24
    49a0:	90 e0       	ldi	r25, 0x00	; 0
    49a2:	24 e0       	ldi	r18, 0x04	; 4
    49a4:	30 e0       	ldi	r19, 0x00	; 0
    49a6:	28 1b       	sub	r18, r24
    49a8:	39 0b       	sbc	r19, r25
    49aa:	8a 81       	ldd	r24, Y+2	; 0x02
    49ac:	9b 81       	ldd	r25, Y+3	; 0x03
    49ae:	fc 01       	movw	r30, r24
    49b0:	35 87       	std	Z+13, r19	; 0x0d
    49b2:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    49b4:	8a 81       	ldd	r24, Y+2	; 0x02
    49b6:	9b 81       	ldd	r25, Y+3	; 0x03
    49b8:	2a 81       	ldd	r18, Y+2	; 0x02
    49ba:	3b 81       	ldd	r19, Y+3	; 0x03
    49bc:	fc 01       	movw	r30, r24
    49be:	33 8b       	std	Z+19, r19	; 0x13
    49c0:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    49c2:	8a 81       	ldd	r24, Y+2	; 0x02
    49c4:	9b 81       	ldd	r25, Y+3	; 0x03
    49c6:	fc 01       	movw	r30, r24
    49c8:	13 a2       	std	Z+35, r1	; 0x23
    49ca:	14 a2       	std	Z+36, r1	; 0x24
    49cc:	15 a2       	std	Z+37, r1	; 0x25
    49ce:	16 a2       	std	Z+38, r1	; 0x26
		pxTCB->eNotifyState = eNotWaitingNotification;
    49d0:	8a 81       	ldd	r24, Y+2	; 0x02
    49d2:	9b 81       	ldd	r25, Y+3	; 0x03
    49d4:	fc 01       	movw	r30, r24
    49d6:	17 a2       	std	Z+39, r1	; 0x27
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    49d8:	2a 96       	adiw	r28, 0x0a	; 10
    49da:	0f b6       	in	r0, 0x3f	; 63
    49dc:	f8 94       	cli
    49de:	de bf       	out	0x3e, r29	; 62
    49e0:	0f be       	out	0x3f, r0	; 63
    49e2:	cd bf       	out	0x3d, r28	; 61
    49e4:	df 91       	pop	r29
    49e6:	cf 91       	pop	r28
    49e8:	1f 91       	pop	r17
    49ea:	0f 91       	pop	r16
    49ec:	08 95       	ret

000049ee <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    49ee:	cf 93       	push	r28
    49f0:	df 93       	push	r29
    49f2:	1f 92       	push	r1
    49f4:	cd b7       	in	r28, 0x3d	; 61
    49f6:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    49f8:	19 82       	std	Y+1, r1	; 0x01
    49fa:	13 c0       	rjmp	.+38     	; 0x4a22 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    49fc:	89 81       	ldd	r24, Y+1	; 0x01
    49fe:	28 2f       	mov	r18, r24
    4a00:	30 e0       	ldi	r19, 0x00	; 0
    4a02:	c9 01       	movw	r24, r18
    4a04:	88 0f       	add	r24, r24
    4a06:	99 1f       	adc	r25, r25
    4a08:	88 0f       	add	r24, r24
    4a0a:	99 1f       	adc	r25, r25
    4a0c:	88 0f       	add	r24, r24
    4a0e:	99 1f       	adc	r25, r25
    4a10:	82 0f       	add	r24, r18
    4a12:	93 1f       	adc	r25, r19
    4a14:	8c 5b       	subi	r24, 0xBC	; 188
    4a16:	9d 4f       	sbci	r25, 0xFD	; 253
    4a18:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4a1c:	89 81       	ldd	r24, Y+1	; 0x01
    4a1e:	8f 5f       	subi	r24, 0xFF	; 255
    4a20:	89 83       	std	Y+1, r24	; 0x01
    4a22:	89 81       	ldd	r24, Y+1	; 0x01
    4a24:	84 30       	cpi	r24, 0x04	; 4
    4a26:	50 f3       	brcs	.-44     	; 0x49fc <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4a28:	88 e6       	ldi	r24, 0x68	; 104
    4a2a:	92 e0       	ldi	r25, 0x02	; 2
    4a2c:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    4a30:	81 e7       	ldi	r24, 0x71	; 113
    4a32:	92 e0       	ldi	r25, 0x02	; 2
    4a34:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4a38:	8e e7       	ldi	r24, 0x7E	; 126
    4a3a:	92 e0       	ldi	r25, 0x02	; 2
    4a3c:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    4a40:	87 e8       	ldi	r24, 0x87	; 135
    4a42:	92 e0       	ldi	r25, 0x02	; 2
    4a44:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    4a48:	81 e9       	ldi	r24, 0x91	; 145
    4a4a:	92 e0       	ldi	r25, 0x02	; 2
    4a4c:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4a50:	88 e6       	ldi	r24, 0x68	; 104
    4a52:	92 e0       	ldi	r25, 0x02	; 2
    4a54:	90 93 7b 02 	sts	0x027B, r25
    4a58:	80 93 7a 02 	sts	0x027A, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4a5c:	81 e7       	ldi	r24, 0x71	; 113
    4a5e:	92 e0       	ldi	r25, 0x02	; 2
    4a60:	90 93 7d 02 	sts	0x027D, r25
    4a64:	80 93 7c 02 	sts	0x027C, r24
}
    4a68:	0f 90       	pop	r0
    4a6a:	df 91       	pop	r29
    4a6c:	cf 91       	pop	r28
    4a6e:	08 95       	ret

00004a70 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4a70:	cf 93       	push	r28
    4a72:	df 93       	push	r29
    4a74:	00 d0       	rcall	.+0      	; 0x4a76 <prvCheckTasksWaitingTermination+0x6>
    4a76:	cd b7       	in	r28, 0x3d	; 61
    4a78:	de b7       	in	r29, 0x3e	; 62
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    4a7a:	2f c0       	rjmp	.+94     	; 0x4ada <prvCheckTasksWaitingTermination+0x6a>
		{
			vTaskSuspendAll();
    4a7c:	0e 94 13 20 	call	0x4026	; 0x4026 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4a80:	90 91 87 02 	lds	r25, 0x0287
    4a84:	81 e0       	ldi	r24, 0x01	; 1
    4a86:	99 23       	and	r25, r25
    4a88:	09 f0       	breq	.+2      	; 0x4a8c <prvCheckTasksWaitingTermination+0x1c>
    4a8a:	80 e0       	ldi	r24, 0x00	; 0
    4a8c:	89 83       	std	Y+1, r24	; 0x01
			}
			( void ) xTaskResumeAll();
    4a8e:	0e 94 1f 20 	call	0x403e	; 0x403e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    4a92:	89 81       	ldd	r24, Y+1	; 0x01
    4a94:	88 23       	and	r24, r24
    4a96:	09 f5       	brne	.+66     	; 0x4ada <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    4a98:	0f b6       	in	r0, 0x3f	; 63
    4a9a:	f8 94       	cli
    4a9c:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    4a9e:	80 91 8c 02 	lds	r24, 0x028C
    4aa2:	90 91 8d 02 	lds	r25, 0x028D
    4aa6:	fc 01       	movw	r30, r24
    4aa8:	86 81       	ldd	r24, Z+6	; 0x06
    4aaa:	97 81       	ldd	r25, Z+7	; 0x07
    4aac:	9b 83       	std	Y+3, r25	; 0x03
    4aae:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4ab0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ab2:	9b 81       	ldd	r25, Y+3	; 0x03
    4ab4:	02 96       	adiw	r24, 0x02	; 2
    4ab6:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
					--uxCurrentNumberOfTasks;
    4aba:	80 91 9a 02 	lds	r24, 0x029A
    4abe:	81 50       	subi	r24, 0x01	; 1
    4ac0:	80 93 9a 02 	sts	0x029A, r24
					--uxTasksDeleted;
    4ac4:	80 91 90 02 	lds	r24, 0x0290
    4ac8:	81 50       	subi	r24, 0x01	; 1
    4aca:	80 93 90 02 	sts	0x0290, r24
				}
				taskEXIT_CRITICAL();
    4ace:	0f 90       	pop	r0
    4ad0:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    4ad2:	8a 81       	ldd	r24, Y+2	; 0x02
    4ad4:	9b 81       	ldd	r25, Y+3	; 0x03
    4ad6:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    4ada:	80 91 90 02 	lds	r24, 0x0290
    4ade:	88 23       	and	r24, r24
    4ae0:	69 f6       	brne	.-102    	; 0x4a7c <prvCheckTasksWaitingTermination+0xc>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    4ae2:	0f 90       	pop	r0
    4ae4:	0f 90       	pop	r0
    4ae6:	0f 90       	pop	r0
    4ae8:	df 91       	pop	r29
    4aea:	cf 91       	pop	r28
    4aec:	08 95       	ret

00004aee <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    4aee:	cf 93       	push	r28
    4af0:	df 93       	push	r29
    4af2:	1f 92       	push	r1
    4af4:	1f 92       	push	r1
    4af6:	cd b7       	in	r28, 0x3d	; 61
    4af8:	de b7       	in	r29, 0x3e	; 62
    4afa:	9a 83       	std	Y+2, r25	; 0x02
    4afc:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    4afe:	80 91 42 02 	lds	r24, 0x0242
    4b02:	90 91 43 02 	lds	r25, 0x0243
    4b06:	29 81       	ldd	r18, Y+1	; 0x01
    4b08:	3a 81       	ldd	r19, Y+2	; 0x02
    4b0a:	fc 01       	movw	r30, r24
    4b0c:	33 83       	std	Z+3, r19	; 0x03
    4b0e:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    4b10:	80 91 9b 02 	lds	r24, 0x029B
    4b14:	90 91 9c 02 	lds	r25, 0x029C
    4b18:	29 81       	ldd	r18, Y+1	; 0x01
    4b1a:	3a 81       	ldd	r19, Y+2	; 0x02
    4b1c:	28 17       	cp	r18, r24
    4b1e:	39 07       	cpc	r19, r25
    4b20:	78 f4       	brcc	.+30     	; 0x4b40 <prvAddCurrentTaskToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    4b22:	80 91 42 02 	lds	r24, 0x0242
    4b26:	90 91 43 02 	lds	r25, 0x0243
    4b2a:	9c 01       	movw	r18, r24
    4b2c:	2e 5f       	subi	r18, 0xFE	; 254
    4b2e:	3f 4f       	sbci	r19, 0xFF	; 255
    4b30:	80 91 7c 02 	lds	r24, 0x027C
    4b34:	90 91 7d 02 	lds	r25, 0x027D
    4b38:	b9 01       	movw	r22, r18
    4b3a:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vListInsert>
    4b3e:	1d c0       	rjmp	.+58     	; 0x4b7a <prvAddCurrentTaskToDelayedList+0x8c>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    4b40:	80 91 42 02 	lds	r24, 0x0242
    4b44:	90 91 43 02 	lds	r25, 0x0243
    4b48:	9c 01       	movw	r18, r24
    4b4a:	2e 5f       	subi	r18, 0xFE	; 254
    4b4c:	3f 4f       	sbci	r19, 0xFF	; 255
    4b4e:	80 91 7a 02 	lds	r24, 0x027A
    4b52:	90 91 7b 02 	lds	r25, 0x027B
    4b56:	b9 01       	movw	r22, r18
    4b58:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    4b5c:	80 91 a3 02 	lds	r24, 0x02A3
    4b60:	90 91 a4 02 	lds	r25, 0x02A4
    4b64:	29 81       	ldd	r18, Y+1	; 0x01
    4b66:	3a 81       	ldd	r19, Y+2	; 0x02
    4b68:	28 17       	cp	r18, r24
    4b6a:	39 07       	cpc	r19, r25
    4b6c:	30 f4       	brcc	.+12     	; 0x4b7a <prvAddCurrentTaskToDelayedList+0x8c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    4b6e:	89 81       	ldd	r24, Y+1	; 0x01
    4b70:	9a 81       	ldd	r25, Y+2	; 0x02
    4b72:	90 93 a4 02 	sts	0x02A4, r25
    4b76:	80 93 a3 02 	sts	0x02A3, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    4b7a:	0f 90       	pop	r0
    4b7c:	0f 90       	pop	r0
    4b7e:	df 91       	pop	r29
    4b80:	cf 91       	pop	r28
    4b82:	08 95       	ret

00004b84 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    4b84:	cf 93       	push	r28
    4b86:	df 93       	push	r29
    4b88:	cd b7       	in	r28, 0x3d	; 61
    4b8a:	de b7       	in	r29, 0x3e	; 62
    4b8c:	28 97       	sbiw	r28, 0x08	; 8
    4b8e:	0f b6       	in	r0, 0x3f	; 63
    4b90:	f8 94       	cli
    4b92:	de bf       	out	0x3e, r29	; 62
    4b94:	0f be       	out	0x3f, r0	; 63
    4b96:	cd bf       	out	0x3d, r28	; 61
    4b98:	9e 83       	std	Y+6, r25	; 0x06
    4b9a:	8d 83       	std	Y+5, r24	; 0x05
    4b9c:	78 87       	std	Y+8, r23	; 0x08
    4b9e:	6f 83       	std	Y+7, r22	; 0x07
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4ba0:	8f 81       	ldd	r24, Y+7	; 0x07
    4ba2:	98 85       	ldd	r25, Y+8	; 0x08
    4ba4:	00 97       	sbiw	r24, 0x00	; 0
    4ba6:	29 f4       	brne	.+10     	; 0x4bb2 <prvAllocateTCBAndStack+0x2e>
    4ba8:	8d 81       	ldd	r24, Y+5	; 0x05
    4baa:	9e 81       	ldd	r25, Y+6	; 0x06
    4bac:	0e 94 3b 0c 	call	0x1876	; 0x1876 <pvPortMalloc>
    4bb0:	02 c0       	rjmp	.+4      	; 0x4bb6 <prvAllocateTCBAndStack+0x32>
    4bb2:	8f 81       	ldd	r24, Y+7	; 0x07
    4bb4:	98 85       	ldd	r25, Y+8	; 0x08
    4bb6:	9c 83       	std	Y+4, r25	; 0x04
    4bb8:	8b 83       	std	Y+3, r24	; 0x03

		if( pxStack != NULL )
    4bba:	8b 81       	ldd	r24, Y+3	; 0x03
    4bbc:	9c 81       	ldd	r25, Y+4	; 0x04
    4bbe:	00 97       	sbiw	r24, 0x00	; 0
    4bc0:	b9 f0       	breq	.+46     	; 0x4bf0 <prvAllocateTCBAndStack+0x6c>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    4bc2:	88 e2       	ldi	r24, 0x28	; 40
    4bc4:	90 e0       	ldi	r25, 0x00	; 0
    4bc6:	0e 94 3b 0c 	call	0x1876	; 0x1876 <pvPortMalloc>
    4bca:	9a 83       	std	Y+2, r25	; 0x02
    4bcc:	89 83       	std	Y+1, r24	; 0x01

			if( pxNewTCB != NULL )
    4bce:	89 81       	ldd	r24, Y+1	; 0x01
    4bd0:	9a 81       	ldd	r25, Y+2	; 0x02
    4bd2:	00 97       	sbiw	r24, 0x00	; 0
    4bd4:	41 f0       	breq	.+16     	; 0x4be6 <prvAllocateTCBAndStack+0x62>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    4bd6:	89 81       	ldd	r24, Y+1	; 0x01
    4bd8:	9a 81       	ldd	r25, Y+2	; 0x02
    4bda:	2b 81       	ldd	r18, Y+3	; 0x03
    4bdc:	3c 81       	ldd	r19, Y+4	; 0x04
    4bde:	fc 01       	movw	r30, r24
    4be0:	30 8f       	std	Z+24, r19	; 0x18
    4be2:	27 8b       	std	Z+23, r18	; 0x17
    4be4:	07 c0       	rjmp	.+14     	; 0x4bf4 <prvAllocateTCBAndStack+0x70>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    4be6:	8b 81       	ldd	r24, Y+3	; 0x03
    4be8:	9c 81       	ldd	r25, Y+4	; 0x04
    4bea:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <vPortFree>
    4bee:	02 c0       	rjmp	.+4      	; 0x4bf4 <prvAllocateTCBAndStack+0x70>
			}
		}
		else
		{
			pxNewTCB = NULL;
    4bf0:	1a 82       	std	Y+2, r1	; 0x02
    4bf2:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	#endif /* portSTACK_GROWTH */

	if( pxNewTCB != NULL )
    4bf4:	89 81       	ldd	r24, Y+1	; 0x01
    4bf6:	9a 81       	ldd	r25, Y+2	; 0x02
    4bf8:	00 97       	sbiw	r24, 0x00	; 0
    4bfa:	61 f0       	breq	.+24     	; 0x4c14 <prvAllocateTCBAndStack+0x90>
	{
		/* Avoid dependency on memset() if it is not required. */
		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
    4bfc:	89 81       	ldd	r24, Y+1	; 0x01
    4bfe:	9a 81       	ldd	r25, Y+2	; 0x02
    4c00:	fc 01       	movw	r30, r24
    4c02:	87 89       	ldd	r24, Z+23	; 0x17
    4c04:	90 8d       	ldd	r25, Z+24	; 0x18
    4c06:	2d 81       	ldd	r18, Y+5	; 0x05
    4c08:	3e 81       	ldd	r19, Y+6	; 0x06
    4c0a:	a9 01       	movw	r20, r18
    4c0c:	65 ea       	ldi	r22, 0xA5	; 165
    4c0e:	70 e0       	ldi	r23, 0x00	; 0
    4c10:	0e 94 4c 2f 	call	0x5e98	; 0x5e98 <memset>
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
    4c14:	89 81       	ldd	r24, Y+1	; 0x01
    4c16:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4c18:	28 96       	adiw	r28, 0x08	; 8
    4c1a:	0f b6       	in	r0, 0x3f	; 63
    4c1c:	f8 94       	cli
    4c1e:	de bf       	out	0x3e, r29	; 62
    4c20:	0f be       	out	0x3f, r0	; 63
    4c22:	cd bf       	out	0x3d, r28	; 61
    4c24:	df 91       	pop	r29
    4c26:	cf 91       	pop	r28
    4c28:	08 95       	ret

00004c2a <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
    4c2a:	cf 93       	push	r28
    4c2c:	df 93       	push	r29
    4c2e:	00 d0       	rcall	.+0      	; 0x4c30 <prvTaskCheckFreeStackSpace+0x6>
    4c30:	00 d0       	rcall	.+0      	; 0x4c32 <prvTaskCheckFreeStackSpace+0x8>
    4c32:	cd b7       	in	r28, 0x3d	; 61
    4c34:	de b7       	in	r29, 0x3e	; 62
    4c36:	9e 83       	std	Y+6, r25	; 0x06
    4c38:	8d 83       	std	Y+5, r24	; 0x05
	uint32_t ulCount = 0U;
    4c3a:	19 82       	std	Y+1, r1	; 0x01
    4c3c:	1a 82       	std	Y+2, r1	; 0x02
    4c3e:	1b 82       	std	Y+3, r1	; 0x03
    4c40:	1c 82       	std	Y+4, r1	; 0x04

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    4c42:	10 c0       	rjmp	.+32     	; 0x4c64 <prvTaskCheckFreeStackSpace+0x3a>
		{
			pucStackByte -= portSTACK_GROWTH;
    4c44:	8d 81       	ldd	r24, Y+5	; 0x05
    4c46:	9e 81       	ldd	r25, Y+6	; 0x06
    4c48:	01 96       	adiw	r24, 0x01	; 1
    4c4a:	9e 83       	std	Y+6, r25	; 0x06
    4c4c:	8d 83       	std	Y+5, r24	; 0x05
			ulCount++;
    4c4e:	89 81       	ldd	r24, Y+1	; 0x01
    4c50:	9a 81       	ldd	r25, Y+2	; 0x02
    4c52:	ab 81       	ldd	r26, Y+3	; 0x03
    4c54:	bc 81       	ldd	r27, Y+4	; 0x04
    4c56:	01 96       	adiw	r24, 0x01	; 1
    4c58:	a1 1d       	adc	r26, r1
    4c5a:	b1 1d       	adc	r27, r1
    4c5c:	89 83       	std	Y+1, r24	; 0x01
    4c5e:	9a 83       	std	Y+2, r25	; 0x02
    4c60:	ab 83       	std	Y+3, r26	; 0x03
    4c62:	bc 83       	std	Y+4, r27	; 0x04

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    4c64:	8d 81       	ldd	r24, Y+5	; 0x05
    4c66:	9e 81       	ldd	r25, Y+6	; 0x06
    4c68:	fc 01       	movw	r30, r24
    4c6a:	80 81       	ld	r24, Z
    4c6c:	85 3a       	cpi	r24, 0xA5	; 165
    4c6e:	51 f3       	breq	.-44     	; 0x4c44 <prvTaskCheckFreeStackSpace+0x1a>
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t );

		return ( uint16_t ) ulCount;
    4c70:	89 81       	ldd	r24, Y+1	; 0x01
    4c72:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4c74:	26 96       	adiw	r28, 0x06	; 6
    4c76:	0f b6       	in	r0, 0x3f	; 63
    4c78:	f8 94       	cli
    4c7a:	de bf       	out	0x3e, r29	; 62
    4c7c:	0f be       	out	0x3f, r0	; 63
    4c7e:	cd bf       	out	0x3d, r28	; 61
    4c80:	df 91       	pop	r29
    4c82:	cf 91       	pop	r28
    4c84:	08 95       	ret

00004c86 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
	{
    4c86:	cf 93       	push	r28
    4c88:	df 93       	push	r29
    4c8a:	cd b7       	in	r28, 0x3d	; 61
    4c8c:	de b7       	in	r29, 0x3e	; 62
    4c8e:	27 97       	sbiw	r28, 0x07	; 7
    4c90:	0f b6       	in	r0, 0x3f	; 63
    4c92:	f8 94       	cli
    4c94:	de bf       	out	0x3e, r29	; 62
    4c96:	0f be       	out	0x3f, r0	; 63
    4c98:	cd bf       	out	0x3d, r28	; 61
    4c9a:	9f 83       	std	Y+7, r25	; 0x07
    4c9c:	8e 83       	std	Y+6, r24	; 0x06
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    4c9e:	8e 81       	ldd	r24, Y+6	; 0x06
    4ca0:	9f 81       	ldd	r25, Y+7	; 0x07
    4ca2:	00 97       	sbiw	r24, 0x00	; 0
    4ca4:	29 f4       	brne	.+10     	; 0x4cb0 <uxTaskGetStackHighWaterMark+0x2a>
    4ca6:	80 91 42 02 	lds	r24, 0x0242
    4caa:	90 91 43 02 	lds	r25, 0x0243
    4cae:	02 c0       	rjmp	.+4      	; 0x4cb4 <uxTaskGetStackHighWaterMark+0x2e>
    4cb0:	8e 81       	ldd	r24, Y+6	; 0x06
    4cb2:	9f 81       	ldd	r25, Y+7	; 0x07
    4cb4:	9a 83       	std	Y+2, r25	; 0x02
    4cb6:	89 83       	std	Y+1, r24	; 0x01

		#if portSTACK_GROWTH < 0
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
    4cb8:	89 81       	ldd	r24, Y+1	; 0x01
    4cba:	9a 81       	ldd	r25, Y+2	; 0x02
    4cbc:	fc 01       	movw	r30, r24
    4cbe:	87 89       	ldd	r24, Z+23	; 0x17
    4cc0:	90 8d       	ldd	r25, Z+24	; 0x18
    4cc2:	9c 83       	std	Y+4, r25	; 0x04
    4cc4:	8b 83       	std	Y+3, r24	; 0x03
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
    4cc6:	8b 81       	ldd	r24, Y+3	; 0x03
    4cc8:	9c 81       	ldd	r25, Y+4	; 0x04
    4cca:	0e 94 15 26 	call	0x4c2a	; 0x4c2a <prvTaskCheckFreeStackSpace>
    4cce:	8d 83       	std	Y+5, r24	; 0x05

		return uxReturn;
    4cd0:	8d 81       	ldd	r24, Y+5	; 0x05
	}
    4cd2:	27 96       	adiw	r28, 0x07	; 7
    4cd4:	0f b6       	in	r0, 0x3f	; 63
    4cd6:	f8 94       	cli
    4cd8:	de bf       	out	0x3e, r29	; 62
    4cda:	0f be       	out	0x3f, r0	; 63
    4cdc:	cd bf       	out	0x3d, r28	; 61
    4cde:	df 91       	pop	r29
    4ce0:	cf 91       	pop	r28
    4ce2:	08 95       	ret

00004ce4 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4ce4:	cf 93       	push	r28
    4ce6:	df 93       	push	r29
    4ce8:	1f 92       	push	r1
    4cea:	1f 92       	push	r1
    4cec:	cd b7       	in	r28, 0x3d	; 61
    4cee:	de b7       	in	r29, 0x3e	; 62
    4cf0:	9a 83       	std	Y+2, r25	; 0x02
    4cf2:	89 83       	std	Y+1, r24	; 0x01
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    4cf4:	89 81       	ldd	r24, Y+1	; 0x01
    4cf6:	9a 81       	ldd	r25, Y+2	; 0x02
    4cf8:	fc 01       	movw	r30, r24
    4cfa:	87 89       	ldd	r24, Z+23	; 0x17
    4cfc:	90 8d       	ldd	r25, Z+24	; 0x18
    4cfe:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    4d02:	89 81       	ldd	r24, Y+1	; 0x01
    4d04:	9a 81       	ldd	r25, Y+2	; 0x02
    4d06:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <vPortFree>
	}
    4d0a:	0f 90       	pop	r0
    4d0c:	0f 90       	pop	r0
    4d0e:	df 91       	pop	r29
    4d10:	cf 91       	pop	r28
    4d12:	08 95       	ret

00004d14 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4d14:	cf 93       	push	r28
    4d16:	df 93       	push	r29
    4d18:	1f 92       	push	r1
    4d1a:	1f 92       	push	r1
    4d1c:	cd b7       	in	r28, 0x3d	; 61
    4d1e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4d20:	80 91 7a 02 	lds	r24, 0x027A
    4d24:	90 91 7b 02 	lds	r25, 0x027B
    4d28:	fc 01       	movw	r30, r24
    4d2a:	80 81       	ld	r24, Z
    4d2c:	88 23       	and	r24, r24
    4d2e:	39 f4       	brne	.+14     	; 0x4d3e <prvResetNextTaskUnblockTime+0x2a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4d30:	8f ef       	ldi	r24, 0xFF	; 255
    4d32:	9f ef       	ldi	r25, 0xFF	; 255
    4d34:	90 93 a4 02 	sts	0x02A4, r25
    4d38:	80 93 a3 02 	sts	0x02A3, r24
    4d3c:	15 c0       	rjmp	.+42     	; 0x4d68 <prvResetNextTaskUnblockTime+0x54>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4d3e:	80 91 7a 02 	lds	r24, 0x027A
    4d42:	90 91 7b 02 	lds	r25, 0x027B
    4d46:	fc 01       	movw	r30, r24
    4d48:	85 81       	ldd	r24, Z+5	; 0x05
    4d4a:	96 81       	ldd	r25, Z+6	; 0x06
    4d4c:	fc 01       	movw	r30, r24
    4d4e:	86 81       	ldd	r24, Z+6	; 0x06
    4d50:	97 81       	ldd	r25, Z+7	; 0x07
    4d52:	9a 83       	std	Y+2, r25	; 0x02
    4d54:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    4d56:	89 81       	ldd	r24, Y+1	; 0x01
    4d58:	9a 81       	ldd	r25, Y+2	; 0x02
    4d5a:	fc 01       	movw	r30, r24
    4d5c:	82 81       	ldd	r24, Z+2	; 0x02
    4d5e:	93 81       	ldd	r25, Z+3	; 0x03
    4d60:	90 93 a4 02 	sts	0x02A4, r25
    4d64:	80 93 a3 02 	sts	0x02A3, r24
	}
}
    4d68:	0f 90       	pop	r0
    4d6a:	0f 90       	pop	r0
    4d6c:	df 91       	pop	r29
    4d6e:	cf 91       	pop	r28
    4d70:	08 95       	ret

00004d72 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    4d72:	cf 93       	push	r28
    4d74:	df 93       	push	r29
    4d76:	1f 92       	push	r1
    4d78:	1f 92       	push	r1
    4d7a:	cd b7       	in	r28, 0x3d	; 61
    4d7c:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4d7e:	80 91 42 02 	lds	r24, 0x0242
    4d82:	90 91 43 02 	lds	r25, 0x0243
    4d86:	9a 83       	std	Y+2, r25	; 0x02
    4d88:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4d8a:	89 81       	ldd	r24, Y+1	; 0x01
    4d8c:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4d8e:	0f 90       	pop	r0
    4d90:	0f 90       	pop	r0
    4d92:	df 91       	pop	r29
    4d94:	cf 91       	pop	r28
    4d96:	08 95       	ret

00004d98 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    4d98:	cf 93       	push	r28
    4d9a:	df 93       	push	r29
    4d9c:	00 d0       	rcall	.+0      	; 0x4d9e <vTaskPriorityInherit+0x6>
    4d9e:	1f 92       	push	r1
    4da0:	cd b7       	in	r28, 0x3d	; 61
    4da2:	de b7       	in	r29, 0x3e	; 62
    4da4:	9c 83       	std	Y+4, r25	; 0x04
    4da6:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    4da8:	8b 81       	ldd	r24, Y+3	; 0x03
    4daa:	9c 81       	ldd	r25, Y+4	; 0x04
    4dac:	9a 83       	std	Y+2, r25	; 0x02
    4dae:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    4db0:	8b 81       	ldd	r24, Y+3	; 0x03
    4db2:	9c 81       	ldd	r25, Y+4	; 0x04
    4db4:	00 97       	sbiw	r24, 0x00	; 0
    4db6:	09 f4       	brne	.+2      	; 0x4dba <vTaskPriorityInherit+0x22>
    4db8:	7f c0       	rjmp	.+254    	; 0x4eb8 <vTaskPriorityInherit+0x120>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    4dba:	89 81       	ldd	r24, Y+1	; 0x01
    4dbc:	9a 81       	ldd	r25, Y+2	; 0x02
    4dbe:	fc 01       	movw	r30, r24
    4dc0:	26 89       	ldd	r18, Z+22	; 0x16
    4dc2:	80 91 42 02 	lds	r24, 0x0242
    4dc6:	90 91 43 02 	lds	r25, 0x0243
    4dca:	fc 01       	movw	r30, r24
    4dcc:	86 89       	ldd	r24, Z+22	; 0x16
    4dce:	28 17       	cp	r18, r24
    4dd0:	08 f0       	brcs	.+2      	; 0x4dd4 <vTaskPriorityInherit+0x3c>
    4dd2:	72 c0       	rjmp	.+228    	; 0x4eb8 <vTaskPriorityInherit+0x120>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    4dd4:	89 81       	ldd	r24, Y+1	; 0x01
    4dd6:	9a 81       	ldd	r25, Y+2	; 0x02
    4dd8:	fc 01       	movw	r30, r24
    4dda:	84 85       	ldd	r24, Z+12	; 0x0c
    4ddc:	95 85       	ldd	r25, Z+13	; 0x0d
    4dde:	99 23       	and	r25, r25
    4de0:	8c f0       	brlt	.+34     	; 0x4e04 <vTaskPriorityInherit+0x6c>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4de2:	80 91 42 02 	lds	r24, 0x0242
    4de6:	90 91 43 02 	lds	r25, 0x0243
    4dea:	fc 01       	movw	r30, r24
    4dec:	86 89       	ldd	r24, Z+22	; 0x16
    4dee:	88 2f       	mov	r24, r24
    4df0:	90 e0       	ldi	r25, 0x00	; 0
    4df2:	24 e0       	ldi	r18, 0x04	; 4
    4df4:	30 e0       	ldi	r19, 0x00	; 0
    4df6:	28 1b       	sub	r18, r24
    4df8:	39 0b       	sbc	r19, r25
    4dfa:	89 81       	ldd	r24, Y+1	; 0x01
    4dfc:	9a 81       	ldd	r25, Y+2	; 0x02
    4dfe:	fc 01       	movw	r30, r24
    4e00:	35 87       	std	Z+13, r19	; 0x0d
    4e02:	24 87       	std	Z+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    4e04:	89 81       	ldd	r24, Y+1	; 0x01
    4e06:	9a 81       	ldd	r25, Y+2	; 0x02
    4e08:	fc 01       	movw	r30, r24
    4e0a:	42 85       	ldd	r20, Z+10	; 0x0a
    4e0c:	53 85       	ldd	r21, Z+11	; 0x0b
    4e0e:	89 81       	ldd	r24, Y+1	; 0x01
    4e10:	9a 81       	ldd	r25, Y+2	; 0x02
    4e12:	fc 01       	movw	r30, r24
    4e14:	86 89       	ldd	r24, Z+22	; 0x16
    4e16:	28 2f       	mov	r18, r24
    4e18:	30 e0       	ldi	r19, 0x00	; 0
    4e1a:	c9 01       	movw	r24, r18
    4e1c:	88 0f       	add	r24, r24
    4e1e:	99 1f       	adc	r25, r25
    4e20:	88 0f       	add	r24, r24
    4e22:	99 1f       	adc	r25, r25
    4e24:	88 0f       	add	r24, r24
    4e26:	99 1f       	adc	r25, r25
    4e28:	82 0f       	add	r24, r18
    4e2a:	93 1f       	adc	r25, r19
    4e2c:	8c 5b       	subi	r24, 0xBC	; 188
    4e2e:	9d 4f       	sbci	r25, 0xFD	; 253
    4e30:	48 17       	cp	r20, r24
    4e32:	59 07       	cpc	r21, r25
    4e34:	b9 f5       	brne	.+110    	; 0x4ea4 <vTaskPriorityInherit+0x10c>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4e36:	89 81       	ldd	r24, Y+1	; 0x01
    4e38:	9a 81       	ldd	r25, Y+2	; 0x02
    4e3a:	02 96       	adiw	r24, 0x02	; 2
    4e3c:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    4e40:	80 91 42 02 	lds	r24, 0x0242
    4e44:	90 91 43 02 	lds	r25, 0x0243
    4e48:	fc 01       	movw	r30, r24
    4e4a:	26 89       	ldd	r18, Z+22	; 0x16
    4e4c:	89 81       	ldd	r24, Y+1	; 0x01
    4e4e:	9a 81       	ldd	r25, Y+2	; 0x02
    4e50:	fc 01       	movw	r30, r24
    4e52:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyList( pxTCB );
    4e54:	89 81       	ldd	r24, Y+1	; 0x01
    4e56:	9a 81       	ldd	r25, Y+2	; 0x02
    4e58:	fc 01       	movw	r30, r24
    4e5a:	96 89       	ldd	r25, Z+22	; 0x16
    4e5c:	80 91 9d 02 	lds	r24, 0x029D
    4e60:	89 17       	cp	r24, r25
    4e62:	30 f4       	brcc	.+12     	; 0x4e70 <vTaskPriorityInherit+0xd8>
    4e64:	89 81       	ldd	r24, Y+1	; 0x01
    4e66:	9a 81       	ldd	r25, Y+2	; 0x02
    4e68:	fc 01       	movw	r30, r24
    4e6a:	86 89       	ldd	r24, Z+22	; 0x16
    4e6c:	80 93 9d 02 	sts	0x029D, r24
    4e70:	89 81       	ldd	r24, Y+1	; 0x01
    4e72:	9a 81       	ldd	r25, Y+2	; 0x02
    4e74:	ac 01       	movw	r20, r24
    4e76:	4e 5f       	subi	r20, 0xFE	; 254
    4e78:	5f 4f       	sbci	r21, 0xFF	; 255
    4e7a:	89 81       	ldd	r24, Y+1	; 0x01
    4e7c:	9a 81       	ldd	r25, Y+2	; 0x02
    4e7e:	fc 01       	movw	r30, r24
    4e80:	86 89       	ldd	r24, Z+22	; 0x16
    4e82:	28 2f       	mov	r18, r24
    4e84:	30 e0       	ldi	r19, 0x00	; 0
    4e86:	c9 01       	movw	r24, r18
    4e88:	88 0f       	add	r24, r24
    4e8a:	99 1f       	adc	r25, r25
    4e8c:	88 0f       	add	r24, r24
    4e8e:	99 1f       	adc	r25, r25
    4e90:	88 0f       	add	r24, r24
    4e92:	99 1f       	adc	r25, r25
    4e94:	82 0f       	add	r24, r18
    4e96:	93 1f       	adc	r25, r19
    4e98:	8c 5b       	subi	r24, 0xBC	; 188
    4e9a:	9d 4f       	sbci	r25, 0xFD	; 253
    4e9c:	ba 01       	movw	r22, r20
    4e9e:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
    4ea2:	0a c0       	rjmp	.+20     	; 0x4eb8 <vTaskPriorityInherit+0x120>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    4ea4:	80 91 42 02 	lds	r24, 0x0242
    4ea8:	90 91 43 02 	lds	r25, 0x0243
    4eac:	fc 01       	movw	r30, r24
    4eae:	26 89       	ldd	r18, Z+22	; 0x16
    4eb0:	89 81       	ldd	r24, Y+1	; 0x01
    4eb2:	9a 81       	ldd	r25, Y+2	; 0x02
    4eb4:	fc 01       	movw	r30, r24
    4eb6:	26 8b       	std	Z+22, r18	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4eb8:	0f 90       	pop	r0
    4eba:	0f 90       	pop	r0
    4ebc:	0f 90       	pop	r0
    4ebe:	0f 90       	pop	r0
    4ec0:	df 91       	pop	r29
    4ec2:	cf 91       	pop	r28
    4ec4:	08 95       	ret

00004ec6 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    4ec6:	cf 93       	push	r28
    4ec8:	df 93       	push	r29
    4eca:	00 d0       	rcall	.+0      	; 0x4ecc <xTaskPriorityDisinherit+0x6>
    4ecc:	1f 92       	push	r1
    4ece:	1f 92       	push	r1
    4ed0:	cd b7       	in	r28, 0x3d	; 61
    4ed2:	de b7       	in	r29, 0x3e	; 62
    4ed4:	9d 83       	std	Y+5, r25	; 0x05
    4ed6:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    4ed8:	8c 81       	ldd	r24, Y+4	; 0x04
    4eda:	9d 81       	ldd	r25, Y+5	; 0x05
    4edc:	9b 83       	std	Y+3, r25	; 0x03
    4ede:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    4ee0:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    4ee2:	8c 81       	ldd	r24, Y+4	; 0x04
    4ee4:	9d 81       	ldd	r25, Y+5	; 0x05
    4ee6:	00 97       	sbiw	r24, 0x00	; 0
    4ee8:	09 f4       	brne	.+2      	; 0x4eec <xTaskPriorityDisinherit+0x26>
    4eea:	61 c0       	rjmp	.+194    	; 0x4fae <xTaskPriorityDisinherit+0xe8>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    4eec:	8a 81       	ldd	r24, Y+2	; 0x02
    4eee:	9b 81       	ldd	r25, Y+3	; 0x03
    4ef0:	fc 01       	movw	r30, r24
    4ef2:	82 a1       	ldd	r24, Z+34	; 0x22
    4ef4:	2f ef       	ldi	r18, 0xFF	; 255
    4ef6:	28 0f       	add	r18, r24
    4ef8:	8a 81       	ldd	r24, Y+2	; 0x02
    4efa:	9b 81       	ldd	r25, Y+3	; 0x03
    4efc:	fc 01       	movw	r30, r24
    4efe:	22 a3       	std	Z+34, r18	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    4f00:	8a 81       	ldd	r24, Y+2	; 0x02
    4f02:	9b 81       	ldd	r25, Y+3	; 0x03
    4f04:	fc 01       	movw	r30, r24
    4f06:	26 89       	ldd	r18, Z+22	; 0x16
    4f08:	8a 81       	ldd	r24, Y+2	; 0x02
    4f0a:	9b 81       	ldd	r25, Y+3	; 0x03
    4f0c:	fc 01       	movw	r30, r24
    4f0e:	81 a1       	ldd	r24, Z+33	; 0x21
    4f10:	28 17       	cp	r18, r24
    4f12:	09 f4       	brne	.+2      	; 0x4f16 <xTaskPriorityDisinherit+0x50>
    4f14:	4c c0       	rjmp	.+152    	; 0x4fae <xTaskPriorityDisinherit+0xe8>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    4f16:	8a 81       	ldd	r24, Y+2	; 0x02
    4f18:	9b 81       	ldd	r25, Y+3	; 0x03
    4f1a:	fc 01       	movw	r30, r24
    4f1c:	82 a1       	ldd	r24, Z+34	; 0x22
    4f1e:	88 23       	and	r24, r24
    4f20:	09 f0       	breq	.+2      	; 0x4f24 <xTaskPriorityDisinherit+0x5e>
    4f22:	45 c0       	rjmp	.+138    	; 0x4fae <xTaskPriorityDisinherit+0xe8>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4f24:	8a 81       	ldd	r24, Y+2	; 0x02
    4f26:	9b 81       	ldd	r25, Y+3	; 0x03
    4f28:	02 96       	adiw	r24, 0x02	; 2
    4f2a:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    4f2e:	8a 81       	ldd	r24, Y+2	; 0x02
    4f30:	9b 81       	ldd	r25, Y+3	; 0x03
    4f32:	fc 01       	movw	r30, r24
    4f34:	21 a1       	ldd	r18, Z+33	; 0x21
    4f36:	8a 81       	ldd	r24, Y+2	; 0x02
    4f38:	9b 81       	ldd	r25, Y+3	; 0x03
    4f3a:	fc 01       	movw	r30, r24
    4f3c:	26 8b       	std	Z+22, r18	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority );
    4f3e:	8a 81       	ldd	r24, Y+2	; 0x02
    4f40:	9b 81       	ldd	r25, Y+3	; 0x03
    4f42:	fc 01       	movw	r30, r24
    4f44:	86 89       	ldd	r24, Z+22	; 0x16
    4f46:	88 2f       	mov	r24, r24
    4f48:	90 e0       	ldi	r25, 0x00	; 0
    4f4a:	24 e0       	ldi	r18, 0x04	; 4
    4f4c:	30 e0       	ldi	r19, 0x00	; 0
    4f4e:	28 1b       	sub	r18, r24
    4f50:	39 0b       	sbc	r19, r25
    4f52:	8a 81       	ldd	r24, Y+2	; 0x02
    4f54:	9b 81       	ldd	r25, Y+3	; 0x03
    4f56:	fc 01       	movw	r30, r24
    4f58:	35 87       	std	Z+13, r19	; 0x0d
    4f5a:	24 87       	std	Z+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    4f5c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f5e:	9b 81       	ldd	r25, Y+3	; 0x03
    4f60:	fc 01       	movw	r30, r24
    4f62:	96 89       	ldd	r25, Z+22	; 0x16
    4f64:	80 91 9d 02 	lds	r24, 0x029D
    4f68:	89 17       	cp	r24, r25
    4f6a:	30 f4       	brcc	.+12     	; 0x4f78 <xTaskPriorityDisinherit+0xb2>
    4f6c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f6e:	9b 81       	ldd	r25, Y+3	; 0x03
    4f70:	fc 01       	movw	r30, r24
    4f72:	86 89       	ldd	r24, Z+22	; 0x16
    4f74:	80 93 9d 02 	sts	0x029D, r24
    4f78:	8a 81       	ldd	r24, Y+2	; 0x02
    4f7a:	9b 81       	ldd	r25, Y+3	; 0x03
    4f7c:	ac 01       	movw	r20, r24
    4f7e:	4e 5f       	subi	r20, 0xFE	; 254
    4f80:	5f 4f       	sbci	r21, 0xFF	; 255
    4f82:	8a 81       	ldd	r24, Y+2	; 0x02
    4f84:	9b 81       	ldd	r25, Y+3	; 0x03
    4f86:	fc 01       	movw	r30, r24
    4f88:	86 89       	ldd	r24, Z+22	; 0x16
    4f8a:	28 2f       	mov	r18, r24
    4f8c:	30 e0       	ldi	r19, 0x00	; 0
    4f8e:	c9 01       	movw	r24, r18
    4f90:	88 0f       	add	r24, r24
    4f92:	99 1f       	adc	r25, r25
    4f94:	88 0f       	add	r24, r24
    4f96:	99 1f       	adc	r25, r25
    4f98:	88 0f       	add	r24, r24
    4f9a:	99 1f       	adc	r25, r25
    4f9c:	82 0f       	add	r24, r18
    4f9e:	93 1f       	adc	r25, r19
    4fa0:	8c 5b       	subi	r24, 0xBC	; 188
    4fa2:	9d 4f       	sbci	r25, 0xFD	; 253
    4fa4:	ba 01       	movw	r22, r20
    4fa6:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    4faa:	81 e0       	ldi	r24, 0x01	; 1
    4fac:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4fae:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4fb0:	0f 90       	pop	r0
    4fb2:	0f 90       	pop	r0
    4fb4:	0f 90       	pop	r0
    4fb6:	0f 90       	pop	r0
    4fb8:	0f 90       	pop	r0
    4fba:	df 91       	pop	r29
    4fbc:	cf 91       	pop	r28
    4fbe:	08 95       	ret

00004fc0 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4fc0:	cf 93       	push	r28
    4fc2:	df 93       	push	r29
    4fc4:	1f 92       	push	r1
    4fc6:	1f 92       	push	r1
    4fc8:	cd b7       	in	r28, 0x3d	; 61
    4fca:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4fcc:	80 91 42 02 	lds	r24, 0x0242
    4fd0:	90 91 43 02 	lds	r25, 0x0243
    4fd4:	fc 01       	movw	r30, r24
    4fd6:	84 85       	ldd	r24, Z+12	; 0x0c
    4fd8:	95 85       	ldd	r25, Z+13	; 0x0d
    4fda:	9a 83       	std	Y+2, r25	; 0x02
    4fdc:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4fde:	80 91 42 02 	lds	r24, 0x0242
    4fe2:	90 91 43 02 	lds	r25, 0x0243
    4fe6:	20 91 42 02 	lds	r18, 0x0242
    4fea:	30 91 43 02 	lds	r19, 0x0243
    4fee:	f9 01       	movw	r30, r18
    4ff0:	26 89       	ldd	r18, Z+22	; 0x16
    4ff2:	22 2f       	mov	r18, r18
    4ff4:	30 e0       	ldi	r19, 0x00	; 0
    4ff6:	44 e0       	ldi	r20, 0x04	; 4
    4ff8:	50 e0       	ldi	r21, 0x00	; 0
    4ffa:	ba 01       	movw	r22, r20
    4ffc:	62 1b       	sub	r22, r18
    4ffe:	73 0b       	sbc	r23, r19
    5000:	9b 01       	movw	r18, r22
    5002:	fc 01       	movw	r30, r24
    5004:	35 87       	std	Z+13, r19	; 0x0d
    5006:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
    5008:	89 81       	ldd	r24, Y+1	; 0x01
    500a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    500c:	0f 90       	pop	r0
    500e:	0f 90       	pop	r0
    5010:	df 91       	pop	r29
    5012:	cf 91       	pop	r28
    5014:	08 95       	ret

00005016 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    5016:	cf 93       	push	r28
    5018:	df 93       	push	r29
    501a:	cd b7       	in	r28, 0x3d	; 61
    501c:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    501e:	80 91 42 02 	lds	r24, 0x0242
    5022:	90 91 43 02 	lds	r25, 0x0243
    5026:	00 97       	sbiw	r24, 0x00	; 0
    5028:	49 f0       	breq	.+18     	; 0x503c <pvTaskIncrementMutexHeldCount+0x26>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    502a:	80 91 42 02 	lds	r24, 0x0242
    502e:	90 91 43 02 	lds	r25, 0x0243
    5032:	fc 01       	movw	r30, r24
    5034:	22 a1       	ldd	r18, Z+34	; 0x22
    5036:	2f 5f       	subi	r18, 0xFF	; 255
    5038:	fc 01       	movw	r30, r24
    503a:	22 a3       	std	Z+34, r18	; 0x22
		}

		return pxCurrentTCB;
    503c:	80 91 42 02 	lds	r24, 0x0242
    5040:	90 91 43 02 	lds	r25, 0x0243
	}
    5044:	df 91       	pop	r29
    5046:	cf 91       	pop	r28
    5048:	08 95       	ret

0000504a <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    504a:	cf 93       	push	r28
    504c:	df 93       	push	r29
    504e:	cd b7       	in	r28, 0x3d	; 61
    5050:	de b7       	in	r29, 0x3e	; 62
    5052:	29 97       	sbiw	r28, 0x09	; 9
    5054:	0f b6       	in	r0, 0x3f	; 63
    5056:	f8 94       	cli
    5058:	de bf       	out	0x3e, r29	; 62
    505a:	0f be       	out	0x3f, r0	; 63
    505c:	cd bf       	out	0x3d, r28	; 61
    505e:	8f 83       	std	Y+7, r24	; 0x07
    5060:	79 87       	std	Y+9, r23	; 0x09
    5062:	68 87       	std	Y+8, r22	; 0x08
	TickType_t xTimeToWake;
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    5064:	0f b6       	in	r0, 0x3f	; 63
    5066:	f8 94       	cli
    5068:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    506a:	80 91 42 02 	lds	r24, 0x0242
    506e:	90 91 43 02 	lds	r25, 0x0243
    5072:	fc 01       	movw	r30, r24
    5074:	83 a1       	ldd	r24, Z+35	; 0x23
    5076:	94 a1       	ldd	r25, Z+36	; 0x24
    5078:	a5 a1       	ldd	r26, Z+37	; 0x25
    507a:	b6 a1       	ldd	r27, Z+38	; 0x26
    507c:	00 97       	sbiw	r24, 0x00	; 0
    507e:	a1 05       	cpc	r26, r1
    5080:	b1 05       	cpc	r27, r1
    5082:	99 f5       	brne	.+102    	; 0x50ea <ulTaskNotifyTake+0xa0>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    5084:	80 91 42 02 	lds	r24, 0x0242
    5088:	90 91 43 02 	lds	r25, 0x0243
    508c:	21 e0       	ldi	r18, 0x01	; 1
    508e:	fc 01       	movw	r30, r24
    5090:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    5092:	88 85       	ldd	r24, Y+8	; 0x08
    5094:	99 85       	ldd	r25, Y+9	; 0x09
    5096:	00 97       	sbiw	r24, 0x00	; 0
    5098:	41 f1       	breq	.+80     	; 0x50ea <ulTaskNotifyTake+0xa0>
				{
					/* The task is going to block.  First it must be removed
					from the ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    509a:	80 91 42 02 	lds	r24, 0x0242
    509e:	90 91 43 02 	lds	r25, 0x0243
    50a2:	02 96       	adiw	r24, 0x02	; 2
    50a4:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
    50a8:	88 85       	ldd	r24, Y+8	; 0x08
    50aa:	99 85       	ldd	r25, Y+9	; 0x09
    50ac:	8f 3f       	cpi	r24, 0xFF	; 255
    50ae:	ff ef       	ldi	r31, 0xFF	; 255
    50b0:	9f 07       	cpc	r25, r31
    50b2:	59 f4       	brne	.+22     	; 0x50ca <ulTaskNotifyTake+0x80>
						{
							/* Add the task to the suspended task list instead
							of a delayed task list to ensure the task is not
							woken by a timing event.  It will block
							indefinitely. */
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    50b4:	80 91 42 02 	lds	r24, 0x0242
    50b8:	90 91 43 02 	lds	r25, 0x0243
    50bc:	02 96       	adiw	r24, 0x02	; 2
    50be:	bc 01       	movw	r22, r24
    50c0:	81 e9       	ldi	r24, 0x91	; 145
    50c2:	92 e0       	ldi	r25, 0x02	; 2
    50c4:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
    50c8:	0e c0       	rjmp	.+28     	; 0x50e6 <ulTaskNotifyTake+0x9c>
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    50ca:	20 91 9b 02 	lds	r18, 0x029B
    50ce:	30 91 9c 02 	lds	r19, 0x029C
    50d2:	88 85       	ldd	r24, Y+8	; 0x08
    50d4:	99 85       	ldd	r25, Y+9	; 0x09
    50d6:	82 0f       	add	r24, r18
    50d8:	93 1f       	adc	r25, r19
    50da:	9a 83       	std	Y+2, r25	; 0x02
    50dc:	89 83       	std	Y+1, r24	; 0x01
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    50de:	89 81       	ldd	r24, Y+1	; 0x01
    50e0:	9a 81       	ldd	r25, Y+2	; 0x02
    50e2:	0e 94 77 25 	call	0x4aee	; 0x4aee <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    50e6:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    50ea:	0f 90       	pop	r0
    50ec:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    50ee:	0f b6       	in	r0, 0x3f	; 63
    50f0:	f8 94       	cli
    50f2:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    50f4:	80 91 42 02 	lds	r24, 0x0242
    50f8:	90 91 43 02 	lds	r25, 0x0243
    50fc:	fc 01       	movw	r30, r24
    50fe:	83 a1       	ldd	r24, Z+35	; 0x23
    5100:	94 a1       	ldd	r25, Z+36	; 0x24
    5102:	a5 a1       	ldd	r26, Z+37	; 0x25
    5104:	b6 a1       	ldd	r27, Z+38	; 0x26
    5106:	8b 83       	std	Y+3, r24	; 0x03
    5108:	9c 83       	std	Y+4, r25	; 0x04
    510a:	ad 83       	std	Y+5, r26	; 0x05
    510c:	be 83       	std	Y+6, r27	; 0x06

			if( ulReturn != 0UL )
    510e:	8b 81       	ldd	r24, Y+3	; 0x03
    5110:	9c 81       	ldd	r25, Y+4	; 0x04
    5112:	ad 81       	ldd	r26, Y+5	; 0x05
    5114:	be 81       	ldd	r27, Y+6	; 0x06
    5116:	00 97       	sbiw	r24, 0x00	; 0
    5118:	a1 05       	cpc	r26, r1
    511a:	b1 05       	cpc	r27, r1
    511c:	f1 f0       	breq	.+60     	; 0x515a <ulTaskNotifyTake+0x110>
			{
				if( xClearCountOnExit != pdFALSE )
    511e:	8f 81       	ldd	r24, Y+7	; 0x07
    5120:	88 23       	and	r24, r24
    5122:	51 f0       	breq	.+20     	; 0x5138 <ulTaskNotifyTake+0xee>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    5124:	80 91 42 02 	lds	r24, 0x0242
    5128:	90 91 43 02 	lds	r25, 0x0243
    512c:	fc 01       	movw	r30, r24
    512e:	13 a2       	std	Z+35, r1	; 0x23
    5130:	14 a2       	std	Z+36, r1	; 0x24
    5132:	15 a2       	std	Z+37, r1	; 0x25
    5134:	16 a2       	std	Z+38, r1	; 0x26
    5136:	11 c0       	rjmp	.+34     	; 0x515a <ulTaskNotifyTake+0x110>
				}
				else
				{
					( pxCurrentTCB->ulNotifiedValue )--;
    5138:	20 91 42 02 	lds	r18, 0x0242
    513c:	30 91 43 02 	lds	r19, 0x0243
    5140:	f9 01       	movw	r30, r18
    5142:	83 a1       	ldd	r24, Z+35	; 0x23
    5144:	94 a1       	ldd	r25, Z+36	; 0x24
    5146:	a5 a1       	ldd	r26, Z+37	; 0x25
    5148:	b6 a1       	ldd	r27, Z+38	; 0x26
    514a:	01 97       	sbiw	r24, 0x01	; 1
    514c:	a1 09       	sbc	r26, r1
    514e:	b1 09       	sbc	r27, r1
    5150:	f9 01       	movw	r30, r18
    5152:	83 a3       	std	Z+35, r24	; 0x23
    5154:	94 a3       	std	Z+36, r25	; 0x24
    5156:	a5 a3       	std	Z+37, r26	; 0x25
    5158:	b6 a3       	std	Z+38, r27	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    515a:	80 91 42 02 	lds	r24, 0x0242
    515e:	90 91 43 02 	lds	r25, 0x0243
    5162:	fc 01       	movw	r30, r24
    5164:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    5166:	0f 90       	pop	r0
    5168:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    516a:	8b 81       	ldd	r24, Y+3	; 0x03
    516c:	9c 81       	ldd	r25, Y+4	; 0x04
    516e:	ad 81       	ldd	r26, Y+5	; 0x05
    5170:	be 81       	ldd	r27, Y+6	; 0x06
	}
    5172:	bc 01       	movw	r22, r24
    5174:	cd 01       	movw	r24, r26
    5176:	29 96       	adiw	r28, 0x09	; 9
    5178:	0f b6       	in	r0, 0x3f	; 63
    517a:	f8 94       	cli
    517c:	de bf       	out	0x3e, r29	; 62
    517e:	0f be       	out	0x3f, r0	; 63
    5180:	cd bf       	out	0x3d, r28	; 61
    5182:	df 91       	pop	r29
    5184:	cf 91       	pop	r28
    5186:	08 95       	ret

00005188 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    5188:	ef 92       	push	r14
    518a:	ff 92       	push	r15
    518c:	0f 93       	push	r16
    518e:	1f 93       	push	r17
    5190:	cf 93       	push	r28
    5192:	df 93       	push	r29
    5194:	cd b7       	in	r28, 0x3d	; 61
    5196:	de b7       	in	r29, 0x3e	; 62
    5198:	2f 97       	sbiw	r28, 0x0f	; 15
    519a:	0f b6       	in	r0, 0x3f	; 63
    519c:	f8 94       	cli
    519e:	de bf       	out	0x3e, r29	; 62
    51a0:	0f be       	out	0x3f, r0	; 63
    51a2:	cd bf       	out	0x3d, r28	; 61
    51a4:	6c 83       	std	Y+4, r22	; 0x04
    51a6:	7d 83       	std	Y+5, r23	; 0x05
    51a8:	8e 83       	std	Y+6, r24	; 0x06
    51aa:	9f 83       	std	Y+7, r25	; 0x07
    51ac:	28 87       	std	Y+8, r18	; 0x08
    51ae:	39 87       	std	Y+9, r19	; 0x09
    51b0:	4a 87       	std	Y+10, r20	; 0x0a
    51b2:	5b 87       	std	Y+11, r21	; 0x0b
    51b4:	1d 87       	std	Y+13, r17	; 0x0d
    51b6:	0c 87       	std	Y+12, r16	; 0x0c
    51b8:	ff 86       	std	Y+15, r15	; 0x0f
    51ba:	ee 86       	std	Y+14, r14	; 0x0e
	TickType_t xTimeToWake;
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    51bc:	0f b6       	in	r0, 0x3f	; 63
    51be:	f8 94       	cli
    51c0:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
    51c2:	80 91 42 02 	lds	r24, 0x0242
    51c6:	90 91 43 02 	lds	r25, 0x0243
    51ca:	fc 01       	movw	r30, r24
    51cc:	87 a1       	ldd	r24, Z+39	; 0x27
    51ce:	82 30       	cpi	r24, 0x02	; 2
    51d0:	09 f4       	brne	.+2      	; 0x51d4 <xTaskNotifyWait+0x4c>
    51d2:	4d c0       	rjmp	.+154    	; 0x526e <xTaskNotifyWait+0xe6>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    51d4:	60 91 42 02 	lds	r22, 0x0242
    51d8:	70 91 43 02 	lds	r23, 0x0243
    51dc:	fb 01       	movw	r30, r22
    51de:	23 a1       	ldd	r18, Z+35	; 0x23
    51e0:	34 a1       	ldd	r19, Z+36	; 0x24
    51e2:	45 a1       	ldd	r20, Z+37	; 0x25
    51e4:	56 a1       	ldd	r21, Z+38	; 0x26
    51e6:	8c 81       	ldd	r24, Y+4	; 0x04
    51e8:	9d 81       	ldd	r25, Y+5	; 0x05
    51ea:	ae 81       	ldd	r26, Y+6	; 0x06
    51ec:	bf 81       	ldd	r27, Y+7	; 0x07
    51ee:	80 95       	com	r24
    51f0:	90 95       	com	r25
    51f2:	a0 95       	com	r26
    51f4:	b0 95       	com	r27
    51f6:	82 23       	and	r24, r18
    51f8:	93 23       	and	r25, r19
    51fa:	a4 23       	and	r26, r20
    51fc:	b5 23       	and	r27, r21
    51fe:	fb 01       	movw	r30, r22
    5200:	83 a3       	std	Z+35, r24	; 0x23
    5202:	94 a3       	std	Z+36, r25	; 0x24
    5204:	a5 a3       	std	Z+37, r26	; 0x25
    5206:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    5208:	80 91 42 02 	lds	r24, 0x0242
    520c:	90 91 43 02 	lds	r25, 0x0243
    5210:	21 e0       	ldi	r18, 0x01	; 1
    5212:	fc 01       	movw	r30, r24
    5214:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    5216:	8e 85       	ldd	r24, Y+14	; 0x0e
    5218:	9f 85       	ldd	r25, Y+15	; 0x0f
    521a:	00 97       	sbiw	r24, 0x00	; 0
    521c:	41 f1       	breq	.+80     	; 0x526e <xTaskNotifyWait+0xe6>
				{
					/* The task is going to block.  First it must be removed
					from the	ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    521e:	80 91 42 02 	lds	r24, 0x0242
    5222:	90 91 43 02 	lds	r25, 0x0243
    5226:	02 96       	adiw	r24, 0x02	; 2
    5228:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
    522c:	8e 85       	ldd	r24, Y+14	; 0x0e
    522e:	9f 85       	ldd	r25, Y+15	; 0x0f
    5230:	8f 3f       	cpi	r24, 0xFF	; 255
    5232:	ff ef       	ldi	r31, 0xFF	; 255
    5234:	9f 07       	cpc	r25, r31
    5236:	59 f4       	brne	.+22     	; 0x524e <xTaskNotifyWait+0xc6>
						{
							/* Add the task to the suspended task list instead
							of a delayed task list to ensure the task is not
							woken by a timing event.  It will block
							indefinitely. */
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    5238:	80 91 42 02 	lds	r24, 0x0242
    523c:	90 91 43 02 	lds	r25, 0x0243
    5240:	02 96       	adiw	r24, 0x02	; 2
    5242:	bc 01       	movw	r22, r24
    5244:	81 e9       	ldi	r24, 0x91	; 145
    5246:	92 e0       	ldi	r25, 0x02	; 2
    5248:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
    524c:	0e c0       	rjmp	.+28     	; 0x526a <xTaskNotifyWait+0xe2>
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    524e:	20 91 9b 02 	lds	r18, 0x029B
    5252:	30 91 9c 02 	lds	r19, 0x029C
    5256:	8e 85       	ldd	r24, Y+14	; 0x0e
    5258:	9f 85       	ldd	r25, Y+15	; 0x0f
    525a:	82 0f       	add	r24, r18
    525c:	93 1f       	adc	r25, r19
    525e:	9b 83       	std	Y+3, r25	; 0x03
    5260:	8a 83       	std	Y+2, r24	; 0x02
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    5262:	8a 81       	ldd	r24, Y+2	; 0x02
    5264:	9b 81       	ldd	r25, Y+3	; 0x03
    5266:	0e 94 77 25 	call	0x4aee	; 0x4aee <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    526a:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    526e:	0f 90       	pop	r0
    5270:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5272:	0f b6       	in	r0, 0x3f	; 63
    5274:	f8 94       	cli
    5276:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    5278:	8c 85       	ldd	r24, Y+12	; 0x0c
    527a:	9d 85       	ldd	r25, Y+13	; 0x0d
    527c:	00 97       	sbiw	r24, 0x00	; 0
    527e:	81 f0       	breq	.+32     	; 0x52a0 <xTaskNotifyWait+0x118>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    5280:	80 91 42 02 	lds	r24, 0x0242
    5284:	90 91 43 02 	lds	r25, 0x0243
    5288:	fc 01       	movw	r30, r24
    528a:	83 a1       	ldd	r24, Z+35	; 0x23
    528c:	94 a1       	ldd	r25, Z+36	; 0x24
    528e:	a5 a1       	ldd	r26, Z+37	; 0x25
    5290:	b6 a1       	ldd	r27, Z+38	; 0x26
    5292:	2c 85       	ldd	r18, Y+12	; 0x0c
    5294:	3d 85       	ldd	r19, Y+13	; 0x0d
    5296:	f9 01       	movw	r30, r18
    5298:	80 83       	st	Z, r24
    529a:	91 83       	std	Z+1, r25	; 0x01
    529c:	a2 83       	std	Z+2, r26	; 0x02
    529e:	b3 83       	std	Z+3, r27	; 0x03

			/* If eNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
    52a0:	80 91 42 02 	lds	r24, 0x0242
    52a4:	90 91 43 02 	lds	r25, 0x0243
    52a8:	fc 01       	movw	r30, r24
    52aa:	87 a1       	ldd	r24, Z+39	; 0x27
    52ac:	81 30       	cpi	r24, 0x01	; 1
    52ae:	11 f4       	brne	.+4      	; 0x52b4 <xTaskNotifyWait+0x12c>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    52b0:	19 82       	std	Y+1, r1	; 0x01
    52b2:	1c c0       	rjmp	.+56     	; 0x52ec <xTaskNotifyWait+0x164>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    52b4:	60 91 42 02 	lds	r22, 0x0242
    52b8:	70 91 43 02 	lds	r23, 0x0243
    52bc:	fb 01       	movw	r30, r22
    52be:	23 a1       	ldd	r18, Z+35	; 0x23
    52c0:	34 a1       	ldd	r19, Z+36	; 0x24
    52c2:	45 a1       	ldd	r20, Z+37	; 0x25
    52c4:	56 a1       	ldd	r21, Z+38	; 0x26
    52c6:	88 85       	ldd	r24, Y+8	; 0x08
    52c8:	99 85       	ldd	r25, Y+9	; 0x09
    52ca:	aa 85       	ldd	r26, Y+10	; 0x0a
    52cc:	bb 85       	ldd	r27, Y+11	; 0x0b
    52ce:	80 95       	com	r24
    52d0:	90 95       	com	r25
    52d2:	a0 95       	com	r26
    52d4:	b0 95       	com	r27
    52d6:	82 23       	and	r24, r18
    52d8:	93 23       	and	r25, r19
    52da:	a4 23       	and	r26, r20
    52dc:	b5 23       	and	r27, r21
    52de:	fb 01       	movw	r30, r22
    52e0:	83 a3       	std	Z+35, r24	; 0x23
    52e2:	94 a3       	std	Z+36, r25	; 0x24
    52e4:	a5 a3       	std	Z+37, r26	; 0x25
    52e6:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    52e8:	81 e0       	ldi	r24, 0x01	; 1
    52ea:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    52ec:	80 91 42 02 	lds	r24, 0x0242
    52f0:	90 91 43 02 	lds	r25, 0x0243
    52f4:	fc 01       	movw	r30, r24
    52f6:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    52f8:	0f 90       	pop	r0
    52fa:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    52fc:	89 81       	ldd	r24, Y+1	; 0x01
	}
    52fe:	2f 96       	adiw	r28, 0x0f	; 15
    5300:	0f b6       	in	r0, 0x3f	; 63
    5302:	f8 94       	cli
    5304:	de bf       	out	0x3e, r29	; 62
    5306:	0f be       	out	0x3f, r0	; 63
    5308:	cd bf       	out	0x3d, r28	; 61
    530a:	df 91       	pop	r29
    530c:	cf 91       	pop	r28
    530e:	1f 91       	pop	r17
    5310:	0f 91       	pop	r16
    5312:	ff 90       	pop	r15
    5314:	ef 90       	pop	r14
    5316:	08 95       	ret

00005318 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    5318:	0f 93       	push	r16
    531a:	1f 93       	push	r17
    531c:	cf 93       	push	r28
    531e:	df 93       	push	r29
    5320:	cd b7       	in	r28, 0x3d	; 61
    5322:	de b7       	in	r29, 0x3e	; 62
    5324:	2d 97       	sbiw	r28, 0x0d	; 13
    5326:	0f b6       	in	r0, 0x3f	; 63
    5328:	f8 94       	cli
    532a:	de bf       	out	0x3e, r29	; 62
    532c:	0f be       	out	0x3f, r0	; 63
    532e:	cd bf       	out	0x3d, r28	; 61
    5330:	9e 83       	std	Y+6, r25	; 0x06
    5332:	8d 83       	std	Y+5, r24	; 0x05
    5334:	4f 83       	std	Y+7, r20	; 0x07
    5336:	58 87       	std	Y+8, r21	; 0x08
    5338:	69 87       	std	Y+9, r22	; 0x09
    533a:	7a 87       	std	Y+10, r23	; 0x0a
    533c:	2b 87       	std	Y+11, r18	; 0x0b
    533e:	1d 87       	std	Y+13, r17	; 0x0d
    5340:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5342:	81 e0       	ldi	r24, 0x01	; 1
    5344:	89 83       	std	Y+1, r24	; 0x01

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    5346:	8d 81       	ldd	r24, Y+5	; 0x05
    5348:	9e 81       	ldd	r25, Y+6	; 0x06
    534a:	9b 83       	std	Y+3, r25	; 0x03
    534c:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    534e:	0f b6       	in	r0, 0x3f	; 63
    5350:	f8 94       	cli
    5352:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    5354:	8c 85       	ldd	r24, Y+12	; 0x0c
    5356:	9d 85       	ldd	r25, Y+13	; 0x0d
    5358:	00 97       	sbiw	r24, 0x00	; 0
    535a:	71 f0       	breq	.+28     	; 0x5378 <xTaskGenericNotify+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    535c:	8a 81       	ldd	r24, Y+2	; 0x02
    535e:	9b 81       	ldd	r25, Y+3	; 0x03
    5360:	fc 01       	movw	r30, r24
    5362:	83 a1       	ldd	r24, Z+35	; 0x23
    5364:	94 a1       	ldd	r25, Z+36	; 0x24
    5366:	a5 a1       	ldd	r26, Z+37	; 0x25
    5368:	b6 a1       	ldd	r27, Z+38	; 0x26
    536a:	2c 85       	ldd	r18, Y+12	; 0x0c
    536c:	3d 85       	ldd	r19, Y+13	; 0x0d
    536e:	f9 01       	movw	r30, r18
    5370:	80 83       	st	Z, r24
    5372:	91 83       	std	Z+1, r25	; 0x01
    5374:	a2 83       	std	Z+2, r26	; 0x02
    5376:	b3 83       	std	Z+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    5378:	8a 81       	ldd	r24, Y+2	; 0x02
    537a:	9b 81       	ldd	r25, Y+3	; 0x03
    537c:	fc 01       	movw	r30, r24
    537e:	87 a1       	ldd	r24, Z+39	; 0x27
    5380:	8c 83       	std	Y+4, r24	; 0x04

			pxTCB->eNotifyState = eNotified;
    5382:	8a 81       	ldd	r24, Y+2	; 0x02
    5384:	9b 81       	ldd	r25, Y+3	; 0x03
    5386:	22 e0       	ldi	r18, 0x02	; 2
    5388:	fc 01       	movw	r30, r24
    538a:	27 a3       	std	Z+39, r18	; 0x27

			switch( eAction )
    538c:	8b 85       	ldd	r24, Y+11	; 0x0b
    538e:	88 2f       	mov	r24, r24
    5390:	90 e0       	ldi	r25, 0x00	; 0
    5392:	82 30       	cpi	r24, 0x02	; 2
    5394:	91 05       	cpc	r25, r1
    5396:	41 f1       	breq	.+80     	; 0x53e8 <xTaskGenericNotify+0xd0>
    5398:	83 30       	cpi	r24, 0x03	; 3
    539a:	91 05       	cpc	r25, r1
    539c:	3c f4       	brge	.+14     	; 0x53ac <xTaskGenericNotify+0x94>
    539e:	00 97       	sbiw	r24, 0x00	; 0
    53a0:	09 f4       	brne	.+2      	; 0x53a4 <xTaskGenericNotify+0x8c>
    53a2:	51 c0       	rjmp	.+162    	; 0x5446 <xTaskGenericNotify+0x12e>
    53a4:	81 30       	cpi	r24, 0x01	; 1
    53a6:	91 05       	cpc	r25, r1
    53a8:	41 f0       	breq	.+16     	; 0x53ba <xTaskGenericNotify+0xa2>
    53aa:	4e c0       	rjmp	.+156    	; 0x5448 <xTaskGenericNotify+0x130>
    53ac:	83 30       	cpi	r24, 0x03	; 3
    53ae:	91 05       	cpc	r25, r1
    53b0:	69 f1       	breq	.+90     	; 0x540c <xTaskGenericNotify+0xf4>
    53b2:	84 30       	cpi	r24, 0x04	; 4
    53b4:	91 05       	cpc	r25, r1
    53b6:	b1 f1       	breq	.+108    	; 0x5424 <xTaskGenericNotify+0x10c>
    53b8:	47 c0       	rjmp	.+142    	; 0x5448 <xTaskGenericNotify+0x130>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    53ba:	8a 81       	ldd	r24, Y+2	; 0x02
    53bc:	9b 81       	ldd	r25, Y+3	; 0x03
    53be:	fc 01       	movw	r30, r24
    53c0:	23 a1       	ldd	r18, Z+35	; 0x23
    53c2:	34 a1       	ldd	r19, Z+36	; 0x24
    53c4:	45 a1       	ldd	r20, Z+37	; 0x25
    53c6:	56 a1       	ldd	r21, Z+38	; 0x26
    53c8:	8f 81       	ldd	r24, Y+7	; 0x07
    53ca:	98 85       	ldd	r25, Y+8	; 0x08
    53cc:	a9 85       	ldd	r26, Y+9	; 0x09
    53ce:	ba 85       	ldd	r27, Y+10	; 0x0a
    53d0:	82 2b       	or	r24, r18
    53d2:	93 2b       	or	r25, r19
    53d4:	a4 2b       	or	r26, r20
    53d6:	b5 2b       	or	r27, r21
    53d8:	2a 81       	ldd	r18, Y+2	; 0x02
    53da:	3b 81       	ldd	r19, Y+3	; 0x03
    53dc:	f9 01       	movw	r30, r18
    53de:	83 a3       	std	Z+35, r24	; 0x23
    53e0:	94 a3       	std	Z+36, r25	; 0x24
    53e2:	a5 a3       	std	Z+37, r26	; 0x25
    53e4:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    53e6:	30 c0       	rjmp	.+96     	; 0x5448 <xTaskGenericNotify+0x130>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    53e8:	8a 81       	ldd	r24, Y+2	; 0x02
    53ea:	9b 81       	ldd	r25, Y+3	; 0x03
    53ec:	fc 01       	movw	r30, r24
    53ee:	83 a1       	ldd	r24, Z+35	; 0x23
    53f0:	94 a1       	ldd	r25, Z+36	; 0x24
    53f2:	a5 a1       	ldd	r26, Z+37	; 0x25
    53f4:	b6 a1       	ldd	r27, Z+38	; 0x26
    53f6:	01 96       	adiw	r24, 0x01	; 1
    53f8:	a1 1d       	adc	r26, r1
    53fa:	b1 1d       	adc	r27, r1
    53fc:	2a 81       	ldd	r18, Y+2	; 0x02
    53fe:	3b 81       	ldd	r19, Y+3	; 0x03
    5400:	f9 01       	movw	r30, r18
    5402:	83 a3       	std	Z+35, r24	; 0x23
    5404:	94 a3       	std	Z+36, r25	; 0x24
    5406:	a5 a3       	std	Z+37, r26	; 0x25
    5408:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    540a:	1e c0       	rjmp	.+60     	; 0x5448 <xTaskGenericNotify+0x130>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    540c:	2a 81       	ldd	r18, Y+2	; 0x02
    540e:	3b 81       	ldd	r19, Y+3	; 0x03
    5410:	8f 81       	ldd	r24, Y+7	; 0x07
    5412:	98 85       	ldd	r25, Y+8	; 0x08
    5414:	a9 85       	ldd	r26, Y+9	; 0x09
    5416:	ba 85       	ldd	r27, Y+10	; 0x0a
    5418:	f9 01       	movw	r30, r18
    541a:	83 a3       	std	Z+35, r24	; 0x23
    541c:	94 a3       	std	Z+36, r25	; 0x24
    541e:	a5 a3       	std	Z+37, r26	; 0x25
    5420:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5422:	12 c0       	rjmp	.+36     	; 0x5448 <xTaskGenericNotify+0x130>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    5424:	8c 81       	ldd	r24, Y+4	; 0x04
    5426:	82 30       	cpi	r24, 0x02	; 2
    5428:	61 f0       	breq	.+24     	; 0x5442 <xTaskGenericNotify+0x12a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    542a:	2a 81       	ldd	r18, Y+2	; 0x02
    542c:	3b 81       	ldd	r19, Y+3	; 0x03
    542e:	8f 81       	ldd	r24, Y+7	; 0x07
    5430:	98 85       	ldd	r25, Y+8	; 0x08
    5432:	a9 85       	ldd	r26, Y+9	; 0x09
    5434:	ba 85       	ldd	r27, Y+10	; 0x0a
    5436:	f9 01       	movw	r30, r18
    5438:	83 a3       	std	Z+35, r24	; 0x23
    543a:	94 a3       	std	Z+36, r25	; 0x24
    543c:	a5 a3       	std	Z+37, r26	; 0x25
    543e:	b6 a3       	std	Z+38, r27	; 0x26
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    5440:	03 c0       	rjmp	.+6      	; 0x5448 <xTaskGenericNotify+0x130>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5442:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    5444:	01 c0       	rjmp	.+2      	; 0x5448 <xTaskGenericNotify+0x130>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
    5446:	00 00       	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    5448:	8c 81       	ldd	r24, Y+4	; 0x04
    544a:	81 30       	cpi	r24, 0x01	; 1
    544c:	d1 f5       	brne	.+116    	; 0x54c2 <xTaskGenericNotify+0x1aa>
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    544e:	8a 81       	ldd	r24, Y+2	; 0x02
    5450:	9b 81       	ldd	r25, Y+3	; 0x03
    5452:	02 96       	adiw	r24, 0x02	; 2
    5454:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    5458:	8a 81       	ldd	r24, Y+2	; 0x02
    545a:	9b 81       	ldd	r25, Y+3	; 0x03
    545c:	fc 01       	movw	r30, r24
    545e:	96 89       	ldd	r25, Z+22	; 0x16
    5460:	80 91 9d 02 	lds	r24, 0x029D
    5464:	89 17       	cp	r24, r25
    5466:	30 f4       	brcc	.+12     	; 0x5474 <xTaskGenericNotify+0x15c>
    5468:	8a 81       	ldd	r24, Y+2	; 0x02
    546a:	9b 81       	ldd	r25, Y+3	; 0x03
    546c:	fc 01       	movw	r30, r24
    546e:	86 89       	ldd	r24, Z+22	; 0x16
    5470:	80 93 9d 02 	sts	0x029D, r24
    5474:	8a 81       	ldd	r24, Y+2	; 0x02
    5476:	9b 81       	ldd	r25, Y+3	; 0x03
    5478:	ac 01       	movw	r20, r24
    547a:	4e 5f       	subi	r20, 0xFE	; 254
    547c:	5f 4f       	sbci	r21, 0xFF	; 255
    547e:	8a 81       	ldd	r24, Y+2	; 0x02
    5480:	9b 81       	ldd	r25, Y+3	; 0x03
    5482:	fc 01       	movw	r30, r24
    5484:	86 89       	ldd	r24, Z+22	; 0x16
    5486:	28 2f       	mov	r18, r24
    5488:	30 e0       	ldi	r19, 0x00	; 0
    548a:	c9 01       	movw	r24, r18
    548c:	88 0f       	add	r24, r24
    548e:	99 1f       	adc	r25, r25
    5490:	88 0f       	add	r24, r24
    5492:	99 1f       	adc	r25, r25
    5494:	88 0f       	add	r24, r24
    5496:	99 1f       	adc	r25, r25
    5498:	82 0f       	add	r24, r18
    549a:	93 1f       	adc	r25, r19
    549c:	8c 5b       	subi	r24, 0xBC	; 188
    549e:	9d 4f       	sbci	r25, 0xFD	; 253
    54a0:	ba 01       	movw	r22, r20
    54a2:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    54a6:	8a 81       	ldd	r24, Y+2	; 0x02
    54a8:	9b 81       	ldd	r25, Y+3	; 0x03
    54aa:	fc 01       	movw	r30, r24
    54ac:	26 89       	ldd	r18, Z+22	; 0x16
    54ae:	80 91 42 02 	lds	r24, 0x0242
    54b2:	90 91 43 02 	lds	r25, 0x0243
    54b6:	fc 01       	movw	r30, r24
    54b8:	86 89       	ldd	r24, Z+22	; 0x16
    54ba:	82 17       	cp	r24, r18
    54bc:	10 f4       	brcc	.+4      	; 0x54c2 <xTaskGenericNotify+0x1aa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    54be:	0e 94 16 13 	call	0x262c	; 0x262c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    54c2:	0f 90       	pop	r0
    54c4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    54c6:	89 81       	ldd	r24, Y+1	; 0x01
	}
    54c8:	2d 96       	adiw	r28, 0x0d	; 13
    54ca:	0f b6       	in	r0, 0x3f	; 63
    54cc:	f8 94       	cli
    54ce:	de bf       	out	0x3e, r29	; 62
    54d0:	0f be       	out	0x3f, r0	; 63
    54d2:	cd bf       	out	0x3d, r28	; 61
    54d4:	df 91       	pop	r29
    54d6:	cf 91       	pop	r28
    54d8:	1f 91       	pop	r17
    54da:	0f 91       	pop	r16
    54dc:	08 95       	ret

000054de <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    54de:	ef 92       	push	r14
    54e0:	ff 92       	push	r15
    54e2:	0f 93       	push	r16
    54e4:	1f 93       	push	r17
    54e6:	cf 93       	push	r28
    54e8:	df 93       	push	r29
    54ea:	cd b7       	in	r28, 0x3d	; 61
    54ec:	de b7       	in	r29, 0x3e	; 62
    54ee:	60 97       	sbiw	r28, 0x10	; 16
    54f0:	0f b6       	in	r0, 0x3f	; 63
    54f2:	f8 94       	cli
    54f4:	de bf       	out	0x3e, r29	; 62
    54f6:	0f be       	out	0x3f, r0	; 63
    54f8:	cd bf       	out	0x3d, r28	; 61
    54fa:	9f 83       	std	Y+7, r25	; 0x07
    54fc:	8e 83       	std	Y+6, r24	; 0x06
    54fe:	48 87       	std	Y+8, r20	; 0x08
    5500:	59 87       	std	Y+9, r21	; 0x09
    5502:	6a 87       	std	Y+10, r22	; 0x0a
    5504:	7b 87       	std	Y+11, r23	; 0x0b
    5506:	2c 87       	std	Y+12, r18	; 0x0c
    5508:	1e 87       	std	Y+14, r17	; 0x0e
    550a:	0d 87       	std	Y+13, r16	; 0x0d
    550c:	f8 8a       	std	Y+16, r15	; 0x10
    550e:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5510:	81 e0       	ldi	r24, 0x01	; 1
    5512:	89 83       	std	Y+1, r24	; 0x01
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    5514:	8e 81       	ldd	r24, Y+6	; 0x06
    5516:	9f 81       	ldd	r25, Y+7	; 0x07
    5518:	9b 83       	std	Y+3, r25	; 0x03
    551a:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    551c:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( pulPreviousNotificationValue != NULL )
    551e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5520:	9e 85       	ldd	r25, Y+14	; 0x0e
    5522:	00 97       	sbiw	r24, 0x00	; 0
    5524:	71 f0       	breq	.+28     	; 0x5542 <xTaskGenericNotifyFromISR+0x64>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5526:	8a 81       	ldd	r24, Y+2	; 0x02
    5528:	9b 81       	ldd	r25, Y+3	; 0x03
    552a:	fc 01       	movw	r30, r24
    552c:	83 a1       	ldd	r24, Z+35	; 0x23
    552e:	94 a1       	ldd	r25, Z+36	; 0x24
    5530:	a5 a1       	ldd	r26, Z+37	; 0x25
    5532:	b6 a1       	ldd	r27, Z+38	; 0x26
    5534:	2d 85       	ldd	r18, Y+13	; 0x0d
    5536:	3e 85       	ldd	r19, Y+14	; 0x0e
    5538:	f9 01       	movw	r30, r18
    553a:	80 83       	st	Z, r24
    553c:	91 83       	std	Z+1, r25	; 0x01
    553e:	a2 83       	std	Z+2, r26	; 0x02
    5540:	b3 83       	std	Z+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    5542:	8a 81       	ldd	r24, Y+2	; 0x02
    5544:	9b 81       	ldd	r25, Y+3	; 0x03
    5546:	fc 01       	movw	r30, r24
    5548:	87 a1       	ldd	r24, Z+39	; 0x27
    554a:	8d 83       	std	Y+5, r24	; 0x05
			pxTCB->eNotifyState = eNotified;
    554c:	8a 81       	ldd	r24, Y+2	; 0x02
    554e:	9b 81       	ldd	r25, Y+3	; 0x03
    5550:	22 e0       	ldi	r18, 0x02	; 2
    5552:	fc 01       	movw	r30, r24
    5554:	27 a3       	std	Z+39, r18	; 0x27

			switch( eAction )
    5556:	8c 85       	ldd	r24, Y+12	; 0x0c
    5558:	88 2f       	mov	r24, r24
    555a:	90 e0       	ldi	r25, 0x00	; 0
    555c:	82 30       	cpi	r24, 0x02	; 2
    555e:	91 05       	cpc	r25, r1
    5560:	41 f1       	breq	.+80     	; 0x55b2 <xTaskGenericNotifyFromISR+0xd4>
    5562:	83 30       	cpi	r24, 0x03	; 3
    5564:	91 05       	cpc	r25, r1
    5566:	3c f4       	brge	.+14     	; 0x5576 <xTaskGenericNotifyFromISR+0x98>
    5568:	00 97       	sbiw	r24, 0x00	; 0
    556a:	09 f4       	brne	.+2      	; 0x556e <xTaskGenericNotifyFromISR+0x90>
    556c:	51 c0       	rjmp	.+162    	; 0x5610 <xTaskGenericNotifyFromISR+0x132>
    556e:	81 30       	cpi	r24, 0x01	; 1
    5570:	91 05       	cpc	r25, r1
    5572:	41 f0       	breq	.+16     	; 0x5584 <xTaskGenericNotifyFromISR+0xa6>
    5574:	4e c0       	rjmp	.+156    	; 0x5612 <xTaskGenericNotifyFromISR+0x134>
    5576:	83 30       	cpi	r24, 0x03	; 3
    5578:	91 05       	cpc	r25, r1
    557a:	69 f1       	breq	.+90     	; 0x55d6 <xTaskGenericNotifyFromISR+0xf8>
    557c:	84 30       	cpi	r24, 0x04	; 4
    557e:	91 05       	cpc	r25, r1
    5580:	b1 f1       	breq	.+108    	; 0x55ee <xTaskGenericNotifyFromISR+0x110>
    5582:	47 c0       	rjmp	.+142    	; 0x5612 <xTaskGenericNotifyFromISR+0x134>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5584:	8a 81       	ldd	r24, Y+2	; 0x02
    5586:	9b 81       	ldd	r25, Y+3	; 0x03
    5588:	fc 01       	movw	r30, r24
    558a:	23 a1       	ldd	r18, Z+35	; 0x23
    558c:	34 a1       	ldd	r19, Z+36	; 0x24
    558e:	45 a1       	ldd	r20, Z+37	; 0x25
    5590:	56 a1       	ldd	r21, Z+38	; 0x26
    5592:	88 85       	ldd	r24, Y+8	; 0x08
    5594:	99 85       	ldd	r25, Y+9	; 0x09
    5596:	aa 85       	ldd	r26, Y+10	; 0x0a
    5598:	bb 85       	ldd	r27, Y+11	; 0x0b
    559a:	82 2b       	or	r24, r18
    559c:	93 2b       	or	r25, r19
    559e:	a4 2b       	or	r26, r20
    55a0:	b5 2b       	or	r27, r21
    55a2:	2a 81       	ldd	r18, Y+2	; 0x02
    55a4:	3b 81       	ldd	r19, Y+3	; 0x03
    55a6:	f9 01       	movw	r30, r18
    55a8:	83 a3       	std	Z+35, r24	; 0x23
    55aa:	94 a3       	std	Z+36, r25	; 0x24
    55ac:	a5 a3       	std	Z+37, r26	; 0x25
    55ae:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    55b0:	30 c0       	rjmp	.+96     	; 0x5612 <xTaskGenericNotifyFromISR+0x134>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    55b2:	8a 81       	ldd	r24, Y+2	; 0x02
    55b4:	9b 81       	ldd	r25, Y+3	; 0x03
    55b6:	fc 01       	movw	r30, r24
    55b8:	83 a1       	ldd	r24, Z+35	; 0x23
    55ba:	94 a1       	ldd	r25, Z+36	; 0x24
    55bc:	a5 a1       	ldd	r26, Z+37	; 0x25
    55be:	b6 a1       	ldd	r27, Z+38	; 0x26
    55c0:	01 96       	adiw	r24, 0x01	; 1
    55c2:	a1 1d       	adc	r26, r1
    55c4:	b1 1d       	adc	r27, r1
    55c6:	2a 81       	ldd	r18, Y+2	; 0x02
    55c8:	3b 81       	ldd	r19, Y+3	; 0x03
    55ca:	f9 01       	movw	r30, r18
    55cc:	83 a3       	std	Z+35, r24	; 0x23
    55ce:	94 a3       	std	Z+36, r25	; 0x24
    55d0:	a5 a3       	std	Z+37, r26	; 0x25
    55d2:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    55d4:	1e c0       	rjmp	.+60     	; 0x5612 <xTaskGenericNotifyFromISR+0x134>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    55d6:	2a 81       	ldd	r18, Y+2	; 0x02
    55d8:	3b 81       	ldd	r19, Y+3	; 0x03
    55da:	88 85       	ldd	r24, Y+8	; 0x08
    55dc:	99 85       	ldd	r25, Y+9	; 0x09
    55de:	aa 85       	ldd	r26, Y+10	; 0x0a
    55e0:	bb 85       	ldd	r27, Y+11	; 0x0b
    55e2:	f9 01       	movw	r30, r18
    55e4:	83 a3       	std	Z+35, r24	; 0x23
    55e6:	94 a3       	std	Z+36, r25	; 0x24
    55e8:	a5 a3       	std	Z+37, r26	; 0x25
    55ea:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    55ec:	12 c0       	rjmp	.+36     	; 0x5612 <xTaskGenericNotifyFromISR+0x134>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    55ee:	8d 81       	ldd	r24, Y+5	; 0x05
    55f0:	82 30       	cpi	r24, 0x02	; 2
    55f2:	61 f0       	breq	.+24     	; 0x560c <xTaskGenericNotifyFromISR+0x12e>
					{
						pxTCB->ulNotifiedValue = ulValue;
    55f4:	2a 81       	ldd	r18, Y+2	; 0x02
    55f6:	3b 81       	ldd	r19, Y+3	; 0x03
    55f8:	88 85       	ldd	r24, Y+8	; 0x08
    55fa:	99 85       	ldd	r25, Y+9	; 0x09
    55fc:	aa 85       	ldd	r26, Y+10	; 0x0a
    55fe:	bb 85       	ldd	r27, Y+11	; 0x0b
    5600:	f9 01       	movw	r30, r18
    5602:	83 a3       	std	Z+35, r24	; 0x23
    5604:	94 a3       	std	Z+36, r25	; 0x24
    5606:	a5 a3       	std	Z+37, r26	; 0x25
    5608:	b6 a3       	std	Z+38, r27	; 0x26
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    560a:	03 c0       	rjmp	.+6      	; 0x5612 <xTaskGenericNotifyFromISR+0x134>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    560c:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    560e:	01 c0       	rjmp	.+2      	; 0x5612 <xTaskGenericNotifyFromISR+0x134>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
    5610:	00 00       	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    5612:	8d 81       	ldd	r24, Y+5	; 0x05
    5614:	81 30       	cpi	r24, 0x01	; 1
    5616:	09 f0       	breq	.+2      	; 0x561a <xTaskGenericNotifyFromISR+0x13c>
    5618:	4e c0       	rjmp	.+156    	; 0x56b6 <xTaskGenericNotifyFromISR+0x1d8>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    561a:	80 91 a5 02 	lds	r24, 0x02A5
    561e:	88 23       	and	r24, r24
    5620:	69 f5       	brne	.+90     	; 0x567c <xTaskGenericNotifyFromISR+0x19e>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    5622:	8a 81       	ldd	r24, Y+2	; 0x02
    5624:	9b 81       	ldd	r25, Y+3	; 0x03
    5626:	02 96       	adiw	r24, 0x02	; 2
    5628:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    562c:	8a 81       	ldd	r24, Y+2	; 0x02
    562e:	9b 81       	ldd	r25, Y+3	; 0x03
    5630:	fc 01       	movw	r30, r24
    5632:	96 89       	ldd	r25, Z+22	; 0x16
    5634:	80 91 9d 02 	lds	r24, 0x029D
    5638:	89 17       	cp	r24, r25
    563a:	30 f4       	brcc	.+12     	; 0x5648 <xTaskGenericNotifyFromISR+0x16a>
    563c:	8a 81       	ldd	r24, Y+2	; 0x02
    563e:	9b 81       	ldd	r25, Y+3	; 0x03
    5640:	fc 01       	movw	r30, r24
    5642:	86 89       	ldd	r24, Z+22	; 0x16
    5644:	80 93 9d 02 	sts	0x029D, r24
    5648:	8a 81       	ldd	r24, Y+2	; 0x02
    564a:	9b 81       	ldd	r25, Y+3	; 0x03
    564c:	ac 01       	movw	r20, r24
    564e:	4e 5f       	subi	r20, 0xFE	; 254
    5650:	5f 4f       	sbci	r21, 0xFF	; 255
    5652:	8a 81       	ldd	r24, Y+2	; 0x02
    5654:	9b 81       	ldd	r25, Y+3	; 0x03
    5656:	fc 01       	movw	r30, r24
    5658:	86 89       	ldd	r24, Z+22	; 0x16
    565a:	28 2f       	mov	r18, r24
    565c:	30 e0       	ldi	r19, 0x00	; 0
    565e:	c9 01       	movw	r24, r18
    5660:	88 0f       	add	r24, r24
    5662:	99 1f       	adc	r25, r25
    5664:	88 0f       	add	r24, r24
    5666:	99 1f       	adc	r25, r25
    5668:	88 0f       	add	r24, r24
    566a:	99 1f       	adc	r25, r25
    566c:	82 0f       	add	r24, r18
    566e:	93 1f       	adc	r25, r19
    5670:	8c 5b       	subi	r24, 0xBC	; 188
    5672:	9d 4f       	sbci	r25, 0xFD	; 253
    5674:	ba 01       	movw	r22, r20
    5676:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
    567a:	08 c0       	rjmp	.+16     	; 0x568c <xTaskGenericNotifyFromISR+0x1ae>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    567c:	8a 81       	ldd	r24, Y+2	; 0x02
    567e:	9b 81       	ldd	r25, Y+3	; 0x03
    5680:	0c 96       	adiw	r24, 0x0c	; 12
    5682:	bc 01       	movw	r22, r24
    5684:	8e e7       	ldi	r24, 0x7E	; 126
    5686:	92 e0       	ldi	r25, 0x02	; 2
    5688:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    568c:	8a 81       	ldd	r24, Y+2	; 0x02
    568e:	9b 81       	ldd	r25, Y+3	; 0x03
    5690:	fc 01       	movw	r30, r24
    5692:	26 89       	ldd	r18, Z+22	; 0x16
    5694:	80 91 42 02 	lds	r24, 0x0242
    5698:	90 91 43 02 	lds	r25, 0x0243
    569c:	fc 01       	movw	r30, r24
    569e:	86 89       	ldd	r24, Z+22	; 0x16
    56a0:	82 17       	cp	r24, r18
    56a2:	48 f4       	brcc	.+18     	; 0x56b6 <xTaskGenericNotifyFromISR+0x1d8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    56a4:	8f 85       	ldd	r24, Y+15	; 0x0f
    56a6:	98 89       	ldd	r25, Y+16	; 0x10
    56a8:	00 97       	sbiw	r24, 0x00	; 0
    56aa:	29 f0       	breq	.+10     	; 0x56b6 <xTaskGenericNotifyFromISR+0x1d8>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    56ac:	8f 85       	ldd	r24, Y+15	; 0x0f
    56ae:	98 89       	ldd	r25, Y+16	; 0x10
    56b0:	21 e0       	ldi	r18, 0x01	; 1
    56b2:	fc 01       	movw	r30, r24
    56b4:	20 83       	st	Z, r18
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    56b6:	89 81       	ldd	r24, Y+1	; 0x01
	}
    56b8:	60 96       	adiw	r28, 0x10	; 16
    56ba:	0f b6       	in	r0, 0x3f	; 63
    56bc:	f8 94       	cli
    56be:	de bf       	out	0x3e, r29	; 62
    56c0:	0f be       	out	0x3f, r0	; 63
    56c2:	cd bf       	out	0x3d, r28	; 61
    56c4:	df 91       	pop	r29
    56c6:	cf 91       	pop	r28
    56c8:	1f 91       	pop	r17
    56ca:	0f 91       	pop	r16
    56cc:	ff 90       	pop	r15
    56ce:	ef 90       	pop	r14
    56d0:	08 95       	ret

000056d2 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    56d2:	cf 93       	push	r28
    56d4:	df 93       	push	r29
    56d6:	cd b7       	in	r28, 0x3d	; 61
    56d8:	de b7       	in	r29, 0x3e	; 62
    56da:	28 97       	sbiw	r28, 0x08	; 8
    56dc:	0f b6       	in	r0, 0x3f	; 63
    56de:	f8 94       	cli
    56e0:	de bf       	out	0x3e, r29	; 62
    56e2:	0f be       	out	0x3f, r0	; 63
    56e4:	cd bf       	out	0x3d, r28	; 61
    56e6:	9e 83       	std	Y+6, r25	; 0x06
    56e8:	8d 83       	std	Y+5, r24	; 0x05
    56ea:	78 87       	std	Y+8, r23	; 0x08
    56ec:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    56ee:	8d 81       	ldd	r24, Y+5	; 0x05
    56f0:	9e 81       	ldd	r25, Y+6	; 0x06
    56f2:	9a 83       	std	Y+2, r25	; 0x02
    56f4:	89 83       	std	Y+1, r24	; 0x01

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    56f6:	1b 82       	std	Y+3, r1	; 0x03
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
    56f8:	89 81       	ldd	r24, Y+1	; 0x01
    56fa:	9a 81       	ldd	r25, Y+2	; 0x02
    56fc:	fc 01       	movw	r30, r24
    56fe:	87 a1       	ldd	r24, Z+39	; 0x27
    5700:	8c 83       	std	Y+4, r24	; 0x04
			pxTCB->eNotifyState = eNotified;
    5702:	89 81       	ldd	r24, Y+1	; 0x01
    5704:	9a 81       	ldd	r25, Y+2	; 0x02
    5706:	22 e0       	ldi	r18, 0x02	; 2
    5708:	fc 01       	movw	r30, r24
    570a:	27 a3       	std	Z+39, r18	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    570c:	89 81       	ldd	r24, Y+1	; 0x01
    570e:	9a 81       	ldd	r25, Y+2	; 0x02
    5710:	fc 01       	movw	r30, r24
    5712:	83 a1       	ldd	r24, Z+35	; 0x23
    5714:	94 a1       	ldd	r25, Z+36	; 0x24
    5716:	a5 a1       	ldd	r26, Z+37	; 0x25
    5718:	b6 a1       	ldd	r27, Z+38	; 0x26
    571a:	01 96       	adiw	r24, 0x01	; 1
    571c:	a1 1d       	adc	r26, r1
    571e:	b1 1d       	adc	r27, r1
    5720:	29 81       	ldd	r18, Y+1	; 0x01
    5722:	3a 81       	ldd	r19, Y+2	; 0x02
    5724:	f9 01       	movw	r30, r18
    5726:	83 a3       	std	Z+35, r24	; 0x23
    5728:	94 a3       	std	Z+36, r25	; 0x24
    572a:	a5 a3       	std	Z+37, r26	; 0x25
    572c:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    572e:	8c 81       	ldd	r24, Y+4	; 0x04
    5730:	81 30       	cpi	r24, 0x01	; 1
    5732:	09 f0       	breq	.+2      	; 0x5736 <vTaskNotifyGiveFromISR+0x64>
    5734:	4e c0       	rjmp	.+156    	; 0x57d2 <vTaskNotifyGiveFromISR+0x100>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5736:	80 91 a5 02 	lds	r24, 0x02A5
    573a:	88 23       	and	r24, r24
    573c:	69 f5       	brne	.+90     	; 0x5798 <vTaskNotifyGiveFromISR+0xc6>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    573e:	89 81       	ldd	r24, Y+1	; 0x01
    5740:	9a 81       	ldd	r25, Y+2	; 0x02
    5742:	02 96       	adiw	r24, 0x02	; 2
    5744:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5748:	89 81       	ldd	r24, Y+1	; 0x01
    574a:	9a 81       	ldd	r25, Y+2	; 0x02
    574c:	fc 01       	movw	r30, r24
    574e:	96 89       	ldd	r25, Z+22	; 0x16
    5750:	80 91 9d 02 	lds	r24, 0x029D
    5754:	89 17       	cp	r24, r25
    5756:	30 f4       	brcc	.+12     	; 0x5764 <vTaskNotifyGiveFromISR+0x92>
    5758:	89 81       	ldd	r24, Y+1	; 0x01
    575a:	9a 81       	ldd	r25, Y+2	; 0x02
    575c:	fc 01       	movw	r30, r24
    575e:	86 89       	ldd	r24, Z+22	; 0x16
    5760:	80 93 9d 02 	sts	0x029D, r24
    5764:	89 81       	ldd	r24, Y+1	; 0x01
    5766:	9a 81       	ldd	r25, Y+2	; 0x02
    5768:	ac 01       	movw	r20, r24
    576a:	4e 5f       	subi	r20, 0xFE	; 254
    576c:	5f 4f       	sbci	r21, 0xFF	; 255
    576e:	89 81       	ldd	r24, Y+1	; 0x01
    5770:	9a 81       	ldd	r25, Y+2	; 0x02
    5772:	fc 01       	movw	r30, r24
    5774:	86 89       	ldd	r24, Z+22	; 0x16
    5776:	28 2f       	mov	r18, r24
    5778:	30 e0       	ldi	r19, 0x00	; 0
    577a:	c9 01       	movw	r24, r18
    577c:	88 0f       	add	r24, r24
    577e:	99 1f       	adc	r25, r25
    5780:	88 0f       	add	r24, r24
    5782:	99 1f       	adc	r25, r25
    5784:	88 0f       	add	r24, r24
    5786:	99 1f       	adc	r25, r25
    5788:	82 0f       	add	r24, r18
    578a:	93 1f       	adc	r25, r19
    578c:	8c 5b       	subi	r24, 0xBC	; 188
    578e:	9d 4f       	sbci	r25, 0xFD	; 253
    5790:	ba 01       	movw	r22, r20
    5792:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
    5796:	08 c0       	rjmp	.+16     	; 0x57a8 <vTaskNotifyGiveFromISR+0xd6>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5798:	89 81       	ldd	r24, Y+1	; 0x01
    579a:	9a 81       	ldd	r25, Y+2	; 0x02
    579c:	0c 96       	adiw	r24, 0x0c	; 12
    579e:	bc 01       	movw	r22, r24
    57a0:	8e e7       	ldi	r24, 0x7E	; 126
    57a2:	92 e0       	ldi	r25, 0x02	; 2
    57a4:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    57a8:	89 81       	ldd	r24, Y+1	; 0x01
    57aa:	9a 81       	ldd	r25, Y+2	; 0x02
    57ac:	fc 01       	movw	r30, r24
    57ae:	26 89       	ldd	r18, Z+22	; 0x16
    57b0:	80 91 42 02 	lds	r24, 0x0242
    57b4:	90 91 43 02 	lds	r25, 0x0243
    57b8:	fc 01       	movw	r30, r24
    57ba:	86 89       	ldd	r24, Z+22	; 0x16
    57bc:	82 17       	cp	r24, r18
    57be:	48 f4       	brcc	.+18     	; 0x57d2 <vTaskNotifyGiveFromISR+0x100>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    57c0:	8f 81       	ldd	r24, Y+7	; 0x07
    57c2:	98 85       	ldd	r25, Y+8	; 0x08
    57c4:	00 97       	sbiw	r24, 0x00	; 0
    57c6:	29 f0       	breq	.+10     	; 0x57d2 <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    57c8:	8f 81       	ldd	r24, Y+7	; 0x07
    57ca:	98 85       	ldd	r25, Y+8	; 0x08
    57cc:	21 e0       	ldi	r18, 0x01	; 1
    57ce:	fc 01       	movw	r30, r24
    57d0:	20 83       	st	Z, r18
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    57d2:	28 96       	adiw	r28, 0x08	; 8
    57d4:	0f b6       	in	r0, 0x3f	; 63
    57d6:	f8 94       	cli
    57d8:	de bf       	out	0x3e, r29	; 62
    57da:	0f be       	out	0x3f, r0	; 63
    57dc:	cd bf       	out	0x3d, r28	; 61
    57de:	df 91       	pop	r29
    57e0:	cf 91       	pop	r28
    57e2:	08 95       	ret

000057e4 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    57e4:	cf 93       	push	r28
    57e6:	df 93       	push	r29
    57e8:	00 d0       	rcall	.+0      	; 0x57ea <xTaskNotifyStateClear+0x6>
    57ea:	1f 92       	push	r1
    57ec:	1f 92       	push	r1
    57ee:	cd b7       	in	r28, 0x3d	; 61
    57f0:	de b7       	in	r29, 0x3e	; 62
    57f2:	9d 83       	std	Y+5, r25	; 0x05
    57f4:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		pxTCB = ( TCB_t * ) xTask;
    57f6:	8c 81       	ldd	r24, Y+4	; 0x04
    57f8:	9d 81       	ldd	r25, Y+5	; 0x05
    57fa:	9b 83       	std	Y+3, r25	; 0x03
    57fc:	8a 83       	std	Y+2, r24	; 0x02

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    57fe:	8a 81       	ldd	r24, Y+2	; 0x02
    5800:	9b 81       	ldd	r25, Y+3	; 0x03
    5802:	00 97       	sbiw	r24, 0x00	; 0
    5804:	29 f4       	brne	.+10     	; 0x5810 <xTaskNotifyStateClear+0x2c>
    5806:	80 91 42 02 	lds	r24, 0x0242
    580a:	90 91 43 02 	lds	r25, 0x0243
    580e:	02 c0       	rjmp	.+4      	; 0x5814 <xTaskNotifyStateClear+0x30>
    5810:	8a 81       	ldd	r24, Y+2	; 0x02
    5812:	9b 81       	ldd	r25, Y+3	; 0x03
    5814:	9b 83       	std	Y+3, r25	; 0x03
    5816:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5818:	0f b6       	in	r0, 0x3f	; 63
    581a:	f8 94       	cli
    581c:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    581e:	8a 81       	ldd	r24, Y+2	; 0x02
    5820:	9b 81       	ldd	r25, Y+3	; 0x03
    5822:	fc 01       	movw	r30, r24
    5824:	87 a1       	ldd	r24, Z+39	; 0x27
    5826:	82 30       	cpi	r24, 0x02	; 2
    5828:	39 f4       	brne	.+14     	; 0x5838 <xTaskNotifyStateClear+0x54>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    582a:	8a 81       	ldd	r24, Y+2	; 0x02
    582c:	9b 81       	ldd	r25, Y+3	; 0x03
    582e:	fc 01       	movw	r30, r24
    5830:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    5832:	81 e0       	ldi	r24, 0x01	; 1
    5834:	89 83       	std	Y+1, r24	; 0x01
    5836:	01 c0       	rjmp	.+2      	; 0x583a <xTaskNotifyStateClear+0x56>
			}
			else
			{
				xReturn = pdFAIL;
    5838:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    583a:	0f 90       	pop	r0
    583c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    583e:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5840:	0f 90       	pop	r0
    5842:	0f 90       	pop	r0
    5844:	0f 90       	pop	r0
    5846:	0f 90       	pop	r0
    5848:	0f 90       	pop	r0
    584a:	df 91       	pop	r29
    584c:	cf 91       	pop	r28
    584e:	08 95       	ret

00005850 <__cmpsf2>:
    5850:	d4 d0       	rcall	.+424    	; 0x59fa <__fp_cmp>
    5852:	08 f4       	brcc	.+2      	; 0x5856 <__cmpsf2+0x6>
    5854:	81 e0       	ldi	r24, 0x01	; 1
    5856:	08 95       	ret

00005858 <__divsf3>:
    5858:	0c d0       	rcall	.+24     	; 0x5872 <__divsf3x>
    585a:	0a c1       	rjmp	.+532    	; 0x5a70 <__fp_round>
    585c:	02 d1       	rcall	.+516    	; 0x5a62 <__fp_pscB>
    585e:	40 f0       	brcs	.+16     	; 0x5870 <__divsf3+0x18>
    5860:	f9 d0       	rcall	.+498    	; 0x5a54 <__fp_pscA>
    5862:	30 f0       	brcs	.+12     	; 0x5870 <__divsf3+0x18>
    5864:	21 f4       	brne	.+8      	; 0x586e <__divsf3+0x16>
    5866:	5f 3f       	cpi	r21, 0xFF	; 255
    5868:	19 f0       	breq	.+6      	; 0x5870 <__divsf3+0x18>
    586a:	eb c0       	rjmp	.+470    	; 0x5a42 <__fp_inf>
    586c:	51 11       	cpse	r21, r1
    586e:	34 c1       	rjmp	.+616    	; 0x5ad8 <__fp_szero>
    5870:	ee c0       	rjmp	.+476    	; 0x5a4e <__fp_nan>

00005872 <__divsf3x>:
    5872:	0f d1       	rcall	.+542    	; 0x5a92 <__fp_split3>
    5874:	98 f3       	brcs	.-26     	; 0x585c <__divsf3+0x4>

00005876 <__divsf3_pse>:
    5876:	99 23       	and	r25, r25
    5878:	c9 f3       	breq	.-14     	; 0x586c <__divsf3+0x14>
    587a:	55 23       	and	r21, r21
    587c:	b1 f3       	breq	.-20     	; 0x586a <__divsf3+0x12>
    587e:	95 1b       	sub	r25, r21
    5880:	55 0b       	sbc	r21, r21
    5882:	bb 27       	eor	r27, r27
    5884:	aa 27       	eor	r26, r26
    5886:	62 17       	cp	r22, r18
    5888:	73 07       	cpc	r23, r19
    588a:	84 07       	cpc	r24, r20
    588c:	38 f0       	brcs	.+14     	; 0x589c <__divsf3_pse+0x26>
    588e:	9f 5f       	subi	r25, 0xFF	; 255
    5890:	5f 4f       	sbci	r21, 0xFF	; 255
    5892:	22 0f       	add	r18, r18
    5894:	33 1f       	adc	r19, r19
    5896:	44 1f       	adc	r20, r20
    5898:	aa 1f       	adc	r26, r26
    589a:	a9 f3       	breq	.-22     	; 0x5886 <__divsf3_pse+0x10>
    589c:	33 d0       	rcall	.+102    	; 0x5904 <__divsf3_pse+0x8e>
    589e:	0e 2e       	mov	r0, r30
    58a0:	3a f0       	brmi	.+14     	; 0x58b0 <__divsf3_pse+0x3a>
    58a2:	e0 e8       	ldi	r30, 0x80	; 128
    58a4:	30 d0       	rcall	.+96     	; 0x5906 <__divsf3_pse+0x90>
    58a6:	91 50       	subi	r25, 0x01	; 1
    58a8:	50 40       	sbci	r21, 0x00	; 0
    58aa:	e6 95       	lsr	r30
    58ac:	00 1c       	adc	r0, r0
    58ae:	ca f7       	brpl	.-14     	; 0x58a2 <__divsf3_pse+0x2c>
    58b0:	29 d0       	rcall	.+82     	; 0x5904 <__divsf3_pse+0x8e>
    58b2:	fe 2f       	mov	r31, r30
    58b4:	27 d0       	rcall	.+78     	; 0x5904 <__divsf3_pse+0x8e>
    58b6:	66 0f       	add	r22, r22
    58b8:	77 1f       	adc	r23, r23
    58ba:	88 1f       	adc	r24, r24
    58bc:	bb 1f       	adc	r27, r27
    58be:	26 17       	cp	r18, r22
    58c0:	37 07       	cpc	r19, r23
    58c2:	48 07       	cpc	r20, r24
    58c4:	ab 07       	cpc	r26, r27
    58c6:	b0 e8       	ldi	r27, 0x80	; 128
    58c8:	09 f0       	breq	.+2      	; 0x58cc <__divsf3_pse+0x56>
    58ca:	bb 0b       	sbc	r27, r27
    58cc:	80 2d       	mov	r24, r0
    58ce:	bf 01       	movw	r22, r30
    58d0:	ff 27       	eor	r31, r31
    58d2:	93 58       	subi	r25, 0x83	; 131
    58d4:	5f 4f       	sbci	r21, 0xFF	; 255
    58d6:	2a f0       	brmi	.+10     	; 0x58e2 <__divsf3_pse+0x6c>
    58d8:	9e 3f       	cpi	r25, 0xFE	; 254
    58da:	51 05       	cpc	r21, r1
    58dc:	68 f0       	brcs	.+26     	; 0x58f8 <__divsf3_pse+0x82>
    58de:	b1 c0       	rjmp	.+354    	; 0x5a42 <__fp_inf>
    58e0:	fb c0       	rjmp	.+502    	; 0x5ad8 <__fp_szero>
    58e2:	5f 3f       	cpi	r21, 0xFF	; 255
    58e4:	ec f3       	brlt	.-6      	; 0x58e0 <__divsf3_pse+0x6a>
    58e6:	98 3e       	cpi	r25, 0xE8	; 232
    58e8:	dc f3       	brlt	.-10     	; 0x58e0 <__divsf3_pse+0x6a>
    58ea:	86 95       	lsr	r24
    58ec:	77 95       	ror	r23
    58ee:	67 95       	ror	r22
    58f0:	b7 95       	ror	r27
    58f2:	f7 95       	ror	r31
    58f4:	9f 5f       	subi	r25, 0xFF	; 255
    58f6:	c9 f7       	brne	.-14     	; 0x58ea <__divsf3_pse+0x74>
    58f8:	88 0f       	add	r24, r24
    58fa:	91 1d       	adc	r25, r1
    58fc:	96 95       	lsr	r25
    58fe:	87 95       	ror	r24
    5900:	97 f9       	bld	r25, 7
    5902:	08 95       	ret
    5904:	e1 e0       	ldi	r30, 0x01	; 1
    5906:	66 0f       	add	r22, r22
    5908:	77 1f       	adc	r23, r23
    590a:	88 1f       	adc	r24, r24
    590c:	bb 1f       	adc	r27, r27
    590e:	62 17       	cp	r22, r18
    5910:	73 07       	cpc	r23, r19
    5912:	84 07       	cpc	r24, r20
    5914:	ba 07       	cpc	r27, r26
    5916:	20 f0       	brcs	.+8      	; 0x5920 <__divsf3_pse+0xaa>
    5918:	62 1b       	sub	r22, r18
    591a:	73 0b       	sbc	r23, r19
    591c:	84 0b       	sbc	r24, r20
    591e:	ba 0b       	sbc	r27, r26
    5920:	ee 1f       	adc	r30, r30
    5922:	88 f7       	brcc	.-30     	; 0x5906 <__divsf3_pse+0x90>
    5924:	e0 95       	com	r30
    5926:	08 95       	ret

00005928 <__fixunssfsi>:
    5928:	bc d0       	rcall	.+376    	; 0x5aa2 <__fp_splitA>
    592a:	88 f0       	brcs	.+34     	; 0x594e <__fixunssfsi+0x26>
    592c:	9f 57       	subi	r25, 0x7F	; 127
    592e:	90 f0       	brcs	.+36     	; 0x5954 <__fixunssfsi+0x2c>
    5930:	b9 2f       	mov	r27, r25
    5932:	99 27       	eor	r25, r25
    5934:	b7 51       	subi	r27, 0x17	; 23
    5936:	a0 f0       	brcs	.+40     	; 0x5960 <__fixunssfsi+0x38>
    5938:	d1 f0       	breq	.+52     	; 0x596e <__fixunssfsi+0x46>
    593a:	66 0f       	add	r22, r22
    593c:	77 1f       	adc	r23, r23
    593e:	88 1f       	adc	r24, r24
    5940:	99 1f       	adc	r25, r25
    5942:	1a f0       	brmi	.+6      	; 0x594a <__fixunssfsi+0x22>
    5944:	ba 95       	dec	r27
    5946:	c9 f7       	brne	.-14     	; 0x593a <__fixunssfsi+0x12>
    5948:	12 c0       	rjmp	.+36     	; 0x596e <__fixunssfsi+0x46>
    594a:	b1 30       	cpi	r27, 0x01	; 1
    594c:	81 f0       	breq	.+32     	; 0x596e <__fixunssfsi+0x46>
    594e:	c3 d0       	rcall	.+390    	; 0x5ad6 <__fp_zero>
    5950:	b1 e0       	ldi	r27, 0x01	; 1
    5952:	08 95       	ret
    5954:	c0 c0       	rjmp	.+384    	; 0x5ad6 <__fp_zero>
    5956:	67 2f       	mov	r22, r23
    5958:	78 2f       	mov	r23, r24
    595a:	88 27       	eor	r24, r24
    595c:	b8 5f       	subi	r27, 0xF8	; 248
    595e:	39 f0       	breq	.+14     	; 0x596e <__fixunssfsi+0x46>
    5960:	b9 3f       	cpi	r27, 0xF9	; 249
    5962:	cc f3       	brlt	.-14     	; 0x5956 <__fixunssfsi+0x2e>
    5964:	86 95       	lsr	r24
    5966:	77 95       	ror	r23
    5968:	67 95       	ror	r22
    596a:	b3 95       	inc	r27
    596c:	d9 f7       	brne	.-10     	; 0x5964 <__fixunssfsi+0x3c>
    596e:	3e f4       	brtc	.+14     	; 0x597e <__fixunssfsi+0x56>
    5970:	90 95       	com	r25
    5972:	80 95       	com	r24
    5974:	70 95       	com	r23
    5976:	61 95       	neg	r22
    5978:	7f 4f       	sbci	r23, 0xFF	; 255
    597a:	8f 4f       	sbci	r24, 0xFF	; 255
    597c:	9f 4f       	sbci	r25, 0xFF	; 255
    597e:	08 95       	ret

00005980 <__floatunsisf>:
    5980:	e8 94       	clt
    5982:	09 c0       	rjmp	.+18     	; 0x5996 <__floatsisf+0x12>

00005984 <__floatsisf>:
    5984:	97 fb       	bst	r25, 7
    5986:	3e f4       	brtc	.+14     	; 0x5996 <__floatsisf+0x12>
    5988:	90 95       	com	r25
    598a:	80 95       	com	r24
    598c:	70 95       	com	r23
    598e:	61 95       	neg	r22
    5990:	7f 4f       	sbci	r23, 0xFF	; 255
    5992:	8f 4f       	sbci	r24, 0xFF	; 255
    5994:	9f 4f       	sbci	r25, 0xFF	; 255
    5996:	99 23       	and	r25, r25
    5998:	a9 f0       	breq	.+42     	; 0x59c4 <__floatsisf+0x40>
    599a:	f9 2f       	mov	r31, r25
    599c:	96 e9       	ldi	r25, 0x96	; 150
    599e:	bb 27       	eor	r27, r27
    59a0:	93 95       	inc	r25
    59a2:	f6 95       	lsr	r31
    59a4:	87 95       	ror	r24
    59a6:	77 95       	ror	r23
    59a8:	67 95       	ror	r22
    59aa:	b7 95       	ror	r27
    59ac:	f1 11       	cpse	r31, r1
    59ae:	f8 cf       	rjmp	.-16     	; 0x59a0 <__floatsisf+0x1c>
    59b0:	fa f4       	brpl	.+62     	; 0x59f0 <__floatsisf+0x6c>
    59b2:	bb 0f       	add	r27, r27
    59b4:	11 f4       	brne	.+4      	; 0x59ba <__floatsisf+0x36>
    59b6:	60 ff       	sbrs	r22, 0
    59b8:	1b c0       	rjmp	.+54     	; 0x59f0 <__floatsisf+0x6c>
    59ba:	6f 5f       	subi	r22, 0xFF	; 255
    59bc:	7f 4f       	sbci	r23, 0xFF	; 255
    59be:	8f 4f       	sbci	r24, 0xFF	; 255
    59c0:	9f 4f       	sbci	r25, 0xFF	; 255
    59c2:	16 c0       	rjmp	.+44     	; 0x59f0 <__floatsisf+0x6c>
    59c4:	88 23       	and	r24, r24
    59c6:	11 f0       	breq	.+4      	; 0x59cc <__floatsisf+0x48>
    59c8:	96 e9       	ldi	r25, 0x96	; 150
    59ca:	11 c0       	rjmp	.+34     	; 0x59ee <__floatsisf+0x6a>
    59cc:	77 23       	and	r23, r23
    59ce:	21 f0       	breq	.+8      	; 0x59d8 <__floatsisf+0x54>
    59d0:	9e e8       	ldi	r25, 0x8E	; 142
    59d2:	87 2f       	mov	r24, r23
    59d4:	76 2f       	mov	r23, r22
    59d6:	05 c0       	rjmp	.+10     	; 0x59e2 <__floatsisf+0x5e>
    59d8:	66 23       	and	r22, r22
    59da:	71 f0       	breq	.+28     	; 0x59f8 <__floatsisf+0x74>
    59dc:	96 e8       	ldi	r25, 0x86	; 134
    59de:	86 2f       	mov	r24, r22
    59e0:	70 e0       	ldi	r23, 0x00	; 0
    59e2:	60 e0       	ldi	r22, 0x00	; 0
    59e4:	2a f0       	brmi	.+10     	; 0x59f0 <__floatsisf+0x6c>
    59e6:	9a 95       	dec	r25
    59e8:	66 0f       	add	r22, r22
    59ea:	77 1f       	adc	r23, r23
    59ec:	88 1f       	adc	r24, r24
    59ee:	da f7       	brpl	.-10     	; 0x59e6 <__floatsisf+0x62>
    59f0:	88 0f       	add	r24, r24
    59f2:	96 95       	lsr	r25
    59f4:	87 95       	ror	r24
    59f6:	97 f9       	bld	r25, 7
    59f8:	08 95       	ret

000059fa <__fp_cmp>:
    59fa:	99 0f       	add	r25, r25
    59fc:	00 08       	sbc	r0, r0
    59fe:	55 0f       	add	r21, r21
    5a00:	aa 0b       	sbc	r26, r26
    5a02:	e0 e8       	ldi	r30, 0x80	; 128
    5a04:	fe ef       	ldi	r31, 0xFE	; 254
    5a06:	16 16       	cp	r1, r22
    5a08:	17 06       	cpc	r1, r23
    5a0a:	e8 07       	cpc	r30, r24
    5a0c:	f9 07       	cpc	r31, r25
    5a0e:	c0 f0       	brcs	.+48     	; 0x5a40 <__fp_cmp+0x46>
    5a10:	12 16       	cp	r1, r18
    5a12:	13 06       	cpc	r1, r19
    5a14:	e4 07       	cpc	r30, r20
    5a16:	f5 07       	cpc	r31, r21
    5a18:	98 f0       	brcs	.+38     	; 0x5a40 <__fp_cmp+0x46>
    5a1a:	62 1b       	sub	r22, r18
    5a1c:	73 0b       	sbc	r23, r19
    5a1e:	84 0b       	sbc	r24, r20
    5a20:	95 0b       	sbc	r25, r21
    5a22:	39 f4       	brne	.+14     	; 0x5a32 <__fp_cmp+0x38>
    5a24:	0a 26       	eor	r0, r26
    5a26:	61 f0       	breq	.+24     	; 0x5a40 <__fp_cmp+0x46>
    5a28:	23 2b       	or	r18, r19
    5a2a:	24 2b       	or	r18, r20
    5a2c:	25 2b       	or	r18, r21
    5a2e:	21 f4       	brne	.+8      	; 0x5a38 <__fp_cmp+0x3e>
    5a30:	08 95       	ret
    5a32:	0a 26       	eor	r0, r26
    5a34:	09 f4       	brne	.+2      	; 0x5a38 <__fp_cmp+0x3e>
    5a36:	a1 40       	sbci	r26, 0x01	; 1
    5a38:	a6 95       	lsr	r26
    5a3a:	8f ef       	ldi	r24, 0xFF	; 255
    5a3c:	81 1d       	adc	r24, r1
    5a3e:	81 1d       	adc	r24, r1
    5a40:	08 95       	ret

00005a42 <__fp_inf>:
    5a42:	97 f9       	bld	r25, 7
    5a44:	9f 67       	ori	r25, 0x7F	; 127
    5a46:	80 e8       	ldi	r24, 0x80	; 128
    5a48:	70 e0       	ldi	r23, 0x00	; 0
    5a4a:	60 e0       	ldi	r22, 0x00	; 0
    5a4c:	08 95       	ret

00005a4e <__fp_nan>:
    5a4e:	9f ef       	ldi	r25, 0xFF	; 255
    5a50:	80 ec       	ldi	r24, 0xC0	; 192
    5a52:	08 95       	ret

00005a54 <__fp_pscA>:
    5a54:	00 24       	eor	r0, r0
    5a56:	0a 94       	dec	r0
    5a58:	16 16       	cp	r1, r22
    5a5a:	17 06       	cpc	r1, r23
    5a5c:	18 06       	cpc	r1, r24
    5a5e:	09 06       	cpc	r0, r25
    5a60:	08 95       	ret

00005a62 <__fp_pscB>:
    5a62:	00 24       	eor	r0, r0
    5a64:	0a 94       	dec	r0
    5a66:	12 16       	cp	r1, r18
    5a68:	13 06       	cpc	r1, r19
    5a6a:	14 06       	cpc	r1, r20
    5a6c:	05 06       	cpc	r0, r21
    5a6e:	08 95       	ret

00005a70 <__fp_round>:
    5a70:	09 2e       	mov	r0, r25
    5a72:	03 94       	inc	r0
    5a74:	00 0c       	add	r0, r0
    5a76:	11 f4       	brne	.+4      	; 0x5a7c <__fp_round+0xc>
    5a78:	88 23       	and	r24, r24
    5a7a:	52 f0       	brmi	.+20     	; 0x5a90 <__fp_round+0x20>
    5a7c:	bb 0f       	add	r27, r27
    5a7e:	40 f4       	brcc	.+16     	; 0x5a90 <__fp_round+0x20>
    5a80:	bf 2b       	or	r27, r31
    5a82:	11 f4       	brne	.+4      	; 0x5a88 <__fp_round+0x18>
    5a84:	60 ff       	sbrs	r22, 0
    5a86:	04 c0       	rjmp	.+8      	; 0x5a90 <__fp_round+0x20>
    5a88:	6f 5f       	subi	r22, 0xFF	; 255
    5a8a:	7f 4f       	sbci	r23, 0xFF	; 255
    5a8c:	8f 4f       	sbci	r24, 0xFF	; 255
    5a8e:	9f 4f       	sbci	r25, 0xFF	; 255
    5a90:	08 95       	ret

00005a92 <__fp_split3>:
    5a92:	57 fd       	sbrc	r21, 7
    5a94:	90 58       	subi	r25, 0x80	; 128
    5a96:	44 0f       	add	r20, r20
    5a98:	55 1f       	adc	r21, r21
    5a9a:	59 f0       	breq	.+22     	; 0x5ab2 <__fp_splitA+0x10>
    5a9c:	5f 3f       	cpi	r21, 0xFF	; 255
    5a9e:	71 f0       	breq	.+28     	; 0x5abc <__fp_splitA+0x1a>
    5aa0:	47 95       	ror	r20

00005aa2 <__fp_splitA>:
    5aa2:	88 0f       	add	r24, r24
    5aa4:	97 fb       	bst	r25, 7
    5aa6:	99 1f       	adc	r25, r25
    5aa8:	61 f0       	breq	.+24     	; 0x5ac2 <__fp_splitA+0x20>
    5aaa:	9f 3f       	cpi	r25, 0xFF	; 255
    5aac:	79 f0       	breq	.+30     	; 0x5acc <__fp_splitA+0x2a>
    5aae:	87 95       	ror	r24
    5ab0:	08 95       	ret
    5ab2:	12 16       	cp	r1, r18
    5ab4:	13 06       	cpc	r1, r19
    5ab6:	14 06       	cpc	r1, r20
    5ab8:	55 1f       	adc	r21, r21
    5aba:	f2 cf       	rjmp	.-28     	; 0x5aa0 <__fp_split3+0xe>
    5abc:	46 95       	lsr	r20
    5abe:	f1 df       	rcall	.-30     	; 0x5aa2 <__fp_splitA>
    5ac0:	08 c0       	rjmp	.+16     	; 0x5ad2 <__fp_splitA+0x30>
    5ac2:	16 16       	cp	r1, r22
    5ac4:	17 06       	cpc	r1, r23
    5ac6:	18 06       	cpc	r1, r24
    5ac8:	99 1f       	adc	r25, r25
    5aca:	f1 cf       	rjmp	.-30     	; 0x5aae <__fp_splitA+0xc>
    5acc:	86 95       	lsr	r24
    5ace:	71 05       	cpc	r23, r1
    5ad0:	61 05       	cpc	r22, r1
    5ad2:	08 94       	sec
    5ad4:	08 95       	ret

00005ad6 <__fp_zero>:
    5ad6:	e8 94       	clt

00005ad8 <__fp_szero>:
    5ad8:	bb 27       	eor	r27, r27
    5ada:	66 27       	eor	r22, r22
    5adc:	77 27       	eor	r23, r23
    5ade:	cb 01       	movw	r24, r22
    5ae0:	97 f9       	bld	r25, 7
    5ae2:	08 95       	ret

00005ae4 <__gesf2>:
    5ae4:	8a df       	rcall	.-236    	; 0x59fa <__fp_cmp>
    5ae6:	08 f4       	brcc	.+2      	; 0x5aea <__gesf2+0x6>
    5ae8:	8f ef       	ldi	r24, 0xFF	; 255
    5aea:	08 95       	ret

00005aec <__mulsf3>:
    5aec:	0b d0       	rcall	.+22     	; 0x5b04 <__mulsf3x>
    5aee:	c0 cf       	rjmp	.-128    	; 0x5a70 <__fp_round>
    5af0:	b1 df       	rcall	.-158    	; 0x5a54 <__fp_pscA>
    5af2:	28 f0       	brcs	.+10     	; 0x5afe <__mulsf3+0x12>
    5af4:	b6 df       	rcall	.-148    	; 0x5a62 <__fp_pscB>
    5af6:	18 f0       	brcs	.+6      	; 0x5afe <__mulsf3+0x12>
    5af8:	95 23       	and	r25, r21
    5afa:	09 f0       	breq	.+2      	; 0x5afe <__mulsf3+0x12>
    5afc:	a2 cf       	rjmp	.-188    	; 0x5a42 <__fp_inf>
    5afe:	a7 cf       	rjmp	.-178    	; 0x5a4e <__fp_nan>
    5b00:	11 24       	eor	r1, r1
    5b02:	ea cf       	rjmp	.-44     	; 0x5ad8 <__fp_szero>

00005b04 <__mulsf3x>:
    5b04:	c6 df       	rcall	.-116    	; 0x5a92 <__fp_split3>
    5b06:	a0 f3       	brcs	.-24     	; 0x5af0 <__mulsf3+0x4>

00005b08 <__mulsf3_pse>:
    5b08:	95 9f       	mul	r25, r21
    5b0a:	d1 f3       	breq	.-12     	; 0x5b00 <__mulsf3+0x14>
    5b0c:	95 0f       	add	r25, r21
    5b0e:	50 e0       	ldi	r21, 0x00	; 0
    5b10:	55 1f       	adc	r21, r21
    5b12:	62 9f       	mul	r22, r18
    5b14:	f0 01       	movw	r30, r0
    5b16:	72 9f       	mul	r23, r18
    5b18:	bb 27       	eor	r27, r27
    5b1a:	f0 0d       	add	r31, r0
    5b1c:	b1 1d       	adc	r27, r1
    5b1e:	63 9f       	mul	r22, r19
    5b20:	aa 27       	eor	r26, r26
    5b22:	f0 0d       	add	r31, r0
    5b24:	b1 1d       	adc	r27, r1
    5b26:	aa 1f       	adc	r26, r26
    5b28:	64 9f       	mul	r22, r20
    5b2a:	66 27       	eor	r22, r22
    5b2c:	b0 0d       	add	r27, r0
    5b2e:	a1 1d       	adc	r26, r1
    5b30:	66 1f       	adc	r22, r22
    5b32:	82 9f       	mul	r24, r18
    5b34:	22 27       	eor	r18, r18
    5b36:	b0 0d       	add	r27, r0
    5b38:	a1 1d       	adc	r26, r1
    5b3a:	62 1f       	adc	r22, r18
    5b3c:	73 9f       	mul	r23, r19
    5b3e:	b0 0d       	add	r27, r0
    5b40:	a1 1d       	adc	r26, r1
    5b42:	62 1f       	adc	r22, r18
    5b44:	83 9f       	mul	r24, r19
    5b46:	a0 0d       	add	r26, r0
    5b48:	61 1d       	adc	r22, r1
    5b4a:	22 1f       	adc	r18, r18
    5b4c:	74 9f       	mul	r23, r20
    5b4e:	33 27       	eor	r19, r19
    5b50:	a0 0d       	add	r26, r0
    5b52:	61 1d       	adc	r22, r1
    5b54:	23 1f       	adc	r18, r19
    5b56:	84 9f       	mul	r24, r20
    5b58:	60 0d       	add	r22, r0
    5b5a:	21 1d       	adc	r18, r1
    5b5c:	82 2f       	mov	r24, r18
    5b5e:	76 2f       	mov	r23, r22
    5b60:	6a 2f       	mov	r22, r26
    5b62:	11 24       	eor	r1, r1
    5b64:	9f 57       	subi	r25, 0x7F	; 127
    5b66:	50 40       	sbci	r21, 0x00	; 0
    5b68:	8a f0       	brmi	.+34     	; 0x5b8c <__mulsf3_pse+0x84>
    5b6a:	e1 f0       	breq	.+56     	; 0x5ba4 <__mulsf3_pse+0x9c>
    5b6c:	88 23       	and	r24, r24
    5b6e:	4a f0       	brmi	.+18     	; 0x5b82 <__mulsf3_pse+0x7a>
    5b70:	ee 0f       	add	r30, r30
    5b72:	ff 1f       	adc	r31, r31
    5b74:	bb 1f       	adc	r27, r27
    5b76:	66 1f       	adc	r22, r22
    5b78:	77 1f       	adc	r23, r23
    5b7a:	88 1f       	adc	r24, r24
    5b7c:	91 50       	subi	r25, 0x01	; 1
    5b7e:	50 40       	sbci	r21, 0x00	; 0
    5b80:	a9 f7       	brne	.-22     	; 0x5b6c <__mulsf3_pse+0x64>
    5b82:	9e 3f       	cpi	r25, 0xFE	; 254
    5b84:	51 05       	cpc	r21, r1
    5b86:	70 f0       	brcs	.+28     	; 0x5ba4 <__mulsf3_pse+0x9c>
    5b88:	5c cf       	rjmp	.-328    	; 0x5a42 <__fp_inf>
    5b8a:	a6 cf       	rjmp	.-180    	; 0x5ad8 <__fp_szero>
    5b8c:	5f 3f       	cpi	r21, 0xFF	; 255
    5b8e:	ec f3       	brlt	.-6      	; 0x5b8a <__mulsf3_pse+0x82>
    5b90:	98 3e       	cpi	r25, 0xE8	; 232
    5b92:	dc f3       	brlt	.-10     	; 0x5b8a <__mulsf3_pse+0x82>
    5b94:	86 95       	lsr	r24
    5b96:	77 95       	ror	r23
    5b98:	67 95       	ror	r22
    5b9a:	b7 95       	ror	r27
    5b9c:	f7 95       	ror	r31
    5b9e:	e7 95       	ror	r30
    5ba0:	9f 5f       	subi	r25, 0xFF	; 255
    5ba2:	c1 f7       	brne	.-16     	; 0x5b94 <__mulsf3_pse+0x8c>
    5ba4:	fe 2b       	or	r31, r30
    5ba6:	88 0f       	add	r24, r24
    5ba8:	91 1d       	adc	r25, r1
    5baa:	96 95       	lsr	r25
    5bac:	87 95       	ror	r24
    5bae:	97 f9       	bld	r25, 7
    5bb0:	08 95       	ret

00005bb2 <dtostrf>:
    5bb2:	ef 92       	push	r14
    5bb4:	0f 93       	push	r16
    5bb6:	1f 93       	push	r17
    5bb8:	cf 93       	push	r28
    5bba:	df 93       	push	r29
    5bbc:	e8 01       	movw	r28, r16
    5bbe:	47 ff       	sbrs	r20, 7
    5bc0:	02 c0       	rjmp	.+4      	; 0x5bc6 <dtostrf+0x14>
    5bc2:	34 e1       	ldi	r19, 0x14	; 20
    5bc4:	01 c0       	rjmp	.+2      	; 0x5bc8 <dtostrf+0x16>
    5bc6:	34 e0       	ldi	r19, 0x04	; 4
    5bc8:	e4 2f       	mov	r30, r20
    5bca:	ff 27       	eor	r31, r31
    5bcc:	e7 fd       	sbrc	r30, 7
    5bce:	f0 95       	com	r31
    5bd0:	f7 ff       	sbrs	r31, 7
    5bd2:	03 c0       	rjmp	.+6      	; 0x5bda <dtostrf+0x28>
    5bd4:	f1 95       	neg	r31
    5bd6:	e1 95       	neg	r30
    5bd8:	f1 09       	sbc	r31, r1
    5bda:	e3 2e       	mov	r14, r19
    5bdc:	02 2f       	mov	r16, r18
    5bde:	2e 2f       	mov	r18, r30
    5be0:	ae 01       	movw	r20, r28
    5be2:	0e 94 c7 2f 	call	0x5f8e	; 0x5f8e <dtoa_prf>
    5be6:	ce 01       	movw	r24, r28
    5be8:	df 91       	pop	r29
    5bea:	cf 91       	pop	r28
    5bec:	1f 91       	pop	r17
    5bee:	0f 91       	pop	r16
    5bf0:	ef 90       	pop	r14
    5bf2:	08 95       	ret

00005bf4 <malloc>:
    5bf4:	cf 93       	push	r28
    5bf6:	df 93       	push	r29
    5bf8:	82 30       	cpi	r24, 0x02	; 2
    5bfa:	91 05       	cpc	r25, r1
    5bfc:	10 f4       	brcc	.+4      	; 0x5c02 <malloc+0xe>
    5bfe:	82 e0       	ldi	r24, 0x02	; 2
    5c00:	90 e0       	ldi	r25, 0x00	; 0
    5c02:	e0 91 b6 02 	lds	r30, 0x02B6
    5c06:	f0 91 b7 02 	lds	r31, 0x02B7
    5c0a:	20 e0       	ldi	r18, 0x00	; 0
    5c0c:	30 e0       	ldi	r19, 0x00	; 0
    5c0e:	a0 e0       	ldi	r26, 0x00	; 0
    5c10:	b0 e0       	ldi	r27, 0x00	; 0
    5c12:	30 97       	sbiw	r30, 0x00	; 0
    5c14:	39 f1       	breq	.+78     	; 0x5c64 <malloc+0x70>
    5c16:	40 81       	ld	r20, Z
    5c18:	51 81       	ldd	r21, Z+1	; 0x01
    5c1a:	48 17       	cp	r20, r24
    5c1c:	59 07       	cpc	r21, r25
    5c1e:	b8 f0       	brcs	.+46     	; 0x5c4e <malloc+0x5a>
    5c20:	48 17       	cp	r20, r24
    5c22:	59 07       	cpc	r21, r25
    5c24:	71 f4       	brne	.+28     	; 0x5c42 <malloc+0x4e>
    5c26:	82 81       	ldd	r24, Z+2	; 0x02
    5c28:	93 81       	ldd	r25, Z+3	; 0x03
    5c2a:	10 97       	sbiw	r26, 0x00	; 0
    5c2c:	29 f0       	breq	.+10     	; 0x5c38 <malloc+0x44>
    5c2e:	13 96       	adiw	r26, 0x03	; 3
    5c30:	9c 93       	st	X, r25
    5c32:	8e 93       	st	-X, r24
    5c34:	12 97       	sbiw	r26, 0x02	; 2
    5c36:	2c c0       	rjmp	.+88     	; 0x5c90 <malloc+0x9c>
    5c38:	90 93 b7 02 	sts	0x02B7, r25
    5c3c:	80 93 b6 02 	sts	0x02B6, r24
    5c40:	27 c0       	rjmp	.+78     	; 0x5c90 <malloc+0x9c>
    5c42:	21 15       	cp	r18, r1
    5c44:	31 05       	cpc	r19, r1
    5c46:	31 f0       	breq	.+12     	; 0x5c54 <malloc+0x60>
    5c48:	42 17       	cp	r20, r18
    5c4a:	53 07       	cpc	r21, r19
    5c4c:	18 f0       	brcs	.+6      	; 0x5c54 <malloc+0x60>
    5c4e:	a9 01       	movw	r20, r18
    5c50:	db 01       	movw	r26, r22
    5c52:	01 c0       	rjmp	.+2      	; 0x5c56 <malloc+0x62>
    5c54:	ef 01       	movw	r28, r30
    5c56:	9a 01       	movw	r18, r20
    5c58:	bd 01       	movw	r22, r26
    5c5a:	df 01       	movw	r26, r30
    5c5c:	02 80       	ldd	r0, Z+2	; 0x02
    5c5e:	f3 81       	ldd	r31, Z+3	; 0x03
    5c60:	e0 2d       	mov	r30, r0
    5c62:	d7 cf       	rjmp	.-82     	; 0x5c12 <malloc+0x1e>
    5c64:	21 15       	cp	r18, r1
    5c66:	31 05       	cpc	r19, r1
    5c68:	f9 f0       	breq	.+62     	; 0x5ca8 <malloc+0xb4>
    5c6a:	28 1b       	sub	r18, r24
    5c6c:	39 0b       	sbc	r19, r25
    5c6e:	24 30       	cpi	r18, 0x04	; 4
    5c70:	31 05       	cpc	r19, r1
    5c72:	80 f4       	brcc	.+32     	; 0x5c94 <malloc+0xa0>
    5c74:	8a 81       	ldd	r24, Y+2	; 0x02
    5c76:	9b 81       	ldd	r25, Y+3	; 0x03
    5c78:	61 15       	cp	r22, r1
    5c7a:	71 05       	cpc	r23, r1
    5c7c:	21 f0       	breq	.+8      	; 0x5c86 <malloc+0x92>
    5c7e:	fb 01       	movw	r30, r22
    5c80:	93 83       	std	Z+3, r25	; 0x03
    5c82:	82 83       	std	Z+2, r24	; 0x02
    5c84:	04 c0       	rjmp	.+8      	; 0x5c8e <malloc+0x9a>
    5c86:	90 93 b7 02 	sts	0x02B7, r25
    5c8a:	80 93 b6 02 	sts	0x02B6, r24
    5c8e:	fe 01       	movw	r30, r28
    5c90:	32 96       	adiw	r30, 0x02	; 2
    5c92:	44 c0       	rjmp	.+136    	; 0x5d1c <malloc+0x128>
    5c94:	fe 01       	movw	r30, r28
    5c96:	e2 0f       	add	r30, r18
    5c98:	f3 1f       	adc	r31, r19
    5c9a:	81 93       	st	Z+, r24
    5c9c:	91 93       	st	Z+, r25
    5c9e:	22 50       	subi	r18, 0x02	; 2
    5ca0:	31 09       	sbc	r19, r1
    5ca2:	39 83       	std	Y+1, r19	; 0x01
    5ca4:	28 83       	st	Y, r18
    5ca6:	3a c0       	rjmp	.+116    	; 0x5d1c <malloc+0x128>
    5ca8:	20 91 b4 02 	lds	r18, 0x02B4
    5cac:	30 91 b5 02 	lds	r19, 0x02B5
    5cb0:	23 2b       	or	r18, r19
    5cb2:	41 f4       	brne	.+16     	; 0x5cc4 <malloc+0xd0>
    5cb4:	20 91 02 02 	lds	r18, 0x0202
    5cb8:	30 91 03 02 	lds	r19, 0x0203
    5cbc:	30 93 b5 02 	sts	0x02B5, r19
    5cc0:	20 93 b4 02 	sts	0x02B4, r18
    5cc4:	20 91 00 02 	lds	r18, 0x0200
    5cc8:	30 91 01 02 	lds	r19, 0x0201
    5ccc:	21 15       	cp	r18, r1
    5cce:	31 05       	cpc	r19, r1
    5cd0:	41 f4       	brne	.+16     	; 0x5ce2 <malloc+0xee>
    5cd2:	2d b7       	in	r18, 0x3d	; 61
    5cd4:	3e b7       	in	r19, 0x3e	; 62
    5cd6:	40 91 04 02 	lds	r20, 0x0204
    5cda:	50 91 05 02 	lds	r21, 0x0205
    5cde:	24 1b       	sub	r18, r20
    5ce0:	35 0b       	sbc	r19, r21
    5ce2:	e0 91 b4 02 	lds	r30, 0x02B4
    5ce6:	f0 91 b5 02 	lds	r31, 0x02B5
    5cea:	e2 17       	cp	r30, r18
    5cec:	f3 07       	cpc	r31, r19
    5cee:	a0 f4       	brcc	.+40     	; 0x5d18 <malloc+0x124>
    5cf0:	2e 1b       	sub	r18, r30
    5cf2:	3f 0b       	sbc	r19, r31
    5cf4:	28 17       	cp	r18, r24
    5cf6:	39 07       	cpc	r19, r25
    5cf8:	78 f0       	brcs	.+30     	; 0x5d18 <malloc+0x124>
    5cfa:	ac 01       	movw	r20, r24
    5cfc:	4e 5f       	subi	r20, 0xFE	; 254
    5cfe:	5f 4f       	sbci	r21, 0xFF	; 255
    5d00:	24 17       	cp	r18, r20
    5d02:	35 07       	cpc	r19, r21
    5d04:	48 f0       	brcs	.+18     	; 0x5d18 <malloc+0x124>
    5d06:	4e 0f       	add	r20, r30
    5d08:	5f 1f       	adc	r21, r31
    5d0a:	50 93 b5 02 	sts	0x02B5, r21
    5d0e:	40 93 b4 02 	sts	0x02B4, r20
    5d12:	81 93       	st	Z+, r24
    5d14:	91 93       	st	Z+, r25
    5d16:	02 c0       	rjmp	.+4      	; 0x5d1c <malloc+0x128>
    5d18:	e0 e0       	ldi	r30, 0x00	; 0
    5d1a:	f0 e0       	ldi	r31, 0x00	; 0
    5d1c:	cf 01       	movw	r24, r30
    5d1e:	df 91       	pop	r29
    5d20:	cf 91       	pop	r28
    5d22:	08 95       	ret

00005d24 <free>:
    5d24:	cf 93       	push	r28
    5d26:	df 93       	push	r29
    5d28:	00 97       	sbiw	r24, 0x00	; 0
    5d2a:	09 f4       	brne	.+2      	; 0x5d2e <free+0xa>
    5d2c:	87 c0       	rjmp	.+270    	; 0x5e3c <free+0x118>
    5d2e:	fc 01       	movw	r30, r24
    5d30:	32 97       	sbiw	r30, 0x02	; 2
    5d32:	13 82       	std	Z+3, r1	; 0x03
    5d34:	12 82       	std	Z+2, r1	; 0x02
    5d36:	c0 91 b6 02 	lds	r28, 0x02B6
    5d3a:	d0 91 b7 02 	lds	r29, 0x02B7
    5d3e:	20 97       	sbiw	r28, 0x00	; 0
    5d40:	81 f4       	brne	.+32     	; 0x5d62 <free+0x3e>
    5d42:	20 81       	ld	r18, Z
    5d44:	31 81       	ldd	r19, Z+1	; 0x01
    5d46:	28 0f       	add	r18, r24
    5d48:	39 1f       	adc	r19, r25
    5d4a:	80 91 b4 02 	lds	r24, 0x02B4
    5d4e:	90 91 b5 02 	lds	r25, 0x02B5
    5d52:	82 17       	cp	r24, r18
    5d54:	93 07       	cpc	r25, r19
    5d56:	79 f5       	brne	.+94     	; 0x5db6 <free+0x92>
    5d58:	f0 93 b5 02 	sts	0x02B5, r31
    5d5c:	e0 93 b4 02 	sts	0x02B4, r30
    5d60:	6d c0       	rjmp	.+218    	; 0x5e3c <free+0x118>
    5d62:	de 01       	movw	r26, r28
    5d64:	20 e0       	ldi	r18, 0x00	; 0
    5d66:	30 e0       	ldi	r19, 0x00	; 0
    5d68:	ae 17       	cp	r26, r30
    5d6a:	bf 07       	cpc	r27, r31
    5d6c:	50 f4       	brcc	.+20     	; 0x5d82 <free+0x5e>
    5d6e:	12 96       	adiw	r26, 0x02	; 2
    5d70:	4d 91       	ld	r20, X+
    5d72:	5c 91       	ld	r21, X
    5d74:	13 97       	sbiw	r26, 0x03	; 3
    5d76:	9d 01       	movw	r18, r26
    5d78:	41 15       	cp	r20, r1
    5d7a:	51 05       	cpc	r21, r1
    5d7c:	09 f1       	breq	.+66     	; 0x5dc0 <free+0x9c>
    5d7e:	da 01       	movw	r26, r20
    5d80:	f3 cf       	rjmp	.-26     	; 0x5d68 <free+0x44>
    5d82:	b3 83       	std	Z+3, r27	; 0x03
    5d84:	a2 83       	std	Z+2, r26	; 0x02
    5d86:	40 81       	ld	r20, Z
    5d88:	51 81       	ldd	r21, Z+1	; 0x01
    5d8a:	84 0f       	add	r24, r20
    5d8c:	95 1f       	adc	r25, r21
    5d8e:	8a 17       	cp	r24, r26
    5d90:	9b 07       	cpc	r25, r27
    5d92:	71 f4       	brne	.+28     	; 0x5db0 <free+0x8c>
    5d94:	8d 91       	ld	r24, X+
    5d96:	9c 91       	ld	r25, X
    5d98:	11 97       	sbiw	r26, 0x01	; 1
    5d9a:	84 0f       	add	r24, r20
    5d9c:	95 1f       	adc	r25, r21
    5d9e:	02 96       	adiw	r24, 0x02	; 2
    5da0:	91 83       	std	Z+1, r25	; 0x01
    5da2:	80 83       	st	Z, r24
    5da4:	12 96       	adiw	r26, 0x02	; 2
    5da6:	8d 91       	ld	r24, X+
    5da8:	9c 91       	ld	r25, X
    5daa:	13 97       	sbiw	r26, 0x03	; 3
    5dac:	93 83       	std	Z+3, r25	; 0x03
    5dae:	82 83       	std	Z+2, r24	; 0x02
    5db0:	21 15       	cp	r18, r1
    5db2:	31 05       	cpc	r19, r1
    5db4:	29 f4       	brne	.+10     	; 0x5dc0 <free+0x9c>
    5db6:	f0 93 b7 02 	sts	0x02B7, r31
    5dba:	e0 93 b6 02 	sts	0x02B6, r30
    5dbe:	3e c0       	rjmp	.+124    	; 0x5e3c <free+0x118>
    5dc0:	d9 01       	movw	r26, r18
    5dc2:	13 96       	adiw	r26, 0x03	; 3
    5dc4:	fc 93       	st	X, r31
    5dc6:	ee 93       	st	-X, r30
    5dc8:	12 97       	sbiw	r26, 0x02	; 2
    5dca:	4d 91       	ld	r20, X+
    5dcc:	5d 91       	ld	r21, X+
    5dce:	a4 0f       	add	r26, r20
    5dd0:	b5 1f       	adc	r27, r21
    5dd2:	ea 17       	cp	r30, r26
    5dd4:	fb 07       	cpc	r31, r27
    5dd6:	79 f4       	brne	.+30     	; 0x5df6 <free+0xd2>
    5dd8:	80 81       	ld	r24, Z
    5dda:	91 81       	ldd	r25, Z+1	; 0x01
    5ddc:	84 0f       	add	r24, r20
    5dde:	95 1f       	adc	r25, r21
    5de0:	02 96       	adiw	r24, 0x02	; 2
    5de2:	d9 01       	movw	r26, r18
    5de4:	11 96       	adiw	r26, 0x01	; 1
    5de6:	9c 93       	st	X, r25
    5de8:	8e 93       	st	-X, r24
    5dea:	82 81       	ldd	r24, Z+2	; 0x02
    5dec:	93 81       	ldd	r25, Z+3	; 0x03
    5dee:	13 96       	adiw	r26, 0x03	; 3
    5df0:	9c 93       	st	X, r25
    5df2:	8e 93       	st	-X, r24
    5df4:	12 97       	sbiw	r26, 0x02	; 2
    5df6:	e0 e0       	ldi	r30, 0x00	; 0
    5df8:	f0 e0       	ldi	r31, 0x00	; 0
    5dfa:	8a 81       	ldd	r24, Y+2	; 0x02
    5dfc:	9b 81       	ldd	r25, Y+3	; 0x03
    5dfe:	00 97       	sbiw	r24, 0x00	; 0
    5e00:	19 f0       	breq	.+6      	; 0x5e08 <free+0xe4>
    5e02:	fe 01       	movw	r30, r28
    5e04:	ec 01       	movw	r28, r24
    5e06:	f9 cf       	rjmp	.-14     	; 0x5dfa <free+0xd6>
    5e08:	ce 01       	movw	r24, r28
    5e0a:	02 96       	adiw	r24, 0x02	; 2
    5e0c:	28 81       	ld	r18, Y
    5e0e:	39 81       	ldd	r19, Y+1	; 0x01
    5e10:	82 0f       	add	r24, r18
    5e12:	93 1f       	adc	r25, r19
    5e14:	20 91 b4 02 	lds	r18, 0x02B4
    5e18:	30 91 b5 02 	lds	r19, 0x02B5
    5e1c:	28 17       	cp	r18, r24
    5e1e:	39 07       	cpc	r19, r25
    5e20:	69 f4       	brne	.+26     	; 0x5e3c <free+0x118>
    5e22:	30 97       	sbiw	r30, 0x00	; 0
    5e24:	29 f4       	brne	.+10     	; 0x5e30 <free+0x10c>
    5e26:	10 92 b7 02 	sts	0x02B7, r1
    5e2a:	10 92 b6 02 	sts	0x02B6, r1
    5e2e:	02 c0       	rjmp	.+4      	; 0x5e34 <free+0x110>
    5e30:	13 82       	std	Z+3, r1	; 0x03
    5e32:	12 82       	std	Z+2, r1	; 0x02
    5e34:	d0 93 b5 02 	sts	0x02B5, r29
    5e38:	c0 93 b4 02 	sts	0x02B4, r28
    5e3c:	df 91       	pop	r29
    5e3e:	cf 91       	pop	r28
    5e40:	08 95       	ret

00005e42 <atof>:
    5e42:	66 27       	eor	r22, r22
    5e44:	77 27       	eor	r23, r23
    5e46:	0c 94 45 31 	jmp	0x628a	; 0x628a <strtod>

00005e4a <atoi>:
    5e4a:	fc 01       	movw	r30, r24
    5e4c:	88 27       	eor	r24, r24
    5e4e:	99 27       	eor	r25, r25
    5e50:	e8 94       	clt
    5e52:	21 91       	ld	r18, Z+
    5e54:	20 32       	cpi	r18, 0x20	; 32
    5e56:	e9 f3       	breq	.-6      	; 0x5e52 <atoi+0x8>
    5e58:	29 30       	cpi	r18, 0x09	; 9
    5e5a:	10 f0       	brcs	.+4      	; 0x5e60 <atoi+0x16>
    5e5c:	2e 30       	cpi	r18, 0x0E	; 14
    5e5e:	c8 f3       	brcs	.-14     	; 0x5e52 <atoi+0x8>
    5e60:	2b 32       	cpi	r18, 0x2B	; 43
    5e62:	41 f0       	breq	.+16     	; 0x5e74 <atoi+0x2a>
    5e64:	2d 32       	cpi	r18, 0x2D	; 45
    5e66:	39 f4       	brne	.+14     	; 0x5e76 <atoi+0x2c>
    5e68:	68 94       	set
    5e6a:	04 c0       	rjmp	.+8      	; 0x5e74 <atoi+0x2a>
    5e6c:	0e 94 83 2f 	call	0x5f06	; 0x5f06 <__mulhi_const_10>
    5e70:	82 0f       	add	r24, r18
    5e72:	91 1d       	adc	r25, r1
    5e74:	21 91       	ld	r18, Z+
    5e76:	20 53       	subi	r18, 0x30	; 48
    5e78:	2a 30       	cpi	r18, 0x0A	; 10
    5e7a:	c0 f3       	brcs	.-16     	; 0x5e6c <atoi+0x22>
    5e7c:	1e f4       	brtc	.+6      	; 0x5e84 <atoi+0x3a>
    5e7e:	90 95       	com	r25
    5e80:	81 95       	neg	r24
    5e82:	9f 4f       	sbci	r25, 0xFF	; 255
    5e84:	08 95       	ret

00005e86 <memcpy>:
    5e86:	fb 01       	movw	r30, r22
    5e88:	dc 01       	movw	r26, r24
    5e8a:	02 c0       	rjmp	.+4      	; 0x5e90 <memcpy+0xa>
    5e8c:	01 90       	ld	r0, Z+
    5e8e:	0d 92       	st	X+, r0
    5e90:	41 50       	subi	r20, 0x01	; 1
    5e92:	50 40       	sbci	r21, 0x00	; 0
    5e94:	d8 f7       	brcc	.-10     	; 0x5e8c <memcpy+0x6>
    5e96:	08 95       	ret

00005e98 <memset>:
    5e98:	dc 01       	movw	r26, r24
    5e9a:	01 c0       	rjmp	.+2      	; 0x5e9e <memset+0x6>
    5e9c:	6d 93       	st	X+, r22
    5e9e:	41 50       	subi	r20, 0x01	; 1
    5ea0:	50 40       	sbci	r21, 0x00	; 0
    5ea2:	e0 f7       	brcc	.-8      	; 0x5e9c <memset+0x4>
    5ea4:	08 95       	ret

00005ea6 <itoa>:
    5ea6:	45 32       	cpi	r20, 0x25	; 37
    5ea8:	51 05       	cpc	r21, r1
    5eaa:	20 f4       	brcc	.+8      	; 0x5eb4 <itoa+0xe>
    5eac:	42 30       	cpi	r20, 0x02	; 2
    5eae:	10 f0       	brcs	.+4      	; 0x5eb4 <itoa+0xe>
    5eb0:	0c 94 5e 2f 	jmp	0x5ebc	; 0x5ebc <__itoa_ncheck>
    5eb4:	fb 01       	movw	r30, r22
    5eb6:	10 82       	st	Z, r1
    5eb8:	cb 01       	movw	r24, r22
    5eba:	08 95       	ret

00005ebc <__itoa_ncheck>:
    5ebc:	bb 27       	eor	r27, r27
    5ebe:	4a 30       	cpi	r20, 0x0A	; 10
    5ec0:	31 f4       	brne	.+12     	; 0x5ece <__itoa_ncheck+0x12>
    5ec2:	99 23       	and	r25, r25
    5ec4:	22 f4       	brpl	.+8      	; 0x5ece <__itoa_ncheck+0x12>
    5ec6:	bd e2       	ldi	r27, 0x2D	; 45
    5ec8:	90 95       	com	r25
    5eca:	81 95       	neg	r24
    5ecc:	9f 4f       	sbci	r25, 0xFF	; 255
    5ece:	0c 94 ae 2f 	jmp	0x5f5c	; 0x5f5c <__utoa_common>

00005ed2 <ltoa>:
    5ed2:	25 32       	cpi	r18, 0x25	; 37
    5ed4:	31 05       	cpc	r19, r1
    5ed6:	20 f4       	brcc	.+8      	; 0x5ee0 <ltoa+0xe>
    5ed8:	22 30       	cpi	r18, 0x02	; 2
    5eda:	10 f0       	brcs	.+4      	; 0x5ee0 <ltoa+0xe>
    5edc:	0c 94 74 2f 	jmp	0x5ee8	; 0x5ee8 <__ltoa_ncheck>
    5ee0:	fa 01       	movw	r30, r20
    5ee2:	10 82       	st	Z, r1
    5ee4:	ca 01       	movw	r24, r20
    5ee6:	08 95       	ret

00005ee8 <__ltoa_ncheck>:
    5ee8:	bb 27       	eor	r27, r27
    5eea:	2a 30       	cpi	r18, 0x0A	; 10
    5eec:	51 f4       	brne	.+20     	; 0x5f02 <__ltoa_ncheck+0x1a>
    5eee:	99 23       	and	r25, r25
    5ef0:	42 f4       	brpl	.+16     	; 0x5f02 <__ltoa_ncheck+0x1a>
    5ef2:	bd e2       	ldi	r27, 0x2D	; 45
    5ef4:	90 95       	com	r25
    5ef6:	80 95       	com	r24
    5ef8:	70 95       	com	r23
    5efa:	61 95       	neg	r22
    5efc:	7f 4f       	sbci	r23, 0xFF	; 255
    5efe:	8f 4f       	sbci	r24, 0xFF	; 255
    5f00:	9f 4f       	sbci	r25, 0xFF	; 255
    5f02:	0c 94 8c 2f 	jmp	0x5f18	; 0x5f18 <__ultoa_common>

00005f06 <__mulhi_const_10>:
    5f06:	7a e0       	ldi	r23, 0x0A	; 10
    5f08:	97 9f       	mul	r25, r23
    5f0a:	90 2d       	mov	r25, r0
    5f0c:	87 9f       	mul	r24, r23
    5f0e:	80 2d       	mov	r24, r0
    5f10:	91 0d       	add	r25, r1
    5f12:	11 24       	eor	r1, r1
    5f14:	08 95       	ret

00005f16 <__ultoa_ncheck>:
    5f16:	bb 27       	eor	r27, r27

00005f18 <__ultoa_common>:
    5f18:	fa 01       	movw	r30, r20
    5f1a:	a6 2f       	mov	r26, r22
    5f1c:	62 17       	cp	r22, r18
    5f1e:	71 05       	cpc	r23, r1
    5f20:	81 05       	cpc	r24, r1
    5f22:	91 05       	cpc	r25, r1
    5f24:	33 0b       	sbc	r19, r19
    5f26:	30 fb       	bst	r19, 0
    5f28:	66 f0       	brts	.+24     	; 0x5f42 <__ultoa_common+0x2a>
    5f2a:	aa 27       	eor	r26, r26
    5f2c:	66 0f       	add	r22, r22
    5f2e:	77 1f       	adc	r23, r23
    5f30:	88 1f       	adc	r24, r24
    5f32:	99 1f       	adc	r25, r25
    5f34:	aa 1f       	adc	r26, r26
    5f36:	a2 17       	cp	r26, r18
    5f38:	10 f0       	brcs	.+4      	; 0x5f3e <__ultoa_common+0x26>
    5f3a:	a2 1b       	sub	r26, r18
    5f3c:	63 95       	inc	r22
    5f3e:	38 50       	subi	r19, 0x08	; 8
    5f40:	a9 f7       	brne	.-22     	; 0x5f2c <__ultoa_common+0x14>
    5f42:	a0 5d       	subi	r26, 0xD0	; 208
    5f44:	aa 33       	cpi	r26, 0x3A	; 58
    5f46:	08 f0       	brcs	.+2      	; 0x5f4a <__ultoa_common+0x32>
    5f48:	a9 5d       	subi	r26, 0xD9	; 217
    5f4a:	a1 93       	st	Z+, r26
    5f4c:	36 f7       	brtc	.-52     	; 0x5f1a <__ultoa_common+0x2>
    5f4e:	b1 11       	cpse	r27, r1
    5f50:	b1 93       	st	Z+, r27
    5f52:	10 82       	st	Z, r1
    5f54:	ca 01       	movw	r24, r20
    5f56:	0c 94 ae 33 	jmp	0x675c	; 0x675c <strrev>

00005f5a <__utoa_ncheck>:
    5f5a:	bb 27       	eor	r27, r27

00005f5c <__utoa_common>:
    5f5c:	fb 01       	movw	r30, r22
    5f5e:	55 27       	eor	r21, r21
    5f60:	aa 27       	eor	r26, r26
    5f62:	88 0f       	add	r24, r24
    5f64:	99 1f       	adc	r25, r25
    5f66:	aa 1f       	adc	r26, r26
    5f68:	a4 17       	cp	r26, r20
    5f6a:	10 f0       	brcs	.+4      	; 0x5f70 <__utoa_common+0x14>
    5f6c:	a4 1b       	sub	r26, r20
    5f6e:	83 95       	inc	r24
    5f70:	50 51       	subi	r21, 0x10	; 16
    5f72:	b9 f7       	brne	.-18     	; 0x5f62 <__utoa_common+0x6>
    5f74:	a0 5d       	subi	r26, 0xD0	; 208
    5f76:	aa 33       	cpi	r26, 0x3A	; 58
    5f78:	08 f0       	brcs	.+2      	; 0x5f7c <__utoa_common+0x20>
    5f7a:	a9 5d       	subi	r26, 0xD9	; 217
    5f7c:	a1 93       	st	Z+, r26
    5f7e:	00 97       	sbiw	r24, 0x00	; 0
    5f80:	79 f7       	brne	.-34     	; 0x5f60 <__utoa_common+0x4>
    5f82:	b1 11       	cpse	r27, r1
    5f84:	b1 93       	st	Z+, r27
    5f86:	11 92       	st	Z+, r1
    5f88:	cb 01       	movw	r24, r22
    5f8a:	0c 94 ae 33 	jmp	0x675c	; 0x675c <strrev>

00005f8e <dtoa_prf>:
    5f8e:	6f 92       	push	r6
    5f90:	7f 92       	push	r7
    5f92:	9f 92       	push	r9
    5f94:	af 92       	push	r10
    5f96:	bf 92       	push	r11
    5f98:	cf 92       	push	r12
    5f9a:	df 92       	push	r13
    5f9c:	ef 92       	push	r14
    5f9e:	ff 92       	push	r15
    5fa0:	0f 93       	push	r16
    5fa2:	1f 93       	push	r17
    5fa4:	cf 93       	push	r28
    5fa6:	df 93       	push	r29
    5fa8:	cd b7       	in	r28, 0x3d	; 61
    5faa:	de b7       	in	r29, 0x3e	; 62
    5fac:	29 97       	sbiw	r28, 0x09	; 9
    5fae:	0f b6       	in	r0, 0x3f	; 63
    5fb0:	f8 94       	cli
    5fb2:	de bf       	out	0x3e, r29	; 62
    5fb4:	0f be       	out	0x3f, r0	; 63
    5fb6:	cd bf       	out	0x3d, r28	; 61
    5fb8:	6a 01       	movw	r12, r20
    5fba:	b2 2e       	mov	r11, r18
    5fbc:	10 2f       	mov	r17, r16
    5fbe:	0c 33       	cpi	r16, 0x3C	; 60
    5fc0:	20 f4       	brcc	.+8      	; 0x5fca <dtoa_prf+0x3c>
    5fc2:	ff 24       	eor	r15, r15
    5fc4:	f3 94       	inc	r15
    5fc6:	f0 0e       	add	r15, r16
    5fc8:	02 c0       	rjmp	.+4      	; 0x5fce <dtoa_prf+0x40>
    5fca:	4c e3       	ldi	r20, 0x3C	; 60
    5fcc:	f4 2e       	mov	r15, r20
    5fce:	0f 2d       	mov	r16, r15
    5fd0:	27 e0       	ldi	r18, 0x07	; 7
    5fd2:	ae 01       	movw	r20, r28
    5fd4:	4f 5f       	subi	r20, 0xFF	; 255
    5fd6:	5f 4f       	sbci	r21, 0xFF	; 255
    5fd8:	0e 94 b6 32 	call	0x656c	; 0x656c <__ftoa_engine>
    5fdc:	79 81       	ldd	r23, Y+1	; 0x01
    5fde:	27 2f       	mov	r18, r23
    5fe0:	29 70       	andi	r18, 0x09	; 9
    5fe2:	21 30       	cpi	r18, 0x01	; 1
    5fe4:	31 f0       	breq	.+12     	; 0x5ff2 <dtoa_prf+0x64>
    5fe6:	e1 fc       	sbrc	r14, 1
    5fe8:	06 c0       	rjmp	.+12     	; 0x5ff6 <dtoa_prf+0x68>
    5fea:	e0 fc       	sbrc	r14, 0
    5fec:	06 c0       	rjmp	.+12     	; 0x5ffa <dtoa_prf+0x6c>
    5fee:	60 e0       	ldi	r22, 0x00	; 0
    5ff0:	05 c0       	rjmp	.+10     	; 0x5ffc <dtoa_prf+0x6e>
    5ff2:	6d e2       	ldi	r22, 0x2D	; 45
    5ff4:	03 c0       	rjmp	.+6      	; 0x5ffc <dtoa_prf+0x6e>
    5ff6:	6b e2       	ldi	r22, 0x2B	; 43
    5ff8:	01 c0       	rjmp	.+2      	; 0x5ffc <dtoa_prf+0x6e>
    5ffa:	60 e2       	ldi	r22, 0x20	; 32
    5ffc:	ae 2d       	mov	r26, r14
    5ffe:	a0 71       	andi	r26, 0x10	; 16
    6000:	73 ff       	sbrs	r23, 3
    6002:	36 c0       	rjmp	.+108    	; 0x6070 <dtoa_prf+0xe2>
    6004:	66 23       	and	r22, r22
    6006:	11 f0       	breq	.+4      	; 0x600c <dtoa_prf+0x7e>
    6008:	84 e0       	ldi	r24, 0x04	; 4
    600a:	01 c0       	rjmp	.+2      	; 0x600e <dtoa_prf+0x80>
    600c:	83 e0       	ldi	r24, 0x03	; 3
    600e:	8b 15       	cp	r24, r11
    6010:	10 f4       	brcc	.+4      	; 0x6016 <dtoa_prf+0x88>
    6012:	b8 1a       	sub	r11, r24
    6014:	01 c0       	rjmp	.+2      	; 0x6018 <dtoa_prf+0x8a>
    6016:	b1 2c       	mov	r11, r1
    6018:	a1 11       	cpse	r26, r1
    601a:	0b c0       	rjmp	.+22     	; 0x6032 <dtoa_prf+0xa4>
    601c:	f6 01       	movw	r30, r12
    601e:	8b 2d       	mov	r24, r11
    6020:	90 e2       	ldi	r25, 0x20	; 32
    6022:	88 23       	and	r24, r24
    6024:	19 f0       	breq	.+6      	; 0x602c <dtoa_prf+0x9e>
    6026:	91 93       	st	Z+, r25
    6028:	81 50       	subi	r24, 0x01	; 1
    602a:	fb cf       	rjmp	.-10     	; 0x6022 <dtoa_prf+0x94>
    602c:	cb 0c       	add	r12, r11
    602e:	d1 1c       	adc	r13, r1
    6030:	b1 2c       	mov	r11, r1
    6032:	66 23       	and	r22, r22
    6034:	31 f0       	breq	.+12     	; 0x6042 <dtoa_prf+0xb4>
    6036:	f6 01       	movw	r30, r12
    6038:	60 83       	st	Z, r22
    603a:	96 01       	movw	r18, r12
    603c:	2f 5f       	subi	r18, 0xFF	; 255
    603e:	3f 4f       	sbci	r19, 0xFF	; 255
    6040:	69 01       	movw	r12, r18
    6042:	c6 01       	movw	r24, r12
    6044:	03 96       	adiw	r24, 0x03	; 3
    6046:	e2 fe       	sbrs	r14, 2
    6048:	05 c0       	rjmp	.+10     	; 0x6054 <dtoa_prf+0xc6>
    604a:	2e e4       	ldi	r18, 0x4E	; 78
    604c:	f6 01       	movw	r30, r12
    604e:	20 83       	st	Z, r18
    6050:	31 e4       	ldi	r19, 0x41	; 65
    6052:	04 c0       	rjmp	.+8      	; 0x605c <dtoa_prf+0xce>
    6054:	2e e6       	ldi	r18, 0x6E	; 110
    6056:	f6 01       	movw	r30, r12
    6058:	20 83       	st	Z, r18
    605a:	31 e6       	ldi	r19, 0x61	; 97
    605c:	31 83       	std	Z+1, r19	; 0x01
    605e:	22 83       	std	Z+2, r18	; 0x02
    6060:	fc 01       	movw	r30, r24
    6062:	2b 2d       	mov	r18, r11
    6064:	30 e2       	ldi	r19, 0x20	; 32
    6066:	22 23       	and	r18, r18
    6068:	f1 f1       	breq	.+124    	; 0x60e6 <dtoa_prf+0x158>
    606a:	31 93       	st	Z+, r19
    606c:	21 50       	subi	r18, 0x01	; 1
    606e:	fb cf       	rjmp	.-10     	; 0x6066 <dtoa_prf+0xd8>
    6070:	72 ff       	sbrs	r23, 2
    6072:	40 c0       	rjmp	.+128    	; 0x60f4 <dtoa_prf+0x166>
    6074:	66 23       	and	r22, r22
    6076:	11 f0       	breq	.+4      	; 0x607c <dtoa_prf+0xee>
    6078:	84 e0       	ldi	r24, 0x04	; 4
    607a:	01 c0       	rjmp	.+2      	; 0x607e <dtoa_prf+0xf0>
    607c:	83 e0       	ldi	r24, 0x03	; 3
    607e:	8b 15       	cp	r24, r11
    6080:	10 f4       	brcc	.+4      	; 0x6086 <dtoa_prf+0xf8>
    6082:	b8 1a       	sub	r11, r24
    6084:	01 c0       	rjmp	.+2      	; 0x6088 <dtoa_prf+0xfa>
    6086:	b1 2c       	mov	r11, r1
    6088:	a1 11       	cpse	r26, r1
    608a:	0b c0       	rjmp	.+22     	; 0x60a2 <dtoa_prf+0x114>
    608c:	f6 01       	movw	r30, r12
    608e:	8b 2d       	mov	r24, r11
    6090:	90 e2       	ldi	r25, 0x20	; 32
    6092:	88 23       	and	r24, r24
    6094:	19 f0       	breq	.+6      	; 0x609c <dtoa_prf+0x10e>
    6096:	91 93       	st	Z+, r25
    6098:	81 50       	subi	r24, 0x01	; 1
    609a:	fb cf       	rjmp	.-10     	; 0x6092 <dtoa_prf+0x104>
    609c:	cb 0c       	add	r12, r11
    609e:	d1 1c       	adc	r13, r1
    60a0:	b1 2c       	mov	r11, r1
    60a2:	66 23       	and	r22, r22
    60a4:	31 f0       	breq	.+12     	; 0x60b2 <dtoa_prf+0x124>
    60a6:	f6 01       	movw	r30, r12
    60a8:	60 83       	st	Z, r22
    60aa:	96 01       	movw	r18, r12
    60ac:	2f 5f       	subi	r18, 0xFF	; 255
    60ae:	3f 4f       	sbci	r19, 0xFF	; 255
    60b0:	69 01       	movw	r12, r18
    60b2:	c6 01       	movw	r24, r12
    60b4:	03 96       	adiw	r24, 0x03	; 3
    60b6:	e2 fe       	sbrs	r14, 2
    60b8:	07 c0       	rjmp	.+14     	; 0x60c8 <dtoa_prf+0x13a>
    60ba:	29 e4       	ldi	r18, 0x49	; 73
    60bc:	f6 01       	movw	r30, r12
    60be:	20 83       	st	Z, r18
    60c0:	2e e4       	ldi	r18, 0x4E	; 78
    60c2:	21 83       	std	Z+1, r18	; 0x01
    60c4:	26 e4       	ldi	r18, 0x46	; 70
    60c6:	06 c0       	rjmp	.+12     	; 0x60d4 <dtoa_prf+0x146>
    60c8:	29 e6       	ldi	r18, 0x69	; 105
    60ca:	f6 01       	movw	r30, r12
    60cc:	20 83       	st	Z, r18
    60ce:	2e e6       	ldi	r18, 0x6E	; 110
    60d0:	21 83       	std	Z+1, r18	; 0x01
    60d2:	26 e6       	ldi	r18, 0x66	; 102
    60d4:	22 83       	std	Z+2, r18	; 0x02
    60d6:	fc 01       	movw	r30, r24
    60d8:	2b 2d       	mov	r18, r11
    60da:	30 e2       	ldi	r19, 0x20	; 32
    60dc:	22 23       	and	r18, r18
    60de:	19 f0       	breq	.+6      	; 0x60e6 <dtoa_prf+0x158>
    60e0:	31 93       	st	Z+, r19
    60e2:	21 50       	subi	r18, 0x01	; 1
    60e4:	fb cf       	rjmp	.-10     	; 0x60dc <dtoa_prf+0x14e>
    60e6:	fc 01       	movw	r30, r24
    60e8:	eb 0d       	add	r30, r11
    60ea:	f1 1d       	adc	r31, r1
    60ec:	10 82       	st	Z, r1
    60ee:	8e ef       	ldi	r24, 0xFE	; 254
    60f0:	9f ef       	ldi	r25, 0xFF	; 255
    60f2:	b7 c0       	rjmp	.+366    	; 0x6262 <dtoa_prf+0x2d4>
    60f4:	b1 e0       	ldi	r27, 0x01	; 1
    60f6:	61 11       	cpse	r22, r1
    60f8:	01 c0       	rjmp	.+2      	; 0x60fc <dtoa_prf+0x16e>
    60fa:	b0 e0       	ldi	r27, 0x00	; 0
    60fc:	4b 2f       	mov	r20, r27
    60fe:	50 e0       	ldi	r21, 0x00	; 0
    6100:	18 16       	cp	r1, r24
    6102:	19 06       	cpc	r1, r25
    6104:	24 f4       	brge	.+8      	; 0x610e <dtoa_prf+0x180>
    6106:	9c 01       	movw	r18, r24
    6108:	2f 5f       	subi	r18, 0xFF	; 255
    610a:	3f 4f       	sbci	r19, 0xFF	; 255
    610c:	02 c0       	rjmp	.+4      	; 0x6112 <dtoa_prf+0x184>
    610e:	21 e0       	ldi	r18, 0x01	; 1
    6110:	30 e0       	ldi	r19, 0x00	; 0
    6112:	24 0f       	add	r18, r20
    6114:	35 1f       	adc	r19, r21
    6116:	11 23       	and	r17, r17
    6118:	29 f0       	breq	.+10     	; 0x6124 <dtoa_prf+0x196>
    611a:	41 2f       	mov	r20, r17
    611c:	50 e0       	ldi	r21, 0x00	; 0
    611e:	4f 5f       	subi	r20, 0xFF	; 255
    6120:	5f 4f       	sbci	r21, 0xFF	; 255
    6122:	02 c0       	rjmp	.+4      	; 0x6128 <dtoa_prf+0x19a>
    6124:	40 e0       	ldi	r20, 0x00	; 0
    6126:	50 e0       	ldi	r21, 0x00	; 0
    6128:	42 0f       	add	r20, r18
    612a:	53 1f       	adc	r21, r19
    612c:	2b 2d       	mov	r18, r11
    612e:	30 e0       	ldi	r19, 0x00	; 0
    6130:	42 17       	cp	r20, r18
    6132:	53 07       	cpc	r21, r19
    6134:	14 f4       	brge	.+4      	; 0x613a <dtoa_prf+0x1ac>
    6136:	b4 1a       	sub	r11, r20
    6138:	01 c0       	rjmp	.+2      	; 0x613c <dtoa_prf+0x1ae>
    613a:	b1 2c       	mov	r11, r1
    613c:	2e 2d       	mov	r18, r14
    613e:	28 71       	andi	r18, 0x18	; 24
    6140:	59 f4       	brne	.+22     	; 0x6158 <dtoa_prf+0x1ca>
    6142:	f6 01       	movw	r30, r12
    6144:	2b 2d       	mov	r18, r11
    6146:	30 e2       	ldi	r19, 0x20	; 32
    6148:	22 23       	and	r18, r18
    614a:	19 f0       	breq	.+6      	; 0x6152 <dtoa_prf+0x1c4>
    614c:	31 93       	st	Z+, r19
    614e:	21 50       	subi	r18, 0x01	; 1
    6150:	fb cf       	rjmp	.-10     	; 0x6148 <dtoa_prf+0x1ba>
    6152:	cb 0c       	add	r12, r11
    6154:	d1 1c       	adc	r13, r1
    6156:	b1 2c       	mov	r11, r1
    6158:	bb 23       	and	r27, r27
    615a:	31 f0       	breq	.+12     	; 0x6168 <dtoa_prf+0x1da>
    615c:	f6 01       	movw	r30, r12
    615e:	60 83       	st	Z, r22
    6160:	96 01       	movw	r18, r12
    6162:	2f 5f       	subi	r18, 0xFF	; 255
    6164:	3f 4f       	sbci	r19, 0xFF	; 255
    6166:	69 01       	movw	r12, r18
    6168:	a1 11       	cpse	r26, r1
    616a:	0b c0       	rjmp	.+22     	; 0x6182 <dtoa_prf+0x1f4>
    616c:	f6 01       	movw	r30, r12
    616e:	2b 2d       	mov	r18, r11
    6170:	30 e3       	ldi	r19, 0x30	; 48
    6172:	22 23       	and	r18, r18
    6174:	19 f0       	breq	.+6      	; 0x617c <dtoa_prf+0x1ee>
    6176:	31 93       	st	Z+, r19
    6178:	21 50       	subi	r18, 0x01	; 1
    617a:	fb cf       	rjmp	.-10     	; 0x6172 <dtoa_prf+0x1e4>
    617c:	cb 0c       	add	r12, r11
    617e:	d1 1c       	adc	r13, r1
    6180:	b1 2c       	mov	r11, r1
    6182:	f8 0e       	add	r15, r24
    6184:	0a 81       	ldd	r16, Y+2	; 0x02
    6186:	37 2f       	mov	r19, r23
    6188:	30 71       	andi	r19, 0x10	; 16
    618a:	a3 2e       	mov	r10, r19
    618c:	74 ff       	sbrs	r23, 4
    618e:	03 c0       	rjmp	.+6      	; 0x6196 <dtoa_prf+0x208>
    6190:	01 33       	cpi	r16, 0x31	; 49
    6192:	09 f4       	brne	.+2      	; 0x6196 <dtoa_prf+0x208>
    6194:	fa 94       	dec	r15
    6196:	1f 14       	cp	r1, r15
    6198:	2c f4       	brge	.+10     	; 0x61a4 <dtoa_prf+0x216>
    619a:	2f 2d       	mov	r18, r15
    619c:	29 30       	cpi	r18, 0x09	; 9
    619e:	18 f0       	brcs	.+6      	; 0x61a6 <dtoa_prf+0x218>
    61a0:	28 e0       	ldi	r18, 0x08	; 8
    61a2:	01 c0       	rjmp	.+2      	; 0x61a6 <dtoa_prf+0x218>
    61a4:	21 e0       	ldi	r18, 0x01	; 1
    61a6:	68 2f       	mov	r22, r24
    61a8:	39 2f       	mov	r19, r25
    61aa:	97 ff       	sbrs	r25, 7
    61ac:	02 c0       	rjmp	.+4      	; 0x61b2 <dtoa_prf+0x224>
    61ae:	60 e0       	ldi	r22, 0x00	; 0
    61b0:	30 e0       	ldi	r19, 0x00	; 0
    61b2:	46 2f       	mov	r20, r22
    61b4:	53 2f       	mov	r21, r19
    61b6:	61 2c       	mov	r6, r1
    61b8:	71 2c       	mov	r7, r1
    61ba:	3e e2       	ldi	r19, 0x2E	; 46
    61bc:	93 2e       	mov	r9, r19
    61be:	bc 01       	movw	r22, r24
    61c0:	62 1b       	sub	r22, r18
    61c2:	71 09       	sbc	r23, r1
    61c4:	9b 01       	movw	r18, r22
    61c6:	dc 01       	movw	r26, r24
    61c8:	a4 1b       	sub	r26, r20
    61ca:	b5 0b       	sbc	r27, r21
    61cc:	e1 e0       	ldi	r30, 0x01	; 1
    61ce:	f0 e0       	ldi	r31, 0x00	; 0
    61d0:	ec 0f       	add	r30, r28
    61d2:	fd 1f       	adc	r31, r29
    61d4:	ae 0f       	add	r26, r30
    61d6:	bf 1f       	adc	r27, r31
    61d8:	e1 2e       	mov	r14, r17
    61da:	f1 2c       	mov	r15, r1
    61dc:	f1 94       	neg	r15
    61de:	e1 94       	neg	r14
    61e0:	f1 08       	sbc	r15, r1
    61e2:	4f 3f       	cpi	r20, 0xFF	; 255
    61e4:	ff ef       	ldi	r31, 0xFF	; 255
    61e6:	5f 07       	cpc	r21, r31
    61e8:	31 f4       	brne	.+12     	; 0x61f6 <dtoa_prf+0x268>
    61ea:	f6 01       	movw	r30, r12
    61ec:	90 82       	st	Z, r9
    61ee:	b6 01       	movw	r22, r12
    61f0:	6f 5f       	subi	r22, 0xFF	; 255
    61f2:	7f 4f       	sbci	r23, 0xFF	; 255
    61f4:	6b 01       	movw	r12, r22
    61f6:	84 17       	cp	r24, r20
    61f8:	95 07       	cpc	r25, r21
    61fa:	4c f0       	brlt	.+18     	; 0x620e <dtoa_prf+0x280>
    61fc:	24 17       	cp	r18, r20
    61fe:	35 07       	cpc	r19, r21
    6200:	34 f4       	brge	.+12     	; 0x620e <dtoa_prf+0x280>
    6202:	bd 01       	movw	r22, r26
    6204:	66 0d       	add	r22, r6
    6206:	77 1d       	adc	r23, r7
    6208:	fb 01       	movw	r30, r22
    620a:	11 81       	ldd	r17, Z+1	; 0x01
    620c:	01 c0       	rjmp	.+2      	; 0x6210 <dtoa_prf+0x282>
    620e:	10 e3       	ldi	r17, 0x30	; 48
    6210:	41 50       	subi	r20, 0x01	; 1
    6212:	51 09       	sbc	r21, r1
    6214:	ff ef       	ldi	r31, 0xFF	; 255
    6216:	6f 1a       	sub	r6, r31
    6218:	7f 0a       	sbc	r7, r31
    621a:	b6 01       	movw	r22, r12
    621c:	6f 5f       	subi	r22, 0xFF	; 255
    621e:	7f 4f       	sbci	r23, 0xFF	; 255
    6220:	4e 15       	cp	r20, r14
    6222:	5f 05       	cpc	r21, r15
    6224:	24 f0       	brlt	.+8      	; 0x622e <dtoa_prf+0x2a0>
    6226:	f6 01       	movw	r30, r12
    6228:	10 83       	st	Z, r17
    622a:	6b 01       	movw	r12, r22
    622c:	da cf       	rjmp	.-76     	; 0x61e2 <dtoa_prf+0x254>
    622e:	48 17       	cp	r20, r24
    6230:	59 07       	cpc	r21, r25
    6232:	39 f4       	brne	.+14     	; 0x6242 <dtoa_prf+0x2b4>
    6234:	06 33       	cpi	r16, 0x36	; 54
    6236:	20 f4       	brcc	.+8      	; 0x6240 <dtoa_prf+0x2b2>
    6238:	05 33       	cpi	r16, 0x35	; 53
    623a:	19 f4       	brne	.+6      	; 0x6242 <dtoa_prf+0x2b4>
    623c:	a1 10       	cpse	r10, r1
    623e:	01 c0       	rjmp	.+2      	; 0x6242 <dtoa_prf+0x2b4>
    6240:	11 e3       	ldi	r17, 0x31	; 49
    6242:	f6 01       	movw	r30, r12
    6244:	10 83       	st	Z, r17
    6246:	fb 01       	movw	r30, r22
    6248:	8b 2d       	mov	r24, r11
    624a:	90 e2       	ldi	r25, 0x20	; 32
    624c:	88 23       	and	r24, r24
    624e:	19 f0       	breq	.+6      	; 0x6256 <dtoa_prf+0x2c8>
    6250:	91 93       	st	Z+, r25
    6252:	81 50       	subi	r24, 0x01	; 1
    6254:	fb cf       	rjmp	.-10     	; 0x624c <dtoa_prf+0x2be>
    6256:	fb 01       	movw	r30, r22
    6258:	eb 0d       	add	r30, r11
    625a:	f1 1d       	adc	r31, r1
    625c:	10 82       	st	Z, r1
    625e:	80 e0       	ldi	r24, 0x00	; 0
    6260:	90 e0       	ldi	r25, 0x00	; 0
    6262:	29 96       	adiw	r28, 0x09	; 9
    6264:	0f b6       	in	r0, 0x3f	; 63
    6266:	f8 94       	cli
    6268:	de bf       	out	0x3e, r29	; 62
    626a:	0f be       	out	0x3f, r0	; 63
    626c:	cd bf       	out	0x3d, r28	; 61
    626e:	df 91       	pop	r29
    6270:	cf 91       	pop	r28
    6272:	1f 91       	pop	r17
    6274:	0f 91       	pop	r16
    6276:	ff 90       	pop	r15
    6278:	ef 90       	pop	r14
    627a:	df 90       	pop	r13
    627c:	cf 90       	pop	r12
    627e:	bf 90       	pop	r11
    6280:	af 90       	pop	r10
    6282:	9f 90       	pop	r9
    6284:	7f 90       	pop	r7
    6286:	6f 90       	pop	r6
    6288:	08 95       	ret

0000628a <strtod>:
    628a:	8f 92       	push	r8
    628c:	9f 92       	push	r9
    628e:	af 92       	push	r10
    6290:	bf 92       	push	r11
    6292:	cf 92       	push	r12
    6294:	df 92       	push	r13
    6296:	ef 92       	push	r14
    6298:	ff 92       	push	r15
    629a:	0f 93       	push	r16
    629c:	1f 93       	push	r17
    629e:	cf 93       	push	r28
    62a0:	df 93       	push	r29
    62a2:	8b 01       	movw	r16, r22
    62a4:	61 15       	cp	r22, r1
    62a6:	71 05       	cpc	r23, r1
    62a8:	21 f0       	breq	.+8      	; 0x62b2 <strtod+0x28>
    62aa:	db 01       	movw	r26, r22
    62ac:	8c 93       	st	X, r24
    62ae:	11 96       	adiw	r26, 0x01	; 1
    62b0:	9c 93       	st	X, r25
    62b2:	ec 01       	movw	r28, r24
    62b4:	5e 01       	movw	r10, r28
    62b6:	bf ef       	ldi	r27, 0xFF	; 255
    62b8:	ab 1a       	sub	r10, r27
    62ba:	bb 0a       	sbc	r11, r27
    62bc:	75 01       	movw	r14, r10
    62be:	c8 80       	ld	r12, Y
    62c0:	8c 2d       	mov	r24, r12
    62c2:	90 e0       	ldi	r25, 0x00	; 0
    62c4:	0e 94 8e 33 	call	0x671c	; 0x671c <isspace>
    62c8:	89 2b       	or	r24, r25
    62ca:	11 f0       	breq	.+4      	; 0x62d0 <strtod+0x46>
    62cc:	e5 01       	movw	r28, r10
    62ce:	f2 cf       	rjmp	.-28     	; 0x62b4 <strtod+0x2a>
    62d0:	ed e2       	ldi	r30, 0x2D	; 45
    62d2:	ce 12       	cpse	r12, r30
    62d4:	08 c0       	rjmp	.+16     	; 0x62e6 <strtod+0x5c>
    62d6:	7e 01       	movw	r14, r28
    62d8:	f2 e0       	ldi	r31, 0x02	; 2
    62da:	ef 0e       	add	r14, r31
    62dc:	f1 1c       	adc	r15, r1
    62de:	c9 80       	ldd	r12, Y+1	; 0x01
    62e0:	dd 24       	eor	r13, r13
    62e2:	d3 94       	inc	r13
    62e4:	09 c0       	rjmp	.+18     	; 0x62f8 <strtod+0x6e>
    62e6:	2b e2       	ldi	r18, 0x2B	; 43
    62e8:	c2 12       	cpse	r12, r18
    62ea:	05 c0       	rjmp	.+10     	; 0x62f6 <strtod+0x6c>
    62ec:	7e 01       	movw	r14, r28
    62ee:	42 e0       	ldi	r20, 0x02	; 2
    62f0:	e4 0e       	add	r14, r20
    62f2:	f1 1c       	adc	r15, r1
    62f4:	c9 80       	ldd	r12, Y+1	; 0x01
    62f6:	d1 2c       	mov	r13, r1
    62f8:	e7 01       	movw	r28, r14
    62fa:	21 97       	sbiw	r28, 0x01	; 1
    62fc:	43 e0       	ldi	r20, 0x03	; 3
    62fe:	50 e0       	ldi	r21, 0x00	; 0
    6300:	64 ef       	ldi	r22, 0xF4	; 244
    6302:	70 e0       	ldi	r23, 0x00	; 0
    6304:	ce 01       	movw	r24, r28
    6306:	0e 94 96 33 	call	0x672c	; 0x672c <strncasecmp_P>
    630a:	89 2b       	or	r24, r25
    630c:	c1 f4       	brne	.+48     	; 0x633e <strtod+0xb4>
    630e:	23 96       	adiw	r28, 0x03	; 3
    6310:	45 e0       	ldi	r20, 0x05	; 5
    6312:	50 e0       	ldi	r21, 0x00	; 0
    6314:	6f ee       	ldi	r22, 0xEF	; 239
    6316:	70 e0       	ldi	r23, 0x00	; 0
    6318:	ce 01       	movw	r24, r28
    631a:	0e 94 96 33 	call	0x672c	; 0x672c <strncasecmp_P>
    631e:	89 2b       	or	r24, r25
    6320:	09 f4       	brne	.+2      	; 0x6324 <strtod+0x9a>
    6322:	25 96       	adiw	r28, 0x05	; 5
    6324:	01 15       	cp	r16, r1
    6326:	11 05       	cpc	r17, r1
    6328:	19 f0       	breq	.+6      	; 0x6330 <strtod+0xa6>
    632a:	d8 01       	movw	r26, r16
    632c:	cd 93       	st	X+, r28
    632e:	dc 93       	st	X, r29
    6330:	d1 10       	cpse	r13, r1
    6332:	06 c1       	rjmp	.+524    	; 0x6540 <strtod+0x2b6>
    6334:	60 e0       	ldi	r22, 0x00	; 0
    6336:	70 e0       	ldi	r23, 0x00	; 0
    6338:	80 e8       	ldi	r24, 0x80	; 128
    633a:	9f e7       	ldi	r25, 0x7F	; 127
    633c:	0a c1       	rjmp	.+532    	; 0x6552 <strtod+0x2c8>
    633e:	43 e0       	ldi	r20, 0x03	; 3
    6340:	50 e0       	ldi	r21, 0x00	; 0
    6342:	6c ee       	ldi	r22, 0xEC	; 236
    6344:	70 e0       	ldi	r23, 0x00	; 0
    6346:	ce 01       	movw	r24, r28
    6348:	0e 94 96 33 	call	0x672c	; 0x672c <strncasecmp_P>
    634c:	89 2b       	or	r24, r25
    634e:	59 f4       	brne	.+22     	; 0x6366 <strtod+0xdc>
    6350:	01 15       	cp	r16, r1
    6352:	11 05       	cpc	r17, r1
    6354:	09 f4       	brne	.+2      	; 0x6358 <strtod+0xce>
    6356:	f9 c0       	rjmp	.+498    	; 0x654a <strtod+0x2c0>
    6358:	b2 e0       	ldi	r27, 0x02	; 2
    635a:	eb 0e       	add	r14, r27
    635c:	f1 1c       	adc	r15, r1
    635e:	f8 01       	movw	r30, r16
    6360:	f1 82       	std	Z+1, r15	; 0x01
    6362:	e0 82       	st	Z, r14
    6364:	f2 c0       	rjmp	.+484    	; 0x654a <strtod+0x2c0>
    6366:	f7 01       	movw	r30, r14
    6368:	60 e0       	ldi	r22, 0x00	; 0
    636a:	70 e0       	ldi	r23, 0x00	; 0
    636c:	cb 01       	movw	r24, r22
    636e:	c0 e0       	ldi	r28, 0x00	; 0
    6370:	d0 e0       	ldi	r29, 0x00	; 0
    6372:	7f 01       	movw	r14, r30
    6374:	a0 ed       	ldi	r26, 0xD0	; 208
    6376:	aa 2e       	mov	r10, r26
    6378:	ac 0c       	add	r10, r12
    637a:	29 e0       	ldi	r18, 0x09	; 9
    637c:	2a 15       	cp	r18, r10
    637e:	30 f1       	brcs	.+76     	; 0x63cc <strtod+0x142>
    6380:	4d 2d       	mov	r20, r13
    6382:	42 60       	ori	r20, 0x02	; 2
    6384:	b4 2e       	mov	r11, r20
    6386:	2d 2d       	mov	r18, r13
    6388:	28 70       	andi	r18, 0x08	; 8
    638a:	d2 fe       	sbrs	r13, 2
    638c:	04 c0       	rjmp	.+8      	; 0x6396 <strtod+0x10c>
    638e:	21 11       	cpse	r18, r1
    6390:	25 c0       	rjmp	.+74     	; 0x63dc <strtod+0x152>
    6392:	21 96       	adiw	r28, 0x01	; 1
    6394:	23 c0       	rjmp	.+70     	; 0x63dc <strtod+0x152>
    6396:	21 11       	cpse	r18, r1
    6398:	21 97       	sbiw	r28, 0x01	; 1
    639a:	a5 e0       	ldi	r26, 0x05	; 5
    639c:	b0 e0       	ldi	r27, 0x00	; 0
    639e:	9b 01       	movw	r18, r22
    63a0:	ac 01       	movw	r20, r24
    63a2:	0e 94 c1 33 	call	0x6782	; 0x6782 <__muluhisi3>
    63a6:	66 0f       	add	r22, r22
    63a8:	77 1f       	adc	r23, r23
    63aa:	88 1f       	adc	r24, r24
    63ac:	99 1f       	adc	r25, r25
    63ae:	6a 0d       	add	r22, r10
    63b0:	71 1d       	adc	r23, r1
    63b2:	81 1d       	adc	r24, r1
    63b4:	91 1d       	adc	r25, r1
    63b6:	68 39       	cpi	r22, 0x98	; 152
    63b8:	a9 e9       	ldi	r26, 0x99	; 153
    63ba:	7a 07       	cpc	r23, r26
    63bc:	8a 07       	cpc	r24, r26
    63be:	a9 e1       	ldi	r26, 0x19	; 25
    63c0:	9a 07       	cpc	r25, r26
    63c2:	60 f0       	brcs	.+24     	; 0x63dc <strtod+0x152>
    63c4:	bd 2d       	mov	r27, r13
    63c6:	b6 60       	ori	r27, 0x06	; 6
    63c8:	bb 2e       	mov	r11, r27
    63ca:	08 c0       	rjmp	.+16     	; 0x63dc <strtod+0x152>
    63cc:	2e ef       	ldi	r18, 0xFE	; 254
    63ce:	a2 12       	cpse	r10, r18
    63d0:	0a c0       	rjmp	.+20     	; 0x63e6 <strtod+0x15c>
    63d2:	d3 fc       	sbrc	r13, 3
    63d4:	50 c0       	rjmp	.+160    	; 0x6476 <strtod+0x1ec>
    63d6:	4d 2d       	mov	r20, r13
    63d8:	48 60       	ori	r20, 0x08	; 8
    63da:	b4 2e       	mov	r11, r20
    63dc:	31 96       	adiw	r30, 0x01	; 1
    63de:	d7 01       	movw	r26, r14
    63e0:	cc 90       	ld	r12, X
    63e2:	db 2c       	mov	r13, r11
    63e4:	c6 cf       	rjmp	.-116    	; 0x6372 <strtod+0xe8>
    63e6:	2c 2d       	mov	r18, r12
    63e8:	2f 7d       	andi	r18, 0xDF	; 223
    63ea:	25 34       	cpi	r18, 0x45	; 69
    63ec:	09 f0       	breq	.+2      	; 0x63f0 <strtod+0x166>
    63ee:	43 c0       	rjmp	.+134    	; 0x6476 <strtod+0x1ec>
    63f0:	a0 81       	ld	r26, Z
    63f2:	ad 32       	cpi	r26, 0x2D	; 45
    63f4:	41 f4       	brne	.+16     	; 0x6406 <strtod+0x17c>
    63f6:	bd 2d       	mov	r27, r13
    63f8:	b0 61       	ori	r27, 0x10	; 16
    63fa:	db 2e       	mov	r13, r27
    63fc:	7f 01       	movw	r14, r30
    63fe:	22 e0       	ldi	r18, 0x02	; 2
    6400:	e2 0e       	add	r14, r18
    6402:	f1 1c       	adc	r15, r1
    6404:	0c c0       	rjmp	.+24     	; 0x641e <strtod+0x194>
    6406:	7f 01       	movw	r14, r30
    6408:	ab 32       	cpi	r26, 0x2B	; 43
    640a:	31 f0       	breq	.+12     	; 0x6418 <strtod+0x18e>
    640c:	4f ef       	ldi	r20, 0xFF	; 255
    640e:	e4 1a       	sub	r14, r20
    6410:	f4 0a       	sbc	r15, r20
    6412:	21 e0       	ldi	r18, 0x01	; 1
    6414:	30 e0       	ldi	r19, 0x00	; 0
    6416:	06 c0       	rjmp	.+12     	; 0x6424 <strtod+0x19a>
    6418:	a2 e0       	ldi	r26, 0x02	; 2
    641a:	ea 0e       	add	r14, r26
    641c:	f1 1c       	adc	r15, r1
    641e:	a1 81       	ldd	r26, Z+1	; 0x01
    6420:	22 e0       	ldi	r18, 0x02	; 2
    6422:	30 e0       	ldi	r19, 0x00	; 0
    6424:	a0 53       	subi	r26, 0x30	; 48
    6426:	aa 30       	cpi	r26, 0x0A	; 10
    6428:	18 f0       	brcs	.+6      	; 0x6430 <strtod+0x1a6>
    642a:	e2 1a       	sub	r14, r18
    642c:	f3 0a       	sbc	r15, r19
    642e:	23 c0       	rjmp	.+70     	; 0x6476 <strtod+0x1ec>
    6430:	f7 01       	movw	r30, r14
    6432:	20 e0       	ldi	r18, 0x00	; 0
    6434:	30 e0       	ldi	r19, 0x00	; 0
    6436:	20 38       	cpi	r18, 0x80	; 128
    6438:	bc e0       	ldi	r27, 0x0C	; 12
    643a:	3b 07       	cpc	r19, r27
    643c:	5c f4       	brge	.+22     	; 0x6454 <strtod+0x1ca>
    643e:	a9 01       	movw	r20, r18
    6440:	44 0f       	add	r20, r20
    6442:	55 1f       	adc	r21, r21
    6444:	44 0f       	add	r20, r20
    6446:	55 1f       	adc	r21, r21
    6448:	24 0f       	add	r18, r20
    644a:	35 1f       	adc	r19, r21
    644c:	22 0f       	add	r18, r18
    644e:	33 1f       	adc	r19, r19
    6450:	2a 0f       	add	r18, r26
    6452:	31 1d       	adc	r19, r1
    6454:	af 01       	movw	r20, r30
    6456:	4f 5f       	subi	r20, 0xFF	; 255
    6458:	5f 4f       	sbci	r21, 0xFF	; 255
    645a:	7a 01       	movw	r14, r20
    645c:	a0 81       	ld	r26, Z
    645e:	a0 53       	subi	r26, 0x30	; 48
    6460:	aa 30       	cpi	r26, 0x0A	; 10
    6462:	10 f4       	brcc	.+4      	; 0x6468 <strtod+0x1de>
    6464:	fa 01       	movw	r30, r20
    6466:	e7 cf       	rjmp	.-50     	; 0x6436 <strtod+0x1ac>
    6468:	d4 fe       	sbrs	r13, 4
    646a:	03 c0       	rjmp	.+6      	; 0x6472 <strtod+0x1e8>
    646c:	31 95       	neg	r19
    646e:	21 95       	neg	r18
    6470:	31 09       	sbc	r19, r1
    6472:	c2 0f       	add	r28, r18
    6474:	d3 1f       	adc	r29, r19
    6476:	d1 fe       	sbrs	r13, 1
    6478:	09 c0       	rjmp	.+18     	; 0x648c <strtod+0x202>
    647a:	01 15       	cp	r16, r1
    647c:	11 05       	cpc	r17, r1
    647e:	31 f0       	breq	.+12     	; 0x648c <strtod+0x202>
    6480:	e1 e0       	ldi	r30, 0x01	; 1
    6482:	ee 1a       	sub	r14, r30
    6484:	f1 08       	sbc	r15, r1
    6486:	d8 01       	movw	r26, r16
    6488:	ed 92       	st	X+, r14
    648a:	fc 92       	st	X, r15
    648c:	0e 94 c0 2c 	call	0x5980	; 0x5980 <__floatunsisf>
    6490:	2d 2d       	mov	r18, r13
    6492:	23 70       	andi	r18, 0x03	; 3
    6494:	23 30       	cpi	r18, 0x03	; 3
    6496:	19 f0       	breq	.+6      	; 0x649e <strtod+0x214>
    6498:	4b 01       	movw	r8, r22
    649a:	5c 01       	movw	r10, r24
    649c:	06 c0       	rjmp	.+12     	; 0x64aa <strtod+0x220>
    649e:	4b 01       	movw	r8, r22
    64a0:	5c 01       	movw	r10, r24
    64a2:	b7 fa       	bst	r11, 7
    64a4:	b0 94       	com	r11
    64a6:	b7 f8       	bld	r11, 7
    64a8:	b0 94       	com	r11
    64aa:	20 e0       	ldi	r18, 0x00	; 0
    64ac:	30 e0       	ldi	r19, 0x00	; 0
    64ae:	a9 01       	movw	r20, r18
    64b0:	c5 01       	movw	r24, r10
    64b2:	b4 01       	movw	r22, r8
    64b4:	0e 94 28 2c 	call	0x5850	; 0x5850 <__cmpsf2>
    64b8:	88 23       	and	r24, r24
    64ba:	09 f4       	brne	.+2      	; 0x64be <strtod+0x234>
    64bc:	3e c0       	rjmp	.+124    	; 0x653a <strtod+0x2b0>
    64be:	d7 ff       	sbrs	r29, 7
    64c0:	06 c0       	rjmp	.+12     	; 0x64ce <strtod+0x244>
    64c2:	d1 95       	neg	r29
    64c4:	c1 95       	neg	r28
    64c6:	d1 09       	sbc	r29, r1
    64c8:	0b e0       	ldi	r16, 0x0B	; 11
    64ca:	11 e0       	ldi	r17, 0x01	; 1
    64cc:	02 c0       	rjmp	.+4      	; 0x64d2 <strtod+0x248>
    64ce:	03 e2       	ldi	r16, 0x23	; 35
    64d0:	11 e0       	ldi	r17, 0x01	; 1
    64d2:	68 01       	movw	r12, r16
    64d4:	b8 e1       	ldi	r27, 0x18	; 24
    64d6:	cb 1a       	sub	r12, r27
    64d8:	d1 08       	sbc	r13, r1
    64da:	90 e2       	ldi	r25, 0x20	; 32
    64dc:	e9 2e       	mov	r14, r25
    64de:	f1 2c       	mov	r15, r1
    64e0:	ce 15       	cp	r28, r14
    64e2:	df 05       	cpc	r29, r15
    64e4:	74 f0       	brlt	.+28     	; 0x6502 <strtod+0x278>
    64e6:	f8 01       	movw	r30, r16
    64e8:	25 91       	lpm	r18, Z+
    64ea:	35 91       	lpm	r19, Z+
    64ec:	45 91       	lpm	r20, Z+
    64ee:	54 91       	lpm	r21, Z
    64f0:	c5 01       	movw	r24, r10
    64f2:	b4 01       	movw	r22, r8
    64f4:	0e 94 76 2d 	call	0x5aec	; 0x5aec <__mulsf3>
    64f8:	4b 01       	movw	r8, r22
    64fa:	5c 01       	movw	r10, r24
    64fc:	ce 19       	sub	r28, r14
    64fe:	df 09       	sbc	r29, r15
    6500:	ef cf       	rjmp	.-34     	; 0x64e0 <strtod+0x256>
    6502:	04 50       	subi	r16, 0x04	; 4
    6504:	11 09       	sbc	r17, r1
    6506:	f5 94       	asr	r15
    6508:	e7 94       	ror	r14
    650a:	0c 15       	cp	r16, r12
    650c:	1d 05       	cpc	r17, r13
    650e:	41 f7       	brne	.-48     	; 0x64e0 <strtod+0x256>
    6510:	8a 2d       	mov	r24, r10
    6512:	88 0f       	add	r24, r24
    6514:	8b 2d       	mov	r24, r11
    6516:	88 1f       	adc	r24, r24
    6518:	8f 3f       	cpi	r24, 0xFF	; 255
    651a:	49 f0       	breq	.+18     	; 0x652e <strtod+0x2a4>
    651c:	20 e0       	ldi	r18, 0x00	; 0
    651e:	30 e0       	ldi	r19, 0x00	; 0
    6520:	a9 01       	movw	r20, r18
    6522:	c5 01       	movw	r24, r10
    6524:	b4 01       	movw	r22, r8
    6526:	0e 94 28 2c 	call	0x5850	; 0x5850 <__cmpsf2>
    652a:	81 11       	cpse	r24, r1
    652c:	06 c0       	rjmp	.+12     	; 0x653a <strtod+0x2b0>
    652e:	82 e2       	ldi	r24, 0x22	; 34
    6530:	90 e0       	ldi	r25, 0x00	; 0
    6532:	90 93 b9 02 	sts	0x02B9, r25
    6536:	80 93 b8 02 	sts	0x02B8, r24
    653a:	c5 01       	movw	r24, r10
    653c:	b4 01       	movw	r22, r8
    653e:	09 c0       	rjmp	.+18     	; 0x6552 <strtod+0x2c8>
    6540:	60 e0       	ldi	r22, 0x00	; 0
    6542:	70 e0       	ldi	r23, 0x00	; 0
    6544:	80 e8       	ldi	r24, 0x80	; 128
    6546:	9f ef       	ldi	r25, 0xFF	; 255
    6548:	04 c0       	rjmp	.+8      	; 0x6552 <strtod+0x2c8>
    654a:	60 e0       	ldi	r22, 0x00	; 0
    654c:	70 e0       	ldi	r23, 0x00	; 0
    654e:	80 ec       	ldi	r24, 0xC0	; 192
    6550:	9f e7       	ldi	r25, 0x7F	; 127
    6552:	df 91       	pop	r29
    6554:	cf 91       	pop	r28
    6556:	1f 91       	pop	r17
    6558:	0f 91       	pop	r16
    655a:	ff 90       	pop	r15
    655c:	ef 90       	pop	r14
    655e:	df 90       	pop	r13
    6560:	cf 90       	pop	r12
    6562:	bf 90       	pop	r11
    6564:	af 90       	pop	r10
    6566:	9f 90       	pop	r9
    6568:	8f 90       	pop	r8
    656a:	08 95       	ret

0000656c <__ftoa_engine>:
    656c:	28 30       	cpi	r18, 0x08	; 8
    656e:	08 f0       	brcs	.+2      	; 0x6572 <__ftoa_engine+0x6>
    6570:	27 e0       	ldi	r18, 0x07	; 7
    6572:	33 27       	eor	r19, r19
    6574:	da 01       	movw	r26, r20
    6576:	99 0f       	add	r25, r25
    6578:	31 1d       	adc	r19, r1
    657a:	87 fd       	sbrc	r24, 7
    657c:	91 60       	ori	r25, 0x01	; 1
    657e:	00 96       	adiw	r24, 0x00	; 0
    6580:	61 05       	cpc	r22, r1
    6582:	71 05       	cpc	r23, r1
    6584:	39 f4       	brne	.+14     	; 0x6594 <__ftoa_engine+0x28>
    6586:	32 60       	ori	r19, 0x02	; 2
    6588:	2e 5f       	subi	r18, 0xFE	; 254
    658a:	3d 93       	st	X+, r19
    658c:	30 e3       	ldi	r19, 0x30	; 48
    658e:	2a 95       	dec	r18
    6590:	e1 f7       	brne	.-8      	; 0x658a <__ftoa_engine+0x1e>
    6592:	08 95       	ret
    6594:	9f 3f       	cpi	r25, 0xFF	; 255
    6596:	30 f0       	brcs	.+12     	; 0x65a4 <__ftoa_engine+0x38>
    6598:	80 38       	cpi	r24, 0x80	; 128
    659a:	71 05       	cpc	r23, r1
    659c:	61 05       	cpc	r22, r1
    659e:	09 f0       	breq	.+2      	; 0x65a2 <__ftoa_engine+0x36>
    65a0:	3c 5f       	subi	r19, 0xFC	; 252
    65a2:	3c 5f       	subi	r19, 0xFC	; 252
    65a4:	3d 93       	st	X+, r19
    65a6:	91 30       	cpi	r25, 0x01	; 1
    65a8:	08 f0       	brcs	.+2      	; 0x65ac <__ftoa_engine+0x40>
    65aa:	80 68       	ori	r24, 0x80	; 128
    65ac:	91 1d       	adc	r25, r1
    65ae:	df 93       	push	r29
    65b0:	cf 93       	push	r28
    65b2:	1f 93       	push	r17
    65b4:	0f 93       	push	r16
    65b6:	ff 92       	push	r15
    65b8:	ef 92       	push	r14
    65ba:	19 2f       	mov	r17, r25
    65bc:	98 7f       	andi	r25, 0xF8	; 248
    65be:	96 95       	lsr	r25
    65c0:	e9 2f       	mov	r30, r25
    65c2:	96 95       	lsr	r25
    65c4:	96 95       	lsr	r25
    65c6:	e9 0f       	add	r30, r25
    65c8:	ff 27       	eor	r31, r31
    65ca:	ef 57       	subi	r30, 0x7F	; 127
    65cc:	fe 4f       	sbci	r31, 0xFE	; 254
    65ce:	99 27       	eor	r25, r25
    65d0:	33 27       	eor	r19, r19
    65d2:	ee 24       	eor	r14, r14
    65d4:	ff 24       	eor	r15, r15
    65d6:	a7 01       	movw	r20, r14
    65d8:	e7 01       	movw	r28, r14
    65da:	05 90       	lpm	r0, Z+
    65dc:	08 94       	sec
    65de:	07 94       	ror	r0
    65e0:	28 f4       	brcc	.+10     	; 0x65ec <__ftoa_engine+0x80>
    65e2:	36 0f       	add	r19, r22
    65e4:	e7 1e       	adc	r14, r23
    65e6:	f8 1e       	adc	r15, r24
    65e8:	49 1f       	adc	r20, r25
    65ea:	51 1d       	adc	r21, r1
    65ec:	66 0f       	add	r22, r22
    65ee:	77 1f       	adc	r23, r23
    65f0:	88 1f       	adc	r24, r24
    65f2:	99 1f       	adc	r25, r25
    65f4:	06 94       	lsr	r0
    65f6:	a1 f7       	brne	.-24     	; 0x65e0 <__ftoa_engine+0x74>
    65f8:	05 90       	lpm	r0, Z+
    65fa:	07 94       	ror	r0
    65fc:	28 f4       	brcc	.+10     	; 0x6608 <__ftoa_engine+0x9c>
    65fe:	e7 0e       	add	r14, r23
    6600:	f8 1e       	adc	r15, r24
    6602:	49 1f       	adc	r20, r25
    6604:	56 1f       	adc	r21, r22
    6606:	c1 1d       	adc	r28, r1
    6608:	77 0f       	add	r23, r23
    660a:	88 1f       	adc	r24, r24
    660c:	99 1f       	adc	r25, r25
    660e:	66 1f       	adc	r22, r22
    6610:	06 94       	lsr	r0
    6612:	a1 f7       	brne	.-24     	; 0x65fc <__ftoa_engine+0x90>
    6614:	05 90       	lpm	r0, Z+
    6616:	07 94       	ror	r0
    6618:	28 f4       	brcc	.+10     	; 0x6624 <__ftoa_engine+0xb8>
    661a:	f8 0e       	add	r15, r24
    661c:	49 1f       	adc	r20, r25
    661e:	56 1f       	adc	r21, r22
    6620:	c7 1f       	adc	r28, r23
    6622:	d1 1d       	adc	r29, r1
    6624:	88 0f       	add	r24, r24
    6626:	99 1f       	adc	r25, r25
    6628:	66 1f       	adc	r22, r22
    662a:	77 1f       	adc	r23, r23
    662c:	06 94       	lsr	r0
    662e:	a1 f7       	brne	.-24     	; 0x6618 <__ftoa_engine+0xac>
    6630:	05 90       	lpm	r0, Z+
    6632:	07 94       	ror	r0
    6634:	20 f4       	brcc	.+8      	; 0x663e <__ftoa_engine+0xd2>
    6636:	49 0f       	add	r20, r25
    6638:	56 1f       	adc	r21, r22
    663a:	c7 1f       	adc	r28, r23
    663c:	d8 1f       	adc	r29, r24
    663e:	99 0f       	add	r25, r25
    6640:	66 1f       	adc	r22, r22
    6642:	77 1f       	adc	r23, r23
    6644:	88 1f       	adc	r24, r24
    6646:	06 94       	lsr	r0
    6648:	a9 f7       	brne	.-22     	; 0x6634 <__ftoa_engine+0xc8>
    664a:	84 91       	lpm	r24, Z
    664c:	10 95       	com	r17
    664e:	17 70       	andi	r17, 0x07	; 7
    6650:	41 f0       	breq	.+16     	; 0x6662 <__ftoa_engine+0xf6>
    6652:	d6 95       	lsr	r29
    6654:	c7 95       	ror	r28
    6656:	57 95       	ror	r21
    6658:	47 95       	ror	r20
    665a:	f7 94       	ror	r15
    665c:	e7 94       	ror	r14
    665e:	1a 95       	dec	r17
    6660:	c1 f7       	brne	.-16     	; 0x6652 <__ftoa_engine+0xe6>
    6662:	e7 e2       	ldi	r30, 0x27	; 39
    6664:	f1 e0       	ldi	r31, 0x01	; 1
    6666:	68 94       	set
    6668:	15 90       	lpm	r1, Z+
    666a:	15 91       	lpm	r17, Z+
    666c:	35 91       	lpm	r19, Z+
    666e:	65 91       	lpm	r22, Z+
    6670:	95 91       	lpm	r25, Z+
    6672:	05 90       	lpm	r0, Z+
    6674:	7f e2       	ldi	r23, 0x2F	; 47
    6676:	73 95       	inc	r23
    6678:	e1 18       	sub	r14, r1
    667a:	f1 0a       	sbc	r15, r17
    667c:	43 0b       	sbc	r20, r19
    667e:	56 0b       	sbc	r21, r22
    6680:	c9 0b       	sbc	r28, r25
    6682:	d0 09       	sbc	r29, r0
    6684:	c0 f7       	brcc	.-16     	; 0x6676 <__ftoa_engine+0x10a>
    6686:	e1 0c       	add	r14, r1
    6688:	f1 1e       	adc	r15, r17
    668a:	43 1f       	adc	r20, r19
    668c:	56 1f       	adc	r21, r22
    668e:	c9 1f       	adc	r28, r25
    6690:	d0 1d       	adc	r29, r0
    6692:	7e f4       	brtc	.+30     	; 0x66b2 <__ftoa_engine+0x146>
    6694:	70 33       	cpi	r23, 0x30	; 48
    6696:	11 f4       	brne	.+4      	; 0x669c <__ftoa_engine+0x130>
    6698:	8a 95       	dec	r24
    669a:	e6 cf       	rjmp	.-52     	; 0x6668 <__ftoa_engine+0xfc>
    669c:	e8 94       	clt
    669e:	01 50       	subi	r16, 0x01	; 1
    66a0:	30 f0       	brcs	.+12     	; 0x66ae <__ftoa_engine+0x142>
    66a2:	08 0f       	add	r16, r24
    66a4:	0a f4       	brpl	.+2      	; 0x66a8 <__ftoa_engine+0x13c>
    66a6:	00 27       	eor	r16, r16
    66a8:	02 17       	cp	r16, r18
    66aa:	08 f4       	brcc	.+2      	; 0x66ae <__ftoa_engine+0x142>
    66ac:	20 2f       	mov	r18, r16
    66ae:	23 95       	inc	r18
    66b0:	02 2f       	mov	r16, r18
    66b2:	7a 33       	cpi	r23, 0x3A	; 58
    66b4:	28 f0       	brcs	.+10     	; 0x66c0 <__ftoa_engine+0x154>
    66b6:	79 e3       	ldi	r23, 0x39	; 57
    66b8:	7d 93       	st	X+, r23
    66ba:	2a 95       	dec	r18
    66bc:	e9 f7       	brne	.-6      	; 0x66b8 <__ftoa_engine+0x14c>
    66be:	10 c0       	rjmp	.+32     	; 0x66e0 <__ftoa_engine+0x174>
    66c0:	7d 93       	st	X+, r23
    66c2:	2a 95       	dec	r18
    66c4:	89 f6       	brne	.-94     	; 0x6668 <__ftoa_engine+0xfc>
    66c6:	06 94       	lsr	r0
    66c8:	97 95       	ror	r25
    66ca:	67 95       	ror	r22
    66cc:	37 95       	ror	r19
    66ce:	17 95       	ror	r17
    66d0:	17 94       	ror	r1
    66d2:	e1 18       	sub	r14, r1
    66d4:	f1 0a       	sbc	r15, r17
    66d6:	43 0b       	sbc	r20, r19
    66d8:	56 0b       	sbc	r21, r22
    66da:	c9 0b       	sbc	r28, r25
    66dc:	d0 09       	sbc	r29, r0
    66de:	98 f0       	brcs	.+38     	; 0x6706 <__ftoa_engine+0x19a>
    66e0:	23 95       	inc	r18
    66e2:	7e 91       	ld	r23, -X
    66e4:	73 95       	inc	r23
    66e6:	7a 33       	cpi	r23, 0x3A	; 58
    66e8:	08 f0       	brcs	.+2      	; 0x66ec <__ftoa_engine+0x180>
    66ea:	70 e3       	ldi	r23, 0x30	; 48
    66ec:	7c 93       	st	X, r23
    66ee:	20 13       	cpse	r18, r16
    66f0:	b8 f7       	brcc	.-18     	; 0x66e0 <__ftoa_engine+0x174>
    66f2:	7e 91       	ld	r23, -X
    66f4:	70 61       	ori	r23, 0x10	; 16
    66f6:	7d 93       	st	X+, r23
    66f8:	30 f0       	brcs	.+12     	; 0x6706 <__ftoa_engine+0x19a>
    66fa:	83 95       	inc	r24
    66fc:	71 e3       	ldi	r23, 0x31	; 49
    66fe:	7d 93       	st	X+, r23
    6700:	70 e3       	ldi	r23, 0x30	; 48
    6702:	2a 95       	dec	r18
    6704:	e1 f7       	brne	.-8      	; 0x66fe <__ftoa_engine+0x192>
    6706:	11 24       	eor	r1, r1
    6708:	ef 90       	pop	r14
    670a:	ff 90       	pop	r15
    670c:	0f 91       	pop	r16
    670e:	1f 91       	pop	r17
    6710:	cf 91       	pop	r28
    6712:	df 91       	pop	r29
    6714:	99 27       	eor	r25, r25
    6716:	87 fd       	sbrc	r24, 7
    6718:	90 95       	com	r25
    671a:	08 95       	ret

0000671c <isspace>:
    671c:	91 11       	cpse	r25, r1
    671e:	2e c0       	rjmp	.+92     	; 0x677c <__ctype_isfalse>
    6720:	80 32       	cpi	r24, 0x20	; 32
    6722:	19 f0       	breq	.+6      	; 0x672a <isspace+0xe>
    6724:	89 50       	subi	r24, 0x09	; 9
    6726:	85 50       	subi	r24, 0x05	; 5
    6728:	d0 f7       	brcc	.-12     	; 0x671e <isspace+0x2>
    672a:	08 95       	ret

0000672c <strncasecmp_P>:
    672c:	fb 01       	movw	r30, r22
    672e:	dc 01       	movw	r26, r24
    6730:	41 50       	subi	r20, 0x01	; 1
    6732:	50 40       	sbci	r21, 0x00	; 0
    6734:	88 f0       	brcs	.+34     	; 0x6758 <strncasecmp_P+0x2c>
    6736:	8d 91       	ld	r24, X+
    6738:	81 34       	cpi	r24, 0x41	; 65
    673a:	1c f0       	brlt	.+6      	; 0x6742 <strncasecmp_P+0x16>
    673c:	8b 35       	cpi	r24, 0x5B	; 91
    673e:	0c f4       	brge	.+2      	; 0x6742 <strncasecmp_P+0x16>
    6740:	80 5e       	subi	r24, 0xE0	; 224
    6742:	65 91       	lpm	r22, Z+
    6744:	61 34       	cpi	r22, 0x41	; 65
    6746:	1c f0       	brlt	.+6      	; 0x674e <strncasecmp_P+0x22>
    6748:	6b 35       	cpi	r22, 0x5B	; 91
    674a:	0c f4       	brge	.+2      	; 0x674e <strncasecmp_P+0x22>
    674c:	60 5e       	subi	r22, 0xE0	; 224
    674e:	86 1b       	sub	r24, r22
    6750:	61 11       	cpse	r22, r1
    6752:	71 f3       	breq	.-36     	; 0x6730 <strncasecmp_P+0x4>
    6754:	99 0b       	sbc	r25, r25
    6756:	08 95       	ret
    6758:	88 1b       	sub	r24, r24
    675a:	fc cf       	rjmp	.-8      	; 0x6754 <strncasecmp_P+0x28>

0000675c <strrev>:
    675c:	dc 01       	movw	r26, r24
    675e:	fc 01       	movw	r30, r24
    6760:	67 2f       	mov	r22, r23
    6762:	71 91       	ld	r23, Z+
    6764:	77 23       	and	r23, r23
    6766:	e1 f7       	brne	.-8      	; 0x6760 <strrev+0x4>
    6768:	32 97       	sbiw	r30, 0x02	; 2
    676a:	04 c0       	rjmp	.+8      	; 0x6774 <strrev+0x18>
    676c:	7c 91       	ld	r23, X
    676e:	6d 93       	st	X+, r22
    6770:	70 83       	st	Z, r23
    6772:	62 91       	ld	r22, -Z
    6774:	ae 17       	cp	r26, r30
    6776:	bf 07       	cpc	r27, r31
    6778:	c8 f3       	brcs	.-14     	; 0x676c <strrev+0x10>
    677a:	08 95       	ret

0000677c <__ctype_isfalse>:
    677c:	99 27       	eor	r25, r25
    677e:	88 27       	eor	r24, r24

00006780 <__ctype_istrue>:
    6780:	08 95       	ret

00006782 <__muluhisi3>:
    6782:	0e 94 cc 33 	call	0x6798	; 0x6798 <__umulhisi3>
    6786:	a5 9f       	mul	r26, r21
    6788:	90 0d       	add	r25, r0
    678a:	b4 9f       	mul	r27, r20
    678c:	90 0d       	add	r25, r0
    678e:	a4 9f       	mul	r26, r20
    6790:	80 0d       	add	r24, r0
    6792:	91 1d       	adc	r25, r1
    6794:	11 24       	eor	r1, r1
    6796:	08 95       	ret

00006798 <__umulhisi3>:
    6798:	a2 9f       	mul	r26, r18
    679a:	b0 01       	movw	r22, r0
    679c:	b3 9f       	mul	r27, r19
    679e:	c0 01       	movw	r24, r0
    67a0:	a3 9f       	mul	r26, r19
    67a2:	70 0d       	add	r23, r0
    67a4:	81 1d       	adc	r24, r1
    67a6:	11 24       	eor	r1, r1
    67a8:	91 1d       	adc	r25, r1
    67aa:	b2 9f       	mul	r27, r18
    67ac:	70 0d       	add	r23, r0
    67ae:	81 1d       	adc	r24, r1
    67b0:	11 24       	eor	r1, r1
    67b2:	91 1d       	adc	r25, r1
    67b4:	08 95       	ret

000067b6 <_exit>:
    67b6:	f8 94       	cli

000067b8 <__stop_program>:
    67b8:	ff cf       	rjmp	.-2      	; 0x67b8 <__stop_program>
