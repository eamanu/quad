
quadcopter_dev.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000018  00800200  00007732  000077c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007732  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000a3  00800218  00800218  000077de  2**0
                  ALLOC
  3 .stab         0000b394  00000000  00000000  000077e0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003f38  00000000  00000000  00012b74  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00016aac  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00016ac0  2**2
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 7c 01 	jmp	0x2f8	; 0x2f8 <__ctors_end>
       4:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
       8:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
       c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      10:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      14:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      18:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      1c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      20:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      24:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      28:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      2c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      30:	0c 94 1a 19 	jmp	0x3234	; 0x3234 <__vector_12>
      34:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      38:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      3c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      40:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      44:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      48:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      4c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      50:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      54:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      58:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      5c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      60:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      64:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      68:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      6c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      70:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      74:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      78:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      7c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      80:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      84:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      88:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      8c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      90:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      94:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      98:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      9c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      a0:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      a4:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      a8:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      ac:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      b0:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      b4:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      b8:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      bc:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      c0:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      c4:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      c8:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      cc:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      d0:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      d4:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      d8:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      dc:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      e0:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      e4:	08 4a       	sbci	r16, 0xA8	; 168
      e6:	d7 3b       	cpi	r29, 0xB7	; 183
      e8:	3b ce       	rjmp	.-906    	; 0xfffffd60 <__eeprom_end+0xff7efd60>
      ea:	01 6e       	ori	r16, 0xE1	; 225
      ec:	84 bc       	out	0x24, r8	; 36
      ee:	bf fd       	.word	0xfdbf	; ????
      f0:	c1 2f       	mov	r28, r17
      f2:	3d 6c       	ori	r19, 0xCD	; 205
      f4:	74 31       	cpi	r23, 0x14	; 20
      f6:	9a bd       	out	0x2a, r25	; 42
      f8:	56 83       	std	Z+6, r21	; 0x06
      fa:	3d da       	rcall	.-2950   	; 0xfffff576 <__eeprom_end+0xff7ef576>
      fc:	3d 00       	.word	0x003d	; ????
      fe:	c7 7f       	andi	r28, 0xF7	; 247
     100:	11 be       	out	0x31, r1	; 49
     102:	d9 e4       	ldi	r29, 0x49	; 73
     104:	bb 4c       	sbci	r27, 0xCB	; 203
     106:	3e 91       	ld	r19, -X
     108:	6b aa       	std	Y+51, r6	; 0x33
     10a:	aa be       	out	0x3a, r10	; 58
     10c:	00 00       	nop
     10e:	00 80       	ld	r0, Z
     110:	3f 07       	cpc	r19, r31
     112:	63 42       	sbci	r22, 0x23	; 35
     114:	36 b7       	in	r19, 0x36	; 54
     116:	9b d8       	rcall	.-3786   	; 0xfffff24e <__eeprom_end+0xff7ef24e>
     118:	a7 1a       	sub	r10, r23
     11a:	39 68       	ori	r19, 0x89	; 137
     11c:	56 18       	sub	r5, r6
     11e:	ae ba       	out	0x1e, r10	; 30
     120:	ab 55       	subi	r26, 0x5B	; 91
     122:	8c 1d       	adc	r24, r12
     124:	3c b7       	in	r19, 0x3c	; 60
     126:	cc 57       	subi	r28, 0x7C	; 124
     128:	63 bd       	out	0x23, r22	; 35
     12a:	6d ed       	ldi	r22, 0xDD	; 221
     12c:	fd 75       	andi	r31, 0x5D	; 93
     12e:	3e f6       	brtc	.-114    	; 0xbe <__SREG__+0x7f>
     130:	17 72       	andi	r17, 0x27	; 39
     132:	31 bf       	out	0x31, r19	; 49
     134:	00 00       	nop
     136:	00 80       	ld	r0, Z
     138:	3f 08       	sbc	r3, r15
     13a:	00 00       	nop
     13c:	00 be       	out	0x30, r0	; 48
     13e:	92 24       	eor	r9, r2
     140:	49 12       	cpse	r4, r25
     142:	3e ab       	std	Y+54, r19	; 0x36
     144:	aa aa       	std	Y+50, r10	; 0x32
     146:	2a be       	out	0x3a, r2	; 58
     148:	cd cc       	rjmp	.-1638   	; 0xfffffae4 <__eeprom_end+0xff7efae4>
     14a:	cc 4c       	sbci	r28, 0xCC	; 204
     14c:	3e 00       	.word	0x003e	; ????
     14e:	00 00       	nop
     150:	80 be       	out	0x30, r8	; 48
     152:	ab aa       	std	Y+51, r10	; 0x33
     154:	aa aa       	std	Y+50, r10	; 0x32
     156:	3e 00       	.word	0x003e	; ????
     158:	00 00       	nop
     15a:	00 bf       	out	0x30, r16	; 48
     15c:	00 00       	nop
     15e:	00 80       	ld	r0, Z
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
     164:	00 00       	nop
     166:	08 41       	sbci	r16, 0x18	; 24
     168:	78 d3       	rcall	.+1776   	; 0x85a <i2c_start_wait+0xc2>
     16a:	bb 43       	sbci	r27, 0x3B	; 59
     16c:	87 d1       	rcall	.+782    	; 0x47c <put_long+0x36>
     16e:	13 3d       	cpi	r17, 0xD3	; 211
     170:	19 0e       	add	r1, r25
     172:	3c c3       	rjmp	.+1656   	; 0x7ec <i2c_start_wait+0x54>
     174:	bd 42       	sbci	r27, 0x2D	; 45
     176:	82 ad       	ldd	r24, Z+58	; 0x3a
     178:	2b 3e       	cpi	r18, 0xEB	; 235
     17a:	68 ec       	ldi	r22, 0xC8	; 200
     17c:	82 76       	andi	r24, 0x62	; 98
     17e:	be d9       	rcall	.-3204   	; 0xfffff4fc <__eeprom_end+0xff7ef4fc>
     180:	8f e1       	ldi	r24, 0x1F	; 31
     182:	a9 3e       	cpi	r26, 0xE9	; 233
     184:	4c 80       	ldd	r4, Y+4	; 0x04
     186:	ef ff       	.word	0xffef	; ????
     188:	be 01       	movw	r22, r28
     18a:	c4 ff       	sbrs	r28, 4
     18c:	7f 3f       	cpi	r23, 0xFF	; 255
     18e:	00 00       	nop
     190:	00 00       	nop
	...

00000194 <__trampolines_start>:
     194:	0c 94 69 01 	jmp	0x2d2	; 0x2d2 <prvIdleTask>
     198:	0c 94 db 15 	jmp	0x2bb6	; 0x2bb6 <LecturaMPU6050>

0000019c <__trampolines_end>:
     19c:	4e 41       	sbci	r20, 0x1E	; 30
     19e:	4e 49       	sbci	r20, 0x9E	; 158

0000019f <pstr_inity>:
     19f:	49 4e 49 54 59                                      INITY

000001a4 <pstr_inf>:
     1a4:	49 4e 46                                            INF

000001a7 <pwr_m10>:
     1a7:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     1b7:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

000001bf <pwr_p10>:
     1bf:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     1cf:	ca 1b 0e 5a ae c5 9d 74 00 40 7a 10 f3 5a 00 a0     ...Z...t.@z..Z..
     1df:	72 4e 18 09 00 10 a5 d4 e8 00 00 e8 76 48 17 00     rN..........vH..
     1ef:	00 e4 0b 54 02 00 00 ca 9a 3b 00 00 00 e1 f5 05     ...T.....;......
     1ff:	00 00 80 96 98 00 00 00 40 42 0f 00 00 00 a0 86     ........@B......
     20f:	01 00 00 00 10 27 00 00 00 00 e8 03 00 00 00 00     .....'..........
     21f:	64 00 00 00 00 00 0a 00 00 00 00 00 01 00 00 00     d...............
     22f:	00 00 2c 76 d8 88 dc 67 4f 08 23 df c1 df ae 59     ..,v...gO.#....Y
     23f:	e1 b1 b7 96 e5 e3 e4 53 c6 3a e6 51 99 76 96 e8     .......S.:.Q.v..
     24f:	e6 c2 84 26 eb 89 8c 9b 62 ed 40 7c 6f fc ef bc     ...&....b.@|o...
     25f:	9c 9f 40 f2 ba a5 6f a5 f4 90 05 5a 2a f7 5c 93     ..@...o....Z*.\.
     26f:	6b 6c f9 67 6d c1 1b fc e0 e4 0d 47 fe f5 20 e6     kl.gm......G.. .
     27f:	b5 00 d0 ed 90 2e 03 00 94 35 77 05 00 80 84 1e     .........5w.....
     28f:	08 00 00 20 4e 0a 00 00 00 c8 0c 33 33 33 33 0f     ... N......3333.
     29f:	98 6e 12 83 11 41 ef 8d 21 14 89 3b e6 55 16 cf     .n...A..!..;.U..
     2af:	fe e6 db 18 d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb     ......K8..|.....
     2bf:	e4 24 20 32 84 72 5e 22 81 00 c9 f1 24 ec a1 e5     .$ 2.r^"....$...
     2cf:	3d 27 00                                            ='.

000002d2 <prvIdleTask>:
     2d2:	cf 93       	push	r28
     2d4:	df 93       	push	r29
     2d6:	1f 92       	push	r1
     2d8:	1f 92       	push	r1
     2da:	cd b7       	in	r28, 0x3d	; 61
     2dc:	de b7       	in	r29, 0x3e	; 62
     2de:	9a 83       	std	Y+2, r25	; 0x02
     2e0:	89 83       	std	Y+1, r24	; 0x01
     2e2:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <prvCheckTasksWaitingTermination>
     2e6:	80 91 42 02 	lds	r24, 0x0242
     2ea:	82 30       	cpi	r24, 0x02	; 2
     2ec:	10 f0       	brcs	.+4      	; 0x2f2 <prvIdleTask+0x20>
     2ee:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
     2f2:	0e 94 9d 12 	call	0x253a	; 0x253a <vApplicationIdleHook>
     2f6:	f5 cf       	rjmp	.-22     	; 0x2e2 <prvIdleTask+0x10>

000002f8 <__ctors_end>:
     2f8:	11 24       	eor	r1, r1
     2fa:	1f be       	out	0x3f, r1	; 63
     2fc:	cf ef       	ldi	r28, 0xFF	; 255
     2fe:	d1 e2       	ldi	r29, 0x21	; 33
     300:	de bf       	out	0x3e, r29	; 62
     302:	cd bf       	out	0x3d, r28	; 61
     304:	00 e0       	ldi	r16, 0x00	; 0
     306:	0c bf       	out	0x3c, r16	; 60

00000308 <__do_copy_data>:
     308:	12 e0       	ldi	r17, 0x02	; 2
     30a:	a0 e0       	ldi	r26, 0x00	; 0
     30c:	b2 e0       	ldi	r27, 0x02	; 2
     30e:	e2 e3       	ldi	r30, 0x32	; 50
     310:	f7 e7       	ldi	r31, 0x77	; 119
     312:	00 e0       	ldi	r16, 0x00	; 0
     314:	0b bf       	out	0x3b, r16	; 59
     316:	02 c0       	rjmp	.+4      	; 0x31c <__do_copy_data+0x14>
     318:	07 90       	elpm	r0, Z+
     31a:	0d 92       	st	X+, r0
     31c:	a8 31       	cpi	r26, 0x18	; 24
     31e:	b1 07       	cpc	r27, r17
     320:	d9 f7       	brne	.-10     	; 0x318 <__do_copy_data+0x10>

00000322 <__do_clear_bss>:
     322:	22 e0       	ldi	r18, 0x02	; 2
     324:	a8 e1       	ldi	r26, 0x18	; 24
     326:	b2 e0       	ldi	r27, 0x02	; 2
     328:	01 c0       	rjmp	.+2      	; 0x32c <.do_clear_bss_start>

0000032a <.do_clear_bss_loop>:
     32a:	1d 92       	st	X+, r1

0000032c <.do_clear_bss_start>:
     32c:	ab 3b       	cpi	r26, 0xBB	; 187
     32e:	b2 07       	cpc	r27, r18
     330:	e1 f7       	brne	.-8      	; 0x32a <.do_clear_bss_loop>
     332:	0e 94 7d 15 	call	0x2afa	; 0x2afa <main>
     336:	0c 94 97 3b 	jmp	0x772e	; 0x772e <_exit>

0000033a <__bad_interrupt>:
     33a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000033e <usart_init>:
     33e:	cf 93       	push	r28
     340:	df 93       	push	r29
     342:	cd b7       	in	r28, 0x3d	; 61
     344:	de b7       	in	r29, 0x3e	; 62
     346:	80 ec       	ldi	r24, 0xC0	; 192
     348:	90 e0       	ldi	r25, 0x00	; 0
     34a:	20 ec       	ldi	r18, 0xC0	; 192
     34c:	30 e0       	ldi	r19, 0x00	; 0
     34e:	f9 01       	movw	r30, r18
     350:	20 81       	ld	r18, Z
     352:	22 60       	ori	r18, 0x02	; 2
     354:	fc 01       	movw	r30, r24
     356:	20 83       	st	Z, r18
     358:	84 ec       	ldi	r24, 0xC4	; 196
     35a:	90 e0       	ldi	r25, 0x00	; 0
     35c:	2f ec       	ldi	r18, 0xCF	; 207
     35e:	30 e0       	ldi	r19, 0x00	; 0
     360:	fc 01       	movw	r30, r24
     362:	31 83       	std	Z+1, r19	; 0x01
     364:	20 83       	st	Z, r18
     366:	82 ec       	ldi	r24, 0xC2	; 194
     368:	90 e0       	ldi	r25, 0x00	; 0
     36a:	26 e0       	ldi	r18, 0x06	; 6
     36c:	fc 01       	movw	r30, r24
     36e:	20 83       	st	Z, r18
     370:	81 ec       	ldi	r24, 0xC1	; 193
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	28 e1       	ldi	r18, 0x18	; 24
     376:	fc 01       	movw	r30, r24
     378:	20 83       	st	Z, r18
     37a:	df 91       	pop	r29
     37c:	cf 91       	pop	r28
     37e:	08 95       	ret

00000380 <put_char>:
	UCSR0B = (1 << TXEN0) | (1 << RXEN0);			// Enable module TX adn RX
	//fdevopen((int (*)(char, FILE*))put_char, (int (*)(FILE*))get_char);		// For use with printf and scanf
}

// TX data char through USART
int put_char (int dato){
     380:	cf 93       	push	r28
     382:	df 93       	push	r29
     384:	1f 92       	push	r1
     386:	1f 92       	push	r1
     388:	cd b7       	in	r28, 0x3d	; 61
     38a:	de b7       	in	r29, 0x3e	; 62
     38c:	9a 83       	std	Y+2, r25	; 0x02
     38e:	89 83       	std	Y+1, r24	; 0x01
	while ((UCSR0A & (1 << UDRE0)) == 0);	// Wait for empty buffer
     390:	00 00       	nop
     392:	80 ec       	ldi	r24, 0xC0	; 192
     394:	90 e0       	ldi	r25, 0x00	; 0
     396:	fc 01       	movw	r30, r24
     398:	80 81       	ld	r24, Z
     39a:	88 2f       	mov	r24, r24
     39c:	90 e0       	ldi	r25, 0x00	; 0
     39e:	80 72       	andi	r24, 0x20	; 32
     3a0:	99 27       	eor	r25, r25
     3a2:	89 2b       	or	r24, r25
     3a4:	b1 f3       	breq	.-20     	; 0x392 <put_char+0x12>
	UDR0 = dato;
     3a6:	86 ec       	ldi	r24, 0xC6	; 198
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	29 81       	ldd	r18, Y+1	; 0x01
     3ac:	fc 01       	movw	r30, r24
     3ae:	20 83       	st	Z, r18
	return dato;
     3b0:	89 81       	ldd	r24, Y+1	; 0x01
     3b2:	9a 81       	ldd	r25, Y+2	; 0x02
}
     3b4:	0f 90       	pop	r0
     3b6:	0f 90       	pop	r0
     3b8:	df 91       	pop	r29
     3ba:	cf 91       	pop	r28
     3bc:	08 95       	ret

000003be <put_string>:

// TX data string ASCII through USART
void put_string(char *s){
     3be:	cf 93       	push	r28
     3c0:	df 93       	push	r29
     3c2:	1f 92       	push	r1
     3c4:	1f 92       	push	r1
     3c6:	cd b7       	in	r28, 0x3d	; 61
     3c8:	de b7       	in	r29, 0x3e	; 62
     3ca:	9a 83       	std	Y+2, r25	; 0x02
     3cc:	89 83       	std	Y+1, r24	; 0x01
	while (*s){
     3ce:	0d c0       	rjmp	.+26     	; 0x3ea <put_string+0x2c>
		put_char(*s);
     3d0:	89 81       	ldd	r24, Y+1	; 0x01
     3d2:	9a 81       	ldd	r25, Y+2	; 0x02
     3d4:	fc 01       	movw	r30, r24
     3d6:	80 81       	ld	r24, Z
     3d8:	88 2f       	mov	r24, r24
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	0e 94 c0 01 	call	0x380	; 0x380 <put_char>
		s++;
     3e0:	89 81       	ldd	r24, Y+1	; 0x01
     3e2:	9a 81       	ldd	r25, Y+2	; 0x02
     3e4:	01 96       	adiw	r24, 0x01	; 1
     3e6:	9a 83       	std	Y+2, r25	; 0x02
     3e8:	89 83       	std	Y+1, r24	; 0x01
	return dato;
}

// TX data string ASCII through USART
void put_string(char *s){
	while (*s){
     3ea:	89 81       	ldd	r24, Y+1	; 0x01
     3ec:	9a 81       	ldd	r25, Y+2	; 0x02
     3ee:	fc 01       	movw	r30, r24
     3f0:	80 81       	ld	r24, Z
     3f2:	88 23       	and	r24, r24
     3f4:	69 f7       	brne	.-38     	; 0x3d0 <put_string+0x12>
		put_char(*s);
		s++;
	}
}
     3f6:	0f 90       	pop	r0
     3f8:	0f 90       	pop	r0
     3fa:	df 91       	pop	r29
     3fc:	cf 91       	pop	r28
     3fe:	08 95       	ret

00000400 <put_int>:

// TX integer variable through USART
void put_int (int dato){
     400:	cf 93       	push	r28
     402:	df 93       	push	r29
     404:	cd b7       	in	r28, 0x3d	; 61
     406:	de b7       	in	r29, 0x3e	; 62
     408:	66 97       	sbiw	r28, 0x16	; 22
     40a:	0f b6       	in	r0, 0x3f	; 63
     40c:	f8 94       	cli
     40e:	de bf       	out	0x3e, r29	; 62
     410:	0f be       	out	0x3f, r0	; 63
     412:	cd bf       	out	0x3d, r28	; 61
     414:	9e 8b       	std	Y+22, r25	; 0x16
     416:	8d 8b       	std	Y+21, r24	; 0x15
	char s[20];
	itoa(dato,s,10);	// Converting data integer to ASCII
     418:	8d 89       	ldd	r24, Y+21	; 0x15
     41a:	9e 89       	ldd	r25, Y+22	; 0x16
     41c:	4a e0       	ldi	r20, 0x0A	; 10
     41e:	50 e0       	ldi	r21, 0x00	; 0
     420:	9e 01       	movw	r18, r28
     422:	2f 5f       	subi	r18, 0xFF	; 255
     424:	3f 4f       	sbci	r19, 0xFF	; 255
     426:	b9 01       	movw	r22, r18
     428:	0e 94 00 37 	call	0x6e00	; 0x6e00 <itoa>
	put_string(s);
     42c:	ce 01       	movw	r24, r28
     42e:	01 96       	adiw	r24, 0x01	; 1
     430:	0e 94 df 01 	call	0x3be	; 0x3be <put_string>
}
     434:	66 96       	adiw	r28, 0x16	; 22
     436:	0f b6       	in	r0, 0x3f	; 63
     438:	f8 94       	cli
     43a:	de bf       	out	0x3e, r29	; 62
     43c:	0f be       	out	0x3f, r0	; 63
     43e:	cd bf       	out	0x3d, r28	; 61
     440:	df 91       	pop	r29
     442:	cf 91       	pop	r28
     444:	08 95       	ret

00000446 <put_long>:

// TX long variable through USART
void put_long (long dato){
     446:	cf 93       	push	r28
     448:	df 93       	push	r29
     44a:	cd b7       	in	r28, 0x3d	; 61
     44c:	de b7       	in	r29, 0x3e	; 62
     44e:	68 97       	sbiw	r28, 0x18	; 24
     450:	0f b6       	in	r0, 0x3f	; 63
     452:	f8 94       	cli
     454:	de bf       	out	0x3e, r29	; 62
     456:	0f be       	out	0x3f, r0	; 63
     458:	cd bf       	out	0x3d, r28	; 61
     45a:	6d 8b       	std	Y+21, r22	; 0x15
     45c:	7e 8b       	std	Y+22, r23	; 0x16
     45e:	8f 8b       	std	Y+23, r24	; 0x17
     460:	98 8f       	std	Y+24, r25	; 0x18
	char s[20];
	ltoa(dato,s,10);	// Converting data integer to ASCII
     462:	8d 89       	ldd	r24, Y+21	; 0x15
     464:	9e 89       	ldd	r25, Y+22	; 0x16
     466:	af 89       	ldd	r26, Y+23	; 0x17
     468:	b8 8d       	ldd	r27, Y+24	; 0x18
     46a:	2a e0       	ldi	r18, 0x0A	; 10
     46c:	30 e0       	ldi	r19, 0x00	; 0
     46e:	ae 01       	movw	r20, r28
     470:	4f 5f       	subi	r20, 0xFF	; 255
     472:	5f 4f       	sbci	r21, 0xFF	; 255
     474:	bc 01       	movw	r22, r24
     476:	cd 01       	movw	r24, r26
     478:	0e 94 16 37 	call	0x6e2c	; 0x6e2c <ltoa>
	put_string(s);
     47c:	ce 01       	movw	r24, r28
     47e:	01 96       	adiw	r24, 0x01	; 1
     480:	0e 94 df 01 	call	0x3be	; 0x3be <put_string>
}
     484:	68 96       	adiw	r28, 0x18	; 24
     486:	0f b6       	in	r0, 0x3f	; 63
     488:	f8 94       	cli
     48a:	de bf       	out	0x3e, r29	; 62
     48c:	0f be       	out	0x3f, r0	; 63
     48e:	cd bf       	out	0x3d, r28	; 61
     490:	df 91       	pop	r29
     492:	cf 91       	pop	r28
     494:	08 95       	ret

00000496 <put_float>:

// Tx float variable through USART
void put_float (float dato){
     496:	0f 93       	push	r16
     498:	1f 93       	push	r17
     49a:	cf 93       	push	r28
     49c:	df 93       	push	r29
     49e:	cd b7       	in	r28, 0x3d	; 61
     4a0:	de b7       	in	r29, 0x3e	; 62
     4a2:	68 97       	sbiw	r28, 0x18	; 24
     4a4:	0f b6       	in	r0, 0x3f	; 63
     4a6:	f8 94       	cli
     4a8:	de bf       	out	0x3e, r29	; 62
     4aa:	0f be       	out	0x3f, r0	; 63
     4ac:	cd bf       	out	0x3d, r28	; 61
     4ae:	6d 8b       	std	Y+21, r22	; 0x15
     4b0:	7e 8b       	std	Y+22, r23	; 0x16
     4b2:	8f 8b       	std	Y+23, r24	; 0x17
     4b4:	98 8f       	std	Y+24, r25	; 0x18
	char s[20];
	dtostrf(dato,8,3,s);	// Converting data integer to ASCII. 3 Decimals
     4b6:	8d 89       	ldd	r24, Y+21	; 0x15
     4b8:	9e 89       	ldd	r25, Y+22	; 0x16
     4ba:	af 89       	ldd	r26, Y+23	; 0x17
     4bc:	b8 8d       	ldd	r27, Y+24	; 0x18
     4be:	9e 01       	movw	r18, r28
     4c0:	2f 5f       	subi	r18, 0xFF	; 255
     4c2:	3f 4f       	sbci	r19, 0xFF	; 255
     4c4:	89 01       	movw	r16, r18
     4c6:	23 e0       	ldi	r18, 0x03	; 3
     4c8:	48 e0       	ldi	r20, 0x08	; 8
     4ca:	bc 01       	movw	r22, r24
     4cc:	cd 01       	movw	r24, r26
     4ce:	0e 94 81 35 	call	0x6b02	; 0x6b02 <dtostrf>
	put_string(s);
     4d2:	ce 01       	movw	r24, r28
     4d4:	01 96       	adiw	r24, 0x01	; 1
     4d6:	0e 94 df 01 	call	0x3be	; 0x3be <put_string>
}
     4da:	68 96       	adiw	r28, 0x18	; 24
     4dc:	0f b6       	in	r0, 0x3f	; 63
     4de:	f8 94       	cli
     4e0:	de bf       	out	0x3e, r29	; 62
     4e2:	0f be       	out	0x3f, r0	; 63
     4e4:	cd bf       	out	0x3d, r28	; 61
     4e6:	df 91       	pop	r29
     4e8:	cf 91       	pop	r28
     4ea:	1f 91       	pop	r17
     4ec:	0f 91       	pop	r16
     4ee:	08 95       	ret

000004f0 <get_char>:

// Rx data char through USART
int get_char(void){
     4f0:	cf 93       	push	r28
     4f2:	df 93       	push	r29
     4f4:	1f 92       	push	r1
     4f6:	1f 92       	push	r1
     4f8:	cd b7       	in	r28, 0x3d	; 61
     4fa:	de b7       	in	r29, 0x3e	; 62
	int dato;
	while ((UCSR0A & (1<<RXC0)) == 0 );		// Wait for data in buffer
     4fc:	00 00       	nop
     4fe:	80 ec       	ldi	r24, 0xC0	; 192
     500:	90 e0       	ldi	r25, 0x00	; 0
     502:	fc 01       	movw	r30, r24
     504:	80 81       	ld	r24, Z
     506:	88 23       	and	r24, r24
     508:	d4 f7       	brge	.-12     	; 0x4fe <get_char+0xe>
	dato = UDR0;
     50a:	86 ec       	ldi	r24, 0xC6	; 198
     50c:	90 e0       	ldi	r25, 0x00	; 0
     50e:	fc 01       	movw	r30, r24
     510:	80 81       	ld	r24, Z
     512:	88 2f       	mov	r24, r24
     514:	90 e0       	ldi	r25, 0x00	; 0
     516:	9a 83       	std	Y+2, r25	; 0x02
     518:	89 83       	std	Y+1, r24	; 0x01
	return dato;
     51a:	89 81       	ldd	r24, Y+1	; 0x01
     51c:	9a 81       	ldd	r25, Y+2	; 0x02
}
     51e:	0f 90       	pop	r0
     520:	0f 90       	pop	r0
     522:	df 91       	pop	r29
     524:	cf 91       	pop	r28
     526:	08 95       	ret

00000528 <get_float>:

// Rx string  through USART
float get_float(void){
     528:	cf 93       	push	r28
     52a:	df 93       	push	r29
     52c:	cd b7       	in	r28, 0x3d	; 61
     52e:	de b7       	in	r29, 0x3e	; 62
     530:	6a 97       	sbiw	r28, 0x1a	; 26
     532:	0f b6       	in	r0, 0x3f	; 63
     534:	f8 94       	cli
     536:	de bf       	out	0x3e, r29	; 62
     538:	0f be       	out	0x3f, r0	; 63
     53a:	cd bf       	out	0x3d, r28	; 61
	char k[20];
	float f;
	int i = 0;
     53c:	1a 82       	std	Y+2, r1	; 0x02
     53e:	19 82       	std	Y+1, r1	; 0x01
	while (1) {
		k[i] = get_char();
     540:	0e 94 78 02 	call	0x4f0	; 0x4f0 <get_char>
     544:	48 2f       	mov	r20, r24
     546:	9e 01       	movw	r18, r28
     548:	29 5f       	subi	r18, 0xF9	; 249
     54a:	3f 4f       	sbci	r19, 0xFF	; 255
     54c:	89 81       	ldd	r24, Y+1	; 0x01
     54e:	9a 81       	ldd	r25, Y+2	; 0x02
     550:	82 0f       	add	r24, r18
     552:	93 1f       	adc	r25, r19
     554:	fc 01       	movw	r30, r24
     556:	40 83       	st	Z, r20
		if (k[i] == '\n') break;
     558:	9e 01       	movw	r18, r28
     55a:	29 5f       	subi	r18, 0xF9	; 249
     55c:	3f 4f       	sbci	r19, 0xFF	; 255
     55e:	89 81       	ldd	r24, Y+1	; 0x01
     560:	9a 81       	ldd	r25, Y+2	; 0x02
     562:	82 0f       	add	r24, r18
     564:	93 1f       	adc	r25, r19
     566:	fc 01       	movw	r30, r24
     568:	80 81       	ld	r24, Z
     56a:	8a 30       	cpi	r24, 0x0A	; 10
     56c:	09 f4       	brne	.+2      	; 0x570 <get_float+0x48>
     56e:	06 c0       	rjmp	.+12     	; 0x57c <get_float+0x54>
		i++;
     570:	89 81       	ldd	r24, Y+1	; 0x01
     572:	9a 81       	ldd	r25, Y+2	; 0x02
     574:	01 96       	adiw	r24, 0x01	; 1
     576:	9a 83       	std	Y+2, r25	; 0x02
     578:	89 83       	std	Y+1, r24	; 0x01
	}
     57a:	e2 cf       	rjmp	.-60     	; 0x540 <get_float+0x18>
	f = atof(k);
     57c:	ce 01       	movw	r24, r28
     57e:	07 96       	adiw	r24, 0x07	; 7
     580:	0e 94 ce 36 	call	0x6d9c	; 0x6d9c <atof>
     584:	dc 01       	movw	r26, r24
     586:	cb 01       	movw	r24, r22
     588:	8b 83       	std	Y+3, r24	; 0x03
     58a:	9c 83       	std	Y+4, r25	; 0x04
     58c:	ad 83       	std	Y+5, r26	; 0x05
     58e:	be 83       	std	Y+6, r27	; 0x06
	put_float(f);		// Echo print
     590:	8b 81       	ldd	r24, Y+3	; 0x03
     592:	9c 81       	ldd	r25, Y+4	; 0x04
     594:	ad 81       	ldd	r26, Y+5	; 0x05
     596:	be 81       	ldd	r27, Y+6	; 0x06
     598:	bc 01       	movw	r22, r24
     59a:	cd 01       	movw	r24, r26
     59c:	0e 94 4b 02 	call	0x496	; 0x496 <put_float>
	put_string("\n");
     5a0:	86 e0       	ldi	r24, 0x06	; 6
     5a2:	92 e0       	ldi	r25, 0x02	; 2
     5a4:	0e 94 df 01 	call	0x3be	; 0x3be <put_string>
	return f;
     5a8:	8b 81       	ldd	r24, Y+3	; 0x03
     5aa:	9c 81       	ldd	r25, Y+4	; 0x04
     5ac:	ad 81       	ldd	r26, Y+5	; 0x05
     5ae:	be 81       	ldd	r27, Y+6	; 0x06
}
     5b0:	bc 01       	movw	r22, r24
     5b2:	cd 01       	movw	r24, r26
     5b4:	6a 96       	adiw	r28, 0x1a	; 26
     5b6:	0f b6       	in	r0, 0x3f	; 63
     5b8:	f8 94       	cli
     5ba:	de bf       	out	0x3e, r29	; 62
     5bc:	0f be       	out	0x3f, r0	; 63
     5be:	cd bf       	out	0x3d, r28	; 61
     5c0:	df 91       	pop	r29
     5c2:	cf 91       	pop	r28
     5c4:	08 95       	ret

000005c6 <get_int>:

// Rx string  through USART
int get_int(void){
     5c6:	cf 93       	push	r28
     5c8:	df 93       	push	r29
     5ca:	cd b7       	in	r28, 0x3d	; 61
     5cc:	de b7       	in	r29, 0x3e	; 62
     5ce:	68 97       	sbiw	r28, 0x18	; 24
     5d0:	0f b6       	in	r0, 0x3f	; 63
     5d2:	f8 94       	cli
     5d4:	de bf       	out	0x3e, r29	; 62
     5d6:	0f be       	out	0x3f, r0	; 63
     5d8:	cd bf       	out	0x3d, r28	; 61
	char k[20];
	int data;
	int i = 0;
     5da:	1a 82       	std	Y+2, r1	; 0x02
     5dc:	19 82       	std	Y+1, r1	; 0x01
	while (1) {
		k[i] = get_char();
     5de:	0e 94 78 02 	call	0x4f0	; 0x4f0 <get_char>
     5e2:	48 2f       	mov	r20, r24
     5e4:	9e 01       	movw	r18, r28
     5e6:	2b 5f       	subi	r18, 0xFB	; 251
     5e8:	3f 4f       	sbci	r19, 0xFF	; 255
     5ea:	89 81       	ldd	r24, Y+1	; 0x01
     5ec:	9a 81       	ldd	r25, Y+2	; 0x02
     5ee:	82 0f       	add	r24, r18
     5f0:	93 1f       	adc	r25, r19
     5f2:	fc 01       	movw	r30, r24
     5f4:	40 83       	st	Z, r20
		if (k[i] == '\n') break;
     5f6:	9e 01       	movw	r18, r28
     5f8:	2b 5f       	subi	r18, 0xFB	; 251
     5fa:	3f 4f       	sbci	r19, 0xFF	; 255
     5fc:	89 81       	ldd	r24, Y+1	; 0x01
     5fe:	9a 81       	ldd	r25, Y+2	; 0x02
     600:	82 0f       	add	r24, r18
     602:	93 1f       	adc	r25, r19
     604:	fc 01       	movw	r30, r24
     606:	80 81       	ld	r24, Z
     608:	8a 30       	cpi	r24, 0x0A	; 10
     60a:	09 f4       	brne	.+2      	; 0x60e <get_int+0x48>
     60c:	06 c0       	rjmp	.+12     	; 0x61a <get_int+0x54>
		i++;
     60e:	89 81       	ldd	r24, Y+1	; 0x01
     610:	9a 81       	ldd	r25, Y+2	; 0x02
     612:	01 96       	adiw	r24, 0x01	; 1
     614:	9a 83       	std	Y+2, r25	; 0x02
     616:	89 83       	std	Y+1, r24	; 0x01
	}
     618:	e2 cf       	rjmp	.-60     	; 0x5de <get_int+0x18>
	data = atoi(k);			// ASCII to data int
     61a:	ce 01       	movw	r24, r28
     61c:	05 96       	adiw	r24, 0x05	; 5
     61e:	0e 94 d2 36 	call	0x6da4	; 0x6da4 <atoi>
     622:	9c 83       	std	Y+4, r25	; 0x04
     624:	8b 83       	std	Y+3, r24	; 0x03
	put_int(data);			// Echo print
     626:	8b 81       	ldd	r24, Y+3	; 0x03
     628:	9c 81       	ldd	r25, Y+4	; 0x04
     62a:	0e 94 00 02 	call	0x400	; 0x400 <put_int>
	put_string("\n");
     62e:	86 e0       	ldi	r24, 0x06	; 6
     630:	92 e0       	ldi	r25, 0x02	; 2
     632:	0e 94 df 01 	call	0x3be	; 0x3be <put_string>
	return data;
     636:	8b 81       	ldd	r24, Y+3	; 0x03
     638:	9c 81       	ldd	r25, Y+4	; 0x04
}
     63a:	68 96       	adiw	r28, 0x18	; 24
     63c:	0f b6       	in	r0, 0x3f	; 63
     63e:	f8 94       	cli
     640:	de bf       	out	0x3e, r29	; 62
     642:	0f be       	out	0x3f, r0	; 63
     644:	cd bf       	out	0x3d, r28	; 61
     646:	df 91       	pop	r29
     648:	cf 91       	pop	r28
     64a:	08 95       	ret

0000064c <i2c_init>:

/*************************************************************************
 Initialization of the I2C bus interface. Need to be called only once
*************************************************************************/
void i2c_init(void)
{
     64c:	cf 93       	push	r28
     64e:	df 93       	push	r29
     650:	cd b7       	in	r28, 0x3d	; 61
     652:	de b7       	in	r29, 0x3e	; 62
  /* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */

  TWSR = 0;                         /* no prescaler */
     654:	89 eb       	ldi	r24, 0xB9	; 185
     656:	90 e0       	ldi	r25, 0x00	; 0
     658:	fc 01       	movw	r30, r24
     65a:	10 82       	st	Z, r1
  TWBR = ((F_CPU/SCL_CLOCK)-16)/2;  /* must be > 10 for stable operation */
     65c:	88 eb       	ldi	r24, 0xB8	; 184
     65e:	90 e0       	ldi	r25, 0x00	; 0
     660:	28 e4       	ldi	r18, 0x48	; 72
     662:	fc 01       	movw	r30, r24
     664:	20 83       	st	Z, r18

}/* i2c_init */
     666:	df 91       	pop	r29
     668:	cf 91       	pop	r28
     66a:	08 95       	ret

0000066c <i2c_start>:
/*************************************************************************
  Issues a start condition and sends address and transfer direction.
  return 0 = device accessible, 1= failed to access device
*************************************************************************/
unsigned char i2c_start(unsigned char address)
{
     66c:	cf 93       	push	r28
     66e:	df 93       	push	r29
     670:	00 d0       	rcall	.+0      	; 0x672 <i2c_start+0x6>
     672:	00 d0       	rcall	.+0      	; 0x674 <i2c_start+0x8>
     674:	cd b7       	in	r28, 0x3d	; 61
     676:	de b7       	in	r29, 0x3e	; 62
     678:	8e 83       	std	Y+6, r24	; 0x06
	uint32_t  i2c_timer = 0;
     67a:	19 82       	std	Y+1, r1	; 0x01
     67c:	1a 82       	std	Y+2, r1	; 0x02
     67e:	1b 82       	std	Y+3, r1	; 0x03
     680:	1c 82       	std	Y+4, r1	; 0x04
    uint8_t   twst;

	// send START condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
     682:	8c eb       	ldi	r24, 0xBC	; 188
     684:	90 e0       	ldi	r25, 0x00	; 0
     686:	24 ea       	ldi	r18, 0xA4	; 164
     688:	fc 01       	movw	r30, r24
     68a:	20 83       	st	Z, r18

	// wait until transmission completed
	i2c_timer = I2C_TIMER_DELAY;
     68c:	8f ef       	ldi	r24, 0xFF	; 255
     68e:	90 e0       	ldi	r25, 0x00	; 0
     690:	a0 e0       	ldi	r26, 0x00	; 0
     692:	b0 e0       	ldi	r27, 0x00	; 0
     694:	89 83       	std	Y+1, r24	; 0x01
     696:	9a 83       	std	Y+2, r25	; 0x02
     698:	ab 83       	std	Y+3, r26	; 0x03
     69a:	bc 83       	std	Y+4, r27	; 0x04
	while(!(TWCR & (1<<TWINT)) && i2c_timer--);
     69c:	00 00       	nop
     69e:	8c eb       	ldi	r24, 0xBC	; 188
     6a0:	90 e0       	ldi	r25, 0x00	; 0
     6a2:	fc 01       	movw	r30, r24
     6a4:	80 81       	ld	r24, Z
     6a6:	88 23       	and	r24, r24
     6a8:	94 f0       	brlt	.+36     	; 0x6ce <i2c_start+0x62>
     6aa:	89 81       	ldd	r24, Y+1	; 0x01
     6ac:	9a 81       	ldd	r25, Y+2	; 0x02
     6ae:	ab 81       	ldd	r26, Y+3	; 0x03
     6b0:	bc 81       	ldd	r27, Y+4	; 0x04
     6b2:	9c 01       	movw	r18, r24
     6b4:	ad 01       	movw	r20, r26
     6b6:	21 50       	subi	r18, 0x01	; 1
     6b8:	31 09       	sbc	r19, r1
     6ba:	41 09       	sbc	r20, r1
     6bc:	51 09       	sbc	r21, r1
     6be:	29 83       	std	Y+1, r18	; 0x01
     6c0:	3a 83       	std	Y+2, r19	; 0x02
     6c2:	4b 83       	std	Y+3, r20	; 0x03
     6c4:	5c 83       	std	Y+4, r21	; 0x04
     6c6:	89 2b       	or	r24, r25
     6c8:	8a 2b       	or	r24, r26
     6ca:	8b 2b       	or	r24, r27
     6cc:	41 f7       	brne	.-48     	; 0x69e <i2c_start+0x32>
	if(i2c_timer == 0)
     6ce:	89 81       	ldd	r24, Y+1	; 0x01
     6d0:	9a 81       	ldd	r25, Y+2	; 0x02
     6d2:	ab 81       	ldd	r26, Y+3	; 0x03
     6d4:	bc 81       	ldd	r27, Y+4	; 0x04
     6d6:	89 2b       	or	r24, r25
     6d8:	8a 2b       	or	r24, r26
     6da:	8b 2b       	or	r24, r27
     6dc:	11 f4       	brne	.+4      	; 0x6e2 <i2c_start+0x76>
		return 1;
     6de:	81 e0       	ldi	r24, 0x01	; 1
     6e0:	52 c0       	rjmp	.+164    	; 0x786 <i2c_start+0x11a>

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
     6e2:	89 eb       	ldi	r24, 0xB9	; 185
     6e4:	90 e0       	ldi	r25, 0x00	; 0
     6e6:	fc 01       	movw	r30, r24
     6e8:	80 81       	ld	r24, Z
     6ea:	88 7f       	andi	r24, 0xF8	; 248
     6ec:	8d 83       	std	Y+5, r24	; 0x05
	if ( (twst != TW_START) && (twst != TW_REP_START)) return 1;
     6ee:	8d 81       	ldd	r24, Y+5	; 0x05
     6f0:	88 30       	cpi	r24, 0x08	; 8
     6f2:	29 f0       	breq	.+10     	; 0x6fe <i2c_start+0x92>
     6f4:	8d 81       	ldd	r24, Y+5	; 0x05
     6f6:	80 31       	cpi	r24, 0x10	; 16
     6f8:	11 f0       	breq	.+4      	; 0x6fe <i2c_start+0x92>
     6fa:	81 e0       	ldi	r24, 0x01	; 1
     6fc:	44 c0       	rjmp	.+136    	; 0x786 <i2c_start+0x11a>

	// send device address
	TWDR = address;
     6fe:	8b eb       	ldi	r24, 0xBB	; 187
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	2e 81       	ldd	r18, Y+6	; 0x06
     704:	fc 01       	movw	r30, r24
     706:	20 83       	st	Z, r18
	TWCR = (1<<TWINT) | (1<<TWEN);
     708:	8c eb       	ldi	r24, 0xBC	; 188
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	24 e8       	ldi	r18, 0x84	; 132
     70e:	fc 01       	movw	r30, r24
     710:	20 83       	st	Z, r18

	// wail until transmission completed and ACK/NACK has been received
	i2c_timer = I2C_TIMER_DELAY;
     712:	8f ef       	ldi	r24, 0xFF	; 255
     714:	90 e0       	ldi	r25, 0x00	; 0
     716:	a0 e0       	ldi	r26, 0x00	; 0
     718:	b0 e0       	ldi	r27, 0x00	; 0
     71a:	89 83       	std	Y+1, r24	; 0x01
     71c:	9a 83       	std	Y+2, r25	; 0x02
     71e:	ab 83       	std	Y+3, r26	; 0x03
     720:	bc 83       	std	Y+4, r27	; 0x04
	while(!(TWCR & (1<<TWINT)) && i2c_timer--);
     722:	00 00       	nop
     724:	8c eb       	ldi	r24, 0xBC	; 188
     726:	90 e0       	ldi	r25, 0x00	; 0
     728:	fc 01       	movw	r30, r24
     72a:	80 81       	ld	r24, Z
     72c:	88 23       	and	r24, r24
     72e:	94 f0       	brlt	.+36     	; 0x754 <i2c_start+0xe8>
     730:	89 81       	ldd	r24, Y+1	; 0x01
     732:	9a 81       	ldd	r25, Y+2	; 0x02
     734:	ab 81       	ldd	r26, Y+3	; 0x03
     736:	bc 81       	ldd	r27, Y+4	; 0x04
     738:	9c 01       	movw	r18, r24
     73a:	ad 01       	movw	r20, r26
     73c:	21 50       	subi	r18, 0x01	; 1
     73e:	31 09       	sbc	r19, r1
     740:	41 09       	sbc	r20, r1
     742:	51 09       	sbc	r21, r1
     744:	29 83       	std	Y+1, r18	; 0x01
     746:	3a 83       	std	Y+2, r19	; 0x02
     748:	4b 83       	std	Y+3, r20	; 0x03
     74a:	5c 83       	std	Y+4, r21	; 0x04
     74c:	89 2b       	or	r24, r25
     74e:	8a 2b       	or	r24, r26
     750:	8b 2b       	or	r24, r27
     752:	41 f7       	brne	.-48     	; 0x724 <i2c_start+0xb8>
	if(i2c_timer == 0)
     754:	89 81       	ldd	r24, Y+1	; 0x01
     756:	9a 81       	ldd	r25, Y+2	; 0x02
     758:	ab 81       	ldd	r26, Y+3	; 0x03
     75a:	bc 81       	ldd	r27, Y+4	; 0x04
     75c:	89 2b       	or	r24, r25
     75e:	8a 2b       	or	r24, r26
     760:	8b 2b       	or	r24, r27
     762:	11 f4       	brne	.+4      	; 0x768 <i2c_start+0xfc>
		return 1;
     764:	81 e0       	ldi	r24, 0x01	; 1
     766:	0f c0       	rjmp	.+30     	; 0x786 <i2c_start+0x11a>

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
     768:	89 eb       	ldi	r24, 0xB9	; 185
     76a:	90 e0       	ldi	r25, 0x00	; 0
     76c:	fc 01       	movw	r30, r24
     76e:	80 81       	ld	r24, Z
     770:	88 7f       	andi	r24, 0xF8	; 248
     772:	8d 83       	std	Y+5, r24	; 0x05
	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	88 31       	cpi	r24, 0x18	; 24
     778:	29 f0       	breq	.+10     	; 0x784 <i2c_start+0x118>
     77a:	8d 81       	ldd	r24, Y+5	; 0x05
     77c:	80 34       	cpi	r24, 0x40	; 64
     77e:	11 f0       	breq	.+4      	; 0x784 <i2c_start+0x118>
     780:	81 e0       	ldi	r24, 0x01	; 1
     782:	01 c0       	rjmp	.+2      	; 0x786 <i2c_start+0x11a>

	return 0;
     784:	80 e0       	ldi	r24, 0x00	; 0

}/* i2c_start */
     786:	26 96       	adiw	r28, 0x06	; 6
     788:	0f b6       	in	r0, 0x3f	; 63
     78a:	f8 94       	cli
     78c:	de bf       	out	0x3e, r29	; 62
     78e:	0f be       	out	0x3f, r0	; 63
     790:	cd bf       	out	0x3d, r28	; 61
     792:	df 91       	pop	r29
     794:	cf 91       	pop	r28
     796:	08 95       	ret

00000798 <i2c_start_wait>:
 If device is busy, use ack polling to wait until device is ready

 Input:   address and transfer direction of I2C device
*************************************************************************/
void i2c_start_wait(unsigned char address)
{
     798:	cf 93       	push	r28
     79a:	df 93       	push	r29
     79c:	00 d0       	rcall	.+0      	; 0x79e <i2c_start_wait+0x6>
     79e:	00 d0       	rcall	.+0      	; 0x7a0 <i2c_start_wait+0x8>
     7a0:	cd b7       	in	r28, 0x3d	; 61
     7a2:	de b7       	in	r29, 0x3e	; 62
     7a4:	8e 83       	std	Y+6, r24	; 0x06
	uint32_t  i2c_timer = 0;
     7a6:	19 82       	std	Y+1, r1	; 0x01
     7a8:	1a 82       	std	Y+2, r1	; 0x02
     7aa:	1b 82       	std	Y+3, r1	; 0x03
     7ac:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t   twst;

    while ( 1 )
    {
	    // send START condition
	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
     7ae:	8c eb       	ldi	r24, 0xBC	; 188
     7b0:	90 e0       	ldi	r25, 0x00	; 0
     7b2:	24 ea       	ldi	r18, 0xA4	; 164
     7b4:	fc 01       	movw	r30, r24
     7b6:	20 83       	st	Z, r18

    	// wait until transmission completed
	    i2c_timer = I2C_TIMER_DELAY;
     7b8:	8f ef       	ldi	r24, 0xFF	; 255
     7ba:	90 e0       	ldi	r25, 0x00	; 0
     7bc:	a0 e0       	ldi	r26, 0x00	; 0
     7be:	b0 e0       	ldi	r27, 0x00	; 0
     7c0:	89 83       	std	Y+1, r24	; 0x01
     7c2:	9a 83       	std	Y+2, r25	; 0x02
     7c4:	ab 83       	std	Y+3, r26	; 0x03
     7c6:	bc 83       	std	Y+4, r27	; 0x04
    	while(!(TWCR & (1<<TWINT)) && i2c_timer--);
     7c8:	00 00       	nop
     7ca:	8c eb       	ldi	r24, 0xBC	; 188
     7cc:	90 e0       	ldi	r25, 0x00	; 0
     7ce:	fc 01       	movw	r30, r24
     7d0:	80 81       	ld	r24, Z
     7d2:	88 23       	and	r24, r24
     7d4:	94 f0       	brlt	.+36     	; 0x7fa <i2c_start_wait+0x62>
     7d6:	89 81       	ldd	r24, Y+1	; 0x01
     7d8:	9a 81       	ldd	r25, Y+2	; 0x02
     7da:	ab 81       	ldd	r26, Y+3	; 0x03
     7dc:	bc 81       	ldd	r27, Y+4	; 0x04
     7de:	9c 01       	movw	r18, r24
     7e0:	ad 01       	movw	r20, r26
     7e2:	21 50       	subi	r18, 0x01	; 1
     7e4:	31 09       	sbc	r19, r1
     7e6:	41 09       	sbc	r20, r1
     7e8:	51 09       	sbc	r21, r1
     7ea:	29 83       	std	Y+1, r18	; 0x01
     7ec:	3a 83       	std	Y+2, r19	; 0x02
     7ee:	4b 83       	std	Y+3, r20	; 0x03
     7f0:	5c 83       	std	Y+4, r21	; 0x04
     7f2:	89 2b       	or	r24, r25
     7f4:	8a 2b       	or	r24, r26
     7f6:	8b 2b       	or	r24, r27
     7f8:	41 f7       	brne	.-48     	; 0x7ca <i2c_start_wait+0x32>

    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
     7fa:	89 eb       	ldi	r24, 0xB9	; 185
     7fc:	90 e0       	ldi	r25, 0x00	; 0
     7fe:	fc 01       	movw	r30, r24
     800:	80 81       	ld	r24, Z
     802:	88 7f       	andi	r24, 0xF8	; 248
     804:	8d 83       	std	Y+5, r24	; 0x05
    	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
     806:	8d 81       	ldd	r24, Y+5	; 0x05
     808:	88 30       	cpi	r24, 0x08	; 8
     80a:	21 f0       	breq	.+8      	; 0x814 <i2c_start_wait+0x7c>
     80c:	8d 81       	ldd	r24, Y+5	; 0x05
     80e:	80 31       	cpi	r24, 0x10	; 16
     810:	09 f0       	breq	.+2      	; 0x814 <i2c_start_wait+0x7c>
     812:	63 c0       	rjmp	.+198    	; 0x8da <i2c_start_wait+0x142>

    	// send device address
    	TWDR = address;
     814:	8b eb       	ldi	r24, 0xBB	; 187
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	2e 81       	ldd	r18, Y+6	; 0x06
     81a:	fc 01       	movw	r30, r24
     81c:	20 83       	st	Z, r18
    	TWCR = (1<<TWINT) | (1<<TWEN);
     81e:	8c eb       	ldi	r24, 0xBC	; 188
     820:	90 e0       	ldi	r25, 0x00	; 0
     822:	24 e8       	ldi	r18, 0x84	; 132
     824:	fc 01       	movw	r30, r24
     826:	20 83       	st	Z, r18

    	// wail until transmission completed
    	i2c_timer = I2C_TIMER_DELAY;
     828:	8f ef       	ldi	r24, 0xFF	; 255
     82a:	90 e0       	ldi	r25, 0x00	; 0
     82c:	a0 e0       	ldi	r26, 0x00	; 0
     82e:	b0 e0       	ldi	r27, 0x00	; 0
     830:	89 83       	std	Y+1, r24	; 0x01
     832:	9a 83       	std	Y+2, r25	; 0x02
     834:	ab 83       	std	Y+3, r26	; 0x03
     836:	bc 83       	std	Y+4, r27	; 0x04
    	while(!(TWCR & (1<<TWINT)) && i2c_timer--);
     838:	00 00       	nop
     83a:	8c eb       	ldi	r24, 0xBC	; 188
     83c:	90 e0       	ldi	r25, 0x00	; 0
     83e:	fc 01       	movw	r30, r24
     840:	80 81       	ld	r24, Z
     842:	88 23       	and	r24, r24
     844:	94 f0       	brlt	.+36     	; 0x86a <i2c_start_wait+0xd2>
     846:	89 81       	ldd	r24, Y+1	; 0x01
     848:	9a 81       	ldd	r25, Y+2	; 0x02
     84a:	ab 81       	ldd	r26, Y+3	; 0x03
     84c:	bc 81       	ldd	r27, Y+4	; 0x04
     84e:	9c 01       	movw	r18, r24
     850:	ad 01       	movw	r20, r26
     852:	21 50       	subi	r18, 0x01	; 1
     854:	31 09       	sbc	r19, r1
     856:	41 09       	sbc	r20, r1
     858:	51 09       	sbc	r21, r1
     85a:	29 83       	std	Y+1, r18	; 0x01
     85c:	3a 83       	std	Y+2, r19	; 0x02
     85e:	4b 83       	std	Y+3, r20	; 0x03
     860:	5c 83       	std	Y+4, r21	; 0x04
     862:	89 2b       	or	r24, r25
     864:	8a 2b       	or	r24, r26
     866:	8b 2b       	or	r24, r27
     868:	41 f7       	brne	.-48     	; 0x83a <i2c_start_wait+0xa2>

    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
     86a:	89 eb       	ldi	r24, 0xB9	; 185
     86c:	90 e0       	ldi	r25, 0x00	; 0
     86e:	fc 01       	movw	r30, r24
     870:	80 81       	ld	r24, Z
     872:	88 7f       	andi	r24, 0xF8	; 248
     874:	8d 83       	std	Y+5, r24	; 0x05
    	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) )
     876:	8d 81       	ldd	r24, Y+5	; 0x05
     878:	80 32       	cpi	r24, 0x20	; 32
     87a:	19 f0       	breq	.+6      	; 0x882 <i2c_start_wait+0xea>
     87c:	8d 81       	ldd	r24, Y+5	; 0x05
     87e:	88 35       	cpi	r24, 0x58	; 88
     880:	59 f5       	brne	.+86     	; 0x8d8 <i2c_start_wait+0x140>
    	{
    	    /* device busy, send stop condition to terminate write operation */
	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
     882:	8c eb       	ldi	r24, 0xBC	; 188
     884:	90 e0       	ldi	r25, 0x00	; 0
     886:	24 e9       	ldi	r18, 0x94	; 148
     888:	fc 01       	movw	r30, r24
     88a:	20 83       	st	Z, r18

	        // wait until stop condition is executed and bus released
	        i2c_timer = I2C_TIMER_DELAY;
     88c:	8f ef       	ldi	r24, 0xFF	; 255
     88e:	90 e0       	ldi	r25, 0x00	; 0
     890:	a0 e0       	ldi	r26, 0x00	; 0
     892:	b0 e0       	ldi	r27, 0x00	; 0
     894:	89 83       	std	Y+1, r24	; 0x01
     896:	9a 83       	std	Y+2, r25	; 0x02
     898:	ab 83       	std	Y+3, r26	; 0x03
     89a:	bc 83       	std	Y+4, r27	; 0x04
	        while((TWCR & (1<<TWSTO)) && i2c_timer--);
     89c:	00 00       	nop
     89e:	8c eb       	ldi	r24, 0xBC	; 188
     8a0:	90 e0       	ldi	r25, 0x00	; 0
     8a2:	fc 01       	movw	r30, r24
     8a4:	80 81       	ld	r24, Z
     8a6:	88 2f       	mov	r24, r24
     8a8:	90 e0       	ldi	r25, 0x00	; 0
     8aa:	80 71       	andi	r24, 0x10	; 16
     8ac:	99 27       	eor	r25, r25
     8ae:	89 2b       	or	r24, r25
     8b0:	91 f0       	breq	.+36     	; 0x8d6 <i2c_start_wait+0x13e>
     8b2:	89 81       	ldd	r24, Y+1	; 0x01
     8b4:	9a 81       	ldd	r25, Y+2	; 0x02
     8b6:	ab 81       	ldd	r26, Y+3	; 0x03
     8b8:	bc 81       	ldd	r27, Y+4	; 0x04
     8ba:	9c 01       	movw	r18, r24
     8bc:	ad 01       	movw	r20, r26
     8be:	21 50       	subi	r18, 0x01	; 1
     8c0:	31 09       	sbc	r19, r1
     8c2:	41 09       	sbc	r20, r1
     8c4:	51 09       	sbc	r21, r1
     8c6:	29 83       	std	Y+1, r18	; 0x01
     8c8:	3a 83       	std	Y+2, r19	; 0x02
     8ca:	4b 83       	std	Y+3, r20	; 0x03
     8cc:	5c 83       	std	Y+4, r21	; 0x04
     8ce:	89 2b       	or	r24, r25
     8d0:	8a 2b       	or	r24, r26
     8d2:	8b 2b       	or	r24, r27
     8d4:	21 f7       	brne	.-56     	; 0x89e <i2c_start_wait+0x106>

    	    continue;
     8d6:	01 c0       	rjmp	.+2      	; 0x8da <i2c_start_wait+0x142>
    	}
    	//if( twst != TW_MT_SLA_ACK) return 1;
    	break;
     8d8:	01 c0       	rjmp	.+2      	; 0x8dc <i2c_start_wait+0x144>
     }
     8da:	69 cf       	rjmp	.-302    	; 0x7ae <i2c_start_wait+0x16>

}/* i2c_start_wait */
     8dc:	26 96       	adiw	r28, 0x06	; 6
     8de:	0f b6       	in	r0, 0x3f	; 63
     8e0:	f8 94       	cli
     8e2:	de bf       	out	0x3e, r29	; 62
     8e4:	0f be       	out	0x3f, r0	; 63
     8e6:	cd bf       	out	0x3d, r28	; 61
     8e8:	df 91       	pop	r29
     8ea:	cf 91       	pop	r28
     8ec:	08 95       	ret

000008ee <i2c_rep_start>:

 Return:  0 device accessible
          1 failed to access device
*************************************************************************/
unsigned char i2c_rep_start(unsigned char address)
{
     8ee:	cf 93       	push	r28
     8f0:	df 93       	push	r29
     8f2:	1f 92       	push	r1
     8f4:	cd b7       	in	r28, 0x3d	; 61
     8f6:	de b7       	in	r29, 0x3e	; 62
     8f8:	89 83       	std	Y+1, r24	; 0x01
    return i2c_start( address );
     8fa:	89 81       	ldd	r24, Y+1	; 0x01
     8fc:	0e 94 36 03 	call	0x66c	; 0x66c <i2c_start>

}/* i2c_rep_start */
     900:	0f 90       	pop	r0
     902:	df 91       	pop	r29
     904:	cf 91       	pop	r28
     906:	08 95       	ret

00000908 <i2c_stop>:

/*************************************************************************
 Terminates the data transfer and releases the I2C bus
*************************************************************************/
void i2c_stop(void)
{
     908:	cf 93       	push	r28
     90a:	df 93       	push	r29
     90c:	00 d0       	rcall	.+0      	; 0x90e <i2c_stop+0x6>
     90e:	1f 92       	push	r1
     910:	cd b7       	in	r28, 0x3d	; 61
     912:	de b7       	in	r29, 0x3e	; 62
	uint32_t  i2c_timer = 0;
     914:	19 82       	std	Y+1, r1	; 0x01
     916:	1a 82       	std	Y+2, r1	; 0x02
     918:	1b 82       	std	Y+3, r1	; 0x03
     91a:	1c 82       	std	Y+4, r1	; 0x04

    /* send stop condition */
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
     91c:	8c eb       	ldi	r24, 0xBC	; 188
     91e:	90 e0       	ldi	r25, 0x00	; 0
     920:	24 e9       	ldi	r18, 0x94	; 148
     922:	fc 01       	movw	r30, r24
     924:	20 83       	st	Z, r18

	// wait until stop condition is executed and bus released
	i2c_timer = I2C_TIMER_DELAY;
     926:	8f ef       	ldi	r24, 0xFF	; 255
     928:	90 e0       	ldi	r25, 0x00	; 0
     92a:	a0 e0       	ldi	r26, 0x00	; 0
     92c:	b0 e0       	ldi	r27, 0x00	; 0
     92e:	89 83       	std	Y+1, r24	; 0x01
     930:	9a 83       	std	Y+2, r25	; 0x02
     932:	ab 83       	std	Y+3, r26	; 0x03
     934:	bc 83       	std	Y+4, r27	; 0x04
	while((TWCR & (1<<TWSTO)) && i2c_timer--);
     936:	00 00       	nop
     938:	8c eb       	ldi	r24, 0xBC	; 188
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	fc 01       	movw	r30, r24
     93e:	80 81       	ld	r24, Z
     940:	88 2f       	mov	r24, r24
     942:	90 e0       	ldi	r25, 0x00	; 0
     944:	80 71       	andi	r24, 0x10	; 16
     946:	99 27       	eor	r25, r25
     948:	89 2b       	or	r24, r25
     94a:	91 f0       	breq	.+36     	; 0x970 <i2c_stop+0x68>
     94c:	89 81       	ldd	r24, Y+1	; 0x01
     94e:	9a 81       	ldd	r25, Y+2	; 0x02
     950:	ab 81       	ldd	r26, Y+3	; 0x03
     952:	bc 81       	ldd	r27, Y+4	; 0x04
     954:	9c 01       	movw	r18, r24
     956:	ad 01       	movw	r20, r26
     958:	21 50       	subi	r18, 0x01	; 1
     95a:	31 09       	sbc	r19, r1
     95c:	41 09       	sbc	r20, r1
     95e:	51 09       	sbc	r21, r1
     960:	29 83       	std	Y+1, r18	; 0x01
     962:	3a 83       	std	Y+2, r19	; 0x02
     964:	4b 83       	std	Y+3, r20	; 0x03
     966:	5c 83       	std	Y+4, r21	; 0x04
     968:	89 2b       	or	r24, r25
     96a:	8a 2b       	or	r24, r26
     96c:	8b 2b       	or	r24, r27
     96e:	21 f7       	brne	.-56     	; 0x938 <i2c_stop+0x30>

}/* i2c_stop */
     970:	0f 90       	pop	r0
     972:	0f 90       	pop	r0
     974:	0f 90       	pop	r0
     976:	0f 90       	pop	r0
     978:	df 91       	pop	r29
     97a:	cf 91       	pop	r28
     97c:	08 95       	ret

0000097e <i2c_write>:
  Input:    byte to be transfered
  Return:   0 write successful
            1 write failed
*************************************************************************/
unsigned char i2c_write( unsigned char data )
{
     97e:	cf 93       	push	r28
     980:	df 93       	push	r29
     982:	00 d0       	rcall	.+0      	; 0x984 <i2c_write+0x6>
     984:	00 d0       	rcall	.+0      	; 0x986 <i2c_write+0x8>
     986:	cd b7       	in	r28, 0x3d	; 61
     988:	de b7       	in	r29, 0x3e	; 62
     98a:	8e 83       	std	Y+6, r24	; 0x06
	uint32_t  i2c_timer = 0;
     98c:	19 82       	std	Y+1, r1	; 0x01
     98e:	1a 82       	std	Y+2, r1	; 0x02
     990:	1b 82       	std	Y+3, r1	; 0x03
     992:	1c 82       	std	Y+4, r1	; 0x04
    uint8_t   twst;

	// send data to the previously addressed device
	TWDR = data;
     994:	8b eb       	ldi	r24, 0xBB	; 187
     996:	90 e0       	ldi	r25, 0x00	; 0
     998:	2e 81       	ldd	r18, Y+6	; 0x06
     99a:	fc 01       	movw	r30, r24
     99c:	20 83       	st	Z, r18
	TWCR = (1<<TWINT) | (1<<TWEN);
     99e:	8c eb       	ldi	r24, 0xBC	; 188
     9a0:	90 e0       	ldi	r25, 0x00	; 0
     9a2:	24 e8       	ldi	r18, 0x84	; 132
     9a4:	fc 01       	movw	r30, r24
     9a6:	20 83       	st	Z, r18

	// wait until transmission completed
	i2c_timer = I2C_TIMER_DELAY;
     9a8:	8f ef       	ldi	r24, 0xFF	; 255
     9aa:	90 e0       	ldi	r25, 0x00	; 0
     9ac:	a0 e0       	ldi	r26, 0x00	; 0
     9ae:	b0 e0       	ldi	r27, 0x00	; 0
     9b0:	89 83       	std	Y+1, r24	; 0x01
     9b2:	9a 83       	std	Y+2, r25	; 0x02
     9b4:	ab 83       	std	Y+3, r26	; 0x03
     9b6:	bc 83       	std	Y+4, r27	; 0x04
	while(!(TWCR & (1<<TWINT)) && i2c_timer--);
     9b8:	00 00       	nop
     9ba:	8c eb       	ldi	r24, 0xBC	; 188
     9bc:	90 e0       	ldi	r25, 0x00	; 0
     9be:	fc 01       	movw	r30, r24
     9c0:	80 81       	ld	r24, Z
     9c2:	88 23       	and	r24, r24
     9c4:	94 f0       	brlt	.+36     	; 0x9ea <i2c_write+0x6c>
     9c6:	89 81       	ldd	r24, Y+1	; 0x01
     9c8:	9a 81       	ldd	r25, Y+2	; 0x02
     9ca:	ab 81       	ldd	r26, Y+3	; 0x03
     9cc:	bc 81       	ldd	r27, Y+4	; 0x04
     9ce:	9c 01       	movw	r18, r24
     9d0:	ad 01       	movw	r20, r26
     9d2:	21 50       	subi	r18, 0x01	; 1
     9d4:	31 09       	sbc	r19, r1
     9d6:	41 09       	sbc	r20, r1
     9d8:	51 09       	sbc	r21, r1
     9da:	29 83       	std	Y+1, r18	; 0x01
     9dc:	3a 83       	std	Y+2, r19	; 0x02
     9de:	4b 83       	std	Y+3, r20	; 0x03
     9e0:	5c 83       	std	Y+4, r21	; 0x04
     9e2:	89 2b       	or	r24, r25
     9e4:	8a 2b       	or	r24, r26
     9e6:	8b 2b       	or	r24, r27
     9e8:	41 f7       	brne	.-48     	; 0x9ba <i2c_write+0x3c>
	if(i2c_timer == 0)
     9ea:	89 81       	ldd	r24, Y+1	; 0x01
     9ec:	9a 81       	ldd	r25, Y+2	; 0x02
     9ee:	ab 81       	ldd	r26, Y+3	; 0x03
     9f0:	bc 81       	ldd	r27, Y+4	; 0x04
     9f2:	89 2b       	or	r24, r25
     9f4:	8a 2b       	or	r24, r26
     9f6:	8b 2b       	or	r24, r27
     9f8:	11 f4       	brne	.+4      	; 0x9fe <i2c_write+0x80>
		return 1;
     9fa:	81 e0       	ldi	r24, 0x01	; 1
     9fc:	0c c0       	rjmp	.+24     	; 0xa16 <i2c_write+0x98>

	// check value of TWI Status Register. Mask prescaler bits
	twst = TW_STATUS & 0xF8;
     9fe:	89 eb       	ldi	r24, 0xB9	; 185
     a00:	90 e0       	ldi	r25, 0x00	; 0
     a02:	fc 01       	movw	r30, r24
     a04:	80 81       	ld	r24, Z
     a06:	88 7f       	andi	r24, 0xF8	; 248
     a08:	8d 83       	std	Y+5, r24	; 0x05
	if( twst != TW_MT_DATA_ACK) return 1;
     a0a:	8d 81       	ldd	r24, Y+5	; 0x05
     a0c:	88 32       	cpi	r24, 0x28	; 40
     a0e:	11 f0       	breq	.+4      	; 0xa14 <i2c_write+0x96>
     a10:	81 e0       	ldi	r24, 0x01	; 1
     a12:	01 c0       	rjmp	.+2      	; 0xa16 <i2c_write+0x98>
	return 0;
     a14:	80 e0       	ldi	r24, 0x00	; 0

}/* i2c_write */
     a16:	26 96       	adiw	r28, 0x06	; 6
     a18:	0f b6       	in	r0, 0x3f	; 63
     a1a:	f8 94       	cli
     a1c:	de bf       	out	0x3e, r29	; 62
     a1e:	0f be       	out	0x3f, r0	; 63
     a20:	cd bf       	out	0x3d, r28	; 61
     a22:	df 91       	pop	r29
     a24:	cf 91       	pop	r28
     a26:	08 95       	ret

00000a28 <i2c_readAck>:
 Read one byte from the I2C device, request more data from device

 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readAck(void)
{
     a28:	cf 93       	push	r28
     a2a:	df 93       	push	r29
     a2c:	00 d0       	rcall	.+0      	; 0xa2e <i2c_readAck+0x6>
     a2e:	1f 92       	push	r1
     a30:	cd b7       	in	r28, 0x3d	; 61
     a32:	de b7       	in	r29, 0x3e	; 62
	uint32_t  i2c_timer = 0;
     a34:	19 82       	std	Y+1, r1	; 0x01
     a36:	1a 82       	std	Y+2, r1	; 0x02
     a38:	1b 82       	std	Y+3, r1	; 0x03
     a3a:	1c 82       	std	Y+4, r1	; 0x04

	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
     a3c:	8c eb       	ldi	r24, 0xBC	; 188
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	24 ec       	ldi	r18, 0xC4	; 196
     a42:	fc 01       	movw	r30, r24
     a44:	20 83       	st	Z, r18
	i2c_timer = I2C_TIMER_DELAY;
     a46:	8f ef       	ldi	r24, 0xFF	; 255
     a48:	90 e0       	ldi	r25, 0x00	; 0
     a4a:	a0 e0       	ldi	r26, 0x00	; 0
     a4c:	b0 e0       	ldi	r27, 0x00	; 0
     a4e:	89 83       	std	Y+1, r24	; 0x01
     a50:	9a 83       	std	Y+2, r25	; 0x02
     a52:	ab 83       	std	Y+3, r26	; 0x03
     a54:	bc 83       	std	Y+4, r27	; 0x04
	while(!(TWCR & (1<<TWINT)) && i2c_timer--);
     a56:	00 00       	nop
     a58:	8c eb       	ldi	r24, 0xBC	; 188
     a5a:	90 e0       	ldi	r25, 0x00	; 0
     a5c:	fc 01       	movw	r30, r24
     a5e:	80 81       	ld	r24, Z
     a60:	88 23       	and	r24, r24
     a62:	94 f0       	brlt	.+36     	; 0xa88 <i2c_readAck+0x60>
     a64:	89 81       	ldd	r24, Y+1	; 0x01
     a66:	9a 81       	ldd	r25, Y+2	; 0x02
     a68:	ab 81       	ldd	r26, Y+3	; 0x03
     a6a:	bc 81       	ldd	r27, Y+4	; 0x04
     a6c:	9c 01       	movw	r18, r24
     a6e:	ad 01       	movw	r20, r26
     a70:	21 50       	subi	r18, 0x01	; 1
     a72:	31 09       	sbc	r19, r1
     a74:	41 09       	sbc	r20, r1
     a76:	51 09       	sbc	r21, r1
     a78:	29 83       	std	Y+1, r18	; 0x01
     a7a:	3a 83       	std	Y+2, r19	; 0x02
     a7c:	4b 83       	std	Y+3, r20	; 0x03
     a7e:	5c 83       	std	Y+4, r21	; 0x04
     a80:	89 2b       	or	r24, r25
     a82:	8a 2b       	or	r24, r26
     a84:	8b 2b       	or	r24, r27
     a86:	41 f7       	brne	.-48     	; 0xa58 <i2c_readAck+0x30>
	if(i2c_timer == 0)
     a88:	89 81       	ldd	r24, Y+1	; 0x01
     a8a:	9a 81       	ldd	r25, Y+2	; 0x02
     a8c:	ab 81       	ldd	r26, Y+3	; 0x03
     a8e:	bc 81       	ldd	r27, Y+4	; 0x04
     a90:	89 2b       	or	r24, r25
     a92:	8a 2b       	or	r24, r26
     a94:	8b 2b       	or	r24, r27
     a96:	11 f4       	brne	.+4      	; 0xa9c <i2c_readAck+0x74>
		return 0;
     a98:	80 e0       	ldi	r24, 0x00	; 0
     a9a:	04 c0       	rjmp	.+8      	; 0xaa4 <i2c_readAck+0x7c>

    return TWDR;
     a9c:	8b eb       	ldi	r24, 0xBB	; 187
     a9e:	90 e0       	ldi	r25, 0x00	; 0
     aa0:	fc 01       	movw	r30, r24
     aa2:	80 81       	ld	r24, Z

}/* i2c_readAck */
     aa4:	0f 90       	pop	r0
     aa6:	0f 90       	pop	r0
     aa8:	0f 90       	pop	r0
     aaa:	0f 90       	pop	r0
     aac:	df 91       	pop	r29
     aae:	cf 91       	pop	r28
     ab0:	08 95       	ret

00000ab2 <i2c_readNak>:
 Read one byte from the I2C device, read is followed by a stop condition

 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readNak(void)
{
     ab2:	cf 93       	push	r28
     ab4:	df 93       	push	r29
     ab6:	00 d0       	rcall	.+0      	; 0xab8 <i2c_readNak+0x6>
     ab8:	1f 92       	push	r1
     aba:	cd b7       	in	r28, 0x3d	; 61
     abc:	de b7       	in	r29, 0x3e	; 62
	uint32_t  i2c_timer = 0;
     abe:	19 82       	std	Y+1, r1	; 0x01
     ac0:	1a 82       	std	Y+2, r1	; 0x02
     ac2:	1b 82       	std	Y+3, r1	; 0x03
     ac4:	1c 82       	std	Y+4, r1	; 0x04

	TWCR = (1<<TWINT) | (1<<TWEN);
     ac6:	8c eb       	ldi	r24, 0xBC	; 188
     ac8:	90 e0       	ldi	r25, 0x00	; 0
     aca:	24 e8       	ldi	r18, 0x84	; 132
     acc:	fc 01       	movw	r30, r24
     ace:	20 83       	st	Z, r18
	i2c_timer = I2C_TIMER_DELAY;
     ad0:	8f ef       	ldi	r24, 0xFF	; 255
     ad2:	90 e0       	ldi	r25, 0x00	; 0
     ad4:	a0 e0       	ldi	r26, 0x00	; 0
     ad6:	b0 e0       	ldi	r27, 0x00	; 0
     ad8:	89 83       	std	Y+1, r24	; 0x01
     ada:	9a 83       	std	Y+2, r25	; 0x02
     adc:	ab 83       	std	Y+3, r26	; 0x03
     ade:	bc 83       	std	Y+4, r27	; 0x04
	while(!(TWCR & (1<<TWINT)) && i2c_timer--);
     ae0:	00 00       	nop
     ae2:	8c eb       	ldi	r24, 0xBC	; 188
     ae4:	90 e0       	ldi	r25, 0x00	; 0
     ae6:	fc 01       	movw	r30, r24
     ae8:	80 81       	ld	r24, Z
     aea:	88 23       	and	r24, r24
     aec:	94 f0       	brlt	.+36     	; 0xb12 <i2c_readNak+0x60>
     aee:	89 81       	ldd	r24, Y+1	; 0x01
     af0:	9a 81       	ldd	r25, Y+2	; 0x02
     af2:	ab 81       	ldd	r26, Y+3	; 0x03
     af4:	bc 81       	ldd	r27, Y+4	; 0x04
     af6:	9c 01       	movw	r18, r24
     af8:	ad 01       	movw	r20, r26
     afa:	21 50       	subi	r18, 0x01	; 1
     afc:	31 09       	sbc	r19, r1
     afe:	41 09       	sbc	r20, r1
     b00:	51 09       	sbc	r21, r1
     b02:	29 83       	std	Y+1, r18	; 0x01
     b04:	3a 83       	std	Y+2, r19	; 0x02
     b06:	4b 83       	std	Y+3, r20	; 0x03
     b08:	5c 83       	std	Y+4, r21	; 0x04
     b0a:	89 2b       	or	r24, r25
     b0c:	8a 2b       	or	r24, r26
     b0e:	8b 2b       	or	r24, r27
     b10:	41 f7       	brne	.-48     	; 0xae2 <i2c_readNak+0x30>
	if(i2c_timer == 0)
     b12:	89 81       	ldd	r24, Y+1	; 0x01
     b14:	9a 81       	ldd	r25, Y+2	; 0x02
     b16:	ab 81       	ldd	r26, Y+3	; 0x03
     b18:	bc 81       	ldd	r27, Y+4	; 0x04
     b1a:	89 2b       	or	r24, r25
     b1c:	8a 2b       	or	r24, r26
     b1e:	8b 2b       	or	r24, r27
     b20:	11 f4       	brne	.+4      	; 0xb26 <i2c_readNak+0x74>
		return 0;
     b22:	80 e0       	ldi	r24, 0x00	; 0
     b24:	04 c0       	rjmp	.+8      	; 0xb2e <i2c_readNak+0x7c>

    return TWDR;
     b26:	8b eb       	ldi	r24, 0xBB	; 187
     b28:	90 e0       	ldi	r25, 0x00	; 0
     b2a:	fc 01       	movw	r30, r24
     b2c:	80 81       	ld	r24, Z

}/* i2c_readNak */
     b2e:	0f 90       	pop	r0
     b30:	0f 90       	pop	r0
     b32:	0f 90       	pop	r0
     b34:	0f 90       	pop	r0
     b36:	df 91       	pop	r29
     b38:	cf 91       	pop	r28
     b3a:	08 95       	ret

00000b3c <rf_int>:
#include "../SPI/spi.h"

// Flag which denotes transmitting mode
volatile uint8_t PTX;

void rf_int(void){
     b3c:	cf 93       	push	r28
     b3e:	df 93       	push	r29
     b40:	cd b7       	in	r28, 0x3d	; 61
     b42:	de b7       	in	r29, 0x3e	; 62
	//set output pin
	DDRL |= (1<<CE)|(1<<CSN);
     b44:	8a e0       	ldi	r24, 0x0A	; 10
     b46:	91 e0       	ldi	r25, 0x01	; 1
     b48:	2a e0       	ldi	r18, 0x0A	; 10
     b4a:	31 e0       	ldi	r19, 0x01	; 1
     b4c:	f9 01       	movw	r30, r18
     b4e:	20 81       	ld	r18, Z
     b50:	23 60       	ori	r18, 0x03	; 3
     b52:	fc 01       	movw	r30, r24
     b54:	20 83       	st	Z, r18

	PORTL |= (1<<CSN);
     b56:	8b e0       	ldi	r24, 0x0B	; 11
     b58:	91 e0       	ldi	r25, 0x01	; 1
     b5a:	2b e0       	ldi	r18, 0x0B	; 11
     b5c:	31 e0       	ldi	r19, 0x01	; 1
     b5e:	f9 01       	movw	r30, r18
     b60:	20 81       	ld	r18, Z
     b62:	22 60       	ori	r18, 0x02	; 2
     b64:	fc 01       	movw	r30, r24
     b66:	20 83       	st	Z, r18
	PORTL &= ~(1<<CE);
     b68:	8b e0       	ldi	r24, 0x0B	; 11
     b6a:	91 e0       	ldi	r25, 0x01	; 1
     b6c:	2b e0       	ldi	r18, 0x0B	; 11
     b6e:	31 e0       	ldi	r19, 0x01	; 1
     b70:	f9 01       	movw	r30, r18
     b72:	20 81       	ld	r18, Z
     b74:	2e 7f       	andi	r18, 0xFE	; 254
     b76:	fc 01       	movw	r30, r24
     b78:	20 83       	st	Z, r18

	//set interrupt in pin PWM 10
	PORTB &= ~(1<<PB4);
     b7a:	85 e2       	ldi	r24, 0x25	; 37
     b7c:	90 e0       	ldi	r25, 0x00	; 0
     b7e:	25 e2       	ldi	r18, 0x25	; 37
     b80:	30 e0       	ldi	r19, 0x00	; 0
     b82:	f9 01       	movw	r30, r18
     b84:	20 81       	ld	r18, Z
     b86:	2f 7e       	andi	r18, 0xEF	; 239
     b88:	fc 01       	movw	r30, r24
     b8a:	20 83       	st	Z, r18
	PCICR  |= (1<<PCIE0);
     b8c:	88 e6       	ldi	r24, 0x68	; 104
     b8e:	90 e0       	ldi	r25, 0x00	; 0
     b90:	28 e6       	ldi	r18, 0x68	; 104
     b92:	30 e0       	ldi	r19, 0x00	; 0
     b94:	f9 01       	movw	r30, r18
     b96:	20 81       	ld	r18, Z
     b98:	21 60       	ori	r18, 0x01	; 1
     b9a:	fc 01       	movw	r30, r24
     b9c:	20 83       	st	Z, r18
	PCMSK0 |= (1<<PCINT4);
     b9e:	8b e6       	ldi	r24, 0x6B	; 107
     ba0:	90 e0       	ldi	r25, 0x00	; 0
     ba2:	2b e6       	ldi	r18, 0x6B	; 107
     ba4:	30 e0       	ldi	r19, 0x00	; 0
     ba6:	f9 01       	movw	r30, r18
     ba8:	20 81       	ld	r18, Z
     baa:	20 61       	ori	r18, 0x10	; 16
     bac:	fc 01       	movw	r30, r24
     bae:	20 83       	st	Z, r18

	//inizialize spi
	init_spi();
     bb0:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <init_spi>
}
     bb4:	df 91       	pop	r29
     bb6:	cf 91       	pop	r28
     bb8:	08 95       	ret

00000bba <rf_w_config_register>:

void rf_w_config_register(uint8_t reg, uint8_t data){
     bba:	cf 93       	push	r28
     bbc:	df 93       	push	r29
     bbe:	1f 92       	push	r1
     bc0:	1f 92       	push	r1
     bc2:	cd b7       	in	r28, 0x3d	; 61
     bc4:	de b7       	in	r29, 0x3e	; 62
     bc6:	89 83       	std	Y+1, r24	; 0x01
     bc8:	6a 83       	std	Y+2, r22	; 0x02
	PORTL &= ~(1<<CSN);
     bca:	8b e0       	ldi	r24, 0x0B	; 11
     bcc:	91 e0       	ldi	r25, 0x01	; 1
     bce:	2b e0       	ldi	r18, 0x0B	; 11
     bd0:	31 e0       	ldi	r19, 0x01	; 1
     bd2:	f9 01       	movw	r30, r18
     bd4:	20 81       	ld	r18, Z
     bd6:	2d 7f       	andi	r18, 0xFD	; 253
     bd8:	fc 01       	movw	r30, r24
     bda:	20 83       	st	Z, r18
	spi_tranceiver(W_REGISTER | (REGISTER_MASK & reg));
     bdc:	89 81       	ldd	r24, Y+1	; 0x01
     bde:	8f 71       	andi	r24, 0x1F	; 31
     be0:	80 62       	ori	r24, 0x20	; 32
     be2:	0e 94 77 0e 	call	0x1cee	; 0x1cee <spi_tranceiver>
	spi_tranceiver(data);
     be6:	8a 81       	ldd	r24, Y+2	; 0x02
     be8:	0e 94 77 0e 	call	0x1cee	; 0x1cee <spi_tranceiver>
	PORTL |= (1<<CSN);
     bec:	8b e0       	ldi	r24, 0x0B	; 11
     bee:	91 e0       	ldi	r25, 0x01	; 1
     bf0:	2b e0       	ldi	r18, 0x0B	; 11
     bf2:	31 e0       	ldi	r19, 0x01	; 1
     bf4:	f9 01       	movw	r30, r18
     bf6:	20 81       	ld	r18, Z
     bf8:	22 60       	ori	r18, 0x02	; 2
     bfa:	fc 01       	movw	r30, r24
     bfc:	20 83       	st	Z, r18
}
     bfe:	0f 90       	pop	r0
     c00:	0f 90       	pop	r0
     c02:	df 91       	pop	r29
     c04:	cf 91       	pop	r28
     c06:	08 95       	ret

00000c08 <rf_config>:

void rf_config(){
     c08:	cf 93       	push	r28
     c0a:	df 93       	push	r29
     c0c:	cd b7       	in	r28, 0x3d	; 61
     c0e:	de b7       	in	r29, 0x3e	; 62
	// set rf channel
	rf_w_config_register(RF_CH, 2);
     c10:	62 e0       	ldi	r22, 0x02	; 2
     c12:	85 e0       	ldi	r24, 0x05	; 5
     c14:	0e 94 dd 05 	call	0xbba	; 0xbba <rf_w_config_register>

	//set payload lenght data
	rf_w_config_register(RX_PW_P0, 16);
     c18:	60 e1       	ldi	r22, 0x10	; 16
     c1a:	81 e1       	ldi	r24, 0x11	; 17
     c1c:	0e 94 dd 05 	call	0xbba	; 0xbba <rf_w_config_register>

	PTX = 0;
     c20:	10 92 a4 02 	sts	0x02A4, r1
	rf_w_config_register(CONFIG_NRF24L01, ( (1<<MASK_RX_DR) | (1<<EN_CRC) | (0<<CRCO) ) | (1<<PRIM_RX | 1<<PWR_UP));
     c24:	6b e4       	ldi	r22, 0x4B	; 75
     c26:	80 e0       	ldi	r24, 0x00	; 0
     c28:	0e 94 dd 05 	call	0xbba	; 0xbba <rf_w_config_register>
	PORTL |= (1<<CE);
     c2c:	8b e0       	ldi	r24, 0x0B	; 11
     c2e:	91 e0       	ldi	r25, 0x01	; 1
     c30:	2b e0       	ldi	r18, 0x0B	; 11
     c32:	31 e0       	ldi	r19, 0x01	; 1
     c34:	f9 01       	movw	r30, r18
     c36:	20 81       	ld	r18, Z
     c38:	21 60       	ori	r18, 0x01	; 1
     c3a:	fc 01       	movw	r30, r24
     c3c:	20 83       	st	Z, r18
}
     c3e:	df 91       	pop	r29
     c40:	cf 91       	pop	r28
     c42:	08 95       	ret

00000c44 <rf_write_register>:

//write register
void rf_write_register(uint8_t reg, uint8_t * data, uint8_t len){
     c44:	cf 93       	push	r28
     c46:	df 93       	push	r29
     c48:	00 d0       	rcall	.+0      	; 0xc4a <rf_write_register+0x6>
     c4a:	1f 92       	push	r1
     c4c:	cd b7       	in	r28, 0x3d	; 61
     c4e:	de b7       	in	r29, 0x3e	; 62
     c50:	89 83       	std	Y+1, r24	; 0x01
     c52:	7b 83       	std	Y+3, r23	; 0x03
     c54:	6a 83       	std	Y+2, r22	; 0x02
     c56:	4c 83       	std	Y+4, r20	; 0x04
	PORTL &= ~(1<<CSN);
     c58:	8b e0       	ldi	r24, 0x0B	; 11
     c5a:	91 e0       	ldi	r25, 0x01	; 1
     c5c:	2b e0       	ldi	r18, 0x0B	; 11
     c5e:	31 e0       	ldi	r19, 0x01	; 1
     c60:	f9 01       	movw	r30, r18
     c62:	20 81       	ld	r18, Z
     c64:	2d 7f       	andi	r18, 0xFD	; 253
     c66:	fc 01       	movw	r30, r24
     c68:	20 83       	st	Z, r18
	spi_tranceiver(W_REGISTER | (REGISTER_MASK & reg));
     c6a:	89 81       	ldd	r24, Y+1	; 0x01
     c6c:	8f 71       	andi	r24, 0x1F	; 31
     c6e:	80 62       	ori	r24, 0x20	; 32
     c70:	0e 94 77 0e 	call	0x1cee	; 0x1cee <spi_tranceiver>
	spi_send(data, len);
     c74:	8a 81       	ldd	r24, Y+2	; 0x02
     c76:	9b 81       	ldd	r25, Y+3	; 0x03
     c78:	6c 81       	ldd	r22, Y+4	; 0x04
     c7a:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <spi_send>
	PORTL |= (1<<CSN);
     c7e:	8b e0       	ldi	r24, 0x0B	; 11
     c80:	91 e0       	ldi	r25, 0x01	; 1
     c82:	2b e0       	ldi	r18, 0x0B	; 11
     c84:	31 e0       	ldi	r19, 0x01	; 1
     c86:	f9 01       	movw	r30, r18
     c88:	20 81       	ld	r18, Z
     c8a:	22 60       	ori	r18, 0x02	; 2
     c8c:	fc 01       	movw	r30, r24
     c8e:	20 83       	st	Z, r18
}
     c90:	0f 90       	pop	r0
     c92:	0f 90       	pop	r0
     c94:	0f 90       	pop	r0
     c96:	0f 90       	pop	r0
     c98:	df 91       	pop	r29
     c9a:	cf 91       	pop	r28
     c9c:	08 95       	ret

00000c9e <rf_read_register>:

//read a register
void rf_read_register(uint8_t reg, uint8_t * data, uint8_t len){
     c9e:	cf 93       	push	r28
     ca0:	df 93       	push	r29
     ca2:	00 d0       	rcall	.+0      	; 0xca4 <rf_read_register+0x6>
     ca4:	1f 92       	push	r1
     ca6:	cd b7       	in	r28, 0x3d	; 61
     ca8:	de b7       	in	r29, 0x3e	; 62
     caa:	89 83       	std	Y+1, r24	; 0x01
     cac:	7b 83       	std	Y+3, r23	; 0x03
     cae:	6a 83       	std	Y+2, r22	; 0x02
     cb0:	4c 83       	std	Y+4, r20	; 0x04
	PORTL &= ~(1<<CSN);
     cb2:	8b e0       	ldi	r24, 0x0B	; 11
     cb4:	91 e0       	ldi	r25, 0x01	; 1
     cb6:	2b e0       	ldi	r18, 0x0B	; 11
     cb8:	31 e0       	ldi	r19, 0x01	; 1
     cba:	f9 01       	movw	r30, r18
     cbc:	20 81       	ld	r18, Z
     cbe:	2d 7f       	andi	r18, 0xFD	; 253
     cc0:	fc 01       	movw	r30, r24
     cc2:	20 83       	st	Z, r18
	spi_tranceiver(R_REGISTER | (REGISTER_MASK & reg));
     cc4:	89 81       	ldd	r24, Y+1	; 0x01
     cc6:	8f 71       	andi	r24, 0x1F	; 31
     cc8:	0e 94 77 0e 	call	0x1cee	; 0x1cee <spi_tranceiver>
	spi_transfer(data,data,len);
     ccc:	2a 81       	ldd	r18, Y+2	; 0x02
     cce:	3b 81       	ldd	r19, Y+3	; 0x03
     cd0:	8a 81       	ldd	r24, Y+2	; 0x02
     cd2:	9b 81       	ldd	r25, Y+3	; 0x03
     cd4:	4c 81       	ldd	r20, Y+4	; 0x04
     cd6:	b9 01       	movw	r22, r18
     cd8:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <spi_transfer>
	PORTL |= (1<<CSN);
     cdc:	8b e0       	ldi	r24, 0x0B	; 11
     cde:	91 e0       	ldi	r25, 0x01	; 1
     ce0:	2b e0       	ldi	r18, 0x0B	; 11
     ce2:	31 e0       	ldi	r19, 0x01	; 1
     ce4:	f9 01       	movw	r30, r18
     ce6:	20 81       	ld	r18, Z
     ce8:	22 60       	ori	r18, 0x02	; 2
     cea:	fc 01       	movw	r30, r24
     cec:	20 83       	st	Z, r18
}
     cee:	0f 90       	pop	r0
     cf0:	0f 90       	pop	r0
     cf2:	0f 90       	pop	r0
     cf4:	0f 90       	pop	r0
     cf6:	df 91       	pop	r29
     cf8:	cf 91       	pop	r28
     cfa:	08 95       	ret

00000cfc <set_RADDR>:

//set address receiver
void set_RADDR(uint8_t *add){
     cfc:	cf 93       	push	r28
     cfe:	df 93       	push	r29
     d00:	1f 92       	push	r1
     d02:	1f 92       	push	r1
     d04:	cd b7       	in	r28, 0x3d	; 61
     d06:	de b7       	in	r29, 0x3e	; 62
     d08:	9a 83       	std	Y+2, r25	; 0x02
     d0a:	89 83       	std	Y+1, r24	; 0x01
	PORTL &= ~(1<<CE);
     d0c:	8b e0       	ldi	r24, 0x0B	; 11
     d0e:	91 e0       	ldi	r25, 0x01	; 1
     d10:	2b e0       	ldi	r18, 0x0B	; 11
     d12:	31 e0       	ldi	r19, 0x01	; 1
     d14:	f9 01       	movw	r30, r18
     d16:	20 81       	ld	r18, Z
     d18:	2e 7f       	andi	r18, 0xFE	; 254
     d1a:	fc 01       	movw	r30, r24
     d1c:	20 83       	st	Z, r18
	rf_write_register(RX_ADDR_P0, add, 5);
     d1e:	89 81       	ldd	r24, Y+1	; 0x01
     d20:	9a 81       	ldd	r25, Y+2	; 0x02
     d22:	45 e0       	ldi	r20, 0x05	; 5
     d24:	bc 01       	movw	r22, r24
     d26:	8a e0       	ldi	r24, 0x0A	; 10
     d28:	0e 94 22 06 	call	0xc44	; 0xc44 <rf_write_register>
	PORTL |= (1<<CE);
     d2c:	8b e0       	ldi	r24, 0x0B	; 11
     d2e:	91 e0       	ldi	r25, 0x01	; 1
     d30:	2b e0       	ldi	r18, 0x0B	; 11
     d32:	31 e0       	ldi	r19, 0x01	; 1
     d34:	f9 01       	movw	r30, r18
     d36:	20 81       	ld	r18, Z
     d38:	21 60       	ori	r18, 0x01	; 1
     d3a:	fc 01       	movw	r30, r24
     d3c:	20 83       	st	Z, r18
}
     d3e:	0f 90       	pop	r0
     d40:	0f 90       	pop	r0
     d42:	df 91       	pop	r29
     d44:	cf 91       	pop	r28
     d46:	08 95       	ret

00000d48 <set_TADDR>:

//set address transmisser
void set_TADDR(uint8_t *add){
     d48:	cf 93       	push	r28
     d4a:	df 93       	push	r29
     d4c:	1f 92       	push	r1
     d4e:	1f 92       	push	r1
     d50:	cd b7       	in	r28, 0x3d	; 61
     d52:	de b7       	in	r29, 0x3e	; 62
     d54:	9a 83       	std	Y+2, r25	; 0x02
     d56:	89 83       	std	Y+1, r24	; 0x01
	rf_write_register(TX_ADDR, add, 5);
     d58:	89 81       	ldd	r24, Y+1	; 0x01
     d5a:	9a 81       	ldd	r25, Y+2	; 0x02
     d5c:	45 e0       	ldi	r20, 0x05	; 5
     d5e:	bc 01       	movw	r22, r24
     d60:	80 e1       	ldi	r24, 0x10	; 16
     d62:	0e 94 22 06 	call	0xc44	; 0xc44 <rf_write_register>
}
     d66:	0f 90       	pop	r0
     d68:	0f 90       	pop	r0
     d6a:	df 91       	pop	r29
     d6c:	cf 91       	pop	r28
     d6e:	08 95       	ret

00000d70 <rf_data_ready>:

uint8_t rf_data_ready(){
     d70:	cf 93       	push	r28
     d72:	df 93       	push	r29
     d74:	1f 92       	push	r1
     d76:	cd b7       	in	r28, 0x3d	; 61
     d78:	de b7       	in	r29, 0x3e	; 62
	if (PTX) return 0;
     d7a:	80 91 a4 02 	lds	r24, 0x02A4
     d7e:	88 23       	and	r24, r24
     d80:	11 f0       	breq	.+4      	; 0xd86 <rf_data_ready+0x16>
     d82:	80 e0       	ldi	r24, 0x00	; 0
     d84:	18 c0       	rjmp	.+48     	; 0xdb6 <rf_data_ready+0x46>
	uint8_t status;
	PORTL &= ~(1<<CSN);
     d86:	8b e0       	ldi	r24, 0x0B	; 11
     d88:	91 e0       	ldi	r25, 0x01	; 1
     d8a:	2b e0       	ldi	r18, 0x0B	; 11
     d8c:	31 e0       	ldi	r19, 0x01	; 1
     d8e:	f9 01       	movw	r30, r18
     d90:	20 81       	ld	r18, Z
     d92:	2d 7f       	andi	r18, 0xFD	; 253
     d94:	fc 01       	movw	r30, r24
     d96:	20 83       	st	Z, r18
	status = spi_tranceiver(NOP);
     d98:	8f ef       	ldi	r24, 0xFF	; 255
     d9a:	0e 94 77 0e 	call	0x1cee	; 0x1cee <spi_tranceiver>
     d9e:	89 83       	std	Y+1, r24	; 0x01
	PORTL |= (1<<CSN);
     da0:	8b e0       	ldi	r24, 0x0B	; 11
     da2:	91 e0       	ldi	r25, 0x01	; 1
     da4:	2b e0       	ldi	r18, 0x0B	; 11
     da6:	31 e0       	ldi	r19, 0x01	; 1
     da8:	f9 01       	movw	r30, r18
     daa:	20 81       	ld	r18, Z
     dac:	22 60       	ori	r18, 0x02	; 2
     dae:	fc 01       	movw	r30, r24
     db0:	20 83       	st	Z, r18
	return status & (1<<RX_DR);
     db2:	89 81       	ldd	r24, Y+1	; 0x01
     db4:	80 74       	andi	r24, 0x40	; 64
}
     db6:	0f 90       	pop	r0
     db8:	df 91       	pop	r29
     dba:	cf 91       	pop	r28
     dbc:	08 95       	ret

00000dbe <rf_get_data>:

void rf_get_data(uint8_t * data){
     dbe:	cf 93       	push	r28
     dc0:	df 93       	push	r29
     dc2:	1f 92       	push	r1
     dc4:	1f 92       	push	r1
     dc6:	cd b7       	in	r28, 0x3d	; 61
     dc8:	de b7       	in	r29, 0x3e	; 62
     dca:	9a 83       	std	Y+2, r25	; 0x02
     dcc:	89 83       	std	Y+1, r24	; 0x01
	PORTL &= ~(1<<CSN);
     dce:	8b e0       	ldi	r24, 0x0B	; 11
     dd0:	91 e0       	ldi	r25, 0x01	; 1
     dd2:	2b e0       	ldi	r18, 0x0B	; 11
     dd4:	31 e0       	ldi	r19, 0x01	; 1
     dd6:	f9 01       	movw	r30, r18
     dd8:	20 81       	ld	r18, Z
     dda:	2d 7f       	andi	r18, 0xFD	; 253
     ddc:	fc 01       	movw	r30, r24
     dde:	20 83       	st	Z, r18
	spi_tranceiver(R_RX_PAYLOAD); //send command to read payload data
     de0:	81 e6       	ldi	r24, 0x61	; 97
     de2:	0e 94 77 0e 	call	0x1cee	; 0x1cee <spi_tranceiver>
	spi_transfer(data,data,16); //read data payload
     de6:	29 81       	ldd	r18, Y+1	; 0x01
     de8:	3a 81       	ldd	r19, Y+2	; 0x02
     dea:	89 81       	ldd	r24, Y+1	; 0x01
     dec:	9a 81       	ldd	r25, Y+2	; 0x02
     dee:	40 e1       	ldi	r20, 0x10	; 16
     df0:	b9 01       	movw	r22, r18
     df2:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <spi_transfer>
	PORTL |= (1<<CSN);
     df6:	8b e0       	ldi	r24, 0x0B	; 11
     df8:	91 e0       	ldi	r25, 0x01	; 1
     dfa:	2b e0       	ldi	r18, 0x0B	; 11
     dfc:	31 e0       	ldi	r19, 0x01	; 1
     dfe:	f9 01       	movw	r30, r18
     e00:	20 81       	ld	r18, Z
     e02:	22 60       	ori	r18, 0x02	; 2
     e04:	fc 01       	movw	r30, r24
     e06:	20 83       	st	Z, r18
	rf_w_config_register(STATUS,(1<<RX_DR));
     e08:	60 e4       	ldi	r22, 0x40	; 64
     e0a:	87 e0       	ldi	r24, 0x07	; 7
     e0c:	0e 94 dd 05 	call	0xbba	; 0xbba <rf_w_config_register>
}
     e10:	0f 90       	pop	r0
     e12:	0f 90       	pop	r0
     e14:	df 91       	pop	r29
     e16:	cf 91       	pop	r28
     e18:	08 95       	ret

00000e1a <calcAnglAccel>:

//convert rad to deg 180/PI
#define RAD_TO_DEG 180/M_PI

// Get the angls roll and pitch using just the accelerometer
void calcAnglAccel(double accelX, double accelY, double accelZ, double* anglAccelRoll, double* anglAccelPitch){
     e1a:	8f 92       	push	r8
     e1c:	9f 92       	push	r9
     e1e:	af 92       	push	r10
     e20:	bf 92       	push	r11
     e22:	cf 92       	push	r12
     e24:	df 92       	push	r13
     e26:	ef 92       	push	r14
     e28:	ff 92       	push	r15
     e2a:	0f 93       	push	r16
     e2c:	1f 93       	push	r17
     e2e:	cf 93       	push	r28
     e30:	df 93       	push	r29
     e32:	cd b7       	in	r28, 0x3d	; 61
     e34:	de b7       	in	r29, 0x3e	; 62
     e36:	60 97       	sbiw	r28, 0x10	; 16
     e38:	0f b6       	in	r0, 0x3f	; 63
     e3a:	f8 94       	cli
     e3c:	de bf       	out	0x3e, r29	; 62
     e3e:	0f be       	out	0x3f, r0	; 63
     e40:	cd bf       	out	0x3d, r28	; 61
     e42:	69 83       	std	Y+1, r22	; 0x01
     e44:	7a 83       	std	Y+2, r23	; 0x02
     e46:	8b 83       	std	Y+3, r24	; 0x03
     e48:	9c 83       	std	Y+4, r25	; 0x04
     e4a:	2d 83       	std	Y+5, r18	; 0x05
     e4c:	3e 83       	std	Y+6, r19	; 0x06
     e4e:	4f 83       	std	Y+7, r20	; 0x07
     e50:	58 87       	std	Y+8, r21	; 0x08
     e52:	e9 86       	std	Y+9, r14	; 0x09
     e54:	fa 86       	std	Y+10, r15	; 0x0a
     e56:	0b 87       	std	Y+11, r16	; 0x0b
     e58:	1c 87       	std	Y+12, r17	; 0x0c
     e5a:	de 86       	std	Y+14, r13	; 0x0e
     e5c:	cd 86       	std	Y+13, r12	; 0x0d
     e5e:	b8 8a       	std	Y+16, r11	; 0x10
     e60:	af 86       	std	Y+15, r10	; 0x0f
	*anglAccelRoll = atan(-1*(accelX)/sqrt(pow((accelY),2) + pow((accelZ),2))) * RAD_TO_DEG;
     e62:	89 81       	ldd	r24, Y+1	; 0x01
     e64:	9a 81       	ldd	r25, Y+2	; 0x02
     e66:	ab 81       	ldd	r26, Y+3	; 0x03
     e68:	bc 81       	ldd	r27, Y+4	; 0x04
     e6a:	6c 01       	movw	r12, r24
     e6c:	7d 01       	movw	r14, r26
     e6e:	f7 fa       	bst	r15, 7
     e70:	f0 94       	com	r15
     e72:	f7 f8       	bld	r15, 7
     e74:	f0 94       	com	r15
     e76:	8d 81       	ldd	r24, Y+5	; 0x05
     e78:	9e 81       	ldd	r25, Y+6	; 0x06
     e7a:	af 81       	ldd	r26, Y+7	; 0x07
     e7c:	b8 85       	ldd	r27, Y+8	; 0x08
     e7e:	20 e0       	ldi	r18, 0x00	; 0
     e80:	30 e0       	ldi	r19, 0x00	; 0
     e82:	40 e0       	ldi	r20, 0x00	; 0
     e84:	50 e4       	ldi	r21, 0x40	; 64
     e86:	bc 01       	movw	r22, r24
     e88:	cd 01       	movw	r24, r26
     e8a:	0e 94 da 33 	call	0x67b4	; 0x67b4 <pow>
     e8e:	4b 01       	movw	r8, r22
     e90:	5c 01       	movw	r10, r24
     e92:	89 85       	ldd	r24, Y+9	; 0x09
     e94:	9a 85       	ldd	r25, Y+10	; 0x0a
     e96:	ab 85       	ldd	r26, Y+11	; 0x0b
     e98:	bc 85       	ldd	r27, Y+12	; 0x0c
     e9a:	20 e0       	ldi	r18, 0x00	; 0
     e9c:	30 e0       	ldi	r19, 0x00	; 0
     e9e:	40 e0       	ldi	r20, 0x00	; 0
     ea0:	50 e4       	ldi	r21, 0x40	; 64
     ea2:	bc 01       	movw	r22, r24
     ea4:	cd 01       	movw	r24, r26
     ea6:	0e 94 da 33 	call	0x67b4	; 0x67b4 <pow>
     eaa:	dc 01       	movw	r26, r24
     eac:	cb 01       	movw	r24, r22
     eae:	9c 01       	movw	r18, r24
     eb0:	ad 01       	movw	r20, r26
     eb2:	c5 01       	movw	r24, r10
     eb4:	b4 01       	movw	r22, r8
     eb6:	0e 94 46 31 	call	0x628c	; 0x628c <__addsf3>
     eba:	dc 01       	movw	r26, r24
     ebc:	cb 01       	movw	r24, r22
     ebe:	bc 01       	movw	r22, r24
     ec0:	cd 01       	movw	r24, r26
     ec2:	0e 94 30 34 	call	0x6860	; 0x6860 <sqrt>
     ec6:	dc 01       	movw	r26, r24
     ec8:	cb 01       	movw	r24, r22
     eca:	9c 01       	movw	r18, r24
     ecc:	ad 01       	movw	r20, r26
     ece:	c7 01       	movw	r24, r14
     ed0:	b6 01       	movw	r22, r12
     ed2:	0e 94 e6 31 	call	0x63cc	; 0x63cc <__divsf3>
     ed6:	dc 01       	movw	r26, r24
     ed8:	cb 01       	movw	r24, r22
     eda:	bc 01       	movw	r22, r24
     edc:	cd 01       	movw	r24, r26
     ede:	0e 94 b2 31 	call	0x6364	; 0x6364 <atan>
     ee2:	dc 01       	movw	r26, r24
     ee4:	cb 01       	movw	r24, r22
     ee6:	20 e0       	ldi	r18, 0x00	; 0
     ee8:	30 e0       	ldi	r19, 0x00	; 0
     eea:	44 e3       	ldi	r20, 0x34	; 52
     eec:	53 e4       	ldi	r21, 0x43	; 67
     eee:	bc 01       	movw	r22, r24
     ef0:	cd 01       	movw	r24, r26
     ef2:	0e 94 6d 33 	call	0x66da	; 0x66da <__mulsf3>
     ef6:	dc 01       	movw	r26, r24
     ef8:	cb 01       	movw	r24, r22
     efa:	2b ed       	ldi	r18, 0xDB	; 219
     efc:	3f e0       	ldi	r19, 0x0F	; 15
     efe:	49 e4       	ldi	r20, 0x49	; 73
     f00:	50 e4       	ldi	r21, 0x40	; 64
     f02:	bc 01       	movw	r22, r24
     f04:	cd 01       	movw	r24, r26
     f06:	0e 94 e6 31 	call	0x63cc	; 0x63cc <__divsf3>
     f0a:	dc 01       	movw	r26, r24
     f0c:	cb 01       	movw	r24, r22
     f0e:	2d 85       	ldd	r18, Y+13	; 0x0d
     f10:	3e 85       	ldd	r19, Y+14	; 0x0e
     f12:	f9 01       	movw	r30, r18
     f14:	80 83       	st	Z, r24
     f16:	91 83       	std	Z+1, r25	; 0x01
     f18:	a2 83       	std	Z+2, r26	; 0x02
     f1a:	b3 83       	std	Z+3, r27	; 0x03
	*anglAccelPitch = atan((accelY)/sqrt(pow((accelX),2) + pow((accelZ),2))) * RAD_TO_DEG;
     f1c:	89 81       	ldd	r24, Y+1	; 0x01
     f1e:	9a 81       	ldd	r25, Y+2	; 0x02
     f20:	ab 81       	ldd	r26, Y+3	; 0x03
     f22:	bc 81       	ldd	r27, Y+4	; 0x04
     f24:	20 e0       	ldi	r18, 0x00	; 0
     f26:	30 e0       	ldi	r19, 0x00	; 0
     f28:	40 e0       	ldi	r20, 0x00	; 0
     f2a:	50 e4       	ldi	r21, 0x40	; 64
     f2c:	bc 01       	movw	r22, r24
     f2e:	cd 01       	movw	r24, r26
     f30:	0e 94 da 33 	call	0x67b4	; 0x67b4 <pow>
     f34:	6b 01       	movw	r12, r22
     f36:	7c 01       	movw	r14, r24
     f38:	89 85       	ldd	r24, Y+9	; 0x09
     f3a:	9a 85       	ldd	r25, Y+10	; 0x0a
     f3c:	ab 85       	ldd	r26, Y+11	; 0x0b
     f3e:	bc 85       	ldd	r27, Y+12	; 0x0c
     f40:	20 e0       	ldi	r18, 0x00	; 0
     f42:	30 e0       	ldi	r19, 0x00	; 0
     f44:	40 e0       	ldi	r20, 0x00	; 0
     f46:	50 e4       	ldi	r21, 0x40	; 64
     f48:	bc 01       	movw	r22, r24
     f4a:	cd 01       	movw	r24, r26
     f4c:	0e 94 da 33 	call	0x67b4	; 0x67b4 <pow>
     f50:	dc 01       	movw	r26, r24
     f52:	cb 01       	movw	r24, r22
     f54:	9c 01       	movw	r18, r24
     f56:	ad 01       	movw	r20, r26
     f58:	c7 01       	movw	r24, r14
     f5a:	b6 01       	movw	r22, r12
     f5c:	0e 94 46 31 	call	0x628c	; 0x628c <__addsf3>
     f60:	dc 01       	movw	r26, r24
     f62:	cb 01       	movw	r24, r22
     f64:	bc 01       	movw	r22, r24
     f66:	cd 01       	movw	r24, r26
     f68:	0e 94 30 34 	call	0x6860	; 0x6860 <sqrt>
     f6c:	dc 01       	movw	r26, r24
     f6e:	cb 01       	movw	r24, r22
     f70:	9c 01       	movw	r18, r24
     f72:	ad 01       	movw	r20, r26
     f74:	6d 81       	ldd	r22, Y+5	; 0x05
     f76:	7e 81       	ldd	r23, Y+6	; 0x06
     f78:	8f 81       	ldd	r24, Y+7	; 0x07
     f7a:	98 85       	ldd	r25, Y+8	; 0x08
     f7c:	0e 94 e6 31 	call	0x63cc	; 0x63cc <__divsf3>
     f80:	dc 01       	movw	r26, r24
     f82:	cb 01       	movw	r24, r22
     f84:	bc 01       	movw	r22, r24
     f86:	cd 01       	movw	r24, r26
     f88:	0e 94 b2 31 	call	0x6364	; 0x6364 <atan>
     f8c:	dc 01       	movw	r26, r24
     f8e:	cb 01       	movw	r24, r22
     f90:	20 e0       	ldi	r18, 0x00	; 0
     f92:	30 e0       	ldi	r19, 0x00	; 0
     f94:	44 e3       	ldi	r20, 0x34	; 52
     f96:	53 e4       	ldi	r21, 0x43	; 67
     f98:	bc 01       	movw	r22, r24
     f9a:	cd 01       	movw	r24, r26
     f9c:	0e 94 6d 33 	call	0x66da	; 0x66da <__mulsf3>
     fa0:	dc 01       	movw	r26, r24
     fa2:	cb 01       	movw	r24, r22
     fa4:	2b ed       	ldi	r18, 0xDB	; 219
     fa6:	3f e0       	ldi	r19, 0x0F	; 15
     fa8:	49 e4       	ldi	r20, 0x49	; 73
     faa:	50 e4       	ldi	r21, 0x40	; 64
     fac:	bc 01       	movw	r22, r24
     fae:	cd 01       	movw	r24, r26
     fb0:	0e 94 e6 31 	call	0x63cc	; 0x63cc <__divsf3>
     fb4:	dc 01       	movw	r26, r24
     fb6:	cb 01       	movw	r24, r22
     fb8:	2f 85       	ldd	r18, Y+15	; 0x0f
     fba:	38 89       	ldd	r19, Y+16	; 0x10
     fbc:	f9 01       	movw	r30, r18
     fbe:	80 83       	st	Z, r24
     fc0:	91 83       	std	Z+1, r25	; 0x01
     fc2:	a2 83       	std	Z+2, r26	; 0x02
     fc4:	b3 83       	std	Z+3, r27	; 0x03
}
     fc6:	60 96       	adiw	r28, 0x10	; 16
     fc8:	0f b6       	in	r0, 0x3f	; 63
     fca:	f8 94       	cli
     fcc:	de bf       	out	0x3e, r29	; 62
     fce:	0f be       	out	0x3f, r0	; 63
     fd0:	cd bf       	out	0x3d, r28	; 61
     fd2:	df 91       	pop	r29
     fd4:	cf 91       	pop	r28
     fd6:	1f 91       	pop	r17
     fd8:	0f 91       	pop	r16
     fda:	ff 90       	pop	r15
     fdc:	ef 90       	pop	r14
     fde:	df 90       	pop	r13
     fe0:	cf 90       	pop	r12
     fe2:	bf 90       	pop	r11
     fe4:	af 90       	pop	r10
     fe6:	9f 90       	pop	r9
     fe8:	8f 90       	pop	r8
     fea:	08 95       	ret

00000fec <getRollPitch>:


// get the angles roll and pitch final
void getRollPitch(double anglAccelRoll, double anglAccelPitch, double anglGyroRoll, double anglGyroPitch, double* Roll, double* Pitch){
     fec:	8f 92       	push	r8
     fee:	9f 92       	push	r9
     ff0:	af 92       	push	r10
     ff2:	bf 92       	push	r11
     ff4:	cf 92       	push	r12
     ff6:	df 92       	push	r13
     ff8:	ef 92       	push	r14
     ffa:	ff 92       	push	r15
     ffc:	0f 93       	push	r16
     ffe:	1f 93       	push	r17
    1000:	cf 93       	push	r28
    1002:	df 93       	push	r29
    1004:	cd b7       	in	r28, 0x3d	; 61
    1006:	de b7       	in	r29, 0x3e	; 62
    1008:	62 97       	sbiw	r28, 0x12	; 18
    100a:	0f b6       	in	r0, 0x3f	; 63
    100c:	f8 94       	cli
    100e:	de bf       	out	0x3e, r29	; 62
    1010:	0f be       	out	0x3f, r0	; 63
    1012:	cd bf       	out	0x3d, r28	; 61
    1014:	69 83       	std	Y+1, r22	; 0x01
    1016:	7a 83       	std	Y+2, r23	; 0x02
    1018:	8b 83       	std	Y+3, r24	; 0x03
    101a:	9c 83       	std	Y+4, r25	; 0x04
    101c:	2d 83       	std	Y+5, r18	; 0x05
    101e:	3e 83       	std	Y+6, r19	; 0x06
    1020:	4f 83       	std	Y+7, r20	; 0x07
    1022:	58 87       	std	Y+8, r21	; 0x08
    1024:	e9 86       	std	Y+9, r14	; 0x09
    1026:	fa 86       	std	Y+10, r15	; 0x0a
    1028:	0b 87       	std	Y+11, r16	; 0x0b
    102a:	1c 87       	std	Y+12, r17	; 0x0c
    102c:	ad 86       	std	Y+13, r10	; 0x0d
    102e:	be 86       	std	Y+14, r11	; 0x0e
    1030:	cf 86       	std	Y+15, r12	; 0x0f
    1032:	d8 8a       	std	Y+16, r13	; 0x10
    1034:	9a 8a       	std	Y+18, r9	; 0x12
    1036:	89 8a       	std	Y+17, r8	; 0x11
	*Roll = ((0.98 * ((*Roll)+ anglGyroRoll * 0.010)) + (0.02 * anglAccelRoll));
    1038:	89 89       	ldd	r24, Y+17	; 0x11
    103a:	9a 89       	ldd	r25, Y+18	; 0x12
    103c:	fc 01       	movw	r30, r24
    103e:	c0 80       	ld	r12, Z
    1040:	d1 80       	ldd	r13, Z+1	; 0x01
    1042:	e2 80       	ldd	r14, Z+2	; 0x02
    1044:	f3 80       	ldd	r15, Z+3	; 0x03
    1046:	2a e0       	ldi	r18, 0x0A	; 10
    1048:	37 ed       	ldi	r19, 0xD7	; 215
    104a:	43 e2       	ldi	r20, 0x23	; 35
    104c:	5c e3       	ldi	r21, 0x3C	; 60
    104e:	69 85       	ldd	r22, Y+9	; 0x09
    1050:	7a 85       	ldd	r23, Y+10	; 0x0a
    1052:	8b 85       	ldd	r24, Y+11	; 0x0b
    1054:	9c 85       	ldd	r25, Y+12	; 0x0c
    1056:	0e 94 6d 33 	call	0x66da	; 0x66da <__mulsf3>
    105a:	dc 01       	movw	r26, r24
    105c:	cb 01       	movw	r24, r22
    105e:	9c 01       	movw	r18, r24
    1060:	ad 01       	movw	r20, r26
    1062:	c7 01       	movw	r24, r14
    1064:	b6 01       	movw	r22, r12
    1066:	0e 94 46 31 	call	0x628c	; 0x628c <__addsf3>
    106a:	dc 01       	movw	r26, r24
    106c:	cb 01       	movw	r24, r22
    106e:	28 e4       	ldi	r18, 0x48	; 72
    1070:	31 ee       	ldi	r19, 0xE1	; 225
    1072:	4a e7       	ldi	r20, 0x7A	; 122
    1074:	5f e3       	ldi	r21, 0x3F	; 63
    1076:	bc 01       	movw	r22, r24
    1078:	cd 01       	movw	r24, r26
    107a:	0e 94 6d 33 	call	0x66da	; 0x66da <__mulsf3>
    107e:	dc 01       	movw	r26, r24
    1080:	cb 01       	movw	r24, r22
    1082:	6c 01       	movw	r12, r24
    1084:	7d 01       	movw	r14, r26
    1086:	2a e0       	ldi	r18, 0x0A	; 10
    1088:	37 ed       	ldi	r19, 0xD7	; 215
    108a:	43 ea       	ldi	r20, 0xA3	; 163
    108c:	5c e3       	ldi	r21, 0x3C	; 60
    108e:	69 81       	ldd	r22, Y+1	; 0x01
    1090:	7a 81       	ldd	r23, Y+2	; 0x02
    1092:	8b 81       	ldd	r24, Y+3	; 0x03
    1094:	9c 81       	ldd	r25, Y+4	; 0x04
    1096:	0e 94 6d 33 	call	0x66da	; 0x66da <__mulsf3>
    109a:	dc 01       	movw	r26, r24
    109c:	cb 01       	movw	r24, r22
    109e:	9c 01       	movw	r18, r24
    10a0:	ad 01       	movw	r20, r26
    10a2:	c7 01       	movw	r24, r14
    10a4:	b6 01       	movw	r22, r12
    10a6:	0e 94 46 31 	call	0x628c	; 0x628c <__addsf3>
    10aa:	dc 01       	movw	r26, r24
    10ac:	cb 01       	movw	r24, r22
    10ae:	29 89       	ldd	r18, Y+17	; 0x11
    10b0:	3a 89       	ldd	r19, Y+18	; 0x12
    10b2:	f9 01       	movw	r30, r18
    10b4:	80 83       	st	Z, r24
    10b6:	91 83       	std	Z+1, r25	; 0x01
    10b8:	a2 83       	std	Z+2, r26	; 0x02
    10ba:	b3 83       	std	Z+3, r27	; 0x03
	*Pitch = ((0.98 * ((*Pitch) + anglGyroPitch * 0.010)) + (0.02 * anglAccelPitch));
    10bc:	8a a1       	ldd	r24, Y+34	; 0x22
    10be:	9b a1       	ldd	r25, Y+35	; 0x23
    10c0:	fc 01       	movw	r30, r24
    10c2:	c0 80       	ld	r12, Z
    10c4:	d1 80       	ldd	r13, Z+1	; 0x01
    10c6:	e2 80       	ldd	r14, Z+2	; 0x02
    10c8:	f3 80       	ldd	r15, Z+3	; 0x03
    10ca:	2a e0       	ldi	r18, 0x0A	; 10
    10cc:	37 ed       	ldi	r19, 0xD7	; 215
    10ce:	43 e2       	ldi	r20, 0x23	; 35
    10d0:	5c e3       	ldi	r21, 0x3C	; 60
    10d2:	6d 85       	ldd	r22, Y+13	; 0x0d
    10d4:	7e 85       	ldd	r23, Y+14	; 0x0e
    10d6:	8f 85       	ldd	r24, Y+15	; 0x0f
    10d8:	98 89       	ldd	r25, Y+16	; 0x10
    10da:	0e 94 6d 33 	call	0x66da	; 0x66da <__mulsf3>
    10de:	dc 01       	movw	r26, r24
    10e0:	cb 01       	movw	r24, r22
    10e2:	9c 01       	movw	r18, r24
    10e4:	ad 01       	movw	r20, r26
    10e6:	c7 01       	movw	r24, r14
    10e8:	b6 01       	movw	r22, r12
    10ea:	0e 94 46 31 	call	0x628c	; 0x628c <__addsf3>
    10ee:	dc 01       	movw	r26, r24
    10f0:	cb 01       	movw	r24, r22
    10f2:	28 e4       	ldi	r18, 0x48	; 72
    10f4:	31 ee       	ldi	r19, 0xE1	; 225
    10f6:	4a e7       	ldi	r20, 0x7A	; 122
    10f8:	5f e3       	ldi	r21, 0x3F	; 63
    10fa:	bc 01       	movw	r22, r24
    10fc:	cd 01       	movw	r24, r26
    10fe:	0e 94 6d 33 	call	0x66da	; 0x66da <__mulsf3>
    1102:	dc 01       	movw	r26, r24
    1104:	cb 01       	movw	r24, r22
    1106:	6c 01       	movw	r12, r24
    1108:	7d 01       	movw	r14, r26
    110a:	2a e0       	ldi	r18, 0x0A	; 10
    110c:	37 ed       	ldi	r19, 0xD7	; 215
    110e:	43 ea       	ldi	r20, 0xA3	; 163
    1110:	5c e3       	ldi	r21, 0x3C	; 60
    1112:	6d 81       	ldd	r22, Y+5	; 0x05
    1114:	7e 81       	ldd	r23, Y+6	; 0x06
    1116:	8f 81       	ldd	r24, Y+7	; 0x07
    1118:	98 85       	ldd	r25, Y+8	; 0x08
    111a:	0e 94 6d 33 	call	0x66da	; 0x66da <__mulsf3>
    111e:	dc 01       	movw	r26, r24
    1120:	cb 01       	movw	r24, r22
    1122:	9c 01       	movw	r18, r24
    1124:	ad 01       	movw	r20, r26
    1126:	c7 01       	movw	r24, r14
    1128:	b6 01       	movw	r22, r12
    112a:	0e 94 46 31 	call	0x628c	; 0x628c <__addsf3>
    112e:	dc 01       	movw	r26, r24
    1130:	cb 01       	movw	r24, r22
    1132:	2a a1       	ldd	r18, Y+34	; 0x22
    1134:	3b a1       	ldd	r19, Y+35	; 0x23
    1136:	f9 01       	movw	r30, r18
    1138:	80 83       	st	Z, r24
    113a:	91 83       	std	Z+1, r25	; 0x01
    113c:	a2 83       	std	Z+2, r26	; 0x02
    113e:	b3 83       	std	Z+3, r27	; 0x03
}
    1140:	62 96       	adiw	r28, 0x12	; 18
    1142:	0f b6       	in	r0, 0x3f	; 63
    1144:	f8 94       	cli
    1146:	de bf       	out	0x3e, r29	; 62
    1148:	0f be       	out	0x3f, r0	; 63
    114a:	cd bf       	out	0x3d, r28	; 61
    114c:	df 91       	pop	r29
    114e:	cf 91       	pop	r28
    1150:	1f 91       	pop	r17
    1152:	0f 91       	pop	r16
    1154:	ff 90       	pop	r15
    1156:	ef 90       	pop	r14
    1158:	df 90       	pop	r13
    115a:	cf 90       	pop	r12
    115c:	bf 90       	pop	r11
    115e:	af 90       	pop	r10
    1160:	9f 90       	pop	r9
    1162:	8f 90       	pop	r8
    1164:	08 95       	ret

00001166 <mpu6050_readBytes>:
volatile uint8_t buffer[14];

/*
 * read bytes from chip register
 */
int8_t mpu6050_readBytes(uint8_t regAddr, uint8_t length, uint8_t *data) {
    1166:	0f 93       	push	r16
    1168:	1f 93       	push	r17
    116a:	cf 93       	push	r28
    116c:	df 93       	push	r29
    116e:	00 d0       	rcall	.+0      	; 0x1170 <mpu6050_readBytes+0xa>
    1170:	00 d0       	rcall	.+0      	; 0x1172 <mpu6050_readBytes+0xc>
    1172:	cd b7       	in	r28, 0x3d	; 61
    1174:	de b7       	in	r29, 0x3e	; 62
    1176:	8b 83       	std	Y+3, r24	; 0x03
    1178:	6c 83       	std	Y+4, r22	; 0x04
    117a:	5e 83       	std	Y+6, r21	; 0x06
    117c:	4d 83       	std	Y+5, r20	; 0x05
	uint8_t i = 0;
    117e:	19 82       	std	Y+1, r1	; 0x01
	int8_t count = 0;
    1180:	1a 82       	std	Y+2, r1	; 0x02
	if(length > 0) {
    1182:	8c 81       	ldd	r24, Y+4	; 0x04
    1184:	88 23       	and	r24, r24
    1186:	d1 f1       	breq	.+116    	; 0x11fc <mpu6050_readBytes+0x96>
		//request register
		i2c_start(MPU6050_ADDR | I2C_WRITE);
    1188:	80 ed       	ldi	r24, 0xD0	; 208
    118a:	0e 94 36 03 	call	0x66c	; 0x66c <i2c_start>
		i2c_write(regAddr);
    118e:	8b 81       	ldd	r24, Y+3	; 0x03
    1190:	0e 94 bf 04 	call	0x97e	; 0x97e <i2c_write>

		//read data
		i2c_start(MPU6050_ADDR | I2C_READ);
    1194:	81 ed       	ldi	r24, 0xD1	; 209
    1196:	0e 94 36 03 	call	0x66c	; 0x66c <i2c_start>
		for(i=0; i<length; i++) {
    119a:	19 82       	std	Y+1, r1	; 0x01
    119c:	29 c0       	rjmp	.+82     	; 0x11f0 <mpu6050_readBytes+0x8a>
			count++;
    119e:	8a 81       	ldd	r24, Y+2	; 0x02
    11a0:	8f 5f       	subi	r24, 0xFF	; 255
    11a2:	8a 83       	std	Y+2, r24	; 0x02
			if(i==length-1)
    11a4:	89 81       	ldd	r24, Y+1	; 0x01
    11a6:	28 2f       	mov	r18, r24
    11a8:	30 e0       	ldi	r19, 0x00	; 0
    11aa:	8c 81       	ldd	r24, Y+4	; 0x04
    11ac:	88 2f       	mov	r24, r24
    11ae:	90 e0       	ldi	r25, 0x00	; 0
    11b0:	01 97       	sbiw	r24, 0x01	; 1
    11b2:	28 17       	cp	r18, r24
    11b4:	39 07       	cpc	r19, r25
    11b6:	69 f4       	brne	.+26     	; 0x11d2 <mpu6050_readBytes+0x6c>
				data[i] = i2c_readNak();
    11b8:	89 81       	ldd	r24, Y+1	; 0x01
    11ba:	88 2f       	mov	r24, r24
    11bc:	90 e0       	ldi	r25, 0x00	; 0
    11be:	2d 81       	ldd	r18, Y+5	; 0x05
    11c0:	3e 81       	ldd	r19, Y+6	; 0x06
    11c2:	89 01       	movw	r16, r18
    11c4:	08 0f       	add	r16, r24
    11c6:	19 1f       	adc	r17, r25
    11c8:	0e 94 59 05 	call	0xab2	; 0xab2 <i2c_readNak>
    11cc:	f8 01       	movw	r30, r16
    11ce:	80 83       	st	Z, r24
    11d0:	0c c0       	rjmp	.+24     	; 0x11ea <mpu6050_readBytes+0x84>
			else
				data[i] = i2c_readAck();
    11d2:	89 81       	ldd	r24, Y+1	; 0x01
    11d4:	88 2f       	mov	r24, r24
    11d6:	90 e0       	ldi	r25, 0x00	; 0
    11d8:	2d 81       	ldd	r18, Y+5	; 0x05
    11da:	3e 81       	ldd	r19, Y+6	; 0x06
    11dc:	89 01       	movw	r16, r18
    11de:	08 0f       	add	r16, r24
    11e0:	19 1f       	adc	r17, r25
    11e2:	0e 94 14 05 	call	0xa28	; 0xa28 <i2c_readAck>
    11e6:	f8 01       	movw	r30, r16
    11e8:	80 83       	st	Z, r24
		i2c_start(MPU6050_ADDR | I2C_WRITE);
		i2c_write(regAddr);

		//read data
		i2c_start(MPU6050_ADDR | I2C_READ);
		for(i=0; i<length; i++) {
    11ea:	89 81       	ldd	r24, Y+1	; 0x01
    11ec:	8f 5f       	subi	r24, 0xFF	; 255
    11ee:	89 83       	std	Y+1, r24	; 0x01
    11f0:	99 81       	ldd	r25, Y+1	; 0x01
    11f2:	8c 81       	ldd	r24, Y+4	; 0x04
    11f4:	98 17       	cp	r25, r24
    11f6:	98 f2       	brcs	.-90     	; 0x119e <mpu6050_readBytes+0x38>
			if(i==length-1)
				data[i] = i2c_readNak();
			else
				data[i] = i2c_readAck();
		}
		i2c_stop();
    11f8:	0e 94 84 04 	call	0x908	; 0x908 <i2c_stop>
	}
	return count;
    11fc:	8a 81       	ldd	r24, Y+2	; 0x02
}
    11fe:	26 96       	adiw	r28, 0x06	; 6
    1200:	0f b6       	in	r0, 0x3f	; 63
    1202:	f8 94       	cli
    1204:	de bf       	out	0x3e, r29	; 62
    1206:	0f be       	out	0x3f, r0	; 63
    1208:	cd bf       	out	0x3d, r28	; 61
    120a:	df 91       	pop	r29
    120c:	cf 91       	pop	r28
    120e:	1f 91       	pop	r17
    1210:	0f 91       	pop	r16
    1212:	08 95       	ret

00001214 <mpu6050_readByte>:

/*
 * read 1 byte from chip register
 */
int8_t mpu6050_readByte(uint8_t regAddr, uint8_t *data) {
    1214:	cf 93       	push	r28
    1216:	df 93       	push	r29
    1218:	00 d0       	rcall	.+0      	; 0x121a <mpu6050_readByte+0x6>
    121a:	cd b7       	in	r28, 0x3d	; 61
    121c:	de b7       	in	r29, 0x3e	; 62
    121e:	89 83       	std	Y+1, r24	; 0x01
    1220:	7b 83       	std	Y+3, r23	; 0x03
    1222:	6a 83       	std	Y+2, r22	; 0x02
    return mpu6050_readBytes(regAddr, 1, data);
    1224:	8a 81       	ldd	r24, Y+2	; 0x02
    1226:	9b 81       	ldd	r25, Y+3	; 0x03
    1228:	ac 01       	movw	r20, r24
    122a:	61 e0       	ldi	r22, 0x01	; 1
    122c:	89 81       	ldd	r24, Y+1	; 0x01
    122e:	0e 94 b3 08 	call	0x1166	; 0x1166 <mpu6050_readBytes>
}
    1232:	0f 90       	pop	r0
    1234:	0f 90       	pop	r0
    1236:	0f 90       	pop	r0
    1238:	df 91       	pop	r29
    123a:	cf 91       	pop	r28
    123c:	08 95       	ret

0000123e <mpu6050_writeBytes>:

/*
 * write bytes to chip register
 */
void mpu6050_writeBytes(uint8_t regAddr, uint8_t length, uint8_t* data) {
    123e:	cf 93       	push	r28
    1240:	df 93       	push	r29
    1242:	00 d0       	rcall	.+0      	; 0x1244 <mpu6050_writeBytes+0x6>
    1244:	1f 92       	push	r1
    1246:	1f 92       	push	r1
    1248:	cd b7       	in	r28, 0x3d	; 61
    124a:	de b7       	in	r29, 0x3e	; 62
    124c:	8a 83       	std	Y+2, r24	; 0x02
    124e:	6b 83       	std	Y+3, r22	; 0x03
    1250:	5d 83       	std	Y+5, r21	; 0x05
    1252:	4c 83       	std	Y+4, r20	; 0x04
	if(length > 0) {
    1254:	8b 81       	ldd	r24, Y+3	; 0x03
    1256:	88 23       	and	r24, r24
    1258:	e1 f0       	breq	.+56     	; 0x1292 <mpu6050_writeBytes+0x54>
		//write data
		i2c_start(MPU6050_ADDR | I2C_WRITE);
    125a:	80 ed       	ldi	r24, 0xD0	; 208
    125c:	0e 94 36 03 	call	0x66c	; 0x66c <i2c_start>
		i2c_write(regAddr); //reg
    1260:	8a 81       	ldd	r24, Y+2	; 0x02
    1262:	0e 94 bf 04 	call	0x97e	; 0x97e <i2c_write>
		for (uint8_t i = 0; i < length; i++) {
    1266:	19 82       	std	Y+1, r1	; 0x01
    1268:	0e c0       	rjmp	.+28     	; 0x1286 <mpu6050_writeBytes+0x48>
			i2c_write((uint8_t) data[i]);
    126a:	89 81       	ldd	r24, Y+1	; 0x01
    126c:	88 2f       	mov	r24, r24
    126e:	90 e0       	ldi	r25, 0x00	; 0
    1270:	2c 81       	ldd	r18, Y+4	; 0x04
    1272:	3d 81       	ldd	r19, Y+5	; 0x05
    1274:	82 0f       	add	r24, r18
    1276:	93 1f       	adc	r25, r19
    1278:	fc 01       	movw	r30, r24
    127a:	80 81       	ld	r24, Z
    127c:	0e 94 bf 04 	call	0x97e	; 0x97e <i2c_write>
void mpu6050_writeBytes(uint8_t regAddr, uint8_t length, uint8_t* data) {
	if(length > 0) {
		//write data
		i2c_start(MPU6050_ADDR | I2C_WRITE);
		i2c_write(regAddr); //reg
		for (uint8_t i = 0; i < length; i++) {
    1280:	89 81       	ldd	r24, Y+1	; 0x01
    1282:	8f 5f       	subi	r24, 0xFF	; 255
    1284:	89 83       	std	Y+1, r24	; 0x01
    1286:	99 81       	ldd	r25, Y+1	; 0x01
    1288:	8b 81       	ldd	r24, Y+3	; 0x03
    128a:	98 17       	cp	r25, r24
    128c:	70 f3       	brcs	.-36     	; 0x126a <mpu6050_writeBytes+0x2c>
			i2c_write((uint8_t) data[i]);
		}
		i2c_stop();
    128e:	0e 94 84 04 	call	0x908	; 0x908 <i2c_stop>
	}
}
    1292:	0f 90       	pop	r0
    1294:	0f 90       	pop	r0
    1296:	0f 90       	pop	r0
    1298:	0f 90       	pop	r0
    129a:	0f 90       	pop	r0
    129c:	df 91       	pop	r29
    129e:	cf 91       	pop	r28
    12a0:	08 95       	ret

000012a2 <mpu6050_writeByte>:
/*
 * write 1 byte to chip register
 */
void mpu6050_writeByte(uint8_t regAddr, uint8_t data) {
    12a2:	cf 93       	push	r28
    12a4:	df 93       	push	r29
    12a6:	1f 92       	push	r1
    12a8:	1f 92       	push	r1
    12aa:	cd b7       	in	r28, 0x3d	; 61
    12ac:	de b7       	in	r29, 0x3e	; 62
    12ae:	89 83       	std	Y+1, r24	; 0x01
    12b0:	6a 83       	std	Y+2, r22	; 0x02
    return mpu6050_writeBytes(regAddr, 1, &data);
    12b2:	ce 01       	movw	r24, r28
    12b4:	02 96       	adiw	r24, 0x02	; 2
    12b6:	ac 01       	movw	r20, r24
    12b8:	61 e0       	ldi	r22, 0x01	; 1
    12ba:	89 81       	ldd	r24, Y+1	; 0x01
    12bc:	0e 94 1f 09 	call	0x123e	; 0x123e <mpu6050_writeBytes>
    12c0:	00 00       	nop
}
    12c2:	0f 90       	pop	r0
    12c4:	0f 90       	pop	r0
    12c6:	df 91       	pop	r29
    12c8:	cf 91       	pop	r28
    12ca:	08 95       	ret

000012cc <mpu6050_readBits>:

/*
 * read bits from chip register
 */
int8_t mpu6050_readBits(uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t *data) {
    12cc:	cf 93       	push	r28
    12ce:	df 93       	push	r29
    12d0:	cd b7       	in	r28, 0x3d	; 61
    12d2:	de b7       	in	r29, 0x3e	; 62
    12d4:	28 97       	sbiw	r28, 0x08	; 8
    12d6:	0f b6       	in	r0, 0x3f	; 63
    12d8:	f8 94       	cli
    12da:	de bf       	out	0x3e, r29	; 62
    12dc:	0f be       	out	0x3f, r0	; 63
    12de:	cd bf       	out	0x3d, r28	; 61
    12e0:	8c 83       	std	Y+4, r24	; 0x04
    12e2:	6d 83       	std	Y+5, r22	; 0x05
    12e4:	4e 83       	std	Y+6, r20	; 0x06
    12e6:	38 87       	std	Y+8, r19	; 0x08
    12e8:	2f 83       	std	Y+7, r18	; 0x07
    // 01101001 read byte
    // 76543210 bit numbers
    //    xxx   args: bitStart=4, length=3
    //    010   masked
    //   -> 010 shifted
    int8_t count = 0;
    12ea:	19 82       	std	Y+1, r1	; 0x01
    if(length > 0) {
    12ec:	8e 81       	ldd	r24, Y+6	; 0x06
    12ee:	88 23       	and	r24, r24
    12f0:	09 f4       	brne	.+2      	; 0x12f4 <mpu6050_readBits+0x28>
    12f2:	45 c0       	rjmp	.+138    	; 0x137e <mpu6050_readBits+0xb2>
		uint8_t b;
		if ((count = mpu6050_readByte(regAddr, &b)) != 0) {
    12f4:	ce 01       	movw	r24, r28
    12f6:	03 96       	adiw	r24, 0x03	; 3
    12f8:	bc 01       	movw	r22, r24
    12fa:	8c 81       	ldd	r24, Y+4	; 0x04
    12fc:	0e 94 0a 09 	call	0x1214	; 0x1214 <mpu6050_readByte>
    1300:	89 83       	std	Y+1, r24	; 0x01
    1302:	89 81       	ldd	r24, Y+1	; 0x01
    1304:	88 23       	and	r24, r24
    1306:	d9 f1       	breq	.+118    	; 0x137e <mpu6050_readBits+0xb2>
			uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
    1308:	8e 81       	ldd	r24, Y+6	; 0x06
    130a:	28 2f       	mov	r18, r24
    130c:	30 e0       	ldi	r19, 0x00	; 0
    130e:	81 e0       	ldi	r24, 0x01	; 1
    1310:	90 e0       	ldi	r25, 0x00	; 0
    1312:	02 c0       	rjmp	.+4      	; 0x1318 <mpu6050_readBits+0x4c>
    1314:	88 0f       	add	r24, r24
    1316:	99 1f       	adc	r25, r25
    1318:	2a 95       	dec	r18
    131a:	e2 f7       	brpl	.-8      	; 0x1314 <mpu6050_readBits+0x48>
    131c:	01 97       	sbiw	r24, 0x01	; 1
    131e:	2d 81       	ldd	r18, Y+5	; 0x05
    1320:	42 2f       	mov	r20, r18
    1322:	50 e0       	ldi	r21, 0x00	; 0
    1324:	2e 81       	ldd	r18, Y+6	; 0x06
    1326:	22 2f       	mov	r18, r18
    1328:	30 e0       	ldi	r19, 0x00	; 0
    132a:	ba 01       	movw	r22, r20
    132c:	62 1b       	sub	r22, r18
    132e:	73 0b       	sbc	r23, r19
    1330:	9b 01       	movw	r18, r22
    1332:	2f 5f       	subi	r18, 0xFF	; 255
    1334:	3f 4f       	sbci	r19, 0xFF	; 255
    1336:	02 c0       	rjmp	.+4      	; 0x133c <mpu6050_readBits+0x70>
    1338:	88 0f       	add	r24, r24
    133a:	99 1f       	adc	r25, r25
    133c:	2a 95       	dec	r18
    133e:	e2 f7       	brpl	.-8      	; 0x1338 <mpu6050_readBits+0x6c>
    1340:	8a 83       	std	Y+2, r24	; 0x02
			b &= mask;
    1342:	9b 81       	ldd	r25, Y+3	; 0x03
    1344:	8a 81       	ldd	r24, Y+2	; 0x02
    1346:	89 23       	and	r24, r25
    1348:	8b 83       	std	Y+3, r24	; 0x03
			b >>= (bitStart - length + 1);
    134a:	8b 81       	ldd	r24, Y+3	; 0x03
    134c:	88 2f       	mov	r24, r24
    134e:	90 e0       	ldi	r25, 0x00	; 0
    1350:	2d 81       	ldd	r18, Y+5	; 0x05
    1352:	42 2f       	mov	r20, r18
    1354:	50 e0       	ldi	r21, 0x00	; 0
    1356:	2e 81       	ldd	r18, Y+6	; 0x06
    1358:	22 2f       	mov	r18, r18
    135a:	30 e0       	ldi	r19, 0x00	; 0
    135c:	fa 01       	movw	r30, r20
    135e:	e2 1b       	sub	r30, r18
    1360:	f3 0b       	sbc	r31, r19
    1362:	9f 01       	movw	r18, r30
    1364:	2f 5f       	subi	r18, 0xFF	; 255
    1366:	3f 4f       	sbci	r19, 0xFF	; 255
    1368:	02 c0       	rjmp	.+4      	; 0x136e <mpu6050_readBits+0xa2>
    136a:	95 95       	asr	r25
    136c:	87 95       	ror	r24
    136e:	2a 95       	dec	r18
    1370:	e2 f7       	brpl	.-8      	; 0x136a <mpu6050_readBits+0x9e>
    1372:	8b 83       	std	Y+3, r24	; 0x03
			*data = b;
    1374:	2b 81       	ldd	r18, Y+3	; 0x03
    1376:	8f 81       	ldd	r24, Y+7	; 0x07
    1378:	98 85       	ldd	r25, Y+8	; 0x08
    137a:	fc 01       	movw	r30, r24
    137c:	20 83       	st	Z, r18
		}
    }
    return count;
    137e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1380:	28 96       	adiw	r28, 0x08	; 8
    1382:	0f b6       	in	r0, 0x3f	; 63
    1384:	f8 94       	cli
    1386:	de bf       	out	0x3e, r29	; 62
    1388:	0f be       	out	0x3f, r0	; 63
    138a:	cd bf       	out	0x3d, r28	; 61
    138c:	df 91       	pop	r29
    138e:	cf 91       	pop	r28
    1390:	08 95       	ret

00001392 <mpu6050_readBit>:

/*
 * read 1 bit from chip register
 */
int8_t mpu6050_readBit(uint8_t regAddr, uint8_t bitNum, uint8_t *data) {
    1392:	cf 93       	push	r28
    1394:	df 93       	push	r29
    1396:	00 d0       	rcall	.+0      	; 0x1398 <mpu6050_readBit+0x6>
    1398:	00 d0       	rcall	.+0      	; 0x139a <mpu6050_readBit+0x8>
    139a:	cd b7       	in	r28, 0x3d	; 61
    139c:	de b7       	in	r29, 0x3e	; 62
    139e:	8b 83       	std	Y+3, r24	; 0x03
    13a0:	6c 83       	std	Y+4, r22	; 0x04
    13a2:	5e 83       	std	Y+6, r21	; 0x06
    13a4:	4d 83       	std	Y+5, r20	; 0x05
    uint8_t b;
    uint8_t count = mpu6050_readByte(regAddr, &b);
    13a6:	ce 01       	movw	r24, r28
    13a8:	02 96       	adiw	r24, 0x02	; 2
    13aa:	bc 01       	movw	r22, r24
    13ac:	8b 81       	ldd	r24, Y+3	; 0x03
    13ae:	0e 94 0a 09 	call	0x1214	; 0x1214 <mpu6050_readByte>
    13b2:	89 83       	std	Y+1, r24	; 0x01
    *data = b & (1 << bitNum);
    13b4:	8c 81       	ldd	r24, Y+4	; 0x04
    13b6:	28 2f       	mov	r18, r24
    13b8:	30 e0       	ldi	r19, 0x00	; 0
    13ba:	81 e0       	ldi	r24, 0x01	; 1
    13bc:	90 e0       	ldi	r25, 0x00	; 0
    13be:	02 c0       	rjmp	.+4      	; 0x13c4 <mpu6050_readBit+0x32>
    13c0:	88 0f       	add	r24, r24
    13c2:	99 1f       	adc	r25, r25
    13c4:	2a 95       	dec	r18
    13c6:	e2 f7       	brpl	.-8      	; 0x13c0 <mpu6050_readBit+0x2e>
    13c8:	98 2f       	mov	r25, r24
    13ca:	8a 81       	ldd	r24, Y+2	; 0x02
    13cc:	89 23       	and	r24, r25
    13ce:	28 2f       	mov	r18, r24
    13d0:	8d 81       	ldd	r24, Y+5	; 0x05
    13d2:	9e 81       	ldd	r25, Y+6	; 0x06
    13d4:	fc 01       	movw	r30, r24
    13d6:	20 83       	st	Z, r18
    return count;
    13d8:	89 81       	ldd	r24, Y+1	; 0x01
}
    13da:	26 96       	adiw	r28, 0x06	; 6
    13dc:	0f b6       	in	r0, 0x3f	; 63
    13de:	f8 94       	cli
    13e0:	de bf       	out	0x3e, r29	; 62
    13e2:	0f be       	out	0x3f, r0	; 63
    13e4:	cd bf       	out	0x3d, r28	; 61
    13e6:	df 91       	pop	r29
    13e8:	cf 91       	pop	r28
    13ea:	08 95       	ret

000013ec <mpu6050_writeBits>:


/*
 * write bit/bits to chip register
 */
void mpu6050_writeBits(uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data) {
    13ec:	cf 93       	push	r28
    13ee:	df 93       	push	r29
    13f0:	00 d0       	rcall	.+0      	; 0x13f2 <mpu6050_writeBits+0x6>
    13f2:	00 d0       	rcall	.+0      	; 0x13f4 <mpu6050_writeBits+0x8>
    13f4:	cd b7       	in	r28, 0x3d	; 61
    13f6:	de b7       	in	r29, 0x3e	; 62
    13f8:	8b 83       	std	Y+3, r24	; 0x03
    13fa:	6c 83       	std	Y+4, r22	; 0x04
    13fc:	4d 83       	std	Y+5, r20	; 0x05
    13fe:	2e 83       	std	Y+6, r18	; 0x06
    //    xxx   args: bitStart=4, length=3
    // 00011100 mask byte
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
	if(length > 0) {
    1400:	8d 81       	ldd	r24, Y+5	; 0x05
    1402:	88 23       	and	r24, r24
    1404:	09 f4       	brne	.+2      	; 0x1408 <mpu6050_writeBits+0x1c>
    1406:	4e c0       	rjmp	.+156    	; 0x14a4 <mpu6050_writeBits+0xb8>
		uint8_t b = 0;
    1408:	1a 82       	std	Y+2, r1	; 0x02
		if (mpu6050_readByte(regAddr, &b) != 0) { //get current data
    140a:	ce 01       	movw	r24, r28
    140c:	02 96       	adiw	r24, 0x02	; 2
    140e:	bc 01       	movw	r22, r24
    1410:	8b 81       	ldd	r24, Y+3	; 0x03
    1412:	0e 94 0a 09 	call	0x1214	; 0x1214 <mpu6050_readByte>
    1416:	88 23       	and	r24, r24
    1418:	09 f4       	brne	.+2      	; 0x141c <mpu6050_writeBits+0x30>
    141a:	44 c0       	rjmp	.+136    	; 0x14a4 <mpu6050_writeBits+0xb8>
			uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
    141c:	8d 81       	ldd	r24, Y+5	; 0x05
    141e:	28 2f       	mov	r18, r24
    1420:	30 e0       	ldi	r19, 0x00	; 0
    1422:	81 e0       	ldi	r24, 0x01	; 1
    1424:	90 e0       	ldi	r25, 0x00	; 0
    1426:	02 c0       	rjmp	.+4      	; 0x142c <mpu6050_writeBits+0x40>
    1428:	88 0f       	add	r24, r24
    142a:	99 1f       	adc	r25, r25
    142c:	2a 95       	dec	r18
    142e:	e2 f7       	brpl	.-8      	; 0x1428 <mpu6050_writeBits+0x3c>
    1430:	01 97       	sbiw	r24, 0x01	; 1
    1432:	2c 81       	ldd	r18, Y+4	; 0x04
    1434:	42 2f       	mov	r20, r18
    1436:	50 e0       	ldi	r21, 0x00	; 0
    1438:	2d 81       	ldd	r18, Y+5	; 0x05
    143a:	22 2f       	mov	r18, r18
    143c:	30 e0       	ldi	r19, 0x00	; 0
    143e:	ba 01       	movw	r22, r20
    1440:	62 1b       	sub	r22, r18
    1442:	73 0b       	sbc	r23, r19
    1444:	9b 01       	movw	r18, r22
    1446:	2f 5f       	subi	r18, 0xFF	; 255
    1448:	3f 4f       	sbci	r19, 0xFF	; 255
    144a:	02 c0       	rjmp	.+4      	; 0x1450 <mpu6050_writeBits+0x64>
    144c:	88 0f       	add	r24, r24
    144e:	99 1f       	adc	r25, r25
    1450:	2a 95       	dec	r18
    1452:	e2 f7       	brpl	.-8      	; 0x144c <mpu6050_writeBits+0x60>
    1454:	89 83       	std	Y+1, r24	; 0x01
			data <<= (bitStart - length + 1); // shift data into correct position
    1456:	8e 81       	ldd	r24, Y+6	; 0x06
    1458:	88 2f       	mov	r24, r24
    145a:	90 e0       	ldi	r25, 0x00	; 0
    145c:	2c 81       	ldd	r18, Y+4	; 0x04
    145e:	42 2f       	mov	r20, r18
    1460:	50 e0       	ldi	r21, 0x00	; 0
    1462:	2d 81       	ldd	r18, Y+5	; 0x05
    1464:	22 2f       	mov	r18, r18
    1466:	30 e0       	ldi	r19, 0x00	; 0
    1468:	ba 01       	movw	r22, r20
    146a:	62 1b       	sub	r22, r18
    146c:	73 0b       	sbc	r23, r19
    146e:	9b 01       	movw	r18, r22
    1470:	2f 5f       	subi	r18, 0xFF	; 255
    1472:	3f 4f       	sbci	r19, 0xFF	; 255
    1474:	02 c0       	rjmp	.+4      	; 0x147a <mpu6050_writeBits+0x8e>
    1476:	88 0f       	add	r24, r24
    1478:	99 1f       	adc	r25, r25
    147a:	2a 95       	dec	r18
    147c:	e2 f7       	brpl	.-8      	; 0x1476 <mpu6050_writeBits+0x8a>
    147e:	8e 83       	std	Y+6, r24	; 0x06
			data &= mask; // zero all non-important bits in data
    1480:	9e 81       	ldd	r25, Y+6	; 0x06
    1482:	89 81       	ldd	r24, Y+1	; 0x01
    1484:	89 23       	and	r24, r25
    1486:	8e 83       	std	Y+6, r24	; 0x06
			b &= ~(mask); // zero all important bits in existing byte
    1488:	89 81       	ldd	r24, Y+1	; 0x01
    148a:	80 95       	com	r24
    148c:	9a 81       	ldd	r25, Y+2	; 0x02
    148e:	89 23       	and	r24, r25
    1490:	8a 83       	std	Y+2, r24	; 0x02
			b |= data; // combine data with existing byte
    1492:	9a 81       	ldd	r25, Y+2	; 0x02
    1494:	8e 81       	ldd	r24, Y+6	; 0x06
    1496:	89 2b       	or	r24, r25
    1498:	8a 83       	std	Y+2, r24	; 0x02
			mpu6050_writeByte(regAddr, b);
    149a:	8a 81       	ldd	r24, Y+2	; 0x02
    149c:	68 2f       	mov	r22, r24
    149e:	8b 81       	ldd	r24, Y+3	; 0x03
    14a0:	0e 94 51 09 	call	0x12a2	; 0x12a2 <mpu6050_writeByte>
		}
	}
}
    14a4:	26 96       	adiw	r28, 0x06	; 6
    14a6:	0f b6       	in	r0, 0x3f	; 63
    14a8:	f8 94       	cli
    14aa:	de bf       	out	0x3e, r29	; 62
    14ac:	0f be       	out	0x3f, r0	; 63
    14ae:	cd bf       	out	0x3d, r28	; 61
    14b0:	df 91       	pop	r29
    14b2:	cf 91       	pop	r28
    14b4:	08 95       	ret

000014b6 <mpu6050_writeBit>:

/*
 * write one bit to chip register
 */
void mpu6050_writeBit(uint8_t regAddr, uint8_t bitNum, uint8_t data) {
    14b6:	cf 93       	push	r28
    14b8:	df 93       	push	r29
    14ba:	00 d0       	rcall	.+0      	; 0x14bc <mpu6050_writeBit+0x6>
    14bc:	1f 92       	push	r1
    14be:	cd b7       	in	r28, 0x3d	; 61
    14c0:	de b7       	in	r29, 0x3e	; 62
    14c2:	8a 83       	std	Y+2, r24	; 0x02
    14c4:	6b 83       	std	Y+3, r22	; 0x03
    14c6:	4c 83       	std	Y+4, r20	; 0x04
    uint8_t b;
    mpu6050_readByte(regAddr, &b);
    14c8:	ce 01       	movw	r24, r28
    14ca:	01 96       	adiw	r24, 0x01	; 1
    14cc:	bc 01       	movw	r22, r24
    14ce:	8a 81       	ldd	r24, Y+2	; 0x02
    14d0:	0e 94 0a 09 	call	0x1214	; 0x1214 <mpu6050_readByte>
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    14d4:	8c 81       	ldd	r24, Y+4	; 0x04
    14d6:	88 23       	and	r24, r24
    14d8:	71 f0       	breq	.+28     	; 0x14f6 <mpu6050_writeBit+0x40>
    14da:	8b 81       	ldd	r24, Y+3	; 0x03
    14dc:	28 2f       	mov	r18, r24
    14de:	30 e0       	ldi	r19, 0x00	; 0
    14e0:	81 e0       	ldi	r24, 0x01	; 1
    14e2:	90 e0       	ldi	r25, 0x00	; 0
    14e4:	02 c0       	rjmp	.+4      	; 0x14ea <mpu6050_writeBit+0x34>
    14e6:	88 0f       	add	r24, r24
    14e8:	99 1f       	adc	r25, r25
    14ea:	2a 95       	dec	r18
    14ec:	e2 f7       	brpl	.-8      	; 0x14e6 <mpu6050_writeBit+0x30>
    14ee:	98 2f       	mov	r25, r24
    14f0:	89 81       	ldd	r24, Y+1	; 0x01
    14f2:	89 2b       	or	r24, r25
    14f4:	0d c0       	rjmp	.+26     	; 0x1510 <mpu6050_writeBit+0x5a>
    14f6:	8b 81       	ldd	r24, Y+3	; 0x03
    14f8:	28 2f       	mov	r18, r24
    14fa:	30 e0       	ldi	r19, 0x00	; 0
    14fc:	81 e0       	ldi	r24, 0x01	; 1
    14fe:	90 e0       	ldi	r25, 0x00	; 0
    1500:	02 c0       	rjmp	.+4      	; 0x1506 <mpu6050_writeBit+0x50>
    1502:	88 0f       	add	r24, r24
    1504:	99 1f       	adc	r25, r25
    1506:	2a 95       	dec	r18
    1508:	e2 f7       	brpl	.-8      	; 0x1502 <mpu6050_writeBit+0x4c>
    150a:	80 95       	com	r24
    150c:	99 81       	ldd	r25, Y+1	; 0x01
    150e:	89 23       	and	r24, r25
    1510:	89 83       	std	Y+1, r24	; 0x01
    mpu6050_writeByte(regAddr, b);
    1512:	89 81       	ldd	r24, Y+1	; 0x01
    1514:	68 2f       	mov	r22, r24
    1516:	8a 81       	ldd	r24, Y+2	; 0x02
    1518:	0e 94 51 09 	call	0x12a2	; 0x12a2 <mpu6050_writeByte>
}
    151c:	0f 90       	pop	r0
    151e:	0f 90       	pop	r0
    1520:	0f 90       	pop	r0
    1522:	0f 90       	pop	r0
    1524:	df 91       	pop	r29
    1526:	cf 91       	pop	r28
    1528:	08 95       	ret

0000152a <mpu6050_getRawData>:


void mpu6050_getRawData(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
    152a:	ef 92       	push	r14
    152c:	ff 92       	push	r15
    152e:	0f 93       	push	r16
    1530:	1f 93       	push	r17
    1532:	cf 93       	push	r28
    1534:	df 93       	push	r29
    1536:	cd b7       	in	r28, 0x3d	; 61
    1538:	de b7       	in	r29, 0x3e	; 62
    153a:	2c 97       	sbiw	r28, 0x0c	; 12
    153c:	0f b6       	in	r0, 0x3f	; 63
    153e:	f8 94       	cli
    1540:	de bf       	out	0x3e, r29	; 62
    1542:	0f be       	out	0x3f, r0	; 63
    1544:	cd bf       	out	0x3d, r28	; 61
    1546:	9a 83       	std	Y+2, r25	; 0x02
    1548:	89 83       	std	Y+1, r24	; 0x01
    154a:	7c 83       	std	Y+4, r23	; 0x04
    154c:	6b 83       	std	Y+3, r22	; 0x03
    154e:	5e 83       	std	Y+6, r21	; 0x06
    1550:	4d 83       	std	Y+5, r20	; 0x05
    1552:	38 87       	std	Y+8, r19	; 0x08
    1554:	2f 83       	std	Y+7, r18	; 0x07
    1556:	1a 87       	std	Y+10, r17	; 0x0a
    1558:	09 87       	std	Y+9, r16	; 0x09
    155a:	fc 86       	std	Y+12, r15	; 0x0c
    155c:	eb 86       	std	Y+11, r14	; 0x0b
	mpu6050_readBytes(MPU6050_RA_ACCEL_XOUT_H, 14, (uint8_t *)buffer);
    155e:	45 ea       	ldi	r20, 0xA5	; 165
    1560:	52 e0       	ldi	r21, 0x02	; 2
    1562:	6e e0       	ldi	r22, 0x0E	; 14
    1564:	8b e3       	ldi	r24, 0x3B	; 59
    1566:	0e 94 b3 08 	call	0x1166	; 0x1166 <mpu6050_readBytes>

    *ax = (((int16_t)buffer[0]) << 8) | buffer[1];
    156a:	80 91 a5 02 	lds	r24, 0x02A5
    156e:	88 2f       	mov	r24, r24
    1570:	90 e0       	ldi	r25, 0x00	; 0
    1572:	38 2f       	mov	r19, r24
    1574:	22 27       	eor	r18, r18
    1576:	80 91 a6 02 	lds	r24, 0x02A6
    157a:	88 2f       	mov	r24, r24
    157c:	90 e0       	ldi	r25, 0x00	; 0
    157e:	28 2b       	or	r18, r24
    1580:	39 2b       	or	r19, r25
    1582:	89 81       	ldd	r24, Y+1	; 0x01
    1584:	9a 81       	ldd	r25, Y+2	; 0x02
    1586:	fc 01       	movw	r30, r24
    1588:	31 83       	std	Z+1, r19	; 0x01
    158a:	20 83       	st	Z, r18
    *ay = (((int16_t)buffer[2]) << 8) | buffer[3];
    158c:	80 91 a7 02 	lds	r24, 0x02A7
    1590:	88 2f       	mov	r24, r24
    1592:	90 e0       	ldi	r25, 0x00	; 0
    1594:	38 2f       	mov	r19, r24
    1596:	22 27       	eor	r18, r18
    1598:	80 91 a8 02 	lds	r24, 0x02A8
    159c:	88 2f       	mov	r24, r24
    159e:	90 e0       	ldi	r25, 0x00	; 0
    15a0:	28 2b       	or	r18, r24
    15a2:	39 2b       	or	r19, r25
    15a4:	8b 81       	ldd	r24, Y+3	; 0x03
    15a6:	9c 81       	ldd	r25, Y+4	; 0x04
    15a8:	fc 01       	movw	r30, r24
    15aa:	31 83       	std	Z+1, r19	; 0x01
    15ac:	20 83       	st	Z, r18
    *az = (((int16_t)buffer[4]) << 8) | buffer[5];
    15ae:	80 91 a9 02 	lds	r24, 0x02A9
    15b2:	88 2f       	mov	r24, r24
    15b4:	90 e0       	ldi	r25, 0x00	; 0
    15b6:	38 2f       	mov	r19, r24
    15b8:	22 27       	eor	r18, r18
    15ba:	80 91 aa 02 	lds	r24, 0x02AA
    15be:	88 2f       	mov	r24, r24
    15c0:	90 e0       	ldi	r25, 0x00	; 0
    15c2:	28 2b       	or	r18, r24
    15c4:	39 2b       	or	r19, r25
    15c6:	8d 81       	ldd	r24, Y+5	; 0x05
    15c8:	9e 81       	ldd	r25, Y+6	; 0x06
    15ca:	fc 01       	movw	r30, r24
    15cc:	31 83       	std	Z+1, r19	; 0x01
    15ce:	20 83       	st	Z, r18
    *gx = (((int16_t)buffer[8]) << 8) | buffer[9];
    15d0:	80 91 ad 02 	lds	r24, 0x02AD
    15d4:	88 2f       	mov	r24, r24
    15d6:	90 e0       	ldi	r25, 0x00	; 0
    15d8:	38 2f       	mov	r19, r24
    15da:	22 27       	eor	r18, r18
    15dc:	80 91 ae 02 	lds	r24, 0x02AE
    15e0:	88 2f       	mov	r24, r24
    15e2:	90 e0       	ldi	r25, 0x00	; 0
    15e4:	28 2b       	or	r18, r24
    15e6:	39 2b       	or	r19, r25
    15e8:	8f 81       	ldd	r24, Y+7	; 0x07
    15ea:	98 85       	ldd	r25, Y+8	; 0x08
    15ec:	fc 01       	movw	r30, r24
    15ee:	31 83       	std	Z+1, r19	; 0x01
    15f0:	20 83       	st	Z, r18
    *gy = (((int16_t)buffer[10]) << 8) | buffer[11];
    15f2:	80 91 af 02 	lds	r24, 0x02AF
    15f6:	88 2f       	mov	r24, r24
    15f8:	90 e0       	ldi	r25, 0x00	; 0
    15fa:	38 2f       	mov	r19, r24
    15fc:	22 27       	eor	r18, r18
    15fe:	80 91 b0 02 	lds	r24, 0x02B0
    1602:	88 2f       	mov	r24, r24
    1604:	90 e0       	ldi	r25, 0x00	; 0
    1606:	28 2b       	or	r18, r24
    1608:	39 2b       	or	r19, r25
    160a:	89 85       	ldd	r24, Y+9	; 0x09
    160c:	9a 85       	ldd	r25, Y+10	; 0x0a
    160e:	fc 01       	movw	r30, r24
    1610:	31 83       	std	Z+1, r19	; 0x01
    1612:	20 83       	st	Z, r18
    *gz = (((int16_t)buffer[12]) << 8) | buffer[13];
    1614:	80 91 b1 02 	lds	r24, 0x02B1
    1618:	88 2f       	mov	r24, r24
    161a:	90 e0       	ldi	r25, 0x00	; 0
    161c:	38 2f       	mov	r19, r24
    161e:	22 27       	eor	r18, r18
    1620:	80 91 b2 02 	lds	r24, 0x02B2
    1624:	88 2f       	mov	r24, r24
    1626:	90 e0       	ldi	r25, 0x00	; 0
    1628:	28 2b       	or	r18, r24
    162a:	39 2b       	or	r19, r25
    162c:	8b 85       	ldd	r24, Y+11	; 0x0b
    162e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1630:	fc 01       	movw	r30, r24
    1632:	31 83       	std	Z+1, r19	; 0x01
    1634:	20 83       	st	Z, r18
}
    1636:	2c 96       	adiw	r28, 0x0c	; 12
    1638:	0f b6       	in	r0, 0x3f	; 63
    163a:	f8 94       	cli
    163c:	de bf       	out	0x3e, r29	; 62
    163e:	0f be       	out	0x3f, r0	; 63
    1640:	cd bf       	out	0x3d, r28	; 61
    1642:	df 91       	pop	r29
    1644:	cf 91       	pop	r28
    1646:	1f 91       	pop	r17
    1648:	0f 91       	pop	r16
    164a:	ff 90       	pop	r15
    164c:	ef 90       	pop	r14
    164e:	08 95       	ret

00001650 <mpu6050_getConvData>:


/*
 * get raw data converted to g and deg/sec values
 */
void mpu6050_getConvData(double* axg, double* ayg, double* azg, double* gxds, double* gyds, double* gzds) {
    1650:	ef 92       	push	r14
    1652:	ff 92       	push	r15
    1654:	0f 93       	push	r16
    1656:	1f 93       	push	r17
    1658:	cf 93       	push	r28
    165a:	df 93       	push	r29
    165c:	cd b7       	in	r28, 0x3d	; 61
    165e:	de b7       	in	r29, 0x3e	; 62
    1660:	68 97       	sbiw	r28, 0x18	; 24
    1662:	0f b6       	in	r0, 0x3f	; 63
    1664:	f8 94       	cli
    1666:	de bf       	out	0x3e, r29	; 62
    1668:	0f be       	out	0x3f, r0	; 63
    166a:	cd bf       	out	0x3d, r28	; 61
    166c:	9e 87       	std	Y+14, r25	; 0x0e
    166e:	8d 87       	std	Y+13, r24	; 0x0d
    1670:	78 8b       	std	Y+16, r23	; 0x10
    1672:	6f 87       	std	Y+15, r22	; 0x0f
    1674:	5a 8b       	std	Y+18, r21	; 0x12
    1676:	49 8b       	std	Y+17, r20	; 0x11
    1678:	3c 8b       	std	Y+20, r19	; 0x14
    167a:	2b 8b       	std	Y+19, r18	; 0x13
    167c:	1e 8b       	std	Y+22, r17	; 0x16
    167e:	0d 8b       	std	Y+21, r16	; 0x15
    1680:	f8 8e       	std	Y+24, r15	; 0x18
    1682:	ef 8a       	std	Y+23, r14	; 0x17
	int16_t ax = 0;
    1684:	1a 82       	std	Y+2, r1	; 0x02
    1686:	19 82       	std	Y+1, r1	; 0x01
	int16_t ay = 0;
    1688:	1c 82       	std	Y+4, r1	; 0x04
    168a:	1b 82       	std	Y+3, r1	; 0x03
	int16_t az = 0;
    168c:	1e 82       	std	Y+6, r1	; 0x06
    168e:	1d 82       	std	Y+5, r1	; 0x05
	int16_t gx = 0;
    1690:	18 86       	std	Y+8, r1	; 0x08
    1692:	1f 82       	std	Y+7, r1	; 0x07
	int16_t gy = 0;
    1694:	1a 86       	std	Y+10, r1	; 0x0a
    1696:	19 86       	std	Y+9, r1	; 0x09
	int16_t gz = 0;
    1698:	1c 86       	std	Y+12, r1	; 0x0c
    169a:	1b 86       	std	Y+11, r1	; 0x0b
	mpu6050_getRawData(&ax, &ay, &az, &gx, &gy, &gz);
    169c:	fe 01       	movw	r30, r28
    169e:	3b 96       	adiw	r30, 0x0b	; 11
    16a0:	be 01       	movw	r22, r28
    16a2:	67 5f       	subi	r22, 0xF7	; 247
    16a4:	7f 4f       	sbci	r23, 0xFF	; 255
    16a6:	9e 01       	movw	r18, r28
    16a8:	29 5f       	subi	r18, 0xF9	; 249
    16aa:	3f 4f       	sbci	r19, 0xFF	; 255
    16ac:	ae 01       	movw	r20, r28
    16ae:	4b 5f       	subi	r20, 0xFB	; 251
    16b0:	5f 4f       	sbci	r21, 0xFF	; 255
    16b2:	ce 01       	movw	r24, r28
    16b4:	03 96       	adiw	r24, 0x03	; 3
    16b6:	7f 01       	movw	r14, r30
    16b8:	8b 01       	movw	r16, r22
    16ba:	bc 01       	movw	r22, r24
    16bc:	ce 01       	movw	r24, r28
    16be:	01 96       	adiw	r24, 0x01	; 1
    16c0:	0e 94 95 0a 	call	0x152a	; 0x152a <mpu6050_getRawData>

	#if MPU6050_CALIBRATEDACCGYRO == 1
    *axg = (double)(ax-MPU6050_AXOFFSET)/MPU6050_AXGAIN;
    16c4:	89 81       	ldd	r24, Y+1	; 0x01
    16c6:	9a 81       	ldd	r25, Y+2	; 0x02
    16c8:	09 2e       	mov	r0, r25
    16ca:	00 0c       	add	r0, r0
    16cc:	aa 0b       	sbc	r26, r26
    16ce:	bb 0b       	sbc	r27, r27
    16d0:	bc 01       	movw	r22, r24
    16d2:	cd 01       	movw	r24, r26
    16d4:	0e 94 89 32 	call	0x6512	; 0x6512 <__floatsisf>
    16d8:	dc 01       	movw	r26, r24
    16da:	cb 01       	movw	r24, r22
    16dc:	20 e0       	ldi	r18, 0x00	; 0
    16de:	30 e0       	ldi	r19, 0x00	; 0
    16e0:	40 e8       	ldi	r20, 0x80	; 128
    16e2:	56 e4       	ldi	r21, 0x46	; 70
    16e4:	bc 01       	movw	r22, r24
    16e6:	cd 01       	movw	r24, r26
    16e8:	0e 94 e6 31 	call	0x63cc	; 0x63cc <__divsf3>
    16ec:	dc 01       	movw	r26, r24
    16ee:	cb 01       	movw	r24, r22
    16f0:	2d 85       	ldd	r18, Y+13	; 0x0d
    16f2:	3e 85       	ldd	r19, Y+14	; 0x0e
    16f4:	f9 01       	movw	r30, r18
    16f6:	80 83       	st	Z, r24
    16f8:	91 83       	std	Z+1, r25	; 0x01
    16fa:	a2 83       	std	Z+2, r26	; 0x02
    16fc:	b3 83       	std	Z+3, r27	; 0x03
    *ayg = (double)(ay-MPU6050_AYOFFSET)/MPU6050_AYGAIN;
    16fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1700:	9c 81       	ldd	r25, Y+4	; 0x04
    1702:	09 2e       	mov	r0, r25
    1704:	00 0c       	add	r0, r0
    1706:	aa 0b       	sbc	r26, r26
    1708:	bb 0b       	sbc	r27, r27
    170a:	bc 01       	movw	r22, r24
    170c:	cd 01       	movw	r24, r26
    170e:	0e 94 89 32 	call	0x6512	; 0x6512 <__floatsisf>
    1712:	dc 01       	movw	r26, r24
    1714:	cb 01       	movw	r24, r22
    1716:	20 e0       	ldi	r18, 0x00	; 0
    1718:	30 e0       	ldi	r19, 0x00	; 0
    171a:	40 e8       	ldi	r20, 0x80	; 128
    171c:	56 e4       	ldi	r21, 0x46	; 70
    171e:	bc 01       	movw	r22, r24
    1720:	cd 01       	movw	r24, r26
    1722:	0e 94 e6 31 	call	0x63cc	; 0x63cc <__divsf3>
    1726:	dc 01       	movw	r26, r24
    1728:	cb 01       	movw	r24, r22
    172a:	2f 85       	ldd	r18, Y+15	; 0x0f
    172c:	38 89       	ldd	r19, Y+16	; 0x10
    172e:	f9 01       	movw	r30, r18
    1730:	80 83       	st	Z, r24
    1732:	91 83       	std	Z+1, r25	; 0x01
    1734:	a2 83       	std	Z+2, r26	; 0x02
    1736:	b3 83       	std	Z+3, r27	; 0x03
    *azg = (double)(az-MPU6050_AZOFFSET)/MPU6050_AZGAIN;
    1738:	8d 81       	ldd	r24, Y+5	; 0x05
    173a:	9e 81       	ldd	r25, Y+6	; 0x06
    173c:	09 2e       	mov	r0, r25
    173e:	00 0c       	add	r0, r0
    1740:	aa 0b       	sbc	r26, r26
    1742:	bb 0b       	sbc	r27, r27
    1744:	bc 01       	movw	r22, r24
    1746:	cd 01       	movw	r24, r26
    1748:	0e 94 89 32 	call	0x6512	; 0x6512 <__floatsisf>
    174c:	dc 01       	movw	r26, r24
    174e:	cb 01       	movw	r24, r22
    1750:	20 e0       	ldi	r18, 0x00	; 0
    1752:	30 e0       	ldi	r19, 0x00	; 0
    1754:	40 e8       	ldi	r20, 0x80	; 128
    1756:	56 e4       	ldi	r21, 0x46	; 70
    1758:	bc 01       	movw	r22, r24
    175a:	cd 01       	movw	r24, r26
    175c:	0e 94 e6 31 	call	0x63cc	; 0x63cc <__divsf3>
    1760:	dc 01       	movw	r26, r24
    1762:	cb 01       	movw	r24, r22
    1764:	29 89       	ldd	r18, Y+17	; 0x11
    1766:	3a 89       	ldd	r19, Y+18	; 0x12
    1768:	f9 01       	movw	r30, r18
    176a:	80 83       	st	Z, r24
    176c:	91 83       	std	Z+1, r25	; 0x01
    176e:	a2 83       	std	Z+2, r26	; 0x02
    1770:	b3 83       	std	Z+3, r27	; 0x03
    *gxds = (double)(gx-MPU6050_GXOFFSET)/MPU6050_GXGAIN;
    1772:	8f 81       	ldd	r24, Y+7	; 0x07
    1774:	98 85       	ldd	r25, Y+8	; 0x08
    1776:	8a 96       	adiw	r24, 0x2a	; 42
    1778:	09 2e       	mov	r0, r25
    177a:	00 0c       	add	r0, r0
    177c:	aa 0b       	sbc	r26, r26
    177e:	bb 0b       	sbc	r27, r27
    1780:	bc 01       	movw	r22, r24
    1782:	cd 01       	movw	r24, r26
    1784:	0e 94 89 32 	call	0x6512	; 0x6512 <__floatsisf>
    1788:	dc 01       	movw	r26, r24
    178a:	cb 01       	movw	r24, r22
    178c:	23 e3       	ldi	r18, 0x33	; 51
    178e:	33 e3       	ldi	r19, 0x33	; 51
    1790:	43 e8       	ldi	r20, 0x83	; 131
    1792:	51 e4       	ldi	r21, 0x41	; 65
    1794:	bc 01       	movw	r22, r24
    1796:	cd 01       	movw	r24, r26
    1798:	0e 94 e6 31 	call	0x63cc	; 0x63cc <__divsf3>
    179c:	dc 01       	movw	r26, r24
    179e:	cb 01       	movw	r24, r22
    17a0:	2b 89       	ldd	r18, Y+19	; 0x13
    17a2:	3c 89       	ldd	r19, Y+20	; 0x14
    17a4:	f9 01       	movw	r30, r18
    17a6:	80 83       	st	Z, r24
    17a8:	91 83       	std	Z+1, r25	; 0x01
    17aa:	a2 83       	std	Z+2, r26	; 0x02
    17ac:	b3 83       	std	Z+3, r27	; 0x03
	*gyds = (double)(gy-MPU6050_GYOFFSET)/MPU6050_GYGAIN;
    17ae:	89 85       	ldd	r24, Y+9	; 0x09
    17b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    17b2:	09 97       	sbiw	r24, 0x09	; 9
    17b4:	09 2e       	mov	r0, r25
    17b6:	00 0c       	add	r0, r0
    17b8:	aa 0b       	sbc	r26, r26
    17ba:	bb 0b       	sbc	r27, r27
    17bc:	bc 01       	movw	r22, r24
    17be:	cd 01       	movw	r24, r26
    17c0:	0e 94 89 32 	call	0x6512	; 0x6512 <__floatsisf>
    17c4:	dc 01       	movw	r26, r24
    17c6:	cb 01       	movw	r24, r22
    17c8:	23 e3       	ldi	r18, 0x33	; 51
    17ca:	33 e3       	ldi	r19, 0x33	; 51
    17cc:	43 e8       	ldi	r20, 0x83	; 131
    17ce:	51 e4       	ldi	r21, 0x41	; 65
    17d0:	bc 01       	movw	r22, r24
    17d2:	cd 01       	movw	r24, r26
    17d4:	0e 94 e6 31 	call	0x63cc	; 0x63cc <__divsf3>
    17d8:	dc 01       	movw	r26, r24
    17da:	cb 01       	movw	r24, r22
    17dc:	2d 89       	ldd	r18, Y+21	; 0x15
    17de:	3e 89       	ldd	r19, Y+22	; 0x16
    17e0:	f9 01       	movw	r30, r18
    17e2:	80 83       	st	Z, r24
    17e4:	91 83       	std	Z+1, r25	; 0x01
    17e6:	a2 83       	std	Z+2, r26	; 0x02
    17e8:	b3 83       	std	Z+3, r27	; 0x03
	*gzds = (double)(gz-MPU6050_GZOFFSET)/MPU6050_GZGAIN;
    17ea:	8b 85       	ldd	r24, Y+11	; 0x0b
    17ec:	9c 85       	ldd	r25, Y+12	; 0x0c
    17ee:	4d 96       	adiw	r24, 0x1d	; 29
    17f0:	09 2e       	mov	r0, r25
    17f2:	00 0c       	add	r0, r0
    17f4:	aa 0b       	sbc	r26, r26
    17f6:	bb 0b       	sbc	r27, r27
    17f8:	bc 01       	movw	r22, r24
    17fa:	cd 01       	movw	r24, r26
    17fc:	0e 94 89 32 	call	0x6512	; 0x6512 <__floatsisf>
    1800:	dc 01       	movw	r26, r24
    1802:	cb 01       	movw	r24, r22
    1804:	23 e3       	ldi	r18, 0x33	; 51
    1806:	33 e3       	ldi	r19, 0x33	; 51
    1808:	43 e8       	ldi	r20, 0x83	; 131
    180a:	51 e4       	ldi	r21, 0x41	; 65
    180c:	bc 01       	movw	r22, r24
    180e:	cd 01       	movw	r24, r26
    1810:	0e 94 e6 31 	call	0x63cc	; 0x63cc <__divsf3>
    1814:	dc 01       	movw	r26, r24
    1816:	cb 01       	movw	r24, r22
    1818:	2f 89       	ldd	r18, Y+23	; 0x17
    181a:	38 8d       	ldd	r19, Y+24	; 0x18
    181c:	f9 01       	movw	r30, r18
    181e:	80 83       	st	Z, r24
    1820:	91 83       	std	Z+1, r25	; 0x01
    1822:	a2 83       	std	Z+2, r26	; 0x02
    1824:	b3 83       	std	Z+3, r27	; 0x03
    *azg = (double)(az)/MPU6050_AGAIN;
    *gxds = (double)(gx)/MPU6050_GGAIN;
	*gyds = (double)(gy)/MPU6050_GGAIN;
	*gzds = (double)(gz)/MPU6050_GGAIN;
	#endif
}
    1826:	68 96       	adiw	r28, 0x18	; 24
    1828:	0f b6       	in	r0, 0x3f	; 63
    182a:	f8 94       	cli
    182c:	de bf       	out	0x3e, r29	; 62
    182e:	0f be       	out	0x3f, r0	; 63
    1830:	cd bf       	out	0x3d, r28	; 61
    1832:	df 91       	pop	r29
    1834:	cf 91       	pop	r28
    1836:	1f 91       	pop	r17
    1838:	0f 91       	pop	r16
    183a:	ff 90       	pop	r15
    183c:	ef 90       	pop	r14
    183e:	08 95       	ret

00001840 <mpu6050_init>:
/*
 * initialize the accel and gyro
 */
void mpu6050_init() {
    1840:	cf 93       	push	r28
    1842:	df 93       	push	r29
    1844:	cd b7       	in	r28, 0x3d	; 61
    1846:	de b7       	in	r29, 0x3e	; 62
	mpu6050_writeBits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, MPU6050_CLOCK_PLL_XGYRO);
    1848:	21 e0       	ldi	r18, 0x01	; 1
    184a:	43 e0       	ldi	r20, 0x03	; 3
    184c:	62 e0       	ldi	r22, 0x02	; 2
    184e:	8b e6       	ldi	r24, 0x6B	; 107
    1850:	0e 94 f6 09 	call	0x13ec	; 0x13ec <mpu6050_writeBits>
	//set DLPF bandwidth to 42Hz
	mpu6050_writeBits(MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, MPU6050_DLPF_BW_42);
    1854:	23 e0       	ldi	r18, 0x03	; 3
    1856:	43 e0       	ldi	r20, 0x03	; 3
    1858:	62 e0       	ldi	r22, 0x02	; 2
    185a:	8a e1       	ldi	r24, 0x1A	; 26
    185c:	0e 94 f6 09 	call	0x13ec	; 0x13ec <mpu6050_writeBits>
    //set sampe rate
	mpu6050_writeByte(MPU6050_RA_SMPLRT_DIV, 4); //1khz / (1 + 4) = 200Hz
    1860:	64 e0       	ldi	r22, 0x04	; 4
    1862:	89 e1       	ldi	r24, 0x19	; 25
    1864:	0e 94 51 09 	call	0x12a2	; 0x12a2 <mpu6050_writeByte>
	//set gyro range
	mpu6050_writeBits(MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, MPU6050_GYRO_FS);
    1868:	23 e0       	ldi	r18, 0x03	; 3
    186a:	42 e0       	ldi	r20, 0x02	; 2
    186c:	64 e0       	ldi	r22, 0x04	; 4
    186e:	8b e1       	ldi	r24, 0x1B	; 27
    1870:	0e 94 f6 09 	call	0x13ec	; 0x13ec <mpu6050_writeBits>
	//set accel range
	mpu6050_writeBits(MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, MPU6050_ACCEL_FS);
    1874:	20 e0       	ldi	r18, 0x00	; 0
    1876:	42 e0       	ldi	r20, 0x02	; 2
    1878:	64 e0       	ldi	r22, 0x04	; 4
    187a:	8c e1       	ldi	r24, 0x1C	; 28
    187c:	0e 94 f6 09 	call	0x13ec	; 0x13ec <mpu6050_writeBits>


}
    1880:	df 91       	pop	r29
    1882:	cf 91       	pop	r28
    1884:	08 95       	ret

00001886 <mpu6050_setSleepDisabled>:
/*
 * set sleep disabled
 */
void mpu6050_setSleepDisabled() {
    1886:	cf 93       	push	r28
    1888:	df 93       	push	r29
    188a:	cd b7       	in	r28, 0x3d	; 61
    188c:	de b7       	in	r29, 0x3e	; 62
	mpu6050_writeBit(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 0);
    188e:	40 e0       	ldi	r20, 0x00	; 0
    1890:	66 e0       	ldi	r22, 0x06	; 6
    1892:	8b e6       	ldi	r24, 0x6B	; 107
    1894:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <mpu6050_writeBit>
}
    1898:	df 91       	pop	r29
    189a:	cf 91       	pop	r28
    189c:	08 95       	ret

0000189e <readBytesFromMPU6050>:

// buffer for the temperature of the sensor
uint8_t temp_buff[2];

// Read datas from mpu6050 registers
int8_t readBytesFromMPU6050(uint8_t regAddr, uint8_t length, uint8_t *data){
    189e:	0f 93       	push	r16
    18a0:	1f 93       	push	r17
    18a2:	cf 93       	push	r28
    18a4:	df 93       	push	r29
    18a6:	00 d0       	rcall	.+0      	; 0x18a8 <readBytesFromMPU6050+0xa>
    18a8:	00 d0       	rcall	.+0      	; 0x18aa <readBytesFromMPU6050+0xc>
    18aa:	cd b7       	in	r28, 0x3d	; 61
    18ac:	de b7       	in	r29, 0x3e	; 62
    18ae:	8b 83       	std	Y+3, r24	; 0x03
    18b0:	6c 83       	std	Y+4, r22	; 0x04
    18b2:	5e 83       	std	Y+6, r21	; 0x06
    18b4:	4d 83       	std	Y+5, r20	; 0x05
	uint8_t i = 0;
    18b6:	19 82       	std	Y+1, r1	; 0x01
	int8_t count = 0;
    18b8:	1a 82       	std	Y+2, r1	; 0x02
	if(length > 0) {
    18ba:	8c 81       	ldd	r24, Y+4	; 0x04
    18bc:	88 23       	and	r24, r24
    18be:	d1 f1       	breq	.+116    	; 0x1934 <readBytesFromMPU6050+0x96>
		// start comm
		i2c_start(MPU6050_ADDR | I2C_WRITE);
    18c0:	80 ed       	ldi	r24, 0xD0	; 208
    18c2:	0e 94 36 03 	call	0x66c	; 0x66c <i2c_start>
		i2c_write(regAddr);
    18c6:	8b 81       	ldd	r24, Y+3	; 0x03
    18c8:	0e 94 bf 04 	call	0x97e	; 0x97e <i2c_write>

		//read data
		i2c_start(MPU6050_ADDR | I2C_READ);
    18cc:	81 ed       	ldi	r24, 0xD1	; 209
    18ce:	0e 94 36 03 	call	0x66c	; 0x66c <i2c_start>
		for(i=0; i<length; i++) {
    18d2:	19 82       	std	Y+1, r1	; 0x01
    18d4:	29 c0       	rjmp	.+82     	; 0x1928 <readBytesFromMPU6050+0x8a>
			count++;
    18d6:	8a 81       	ldd	r24, Y+2	; 0x02
    18d8:	8f 5f       	subi	r24, 0xFF	; 255
    18da:	8a 83       	std	Y+2, r24	; 0x02
			if(i==length-1)
    18dc:	89 81       	ldd	r24, Y+1	; 0x01
    18de:	28 2f       	mov	r18, r24
    18e0:	30 e0       	ldi	r19, 0x00	; 0
    18e2:	8c 81       	ldd	r24, Y+4	; 0x04
    18e4:	88 2f       	mov	r24, r24
    18e6:	90 e0       	ldi	r25, 0x00	; 0
    18e8:	01 97       	sbiw	r24, 0x01	; 1
    18ea:	28 17       	cp	r18, r24
    18ec:	39 07       	cpc	r19, r25
    18ee:	69 f4       	brne	.+26     	; 0x190a <readBytesFromMPU6050+0x6c>
				data[i] = i2c_readNak();
    18f0:	89 81       	ldd	r24, Y+1	; 0x01
    18f2:	88 2f       	mov	r24, r24
    18f4:	90 e0       	ldi	r25, 0x00	; 0
    18f6:	2d 81       	ldd	r18, Y+5	; 0x05
    18f8:	3e 81       	ldd	r19, Y+6	; 0x06
    18fa:	89 01       	movw	r16, r18
    18fc:	08 0f       	add	r16, r24
    18fe:	19 1f       	adc	r17, r25
    1900:	0e 94 59 05 	call	0xab2	; 0xab2 <i2c_readNak>
    1904:	f8 01       	movw	r30, r16
    1906:	80 83       	st	Z, r24
    1908:	0c c0       	rjmp	.+24     	; 0x1922 <readBytesFromMPU6050+0x84>
			else
				data[i] = i2c_readAck();
    190a:	89 81       	ldd	r24, Y+1	; 0x01
    190c:	88 2f       	mov	r24, r24
    190e:	90 e0       	ldi	r25, 0x00	; 0
    1910:	2d 81       	ldd	r18, Y+5	; 0x05
    1912:	3e 81       	ldd	r19, Y+6	; 0x06
    1914:	89 01       	movw	r16, r18
    1916:	08 0f       	add	r16, r24
    1918:	19 1f       	adc	r17, r25
    191a:	0e 94 14 05 	call	0xa28	; 0xa28 <i2c_readAck>
    191e:	f8 01       	movw	r30, r16
    1920:	80 83       	st	Z, r24
		i2c_start(MPU6050_ADDR | I2C_WRITE);
		i2c_write(regAddr);

		//read data
		i2c_start(MPU6050_ADDR | I2C_READ);
		for(i=0; i<length; i++) {
    1922:	89 81       	ldd	r24, Y+1	; 0x01
    1924:	8f 5f       	subi	r24, 0xFF	; 255
    1926:	89 83       	std	Y+1, r24	; 0x01
    1928:	99 81       	ldd	r25, Y+1	; 0x01
    192a:	8c 81       	ldd	r24, Y+4	; 0x04
    192c:	98 17       	cp	r25, r24
    192e:	98 f2       	brcs	.-90     	; 0x18d6 <readBytesFromMPU6050+0x38>
			if(i==length-1)
				data[i] = i2c_readNak();
			else
				data[i] = i2c_readAck();
		}
		i2c_stop();
    1930:	0e 94 84 04 	call	0x908	; 0x908 <i2c_stop>
	}
	return count;
    1934:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1936:	26 96       	adiw	r28, 0x06	; 6
    1938:	0f b6       	in	r0, 0x3f	; 63
    193a:	f8 94       	cli
    193c:	de bf       	out	0x3e, r29	; 62
    193e:	0f be       	out	0x3f, r0	; 63
    1940:	cd bf       	out	0x3d, r28	; 61
    1942:	df 91       	pop	r29
    1944:	cf 91       	pop	r28
    1946:	1f 91       	pop	r17
    1948:	0f 91       	pop	r16
    194a:	08 95       	ret

0000194c <getConvData>:

// get convert data from mpu6050
void getConvData(double *acelX, double *acelY, double *acelZ, double *rateX, double *rateY, double *rateZ){
    194c:	ef 92       	push	r14
    194e:	ff 92       	push	r15
    1950:	0f 93       	push	r16
    1952:	1f 93       	push	r17
    1954:	cf 93       	push	r28
    1956:	df 93       	push	r29
    1958:	cd b7       	in	r28, 0x3d	; 61
    195a:	de b7       	in	r29, 0x3e	; 62
    195c:	a4 97       	sbiw	r28, 0x24	; 36
    195e:	0f b6       	in	r0, 0x3f	; 63
    1960:	f8 94       	cli
    1962:	de bf       	out	0x3e, r29	; 62
    1964:	0f be       	out	0x3f, r0	; 63
    1966:	cd bf       	out	0x3d, r28	; 61
    1968:	9a 8f       	std	Y+26, r25	; 0x1a
    196a:	89 8f       	std	Y+25, r24	; 0x19
    196c:	7c 8f       	std	Y+28, r23	; 0x1c
    196e:	6b 8f       	std	Y+27, r22	; 0x1b
    1970:	5e 8f       	std	Y+30, r21	; 0x1e
    1972:	4d 8f       	std	Y+29, r20	; 0x1d
    1974:	38 a3       	std	Y+32, r19	; 0x20
    1976:	2f 8f       	std	Y+31, r18	; 0x1f
    1978:	1a a3       	std	Y+34, r17	; 0x22
    197a:	09 a3       	std	Y+33, r16	; 0x21
    197c:	fc a2       	std	Y+36, r15	; 0x24
    197e:	eb a2       	std	Y+35, r14	; 0x23
	double ax = 0;
    1980:	19 82       	std	Y+1, r1	; 0x01
    1982:	1a 82       	std	Y+2, r1	; 0x02
    1984:	1b 82       	std	Y+3, r1	; 0x03
    1986:	1c 82       	std	Y+4, r1	; 0x04
	double ay = 0;
    1988:	1d 82       	std	Y+5, r1	; 0x05
    198a:	1e 82       	std	Y+6, r1	; 0x06
    198c:	1f 82       	std	Y+7, r1	; 0x07
    198e:	18 86       	std	Y+8, r1	; 0x08
	double az = 0;
    1990:	19 86       	std	Y+9, r1	; 0x09
    1992:	1a 86       	std	Y+10, r1	; 0x0a
    1994:	1b 86       	std	Y+11, r1	; 0x0b
    1996:	1c 86       	std	Y+12, r1	; 0x0c
	double gx = 0;
    1998:	1d 86       	std	Y+13, r1	; 0x0d
    199a:	1e 86       	std	Y+14, r1	; 0x0e
    199c:	1f 86       	std	Y+15, r1	; 0x0f
    199e:	18 8a       	std	Y+16, r1	; 0x10
	double gy = 0;
    19a0:	19 8a       	std	Y+17, r1	; 0x11
    19a2:	1a 8a       	std	Y+18, r1	; 0x12
    19a4:	1b 8a       	std	Y+19, r1	; 0x13
    19a6:	1c 8a       	std	Y+20, r1	; 0x14
	double gz = 0;
    19a8:	1d 8a       	std	Y+21, r1	; 0x15
    19aa:	1e 8a       	std	Y+22, r1	; 0x16
    19ac:	1f 8a       	std	Y+23, r1	; 0x17
    19ae:	18 8e       	std	Y+24, r1	; 0x18

	mpu6050_getConvData(&ax, &ay, &az, &gx, &gy, &gz);
    19b0:	fe 01       	movw	r30, r28
    19b2:	75 96       	adiw	r30, 0x15	; 21
    19b4:	be 01       	movw	r22, r28
    19b6:	6f 5e       	subi	r22, 0xEF	; 239
    19b8:	7f 4f       	sbci	r23, 0xFF	; 255
    19ba:	9e 01       	movw	r18, r28
    19bc:	23 5f       	subi	r18, 0xF3	; 243
    19be:	3f 4f       	sbci	r19, 0xFF	; 255
    19c0:	ae 01       	movw	r20, r28
    19c2:	47 5f       	subi	r20, 0xF7	; 247
    19c4:	5f 4f       	sbci	r21, 0xFF	; 255
    19c6:	ce 01       	movw	r24, r28
    19c8:	05 96       	adiw	r24, 0x05	; 5
    19ca:	7f 01       	movw	r14, r30
    19cc:	8b 01       	movw	r16, r22
    19ce:	bc 01       	movw	r22, r24
    19d0:	ce 01       	movw	r24, r28
    19d2:	01 96       	adiw	r24, 0x01	; 1
    19d4:	0e 94 28 0b 	call	0x1650	; 0x1650 <mpu6050_getConvData>

	*acelX = ax;
    19d8:	89 81       	ldd	r24, Y+1	; 0x01
    19da:	9a 81       	ldd	r25, Y+2	; 0x02
    19dc:	ab 81       	ldd	r26, Y+3	; 0x03
    19de:	bc 81       	ldd	r27, Y+4	; 0x04
    19e0:	29 8d       	ldd	r18, Y+25	; 0x19
    19e2:	3a 8d       	ldd	r19, Y+26	; 0x1a
    19e4:	f9 01       	movw	r30, r18
    19e6:	80 83       	st	Z, r24
    19e8:	91 83       	std	Z+1, r25	; 0x01
    19ea:	a2 83       	std	Z+2, r26	; 0x02
    19ec:	b3 83       	std	Z+3, r27	; 0x03
	*acelY = ay;
    19ee:	8d 81       	ldd	r24, Y+5	; 0x05
    19f0:	9e 81       	ldd	r25, Y+6	; 0x06
    19f2:	af 81       	ldd	r26, Y+7	; 0x07
    19f4:	b8 85       	ldd	r27, Y+8	; 0x08
    19f6:	2b 8d       	ldd	r18, Y+27	; 0x1b
    19f8:	3c 8d       	ldd	r19, Y+28	; 0x1c
    19fa:	f9 01       	movw	r30, r18
    19fc:	80 83       	st	Z, r24
    19fe:	91 83       	std	Z+1, r25	; 0x01
    1a00:	a2 83       	std	Z+2, r26	; 0x02
    1a02:	b3 83       	std	Z+3, r27	; 0x03
	*acelZ = az;
    1a04:	89 85       	ldd	r24, Y+9	; 0x09
    1a06:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a08:	ab 85       	ldd	r26, Y+11	; 0x0b
    1a0a:	bc 85       	ldd	r27, Y+12	; 0x0c
    1a0c:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1a0e:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1a10:	f9 01       	movw	r30, r18
    1a12:	80 83       	st	Z, r24
    1a14:	91 83       	std	Z+1, r25	; 0x01
    1a16:	a2 83       	std	Z+2, r26	; 0x02
    1a18:	b3 83       	std	Z+3, r27	; 0x03
	*rateX = gx;
    1a1a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a1c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a1e:	af 85       	ldd	r26, Y+15	; 0x0f
    1a20:	b8 89       	ldd	r27, Y+16	; 0x10
    1a22:	2f 8d       	ldd	r18, Y+31	; 0x1f
    1a24:	38 a1       	ldd	r19, Y+32	; 0x20
    1a26:	f9 01       	movw	r30, r18
    1a28:	80 83       	st	Z, r24
    1a2a:	91 83       	std	Z+1, r25	; 0x01
    1a2c:	a2 83       	std	Z+2, r26	; 0x02
    1a2e:	b3 83       	std	Z+3, r27	; 0x03
	*rateY = gy;
    1a30:	89 89       	ldd	r24, Y+17	; 0x11
    1a32:	9a 89       	ldd	r25, Y+18	; 0x12
    1a34:	ab 89       	ldd	r26, Y+19	; 0x13
    1a36:	bc 89       	ldd	r27, Y+20	; 0x14
    1a38:	29 a1       	ldd	r18, Y+33	; 0x21
    1a3a:	3a a1       	ldd	r19, Y+34	; 0x22
    1a3c:	f9 01       	movw	r30, r18
    1a3e:	80 83       	st	Z, r24
    1a40:	91 83       	std	Z+1, r25	; 0x01
    1a42:	a2 83       	std	Z+2, r26	; 0x02
    1a44:	b3 83       	std	Z+3, r27	; 0x03
	*rateZ = gz;
    1a46:	8d 89       	ldd	r24, Y+21	; 0x15
    1a48:	9e 89       	ldd	r25, Y+22	; 0x16
    1a4a:	af 89       	ldd	r26, Y+23	; 0x17
    1a4c:	b8 8d       	ldd	r27, Y+24	; 0x18
    1a4e:	2b a1       	ldd	r18, Y+35	; 0x23
    1a50:	3c a1       	ldd	r19, Y+36	; 0x24
    1a52:	f9 01       	movw	r30, r18
    1a54:	80 83       	st	Z, r24
    1a56:	91 83       	std	Z+1, r25	; 0x01
    1a58:	a2 83       	std	Z+2, r26	; 0x02
    1a5a:	b3 83       	std	Z+3, r27	; 0x03
}
    1a5c:	a4 96       	adiw	r28, 0x24	; 36
    1a5e:	0f b6       	in	r0, 0x3f	; 63
    1a60:	f8 94       	cli
    1a62:	de bf       	out	0x3e, r29	; 62
    1a64:	0f be       	out	0x3f, r0	; 63
    1a66:	cd bf       	out	0x3d, r28	; 61
    1a68:	df 91       	pop	r29
    1a6a:	cf 91       	pop	r28
    1a6c:	1f 91       	pop	r17
    1a6e:	0f 91       	pop	r16
    1a70:	ff 90       	pop	r15
    1a72:	ef 90       	pop	r14
    1a74:	08 95       	ret

00001a76 <getTemperature>:

// get temperature of the mpu6050
void getTemperature(double *temp){
    1a76:	cf 93       	push	r28
    1a78:	df 93       	push	r29
    1a7a:	1f 92       	push	r1
    1a7c:	1f 92       	push	r1
    1a7e:	cd b7       	in	r28, 0x3d	; 61
    1a80:	de b7       	in	r29, 0x3e	; 62
    1a82:	9a 83       	std	Y+2, r25	; 0x02
    1a84:	89 83       	std	Y+1, r24	; 0x01
	readBytesFromMPU6050(MPU6050_RA_TEMP_OUT_H, 2, (uint8_t*)temp_buff);
    1a86:	43 eb       	ldi	r20, 0xB3	; 179
    1a88:	52 e0       	ldi	r21, 0x02	; 2
    1a8a:	62 e0       	ldi	r22, 0x02	; 2
    1a8c:	81 e4       	ldi	r24, 0x41	; 65
    1a8e:	0e 94 4f 0c 	call	0x189e	; 0x189e <readBytesFromMPU6050>
	// set temperature
	*temp = (((((int16_t)temp_buff[0]) << 8 )| temp_buff[1]) + 12412.0)/340.0;
    1a92:	80 91 b3 02 	lds	r24, 0x02B3
    1a96:	88 2f       	mov	r24, r24
    1a98:	90 e0       	ldi	r25, 0x00	; 0
    1a9a:	38 2f       	mov	r19, r24
    1a9c:	22 27       	eor	r18, r18
    1a9e:	80 91 b4 02 	lds	r24, 0x02B4
    1aa2:	88 2f       	mov	r24, r24
    1aa4:	90 e0       	ldi	r25, 0x00	; 0
    1aa6:	82 2b       	or	r24, r18
    1aa8:	93 2b       	or	r25, r19
    1aaa:	09 2e       	mov	r0, r25
    1aac:	00 0c       	add	r0, r0
    1aae:	aa 0b       	sbc	r26, r26
    1ab0:	bb 0b       	sbc	r27, r27
    1ab2:	bc 01       	movw	r22, r24
    1ab4:	cd 01       	movw	r24, r26
    1ab6:	0e 94 89 32 	call	0x6512	; 0x6512 <__floatsisf>
    1aba:	dc 01       	movw	r26, r24
    1abc:	cb 01       	movw	r24, r22
    1abe:	20 e0       	ldi	r18, 0x00	; 0
    1ac0:	30 ef       	ldi	r19, 0xF0	; 240
    1ac2:	41 e4       	ldi	r20, 0x41	; 65
    1ac4:	56 e4       	ldi	r21, 0x46	; 70
    1ac6:	bc 01       	movw	r22, r24
    1ac8:	cd 01       	movw	r24, r26
    1aca:	0e 94 46 31 	call	0x628c	; 0x628c <__addsf3>
    1ace:	dc 01       	movw	r26, r24
    1ad0:	cb 01       	movw	r24, r22
    1ad2:	20 e0       	ldi	r18, 0x00	; 0
    1ad4:	30 e0       	ldi	r19, 0x00	; 0
    1ad6:	4a ea       	ldi	r20, 0xAA	; 170
    1ad8:	53 e4       	ldi	r21, 0x43	; 67
    1ada:	bc 01       	movw	r22, r24
    1adc:	cd 01       	movw	r24, r26
    1ade:	0e 94 e6 31 	call	0x63cc	; 0x63cc <__divsf3>
    1ae2:	dc 01       	movw	r26, r24
    1ae4:	cb 01       	movw	r24, r22
    1ae6:	29 81       	ldd	r18, Y+1	; 0x01
    1ae8:	3a 81       	ldd	r19, Y+2	; 0x02
    1aea:	f9 01       	movw	r30, r18
    1aec:	80 83       	st	Z, r24
    1aee:	91 83       	std	Z+1, r25	; 0x01
    1af0:	a2 83       	std	Z+2, r26	; 0x02
    1af2:	b3 83       	std	Z+3, r27	; 0x03
}
    1af4:	0f 90       	pop	r0
    1af6:	0f 90       	pop	r0
    1af8:	df 91       	pop	r29
    1afa:	cf 91       	pop	r28
    1afc:	08 95       	ret

00001afe <getAttitudeData>:

//get attitude data. Transfor the Convert Data to attitude data using a filter
void getAttitudeData(double *anglX, double *anglY, double *anglZ, double *Roll, double *Pitch){
    1afe:	8f 92       	push	r8
    1b00:	9f 92       	push	r9
    1b02:	af 92       	push	r10
    1b04:	bf 92       	push	r11
    1b06:	cf 92       	push	r12
    1b08:	df 92       	push	r13
    1b0a:	ef 92       	push	r14
    1b0c:	ff 92       	push	r15
    1b0e:	0f 93       	push	r16
    1b10:	1f 93       	push	r17
    1b12:	cf 93       	push	r28
    1b14:	df 93       	push	r29
    1b16:	cd b7       	in	r28, 0x3d	; 61
    1b18:	de b7       	in	r29, 0x3e	; 62
    1b1a:	e2 97       	sbiw	r28, 0x32	; 50
    1b1c:	0f b6       	in	r0, 0x3f	; 63
    1b1e:	f8 94       	cli
    1b20:	de bf       	out	0x3e, r29	; 62
    1b22:	0f be       	out	0x3f, r0	; 63
    1b24:	cd bf       	out	0x3d, r28	; 61
    1b26:	9a a7       	std	Y+42, r25	; 0x2a
    1b28:	89 a7       	std	Y+41, r24	; 0x29
    1b2a:	7c a7       	std	Y+44, r23	; 0x2c
    1b2c:	6b a7       	std	Y+43, r22	; 0x2b
    1b2e:	5e a7       	std	Y+46, r21	; 0x2e
    1b30:	4d a7       	std	Y+45, r20	; 0x2d
    1b32:	38 ab       	std	Y+48, r19	; 0x30
    1b34:	2f a7       	std	Y+47, r18	; 0x2f
    1b36:	1a ab       	std	Y+50, r17	; 0x32
    1b38:	09 ab       	std	Y+49, r16	; 0x31
	double ax = 0;
    1b3a:	1d 82       	std	Y+5, r1	; 0x05
    1b3c:	1e 82       	std	Y+6, r1	; 0x06
    1b3e:	1f 82       	std	Y+7, r1	; 0x07
    1b40:	18 86       	std	Y+8, r1	; 0x08
	double ay = 0;
    1b42:	19 86       	std	Y+9, r1	; 0x09
    1b44:	1a 86       	std	Y+10, r1	; 0x0a
    1b46:	1b 86       	std	Y+11, r1	; 0x0b
    1b48:	1c 86       	std	Y+12, r1	; 0x0c
	double az = 0;
    1b4a:	1d 86       	std	Y+13, r1	; 0x0d
    1b4c:	1e 86       	std	Y+14, r1	; 0x0e
    1b4e:	1f 86       	std	Y+15, r1	; 0x0f
    1b50:	18 8a       	std	Y+16, r1	; 0x10
	double gx = 0;
    1b52:	19 82       	std	Y+1, r1	; 0x01
    1b54:	1a 82       	std	Y+2, r1	; 0x02
    1b56:	1b 82       	std	Y+3, r1	; 0x03
    1b58:	1c 82       	std	Y+4, r1	; 0x04
	double gy = 0;
    1b5a:	19 8a       	std	Y+17, r1	; 0x11
    1b5c:	1a 8a       	std	Y+18, r1	; 0x12
    1b5e:	1b 8a       	std	Y+19, r1	; 0x13
    1b60:	1c 8a       	std	Y+20, r1	; 0x14
	double gz = 0;
    1b62:	1d 8a       	std	Y+21, r1	; 0x15
    1b64:	1e 8a       	std	Y+22, r1	; 0x16
    1b66:	1f 8a       	std	Y+23, r1	; 0x17
    1b68:	18 8e       	std	Y+24, r1	; 0x18

	/*Roll and pitch*/
	double rollBuff = *Roll;
    1b6a:	8f a5       	ldd	r24, Y+47	; 0x2f
    1b6c:	98 a9       	ldd	r25, Y+48	; 0x30
    1b6e:	fc 01       	movw	r30, r24
    1b70:	80 81       	ld	r24, Z
    1b72:	91 81       	ldd	r25, Z+1	; 0x01
    1b74:	a2 81       	ldd	r26, Z+2	; 0x02
    1b76:	b3 81       	ldd	r27, Z+3	; 0x03
    1b78:	89 8f       	std	Y+25, r24	; 0x19
    1b7a:	9a 8f       	std	Y+26, r25	; 0x1a
    1b7c:	ab 8f       	std	Y+27, r26	; 0x1b
    1b7e:	bc 8f       	std	Y+28, r27	; 0x1c
	double pitchBuff = *Pitch;
    1b80:	89 a9       	ldd	r24, Y+49	; 0x31
    1b82:	9a a9       	ldd	r25, Y+50	; 0x32
    1b84:	fc 01       	movw	r30, r24
    1b86:	80 81       	ld	r24, Z
    1b88:	91 81       	ldd	r25, Z+1	; 0x01
    1b8a:	a2 81       	ldd	r26, Z+2	; 0x02
    1b8c:	b3 81       	ldd	r27, Z+3	; 0x03
    1b8e:	8d 8f       	std	Y+29, r24	; 0x1d
    1b90:	9e 8f       	std	Y+30, r25	; 0x1e
    1b92:	af 8f       	std	Y+31, r26	; 0x1f
    1b94:	b8 a3       	std	Y+32, r27	; 0x20

	double anglAccelRoll = 0.0;
    1b96:	19 a2       	std	Y+33, r1	; 0x21
    1b98:	1a a2       	std	Y+34, r1	; 0x22
    1b9a:	1b a2       	std	Y+35, r1	; 0x23
    1b9c:	1c a2       	std	Y+36, r1	; 0x24
	double anglAccelPitch = 0.0;
    1b9e:	1d a2       	std	Y+37, r1	; 0x25
    1ba0:	1e a2       	std	Y+38, r1	; 0x26
    1ba2:	1f a2       	std	Y+39, r1	; 0x27
    1ba4:	18 a6       	std	Y+40, r1	; 0x28

	getConvData(&ax, &ay, &az, &gz, &gy, &gz);
    1ba6:	de 01       	movw	r26, r28
    1ba8:	55 96       	adiw	r26, 0x15	; 21
    1baa:	fe 01       	movw	r30, r28
    1bac:	71 96       	adiw	r30, 0x11	; 17
    1bae:	9e 01       	movw	r18, r28
    1bb0:	2b 5e       	subi	r18, 0xEB	; 235
    1bb2:	3f 4f       	sbci	r19, 0xFF	; 255
    1bb4:	ae 01       	movw	r20, r28
    1bb6:	43 5f       	subi	r20, 0xF3	; 243
    1bb8:	5f 4f       	sbci	r21, 0xFF	; 255
    1bba:	be 01       	movw	r22, r28
    1bbc:	67 5f       	subi	r22, 0xF7	; 247
    1bbe:	7f 4f       	sbci	r23, 0xFF	; 255
    1bc0:	ce 01       	movw	r24, r28
    1bc2:	05 96       	adiw	r24, 0x05	; 5
    1bc4:	7d 01       	movw	r14, r26
    1bc6:	8f 01       	movw	r16, r30
    1bc8:	0e 94 a6 0c 	call	0x194c	; 0x194c <getConvData>
	calcAnglAccel(ax, ay, az, &anglAccelRoll, &anglAccelPitch);
    1bcc:	ed 84       	ldd	r14, Y+13	; 0x0d
    1bce:	fe 84       	ldd	r15, Y+14	; 0x0e
    1bd0:	0f 85       	ldd	r16, Y+15	; 0x0f
    1bd2:	18 89       	ldd	r17, Y+16	; 0x10
    1bd4:	29 85       	ldd	r18, Y+9	; 0x09
    1bd6:	3a 85       	ldd	r19, Y+10	; 0x0a
    1bd8:	4b 85       	ldd	r20, Y+11	; 0x0b
    1bda:	5c 85       	ldd	r21, Y+12	; 0x0c
    1bdc:	8d 81       	ldd	r24, Y+5	; 0x05
    1bde:	9e 81       	ldd	r25, Y+6	; 0x06
    1be0:	af 81       	ldd	r26, Y+7	; 0x07
    1be2:	b8 85       	ldd	r27, Y+8	; 0x08
    1be4:	fe 01       	movw	r30, r28
    1be6:	b5 96       	adiw	r30, 0x25	; 37
    1be8:	be 01       	movw	r22, r28
    1bea:	6f 5d       	subi	r22, 0xDF	; 223
    1bec:	7f 4f       	sbci	r23, 0xFF	; 255
    1bee:	5f 01       	movw	r10, r30
    1bf0:	6b 01       	movw	r12, r22
    1bf2:	bc 01       	movw	r22, r24
    1bf4:	cd 01       	movw	r24, r26
    1bf6:	0e 94 0d 07 	call	0xe1a	; 0xe1a <calcAnglAccel>
	getRollPitch(anglAccelRoll, anglAccelPitch, gx,gy, &rollBuff, &pitchBuff);
    1bfa:	a9 88       	ldd	r10, Y+17	; 0x11
    1bfc:	ba 88       	ldd	r11, Y+18	; 0x12
    1bfe:	cb 88       	ldd	r12, Y+19	; 0x13
    1c00:	dc 88       	ldd	r13, Y+20	; 0x14
    1c02:	2d a1       	ldd	r18, Y+37	; 0x25
    1c04:	3e a1       	ldd	r19, Y+38	; 0x26
    1c06:	4f a1       	ldd	r20, Y+39	; 0x27
    1c08:	58 a5       	ldd	r21, Y+40	; 0x28
    1c0a:	89 a1       	ldd	r24, Y+33	; 0x21
    1c0c:	9a a1       	ldd	r25, Y+34	; 0x22
    1c0e:	ab a1       	ldd	r26, Y+35	; 0x23
    1c10:	bc a1       	ldd	r27, Y+36	; 0x24
    1c12:	fe 01       	movw	r30, r28
    1c14:	79 96       	adiw	r30, 0x19	; 25
    1c16:	e9 80       	ldd	r14, Y+1	; 0x01
    1c18:	fa 80       	ldd	r15, Y+2	; 0x02
    1c1a:	0b 81       	ldd	r16, Y+3	; 0x03
    1c1c:	1c 81       	ldd	r17, Y+4	; 0x04
    1c1e:	be 01       	movw	r22, r28
    1c20:	63 5e       	subi	r22, 0xE3	; 227
    1c22:	7f 4f       	sbci	r23, 0xFF	; 255
    1c24:	97 2e       	mov	r9, r23
    1c26:	9f 92       	push	r9
    1c28:	6f 93       	push	r22
    1c2a:	4f 01       	movw	r8, r30
    1c2c:	bc 01       	movw	r22, r24
    1c2e:	cd 01       	movw	r24, r26
    1c30:	0e 94 f6 07 	call	0xfec	; 0xfec <getRollPitch>
    1c34:	0f 90       	pop	r0
    1c36:	0f 90       	pop	r0

	// Data for accel and gyro
	*anglX = ax;
    1c38:	8d 81       	ldd	r24, Y+5	; 0x05
    1c3a:	9e 81       	ldd	r25, Y+6	; 0x06
    1c3c:	af 81       	ldd	r26, Y+7	; 0x07
    1c3e:	b8 85       	ldd	r27, Y+8	; 0x08
    1c40:	29 a5       	ldd	r18, Y+41	; 0x29
    1c42:	3a a5       	ldd	r19, Y+42	; 0x2a
    1c44:	f9 01       	movw	r30, r18
    1c46:	80 83       	st	Z, r24
    1c48:	91 83       	std	Z+1, r25	; 0x01
    1c4a:	a2 83       	std	Z+2, r26	; 0x02
    1c4c:	b3 83       	std	Z+3, r27	; 0x03
	*anglY = ay;
    1c4e:	89 85       	ldd	r24, Y+9	; 0x09
    1c50:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c52:	ab 85       	ldd	r26, Y+11	; 0x0b
    1c54:	bc 85       	ldd	r27, Y+12	; 0x0c
    1c56:	2b a5       	ldd	r18, Y+43	; 0x2b
    1c58:	3c a5       	ldd	r19, Y+44	; 0x2c
    1c5a:	f9 01       	movw	r30, r18
    1c5c:	80 83       	st	Z, r24
    1c5e:	91 83       	std	Z+1, r25	; 0x01
    1c60:	a2 83       	std	Z+2, r26	; 0x02
    1c62:	b3 83       	std	Z+3, r27	; 0x03
	*anglZ = az;
    1c64:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c66:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c68:	af 85       	ldd	r26, Y+15	; 0x0f
    1c6a:	b8 89       	ldd	r27, Y+16	; 0x10
    1c6c:	2d a5       	ldd	r18, Y+45	; 0x2d
    1c6e:	3e a5       	ldd	r19, Y+46	; 0x2e
    1c70:	f9 01       	movw	r30, r18
    1c72:	80 83       	st	Z, r24
    1c74:	91 83       	std	Z+1, r25	; 0x01
    1c76:	a2 83       	std	Z+2, r26	; 0x02
    1c78:	b3 83       	std	Z+3, r27	; 0x03
	// pitch and roll
	*Roll = rollBuff;
    1c7a:	89 8d       	ldd	r24, Y+25	; 0x19
    1c7c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1c7e:	ab 8d       	ldd	r26, Y+27	; 0x1b
    1c80:	bc 8d       	ldd	r27, Y+28	; 0x1c
    1c82:	2f a5       	ldd	r18, Y+47	; 0x2f
    1c84:	38 a9       	ldd	r19, Y+48	; 0x30
    1c86:	f9 01       	movw	r30, r18
    1c88:	80 83       	st	Z, r24
    1c8a:	91 83       	std	Z+1, r25	; 0x01
    1c8c:	a2 83       	std	Z+2, r26	; 0x02
    1c8e:	b3 83       	std	Z+3, r27	; 0x03
	*Pitch = pitchBuff;
    1c90:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1c92:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1c94:	af 8d       	ldd	r26, Y+31	; 0x1f
    1c96:	b8 a1       	ldd	r27, Y+32	; 0x20
    1c98:	29 a9       	ldd	r18, Y+49	; 0x31
    1c9a:	3a a9       	ldd	r19, Y+50	; 0x32
    1c9c:	f9 01       	movw	r30, r18
    1c9e:	80 83       	st	Z, r24
    1ca0:	91 83       	std	Z+1, r25	; 0x01
    1ca2:	a2 83       	std	Z+2, r26	; 0x02
    1ca4:	b3 83       	std	Z+3, r27	; 0x03




}
    1ca6:	e2 96       	adiw	r28, 0x32	; 50
    1ca8:	0f b6       	in	r0, 0x3f	; 63
    1caa:	f8 94       	cli
    1cac:	de bf       	out	0x3e, r29	; 62
    1cae:	0f be       	out	0x3f, r0	; 63
    1cb0:	cd bf       	out	0x3d, r28	; 61
    1cb2:	df 91       	pop	r29
    1cb4:	cf 91       	pop	r28
    1cb6:	1f 91       	pop	r17
    1cb8:	0f 91       	pop	r16
    1cba:	ff 90       	pop	r15
    1cbc:	ef 90       	pop	r14
    1cbe:	df 90       	pop	r13
    1cc0:	cf 90       	pop	r12
    1cc2:	bf 90       	pop	r11
    1cc4:	af 90       	pop	r10
    1cc6:	9f 90       	pop	r9
    1cc8:	8f 90       	pop	r8
    1cca:	08 95       	ret

00001ccc <init_spi>:
 */
#include <avr/io.h>
#include <avr/interrupt.h>
#include "spi.h"

void init_spi(void){
    1ccc:	cf 93       	push	r28
    1cce:	df 93       	push	r29
    1cd0:	cd b7       	in	r28, 0x3d	; 61
    1cd2:	de b7       	in	r29, 0x3e	; 62
	DDRB = (1<<MOSI) | (1<<SCK);
    1cd4:	84 e2       	ldi	r24, 0x24	; 36
    1cd6:	90 e0       	ldi	r25, 0x00	; 0
    1cd8:	26 e0       	ldi	r18, 0x06	; 6
    1cda:	fc 01       	movw	r30, r24
    1cdc:	20 83       	st	Z, r18

	SPCR = ((1<<SPE)|               // SPI Enable
    1cde:	8c e4       	ldi	r24, 0x4C	; 76
    1ce0:	90 e0       	ldi	r25, 0x00	; 0
    1ce2:	21 ed       	ldi	r18, 0xD1	; 209
    1ce4:	fc 01       	movw	r30, r24
    1ce6:	20 83       	st	Z, r18
	        (1<<MSTR)|              // Master/Slave select
	        (0<<SPR1)|(1<<SPR0)|    // SPI Clock Rate
	        (0<<CPOL)|              // Clock Polarity (0:SCK low / 1:SCK hi when idle)
	        (0<<CPHA));             // Clock Phase (0:leading / 1:trailing edge sampling)

}
    1ce8:	df 91       	pop	r29
    1cea:	cf 91       	pop	r28
    1cec:	08 95       	ret

00001cee <spi_tranceiver>:

uint8_t spi_tranceiver(uint8_t data){
    1cee:	cf 93       	push	r28
    1cf0:	df 93       	push	r29
    1cf2:	1f 92       	push	r1
    1cf4:	cd b7       	in	r28, 0x3d	; 61
    1cf6:	de b7       	in	r29, 0x3e	; 62
    1cf8:	89 83       	std	Y+1, r24	; 0x01
	SPDR = data;
    1cfa:	8e e4       	ldi	r24, 0x4E	; 78
    1cfc:	90 e0       	ldi	r25, 0x00	; 0
    1cfe:	29 81       	ldd	r18, Y+1	; 0x01
    1d00:	fc 01       	movw	r30, r24
    1d02:	20 83       	st	Z, r18
	while((SPSR & (1<<SPIF))==0);
    1d04:	00 00       	nop
    1d06:	8d e4       	ldi	r24, 0x4D	; 77
    1d08:	90 e0       	ldi	r25, 0x00	; 0
    1d0a:	fc 01       	movw	r30, r24
    1d0c:	80 81       	ld	r24, Z
    1d0e:	88 23       	and	r24, r24
    1d10:	d4 f7       	brge	.-12     	; 0x1d06 <spi_tranceiver+0x18>
	return SPDR;
    1d12:	8e e4       	ldi	r24, 0x4E	; 78
    1d14:	90 e0       	ldi	r25, 0x00	; 0
    1d16:	fc 01       	movw	r30, r24
    1d18:	80 81       	ld	r24, Z
}
    1d1a:	0f 90       	pop	r0
    1d1c:	df 91       	pop	r29
    1d1e:	cf 91       	pop	r28
    1d20:	08 95       	ret

00001d22 <spi_transfer>:

/*spi send array with return data*/
void spi_transfer(uint8_t *out, uint8_t *in, uint8_t len){
    1d22:	cf 93       	push	r28
    1d24:	df 93       	push	r29
    1d26:	cd b7       	in	r28, 0x3d	; 61
    1d28:	de b7       	in	r29, 0x3e	; 62
    1d2a:	27 97       	sbiw	r28, 0x07	; 7
    1d2c:	0f b6       	in	r0, 0x3f	; 63
    1d2e:	f8 94       	cli
    1d30:	de bf       	out	0x3e, r29	; 62
    1d32:	0f be       	out	0x3f, r0	; 63
    1d34:	cd bf       	out	0x3d, r28	; 61
    1d36:	9c 83       	std	Y+4, r25	; 0x04
    1d38:	8b 83       	std	Y+3, r24	; 0x03
    1d3a:	7e 83       	std	Y+6, r23	; 0x06
    1d3c:	6d 83       	std	Y+5, r22	; 0x05
    1d3e:	4f 83       	std	Y+7, r20	; 0x07
	int i;
	for(i = 0; i<len; i++){
    1d40:	1a 82       	std	Y+2, r1	; 0x02
    1d42:	19 82       	std	Y+1, r1	; 0x01
    1d44:	24 c0       	rjmp	.+72     	; 0x1d8e <spi_transfer+0x6c>
		SPDR = out[i];
    1d46:	8e e4       	ldi	r24, 0x4E	; 78
    1d48:	90 e0       	ldi	r25, 0x00	; 0
    1d4a:	29 81       	ldd	r18, Y+1	; 0x01
    1d4c:	3a 81       	ldd	r19, Y+2	; 0x02
    1d4e:	4b 81       	ldd	r20, Y+3	; 0x03
    1d50:	5c 81       	ldd	r21, Y+4	; 0x04
    1d52:	24 0f       	add	r18, r20
    1d54:	35 1f       	adc	r19, r21
    1d56:	f9 01       	movw	r30, r18
    1d58:	20 81       	ld	r18, Z
    1d5a:	fc 01       	movw	r30, r24
    1d5c:	20 83       	st	Z, r18
		while((SPSR & (1<<SPIF))==0);
    1d5e:	00 00       	nop
    1d60:	8d e4       	ldi	r24, 0x4D	; 77
    1d62:	90 e0       	ldi	r25, 0x00	; 0
    1d64:	fc 01       	movw	r30, r24
    1d66:	80 81       	ld	r24, Z
    1d68:	88 23       	and	r24, r24
    1d6a:	d4 f7       	brge	.-12     	; 0x1d60 <spi_transfer+0x3e>
		in[i] = SPDR;
    1d6c:	89 81       	ldd	r24, Y+1	; 0x01
    1d6e:	9a 81       	ldd	r25, Y+2	; 0x02
    1d70:	2d 81       	ldd	r18, Y+5	; 0x05
    1d72:	3e 81       	ldd	r19, Y+6	; 0x06
    1d74:	82 0f       	add	r24, r18
    1d76:	93 1f       	adc	r25, r19
    1d78:	2e e4       	ldi	r18, 0x4E	; 78
    1d7a:	30 e0       	ldi	r19, 0x00	; 0
    1d7c:	f9 01       	movw	r30, r18
    1d7e:	20 81       	ld	r18, Z
    1d80:	fc 01       	movw	r30, r24
    1d82:	20 83       	st	Z, r18
}

/*spi send array with return data*/
void spi_transfer(uint8_t *out, uint8_t *in, uint8_t len){
	int i;
	for(i = 0; i<len; i++){
    1d84:	89 81       	ldd	r24, Y+1	; 0x01
    1d86:	9a 81       	ldd	r25, Y+2	; 0x02
    1d88:	01 96       	adiw	r24, 0x01	; 1
    1d8a:	9a 83       	std	Y+2, r25	; 0x02
    1d8c:	89 83       	std	Y+1, r24	; 0x01
    1d8e:	8f 81       	ldd	r24, Y+7	; 0x07
    1d90:	28 2f       	mov	r18, r24
    1d92:	30 e0       	ldi	r19, 0x00	; 0
    1d94:	89 81       	ldd	r24, Y+1	; 0x01
    1d96:	9a 81       	ldd	r25, Y+2	; 0x02
    1d98:	82 17       	cp	r24, r18
    1d9a:	93 07       	cpc	r25, r19
    1d9c:	a4 f2       	brlt	.-88     	; 0x1d46 <spi_transfer+0x24>
		SPDR = out[i];
		while((SPSR & (1<<SPIF))==0);
		in[i] = SPDR;
	}
}
    1d9e:	27 96       	adiw	r28, 0x07	; 7
    1da0:	0f b6       	in	r0, 0x3f	; 63
    1da2:	f8 94       	cli
    1da4:	de bf       	out	0x3e, r29	; 62
    1da6:	0f be       	out	0x3f, r0	; 63
    1da8:	cd bf       	out	0x3d, r28	; 61
    1daa:	df 91       	pop	r29
    1dac:	cf 91       	pop	r28
    1dae:	08 95       	ret

00001db0 <spi_send>:
void spi_send(uint8_t *out, uint8_t len){
    1db0:	cf 93       	push	r28
    1db2:	df 93       	push	r29
    1db4:	00 d0       	rcall	.+0      	; 0x1db6 <spi_send+0x6>
    1db6:	1f 92       	push	r1
    1db8:	1f 92       	push	r1
    1dba:	cd b7       	in	r28, 0x3d	; 61
    1dbc:	de b7       	in	r29, 0x3e	; 62
    1dbe:	9c 83       	std	Y+4, r25	; 0x04
    1dc0:	8b 83       	std	Y+3, r24	; 0x03
    1dc2:	6d 83       	std	Y+5, r22	; 0x05
	int i;
	for(i = 0; i<len; i++){
    1dc4:	1a 82       	std	Y+2, r1	; 0x02
    1dc6:	19 82       	std	Y+1, r1	; 0x01
    1dc8:	18 c0       	rjmp	.+48     	; 0x1dfa <spi_send+0x4a>
		SPDR = out[i];
    1dca:	8e e4       	ldi	r24, 0x4E	; 78
    1dcc:	90 e0       	ldi	r25, 0x00	; 0
    1dce:	29 81       	ldd	r18, Y+1	; 0x01
    1dd0:	3a 81       	ldd	r19, Y+2	; 0x02
    1dd2:	4b 81       	ldd	r20, Y+3	; 0x03
    1dd4:	5c 81       	ldd	r21, Y+4	; 0x04
    1dd6:	24 0f       	add	r18, r20
    1dd8:	35 1f       	adc	r19, r21
    1dda:	f9 01       	movw	r30, r18
    1ddc:	20 81       	ld	r18, Z
    1dde:	fc 01       	movw	r30, r24
    1de0:	20 83       	st	Z, r18
		while((SPSR & (1<<SPIF))==0);
    1de2:	00 00       	nop
    1de4:	8d e4       	ldi	r24, 0x4D	; 77
    1de6:	90 e0       	ldi	r25, 0x00	; 0
    1de8:	fc 01       	movw	r30, r24
    1dea:	80 81       	ld	r24, Z
    1dec:	88 23       	and	r24, r24
    1dee:	d4 f7       	brge	.-12     	; 0x1de4 <spi_send+0x34>
		in[i] = SPDR;
	}
}
void spi_send(uint8_t *out, uint8_t len){
	int i;
	for(i = 0; i<len; i++){
    1df0:	89 81       	ldd	r24, Y+1	; 0x01
    1df2:	9a 81       	ldd	r25, Y+2	; 0x02
    1df4:	01 96       	adiw	r24, 0x01	; 1
    1df6:	9a 83       	std	Y+2, r25	; 0x02
    1df8:	89 83       	std	Y+1, r24	; 0x01
    1dfa:	8d 81       	ldd	r24, Y+5	; 0x05
    1dfc:	28 2f       	mov	r18, r24
    1dfe:	30 e0       	ldi	r19, 0x00	; 0
    1e00:	89 81       	ldd	r24, Y+1	; 0x01
    1e02:	9a 81       	ldd	r25, Y+2	; 0x02
    1e04:	82 17       	cp	r24, r18
    1e06:	93 07       	cpc	r25, r19
    1e08:	04 f3       	brlt	.-64     	; 0x1dca <spi_send+0x1a>
		SPDR = out[i];
		while((SPSR & (1<<SPIF))==0);
	}
}
    1e0a:	0f 90       	pop	r0
    1e0c:	0f 90       	pop	r0
    1e0e:	0f 90       	pop	r0
    1e10:	0f 90       	pop	r0
    1e12:	0f 90       	pop	r0
    1e14:	df 91       	pop	r29
    1e16:	cf 91       	pop	r28
    1e18:	08 95       	ret

00001e1a <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
    1e1a:	cf 93       	push	r28
    1e1c:	df 93       	push	r29
    1e1e:	1f 92       	push	r1
    1e20:	1f 92       	push	r1
    1e22:	cd b7       	in	r28, 0x3d	; 61
    1e24:	de b7       	in	r29, 0x3e	; 62
EventGroup_t *pxEventBits;

	pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
    1e26:	8b e0       	ldi	r24, 0x0B	; 11
    1e28:	90 e0       	ldi	r25, 0x00	; 0
    1e2a:	0e 94 63 12 	call	0x24c6	; 0x24c6 <pvPortMalloc>
    1e2e:	9a 83       	std	Y+2, r25	; 0x02
    1e30:	89 83       	std	Y+1, r24	; 0x01
	if( pxEventBits != NULL )
    1e32:	89 81       	ldd	r24, Y+1	; 0x01
    1e34:	9a 81       	ldd	r25, Y+2	; 0x02
    1e36:	89 2b       	or	r24, r25
    1e38:	51 f0       	breq	.+20     	; 0x1e4e <xEventGroupCreate+0x34>
	{
		pxEventBits->uxEventBits = 0;
    1e3a:	89 81       	ldd	r24, Y+1	; 0x01
    1e3c:	9a 81       	ldd	r25, Y+2	; 0x02
    1e3e:	fc 01       	movw	r30, r24
    1e40:	11 82       	std	Z+1, r1	; 0x01
    1e42:	10 82       	st	Z, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1e44:	89 81       	ldd	r24, Y+1	; 0x01
    1e46:	9a 81       	ldd	r25, Y+2	; 0x02
    1e48:	02 96       	adiw	r24, 0x02	; 2
    1e4a:	0e 94 1a 14 	call	0x2834	; 0x2834 <vListInitialise>
	else
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
    1e4e:	89 81       	ldd	r24, Y+1	; 0x01
    1e50:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1e52:	0f 90       	pop	r0
    1e54:	0f 90       	pop	r0
    1e56:	df 91       	pop	r29
    1e58:	cf 91       	pop	r28
    1e5a:	08 95       	ret

00001e5c <xEventGroupSync>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    1e5c:	cf 93       	push	r28
    1e5e:	df 93       	push	r29
    1e60:	cd b7       	in	r28, 0x3d	; 61
    1e62:	de b7       	in	r29, 0x3e	; 62
    1e64:	60 97       	sbiw	r28, 0x10	; 16
    1e66:	0f b6       	in	r0, 0x3f	; 63
    1e68:	f8 94       	cli
    1e6a:	de bf       	out	0x3e, r29	; 62
    1e6c:	0f be       	out	0x3f, r0	; 63
    1e6e:	cd bf       	out	0x3d, r28	; 61
    1e70:	9a 87       	std	Y+10, r25	; 0x0a
    1e72:	89 87       	std	Y+9, r24	; 0x09
    1e74:	7c 87       	std	Y+12, r23	; 0x0c
    1e76:	6b 87       	std	Y+11, r22	; 0x0b
    1e78:	5e 87       	std	Y+14, r21	; 0x0e
    1e7a:	4d 87       	std	Y+13, r20	; 0x0d
    1e7c:	38 8b       	std	Y+16, r19	; 0x10
    1e7e:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1e80:	89 85       	ldd	r24, Y+9	; 0x09
    1e82:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e84:	9c 83       	std	Y+4, r25	; 0x04
    1e86:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1e88:	1d 82       	std	Y+5, r1	; 0x05
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1e8a:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    1e8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e90:	9c 81       	ldd	r25, Y+4	; 0x04
    1e92:	fc 01       	movw	r30, r24
    1e94:	80 81       	ld	r24, Z
    1e96:	91 81       	ldd	r25, Z+1	; 0x01
    1e98:	9f 83       	std	Y+7, r25	; 0x07
    1e9a:	8e 83       	std	Y+6, r24	; 0x06

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1e9c:	2b 85       	ldd	r18, Y+11	; 0x0b
    1e9e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1ea0:	89 85       	ldd	r24, Y+9	; 0x09
    1ea2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ea4:	b9 01       	movw	r22, r18
    1ea6:	0e 94 0b 11 	call	0x2216	; 0x2216 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1eaa:	2e 81       	ldd	r18, Y+6	; 0x06
    1eac:	3f 81       	ldd	r19, Y+7	; 0x07
    1eae:	8b 85       	ldd	r24, Y+11	; 0x0b
    1eb0:	9c 85       	ldd	r25, Y+12	; 0x0c
    1eb2:	28 2b       	or	r18, r24
    1eb4:	39 2b       	or	r19, r25
    1eb6:	8d 85       	ldd	r24, Y+13	; 0x0d
    1eb8:	9e 85       	ldd	r25, Y+14	; 0x0e
    1eba:	28 23       	and	r18, r24
    1ebc:	39 23       	and	r19, r25
    1ebe:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ec0:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ec2:	28 17       	cp	r18, r24
    1ec4:	39 07       	cpc	r19, r25
    1ec6:	d9 f4       	brne	.+54     	; 0x1efe <xEventGroupSync+0xa2>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1ec8:	2e 81       	ldd	r18, Y+6	; 0x06
    1eca:	3f 81       	ldd	r19, Y+7	; 0x07
    1ecc:	8b 85       	ldd	r24, Y+11	; 0x0b
    1ece:	9c 85       	ldd	r25, Y+12	; 0x0c
    1ed0:	82 2b       	or	r24, r18
    1ed2:	93 2b       	or	r25, r19
    1ed4:	9a 83       	std	Y+2, r25	; 0x02
    1ed6:	89 83       	std	Y+1, r24	; 0x01

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1ed8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eda:	9c 81       	ldd	r25, Y+4	; 0x04
    1edc:	fc 01       	movw	r30, r24
    1ede:	20 81       	ld	r18, Z
    1ee0:	31 81       	ldd	r19, Z+1	; 0x01
    1ee2:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ee4:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ee6:	80 95       	com	r24
    1ee8:	90 95       	com	r25
    1eea:	28 23       	and	r18, r24
    1eec:	39 23       	and	r19, r25
    1eee:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ef2:	fc 01       	movw	r30, r24
    1ef4:	31 83       	std	Z+1, r19	; 0x01
    1ef6:	20 83       	st	Z, r18

			xTicksToWait = 0;
    1ef8:	18 8a       	std	Y+16, r1	; 0x10
    1efa:	1f 86       	std	Y+15, r1	; 0x0f
    1efc:	1a c0       	rjmp	.+52     	; 0x1f32 <xEventGroupSync+0xd6>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    1efe:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f00:	98 89       	ldd	r25, Y+16	; 0x10
    1f02:	89 2b       	or	r24, r25
    1f04:	79 f0       	breq	.+30     	; 0x1f24 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1f06:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f08:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f0a:	9c 01       	movw	r18, r24
    1f0c:	35 60       	ori	r19, 0x05	; 5
    1f0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f10:	9c 81       	ldd	r25, Y+4	; 0x04
    1f12:	02 96       	adiw	r24, 0x02	; 2
    1f14:	4f 85       	ldd	r20, Y+15	; 0x0f
    1f16:	58 89       	ldd	r21, Y+16	; 0x10
    1f18:	b9 01       	movw	r22, r18
    1f1a:	0e 94 cd 27 	call	0x4f9a	; 0x4f9a <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    1f1e:	1a 82       	std	Y+2, r1	; 0x02
    1f20:	19 82       	std	Y+1, r1	; 0x01
    1f22:	07 c0       	rjmp	.+14     	; 0x1f32 <xEventGroupSync+0xd6>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1f24:	8b 81       	ldd	r24, Y+3	; 0x03
    1f26:	9c 81       	ldd	r25, Y+4	; 0x04
    1f28:	fc 01       	movw	r30, r24
    1f2a:	80 81       	ld	r24, Z
    1f2c:	91 81       	ldd	r25, Z+1	; 0x01
    1f2e:	9a 83       	std	Y+2, r25	; 0x02
    1f30:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1f32:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>
    1f36:	88 87       	std	Y+8, r24	; 0x08

	if( xTicksToWait != ( TickType_t ) 0 )
    1f38:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f3a:	98 89       	ldd	r25, Y+16	; 0x10
    1f3c:	89 2b       	or	r24, r25
    1f3e:	09 f4       	brne	.+2      	; 0x1f42 <xEventGroupSync+0xe6>
    1f40:	3d c0       	rjmp	.+122    	; 0x1fbc <xEventGroupSync+0x160>
	{
		if( xAlreadyYielded == pdFALSE )
    1f42:	88 85       	ldd	r24, Y+8	; 0x08
    1f44:	88 23       	and	r24, r24
    1f46:	11 f4       	brne	.+4      	; 0x1f4c <xEventGroupSync+0xf0>
		{
			portYIELD_WITHIN_API();
    1f48:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1f4c:	0e 94 05 2d 	call	0x5a0a	; 0x5a0a <uxTaskResetEventItemValue>
    1f50:	9a 83       	std	Y+2, r25	; 0x02
    1f52:	89 83       	std	Y+1, r24	; 0x01

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1f54:	89 81       	ldd	r24, Y+1	; 0x01
    1f56:	9a 81       	ldd	r25, Y+2	; 0x02
    1f58:	88 27       	eor	r24, r24
    1f5a:	92 70       	andi	r25, 0x02	; 2
    1f5c:	89 2b       	or	r24, r25
    1f5e:	49 f5       	brne	.+82     	; 0x1fb2 <xEventGroupSync+0x156>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1f60:	0f b6       	in	r0, 0x3f	; 63
    1f62:	f8 94       	cli
    1f64:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1f66:	8b 81       	ldd	r24, Y+3	; 0x03
    1f68:	9c 81       	ldd	r25, Y+4	; 0x04
    1f6a:	fc 01       	movw	r30, r24
    1f6c:	80 81       	ld	r24, Z
    1f6e:	91 81       	ldd	r25, Z+1	; 0x01
    1f70:	9a 83       	std	Y+2, r25	; 0x02
    1f72:	89 83       	std	Y+1, r24	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1f74:	29 81       	ldd	r18, Y+1	; 0x01
    1f76:	3a 81       	ldd	r19, Y+2	; 0x02
    1f78:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f7a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f7c:	28 23       	and	r18, r24
    1f7e:	39 23       	and	r19, r25
    1f80:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f82:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f84:	28 17       	cp	r18, r24
    1f86:	39 07       	cpc	r19, r25
    1f88:	81 f4       	brne	.+32     	; 0x1faa <xEventGroupSync+0x14e>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1f8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f8c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f8e:	fc 01       	movw	r30, r24
    1f90:	20 81       	ld	r18, Z
    1f92:	31 81       	ldd	r19, Z+1	; 0x01
    1f94:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f96:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f98:	80 95       	com	r24
    1f9a:	90 95       	com	r25
    1f9c:	28 23       	and	r18, r24
    1f9e:	39 23       	and	r19, r25
    1fa0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fa2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fa4:	fc 01       	movw	r30, r24
    1fa6:	31 83       	std	Z+1, r19	; 0x01
    1fa8:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1faa:	0f 90       	pop	r0
    1fac:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    1fae:	81 e0       	ldi	r24, 0x01	; 1
    1fb0:	8d 83       	std	Y+5, r24	; 0x05
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1fb2:	89 81       	ldd	r24, Y+1	; 0x01
    1fb4:	9a 81       	ldd	r25, Y+2	; 0x02
    1fb6:	99 27       	eor	r25, r25
    1fb8:	9a 83       	std	Y+2, r25	; 0x02
    1fba:	89 83       	std	Y+1, r24	; 0x01
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    1fbc:	89 81       	ldd	r24, Y+1	; 0x01
    1fbe:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1fc0:	60 96       	adiw	r28, 0x10	; 16
    1fc2:	0f b6       	in	r0, 0x3f	; 63
    1fc4:	f8 94       	cli
    1fc6:	de bf       	out	0x3e, r29	; 62
    1fc8:	0f be       	out	0x3f, r0	; 63
    1fca:	cd bf       	out	0x3d, r28	; 61
    1fcc:	df 91       	pop	r29
    1fce:	cf 91       	pop	r28
    1fd0:	08 95       	ret

00001fd2 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    1fd2:	0f 93       	push	r16
    1fd4:	1f 93       	push	r17
    1fd6:	cf 93       	push	r28
    1fd8:	df 93       	push	r29
    1fda:	cd b7       	in	r28, 0x3d	; 61
    1fdc:	de b7       	in	r29, 0x3e	; 62
    1fde:	63 97       	sbiw	r28, 0x13	; 19
    1fe0:	0f b6       	in	r0, 0x3f	; 63
    1fe2:	f8 94       	cli
    1fe4:	de bf       	out	0x3e, r29	; 62
    1fe6:	0f be       	out	0x3f, r0	; 63
    1fe8:	cd bf       	out	0x3d, r28	; 61
    1fea:	9d 87       	std	Y+13, r25	; 0x0d
    1fec:	8c 87       	std	Y+12, r24	; 0x0c
    1fee:	7f 87       	std	Y+15, r23	; 0x0f
    1ff0:	6e 87       	std	Y+14, r22	; 0x0e
    1ff2:	48 8b       	std	Y+16, r20	; 0x10
    1ff4:	29 8b       	std	Y+17, r18	; 0x11
    1ff6:	1b 8b       	std	Y+19, r17	; 0x13
    1ff8:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1ffa:	8c 85       	ldd	r24, Y+12	; 0x0c
    1ffc:	9d 85       	ldd	r25, Y+13	; 0x0d
    1ffe:	9e 83       	std	Y+6, r25	; 0x06
    2000:	8d 83       	std	Y+5, r24	; 0x05
EventBits_t uxReturn, uxControlBits = 0;
    2002:	1c 82       	std	Y+4, r1	; 0x04
    2004:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2006:	1f 82       	std	Y+7, r1	; 0x07
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2008:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    200c:	8d 81       	ldd	r24, Y+5	; 0x05
    200e:	9e 81       	ldd	r25, Y+6	; 0x06
    2010:	fc 01       	movw	r30, r24
    2012:	80 81       	ld	r24, Z
    2014:	91 81       	ldd	r25, Z+1	; 0x01
    2016:	99 87       	std	Y+9, r25	; 0x09
    2018:	88 87       	std	Y+8, r24	; 0x08

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    201a:	2e 85       	ldd	r18, Y+14	; 0x0e
    201c:	3f 85       	ldd	r19, Y+15	; 0x0f
    201e:	88 85       	ldd	r24, Y+8	; 0x08
    2020:	99 85       	ldd	r25, Y+9	; 0x09
    2022:	49 89       	ldd	r20, Y+17	; 0x11
    2024:	b9 01       	movw	r22, r18
    2026:	0e 94 32 12 	call	0x2464	; 0x2464 <prvTestWaitCondition>
    202a:	8a 87       	std	Y+10, r24	; 0x0a

		if( xWaitConditionMet != pdFALSE )
    202c:	8a 85       	ldd	r24, Y+10	; 0x0a
    202e:	88 23       	and	r24, r24
    2030:	d1 f0       	breq	.+52     	; 0x2066 <xEventGroupWaitBits+0x94>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    2032:	88 85       	ldd	r24, Y+8	; 0x08
    2034:	99 85       	ldd	r25, Y+9	; 0x09
    2036:	9a 83       	std	Y+2, r25	; 0x02
    2038:	89 83       	std	Y+1, r24	; 0x01
			xTicksToWait = ( TickType_t ) 0;
    203a:	1b 8a       	std	Y+19, r1	; 0x13
    203c:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    203e:	88 89       	ldd	r24, Y+16	; 0x10
    2040:	88 23       	and	r24, r24
    2042:	d1 f1       	breq	.+116    	; 0x20b8 <xEventGroupWaitBits+0xe6>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2044:	8d 81       	ldd	r24, Y+5	; 0x05
    2046:	9e 81       	ldd	r25, Y+6	; 0x06
    2048:	fc 01       	movw	r30, r24
    204a:	20 81       	ld	r18, Z
    204c:	31 81       	ldd	r19, Z+1	; 0x01
    204e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2050:	9f 85       	ldd	r25, Y+15	; 0x0f
    2052:	80 95       	com	r24
    2054:	90 95       	com	r25
    2056:	28 23       	and	r18, r24
    2058:	39 23       	and	r19, r25
    205a:	8d 81       	ldd	r24, Y+5	; 0x05
    205c:	9e 81       	ldd	r25, Y+6	; 0x06
    205e:	fc 01       	movw	r30, r24
    2060:	31 83       	std	Z+1, r19	; 0x01
    2062:	20 83       	st	Z, r18
    2064:	29 c0       	rjmp	.+82     	; 0x20b8 <xEventGroupWaitBits+0xe6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    2066:	8a 89       	ldd	r24, Y+18	; 0x12
    2068:	9b 89       	ldd	r25, Y+19	; 0x13
    206a:	89 2b       	or	r24, r25
    206c:	29 f4       	brne	.+10     	; 0x2078 <xEventGroupWaitBits+0xa6>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    206e:	88 85       	ldd	r24, Y+8	; 0x08
    2070:	99 85       	ldd	r25, Y+9	; 0x09
    2072:	9a 83       	std	Y+2, r25	; 0x02
    2074:	89 83       	std	Y+1, r24	; 0x01
    2076:	20 c0       	rjmp	.+64     	; 0x20b8 <xEventGroupWaitBits+0xe6>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    2078:	88 89       	ldd	r24, Y+16	; 0x10
    207a:	88 23       	and	r24, r24
    207c:	29 f0       	breq	.+10     	; 0x2088 <xEventGroupWaitBits+0xb6>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    207e:	8b 81       	ldd	r24, Y+3	; 0x03
    2080:	9c 81       	ldd	r25, Y+4	; 0x04
    2082:	91 60       	ori	r25, 0x01	; 1
    2084:	9c 83       	std	Y+4, r25	; 0x04
    2086:	8b 83       	std	Y+3, r24	; 0x03
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    2088:	89 89       	ldd	r24, Y+17	; 0x11
    208a:	88 23       	and	r24, r24
    208c:	29 f0       	breq	.+10     	; 0x2098 <xEventGroupWaitBits+0xc6>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    208e:	8b 81       	ldd	r24, Y+3	; 0x03
    2090:	9c 81       	ldd	r25, Y+4	; 0x04
    2092:	94 60       	ori	r25, 0x04	; 4
    2094:	9c 83       	std	Y+4, r25	; 0x04
    2096:	8b 83       	std	Y+3, r24	; 0x03
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2098:	2e 85       	ldd	r18, Y+14	; 0x0e
    209a:	3f 85       	ldd	r19, Y+15	; 0x0f
    209c:	8b 81       	ldd	r24, Y+3	; 0x03
    209e:	9c 81       	ldd	r25, Y+4	; 0x04
    20a0:	28 2b       	or	r18, r24
    20a2:	39 2b       	or	r19, r25
    20a4:	8d 81       	ldd	r24, Y+5	; 0x05
    20a6:	9e 81       	ldd	r25, Y+6	; 0x06
    20a8:	02 96       	adiw	r24, 0x02	; 2
    20aa:	4a 89       	ldd	r20, Y+18	; 0x12
    20ac:	5b 89       	ldd	r21, Y+19	; 0x13
    20ae:	b9 01       	movw	r22, r18
    20b0:	0e 94 cd 27 	call	0x4f9a	; 0x4f9a <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    20b4:	1a 82       	std	Y+2, r1	; 0x02
    20b6:	19 82       	std	Y+1, r1	; 0x01

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    20b8:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>
    20bc:	8b 87       	std	Y+11, r24	; 0x0b

	if( xTicksToWait != ( TickType_t ) 0 )
    20be:	8a 89       	ldd	r24, Y+18	; 0x12
    20c0:	9b 89       	ldd	r25, Y+19	; 0x13
    20c2:	89 2b       	or	r24, r25
    20c4:	09 f4       	brne	.+2      	; 0x20c8 <xEventGroupWaitBits+0xf6>
    20c6:	3e c0       	rjmp	.+124    	; 0x2144 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
    20c8:	8b 85       	ldd	r24, Y+11	; 0x0b
    20ca:	88 23       	and	r24, r24
    20cc:	11 f4       	brne	.+4      	; 0x20d2 <xEventGroupWaitBits+0x100>
		{
			portYIELD_WITHIN_API();
    20ce:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    20d2:	0e 94 05 2d 	call	0x5a0a	; 0x5a0a <uxTaskResetEventItemValue>
    20d6:	9a 83       	std	Y+2, r25	; 0x02
    20d8:	89 83       	std	Y+1, r24	; 0x01

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    20da:	89 81       	ldd	r24, Y+1	; 0x01
    20dc:	9a 81       	ldd	r25, Y+2	; 0x02
    20de:	88 27       	eor	r24, r24
    20e0:	92 70       	andi	r25, 0x02	; 2
    20e2:	89 2b       	or	r24, r25
    20e4:	51 f5       	brne	.+84     	; 0x213a <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
    20e6:	0f b6       	in	r0, 0x3f	; 63
    20e8:	f8 94       	cli
    20ea:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    20ec:	8d 81       	ldd	r24, Y+5	; 0x05
    20ee:	9e 81       	ldd	r25, Y+6	; 0x06
    20f0:	fc 01       	movw	r30, r24
    20f2:	80 81       	ld	r24, Z
    20f4:	91 81       	ldd	r25, Z+1	; 0x01
    20f6:	9a 83       	std	Y+2, r25	; 0x02
    20f8:	89 83       	std	Y+1, r24	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    20fa:	2e 85       	ldd	r18, Y+14	; 0x0e
    20fc:	3f 85       	ldd	r19, Y+15	; 0x0f
    20fe:	89 81       	ldd	r24, Y+1	; 0x01
    2100:	9a 81       	ldd	r25, Y+2	; 0x02
    2102:	49 89       	ldd	r20, Y+17	; 0x11
    2104:	b9 01       	movw	r22, r18
    2106:	0e 94 32 12 	call	0x2464	; 0x2464 <prvTestWaitCondition>
    210a:	88 23       	and	r24, r24
    210c:	99 f0       	breq	.+38     	; 0x2134 <xEventGroupWaitBits+0x162>
				{
					if( xClearOnExit != pdFALSE )
    210e:	88 89       	ldd	r24, Y+16	; 0x10
    2110:	88 23       	and	r24, r24
    2112:	81 f0       	breq	.+32     	; 0x2134 <xEventGroupWaitBits+0x162>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2114:	8d 81       	ldd	r24, Y+5	; 0x05
    2116:	9e 81       	ldd	r25, Y+6	; 0x06
    2118:	fc 01       	movw	r30, r24
    211a:	20 81       	ld	r18, Z
    211c:	31 81       	ldd	r19, Z+1	; 0x01
    211e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2120:	9f 85       	ldd	r25, Y+15	; 0x0f
    2122:	80 95       	com	r24
    2124:	90 95       	com	r25
    2126:	28 23       	and	r18, r24
    2128:	39 23       	and	r19, r25
    212a:	8d 81       	ldd	r24, Y+5	; 0x05
    212c:	9e 81       	ldd	r25, Y+6	; 0x06
    212e:	fc 01       	movw	r30, r24
    2130:	31 83       	std	Z+1, r19	; 0x01
    2132:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2134:	0f 90       	pop	r0
    2136:	0f be       	out	0x3f, r0	; 63

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
    2138:	1f 82       	std	Y+7, r1	; 0x07
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    213a:	89 81       	ldd	r24, Y+1	; 0x01
    213c:	9a 81       	ldd	r25, Y+2	; 0x02
    213e:	99 27       	eor	r25, r25
    2140:	9a 83       	std	Y+2, r25	; 0x02
    2142:	89 83       	std	Y+1, r24	; 0x01
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    2144:	89 81       	ldd	r24, Y+1	; 0x01
    2146:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2148:	63 96       	adiw	r28, 0x13	; 19
    214a:	0f b6       	in	r0, 0x3f	; 63
    214c:	f8 94       	cli
    214e:	de bf       	out	0x3e, r29	; 62
    2150:	0f be       	out	0x3f, r0	; 63
    2152:	cd bf       	out	0x3d, r28	; 61
    2154:	df 91       	pop	r29
    2156:	cf 91       	pop	r28
    2158:	1f 91       	pop	r17
    215a:	0f 91       	pop	r16
    215c:	08 95       	ret

0000215e <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    215e:	cf 93       	push	r28
    2160:	df 93       	push	r29
    2162:	cd b7       	in	r28, 0x3d	; 61
    2164:	de b7       	in	r29, 0x3e	; 62
    2166:	28 97       	sbiw	r28, 0x08	; 8
    2168:	0f b6       	in	r0, 0x3f	; 63
    216a:	f8 94       	cli
    216c:	de bf       	out	0x3e, r29	; 62
    216e:	0f be       	out	0x3f, r0	; 63
    2170:	cd bf       	out	0x3d, r28	; 61
    2172:	9e 83       	std	Y+6, r25	; 0x06
    2174:	8d 83       	std	Y+5, r24	; 0x05
    2176:	78 87       	std	Y+8, r23	; 0x08
    2178:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    217a:	8d 81       	ldd	r24, Y+5	; 0x05
    217c:	9e 81       	ldd	r25, Y+6	; 0x06
    217e:	9a 83       	std	Y+2, r25	; 0x02
    2180:	89 83       	std	Y+1, r24	; 0x01
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    2182:	0f b6       	in	r0, 0x3f	; 63
    2184:	f8 94       	cli
    2186:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    2188:	89 81       	ldd	r24, Y+1	; 0x01
    218a:	9a 81       	ldd	r25, Y+2	; 0x02
    218c:	fc 01       	movw	r30, r24
    218e:	80 81       	ld	r24, Z
    2190:	91 81       	ldd	r25, Z+1	; 0x01
    2192:	9c 83       	std	Y+4, r25	; 0x04
    2194:	8b 83       	std	Y+3, r24	; 0x03

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2196:	89 81       	ldd	r24, Y+1	; 0x01
    2198:	9a 81       	ldd	r25, Y+2	; 0x02
    219a:	fc 01       	movw	r30, r24
    219c:	20 81       	ld	r18, Z
    219e:	31 81       	ldd	r19, Z+1	; 0x01
    21a0:	8f 81       	ldd	r24, Y+7	; 0x07
    21a2:	98 85       	ldd	r25, Y+8	; 0x08
    21a4:	80 95       	com	r24
    21a6:	90 95       	com	r25
    21a8:	28 23       	and	r18, r24
    21aa:	39 23       	and	r19, r25
    21ac:	89 81       	ldd	r24, Y+1	; 0x01
    21ae:	9a 81       	ldd	r25, Y+2	; 0x02
    21b0:	fc 01       	movw	r30, r24
    21b2:	31 83       	std	Z+1, r19	; 0x01
    21b4:	20 83       	st	Z, r18
	}
	taskEXIT_CRITICAL();
    21b6:	0f 90       	pop	r0
    21b8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    21ba:	8b 81       	ldd	r24, Y+3	; 0x03
    21bc:	9c 81       	ldd	r25, Y+4	; 0x04
}
    21be:	28 96       	adiw	r28, 0x08	; 8
    21c0:	0f b6       	in	r0, 0x3f	; 63
    21c2:	f8 94       	cli
    21c4:	de bf       	out	0x3e, r29	; 62
    21c6:	0f be       	out	0x3f, r0	; 63
    21c8:	cd bf       	out	0x3d, r28	; 61
    21ca:	df 91       	pop	r29
    21cc:	cf 91       	pop	r28
    21ce:	08 95       	ret

000021d0 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    21d0:	cf 93       	push	r28
    21d2:	df 93       	push	r29
    21d4:	cd b7       	in	r28, 0x3d	; 61
    21d6:	de b7       	in	r29, 0x3e	; 62
    21d8:	27 97       	sbiw	r28, 0x07	; 7
    21da:	0f b6       	in	r0, 0x3f	; 63
    21dc:	f8 94       	cli
    21de:	de bf       	out	0x3e, r29	; 62
    21e0:	0f be       	out	0x3f, r0	; 63
    21e2:	cd bf       	out	0x3d, r28	; 61
    21e4:	9f 83       	std	Y+7, r25	; 0x07
    21e6:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    21e8:	8e 81       	ldd	r24, Y+6	; 0x06
    21ea:	9f 81       	ldd	r25, Y+7	; 0x07
    21ec:	9a 83       	std	Y+2, r25	; 0x02
    21ee:	89 83       	std	Y+1, r24	; 0x01
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    21f0:	1b 82       	std	Y+3, r1	; 0x03
	{
		uxReturn = pxEventBits->uxEventBits;
    21f2:	89 81       	ldd	r24, Y+1	; 0x01
    21f4:	9a 81       	ldd	r25, Y+2	; 0x02
    21f6:	fc 01       	movw	r30, r24
    21f8:	80 81       	ld	r24, Z
    21fa:	91 81       	ldd	r25, Z+1	; 0x01
    21fc:	9d 83       	std	Y+5, r25	; 0x05
    21fe:	8c 83       	std	Y+4, r24	; 0x04
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    2200:	8c 81       	ldd	r24, Y+4	; 0x04
    2202:	9d 81       	ldd	r25, Y+5	; 0x05
}
    2204:	27 96       	adiw	r28, 0x07	; 7
    2206:	0f b6       	in	r0, 0x3f	; 63
    2208:	f8 94       	cli
    220a:	de bf       	out	0x3e, r29	; 62
    220c:	0f be       	out	0x3f, r0	; 63
    220e:	cd bf       	out	0x3d, r28	; 61
    2210:	df 91       	pop	r29
    2212:	cf 91       	pop	r28
    2214:	08 95       	ret

00002216 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    2216:	cf 93       	push	r28
    2218:	df 93       	push	r29
    221a:	cd b7       	in	r28, 0x3d	; 61
    221c:	de b7       	in	r29, 0x3e	; 62
    221e:	65 97       	sbiw	r28, 0x15	; 21
    2220:	0f b6       	in	r0, 0x3f	; 63
    2222:	f8 94       	cli
    2224:	de bf       	out	0x3e, r29	; 62
    2226:	0f be       	out	0x3f, r0	; 63
    2228:	cd bf       	out	0x3d, r28	; 61
    222a:	9b 8b       	std	Y+19, r25	; 0x13
    222c:	8a 8b       	std	Y+18, r24	; 0x12
    222e:	7d 8b       	std	Y+21, r23	; 0x15
    2230:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2232:	1c 82       	std	Y+4, r1	; 0x04
    2234:	1b 82       	std	Y+3, r1	; 0x03
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    2236:	8a 89       	ldd	r24, Y+18	; 0x12
    2238:	9b 89       	ldd	r25, Y+19	; 0x13
    223a:	9f 83       	std	Y+7, r25	; 0x07
    223c:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xMatchFound = pdFALSE;
    223e:	1d 82       	std	Y+5, r1	; 0x05
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    2240:	8e 81       	ldd	r24, Y+6	; 0x06
    2242:	9f 81       	ldd	r25, Y+7	; 0x07
    2244:	02 96       	adiw	r24, 0x02	; 2
    2246:	99 87       	std	Y+9, r25	; 0x09
    2248:	88 87       	std	Y+8, r24	; 0x08
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    224a:	88 85       	ldd	r24, Y+8	; 0x08
    224c:	99 85       	ldd	r25, Y+9	; 0x09
    224e:	03 96       	adiw	r24, 0x03	; 3
    2250:	9b 87       	std	Y+11, r25	; 0x0b
    2252:	8a 87       	std	Y+10, r24	; 0x0a
	vTaskSuspendAll();
    2254:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    2258:	88 85       	ldd	r24, Y+8	; 0x08
    225a:	99 85       	ldd	r25, Y+9	; 0x09
    225c:	fc 01       	movw	r30, r24
    225e:	85 81       	ldd	r24, Z+5	; 0x05
    2260:	96 81       	ldd	r25, Z+6	; 0x06
    2262:	9a 83       	std	Y+2, r25	; 0x02
    2264:	89 83       	std	Y+1, r24	; 0x01

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    2266:	8e 81       	ldd	r24, Y+6	; 0x06
    2268:	9f 81       	ldd	r25, Y+7	; 0x07
    226a:	fc 01       	movw	r30, r24
    226c:	20 81       	ld	r18, Z
    226e:	31 81       	ldd	r19, Z+1	; 0x01
    2270:	8c 89       	ldd	r24, Y+20	; 0x14
    2272:	9d 89       	ldd	r25, Y+21	; 0x15
    2274:	28 2b       	or	r18, r24
    2276:	39 2b       	or	r19, r25
    2278:	8e 81       	ldd	r24, Y+6	; 0x06
    227a:	9f 81       	ldd	r25, Y+7	; 0x07
    227c:	fc 01       	movw	r30, r24
    227e:	31 83       	std	Z+1, r19	; 0x01
    2280:	20 83       	st	Z, r18

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    2282:	5e c0       	rjmp	.+188    	; 0x2340 <xEventGroupSetBits+0x12a>
		{
			pxNext = listGET_NEXT( pxListItem );
    2284:	89 81       	ldd	r24, Y+1	; 0x01
    2286:	9a 81       	ldd	r25, Y+2	; 0x02
    2288:	fc 01       	movw	r30, r24
    228a:	82 81       	ldd	r24, Z+2	; 0x02
    228c:	93 81       	ldd	r25, Z+3	; 0x03
    228e:	9d 87       	std	Y+13, r25	; 0x0d
    2290:	8c 87       	std	Y+12, r24	; 0x0c
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2292:	89 81       	ldd	r24, Y+1	; 0x01
    2294:	9a 81       	ldd	r25, Y+2	; 0x02
    2296:	fc 01       	movw	r30, r24
    2298:	80 81       	ld	r24, Z
    229a:	91 81       	ldd	r25, Z+1	; 0x01
    229c:	9f 87       	std	Y+15, r25	; 0x0f
    229e:	8e 87       	std	Y+14, r24	; 0x0e
			xMatchFound = pdFALSE;
    22a0:	1d 82       	std	Y+5, r1	; 0x05

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    22a2:	8e 85       	ldd	r24, Y+14	; 0x0e
    22a4:	9f 85       	ldd	r25, Y+15	; 0x0f
    22a6:	88 27       	eor	r24, r24
    22a8:	99 8b       	std	Y+17, r25	; 0x11
    22aa:	88 8b       	std	Y+16, r24	; 0x10
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    22ac:	8e 85       	ldd	r24, Y+14	; 0x0e
    22ae:	9f 85       	ldd	r25, Y+15	; 0x0f
    22b0:	99 27       	eor	r25, r25
    22b2:	9f 87       	std	Y+15, r25	; 0x0f
    22b4:	8e 87       	std	Y+14, r24	; 0x0e

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    22b6:	88 89       	ldd	r24, Y+16	; 0x10
    22b8:	99 89       	ldd	r25, Y+17	; 0x11
    22ba:	88 27       	eor	r24, r24
    22bc:	94 70       	andi	r25, 0x04	; 4
    22be:	89 2b       	or	r24, r25
    22c0:	71 f4       	brne	.+28     	; 0x22de <xEventGroupSetBits+0xc8>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    22c2:	8e 81       	ldd	r24, Y+6	; 0x06
    22c4:	9f 81       	ldd	r25, Y+7	; 0x07
    22c6:	fc 01       	movw	r30, r24
    22c8:	20 81       	ld	r18, Z
    22ca:	31 81       	ldd	r19, Z+1	; 0x01
    22cc:	8e 85       	ldd	r24, Y+14	; 0x0e
    22ce:	9f 85       	ldd	r25, Y+15	; 0x0f
    22d0:	82 23       	and	r24, r18
    22d2:	93 23       	and	r25, r19
    22d4:	89 2b       	or	r24, r25
    22d6:	99 f0       	breq	.+38     	; 0x22fe <xEventGroupSetBits+0xe8>
				{
					xMatchFound = pdTRUE;
    22d8:	81 e0       	ldi	r24, 0x01	; 1
    22da:	8d 83       	std	Y+5, r24	; 0x05
    22dc:	10 c0       	rjmp	.+32     	; 0x22fe <xEventGroupSetBits+0xe8>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    22de:	8e 81       	ldd	r24, Y+6	; 0x06
    22e0:	9f 81       	ldd	r25, Y+7	; 0x07
    22e2:	fc 01       	movw	r30, r24
    22e4:	20 81       	ld	r18, Z
    22e6:	31 81       	ldd	r19, Z+1	; 0x01
    22e8:	8e 85       	ldd	r24, Y+14	; 0x0e
    22ea:	9f 85       	ldd	r25, Y+15	; 0x0f
    22ec:	28 23       	and	r18, r24
    22ee:	39 23       	and	r19, r25
    22f0:	8e 85       	ldd	r24, Y+14	; 0x0e
    22f2:	9f 85       	ldd	r25, Y+15	; 0x0f
    22f4:	28 17       	cp	r18, r24
    22f6:	39 07       	cpc	r19, r25
    22f8:	11 f4       	brne	.+4      	; 0x22fe <xEventGroupSetBits+0xe8>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    22fa:	81 e0       	ldi	r24, 0x01	; 1
    22fc:	8d 83       	std	Y+5, r24	; 0x05
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    22fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2300:	88 23       	and	r24, r24
    2302:	d1 f0       	breq	.+52     	; 0x2338 <xEventGroupSetBits+0x122>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    2304:	88 89       	ldd	r24, Y+16	; 0x10
    2306:	99 89       	ldd	r25, Y+17	; 0x11
    2308:	88 27       	eor	r24, r24
    230a:	91 70       	andi	r25, 0x01	; 1
    230c:	89 2b       	or	r24, r25
    230e:	41 f0       	breq	.+16     	; 0x2320 <xEventGroupSetBits+0x10a>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    2310:	2b 81       	ldd	r18, Y+3	; 0x03
    2312:	3c 81       	ldd	r19, Y+4	; 0x04
    2314:	8e 85       	ldd	r24, Y+14	; 0x0e
    2316:	9f 85       	ldd	r25, Y+15	; 0x0f
    2318:	82 2b       	or	r24, r18
    231a:	93 2b       	or	r25, r19
    231c:	9c 83       	std	Y+4, r25	; 0x04
    231e:	8b 83       	std	Y+3, r24	; 0x03
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    2320:	8e 81       	ldd	r24, Y+6	; 0x06
    2322:	9f 81       	ldd	r25, Y+7	; 0x07
    2324:	fc 01       	movw	r30, r24
    2326:	80 81       	ld	r24, Z
    2328:	91 81       	ldd	r25, Z+1	; 0x01
    232a:	9c 01       	movw	r18, r24
    232c:	32 60       	ori	r19, 0x02	; 2
    232e:	89 81       	ldd	r24, Y+1	; 0x01
    2330:	9a 81       	ldd	r25, Y+2	; 0x02
    2332:	b9 01       	movw	r22, r18
    2334:	0e 94 8d 28 	call	0x511a	; 0x511a <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    2338:	8c 85       	ldd	r24, Y+12	; 0x0c
    233a:	9d 85       	ldd	r25, Y+13	; 0x0d
    233c:	9a 83       	std	Y+2, r25	; 0x02
    233e:	89 83       	std	Y+1, r24	; 0x01

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    2340:	29 81       	ldd	r18, Y+1	; 0x01
    2342:	3a 81       	ldd	r19, Y+2	; 0x02
    2344:	8a 85       	ldd	r24, Y+10	; 0x0a
    2346:	9b 85       	ldd	r25, Y+11	; 0x0b
    2348:	28 17       	cp	r18, r24
    234a:	39 07       	cpc	r19, r25
    234c:	09 f0       	breq	.+2      	; 0x2350 <xEventGroupSetBits+0x13a>
    234e:	9a cf       	rjmp	.-204    	; 0x2284 <xEventGroupSetBits+0x6e>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2350:	8e 81       	ldd	r24, Y+6	; 0x06
    2352:	9f 81       	ldd	r25, Y+7	; 0x07
    2354:	fc 01       	movw	r30, r24
    2356:	20 81       	ld	r18, Z
    2358:	31 81       	ldd	r19, Z+1	; 0x01
    235a:	8b 81       	ldd	r24, Y+3	; 0x03
    235c:	9c 81       	ldd	r25, Y+4	; 0x04
    235e:	80 95       	com	r24
    2360:	90 95       	com	r25
    2362:	28 23       	and	r18, r24
    2364:	39 23       	and	r19, r25
    2366:	8e 81       	ldd	r24, Y+6	; 0x06
    2368:	9f 81       	ldd	r25, Y+7	; 0x07
    236a:	fc 01       	movw	r30, r24
    236c:	31 83       	std	Z+1, r19	; 0x01
    236e:	20 83       	st	Z, r18
	}
	( void ) xTaskResumeAll();
    2370:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    2374:	8e 81       	ldd	r24, Y+6	; 0x06
    2376:	9f 81       	ldd	r25, Y+7	; 0x07
    2378:	fc 01       	movw	r30, r24
    237a:	80 81       	ld	r24, Z
    237c:	91 81       	ldd	r25, Z+1	; 0x01
}
    237e:	65 96       	adiw	r28, 0x15	; 21
    2380:	0f b6       	in	r0, 0x3f	; 63
    2382:	f8 94       	cli
    2384:	de bf       	out	0x3e, r29	; 62
    2386:	0f be       	out	0x3f, r0	; 63
    2388:	cd bf       	out	0x3d, r28	; 61
    238a:	df 91       	pop	r29
    238c:	cf 91       	pop	r28
    238e:	08 95       	ret

00002390 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    2390:	cf 93       	push	r28
    2392:	df 93       	push	r29
    2394:	00 d0       	rcall	.+0      	; 0x2396 <vEventGroupDelete+0x6>
    2396:	00 d0       	rcall	.+0      	; 0x2398 <vEventGroupDelete+0x8>
    2398:	cd b7       	in	r28, 0x3d	; 61
    239a:	de b7       	in	r29, 0x3e	; 62
    239c:	9e 83       	std	Y+6, r25	; 0x06
    239e:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    23a0:	8d 81       	ldd	r24, Y+5	; 0x05
    23a2:	9e 81       	ldd	r25, Y+6	; 0x06
    23a4:	9a 83       	std	Y+2, r25	; 0x02
    23a6:	89 83       	std	Y+1, r24	; 0x01
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    23a8:	89 81       	ldd	r24, Y+1	; 0x01
    23aa:	9a 81       	ldd	r25, Y+2	; 0x02
    23ac:	02 96       	adiw	r24, 0x02	; 2
    23ae:	9c 83       	std	Y+4, r25	; 0x04
    23b0:	8b 83       	std	Y+3, r24	; 0x03

	vTaskSuspendAll();
    23b2:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    23b6:	09 c0       	rjmp	.+18     	; 0x23ca <vEventGroupDelete+0x3a>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    23b8:	8b 81       	ldd	r24, Y+3	; 0x03
    23ba:	9c 81       	ldd	r25, Y+4	; 0x04
    23bc:	fc 01       	movw	r30, r24
    23be:	85 81       	ldd	r24, Z+5	; 0x05
    23c0:	96 81       	ldd	r25, Z+6	; 0x06
    23c2:	60 e0       	ldi	r22, 0x00	; 0
    23c4:	72 e0       	ldi	r23, 0x02	; 2
    23c6:	0e 94 8d 28 	call	0x511a	; 0x511a <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    23ca:	8b 81       	ldd	r24, Y+3	; 0x03
    23cc:	9c 81       	ldd	r25, Y+4	; 0x04
    23ce:	fc 01       	movw	r30, r24
    23d0:	80 81       	ld	r24, Z
    23d2:	88 23       	and	r24, r24
    23d4:	89 f7       	brne	.-30     	; 0x23b8 <vEventGroupDelete+0x28>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
    23d6:	89 81       	ldd	r24, Y+1	; 0x01
    23d8:	9a 81       	ldd	r25, Y+2	; 0x02
    23da:	0e 94 84 12 	call	0x2508	; 0x2508 <vPortFree>
	}
	( void ) xTaskResumeAll();
    23de:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>
}
    23e2:	26 96       	adiw	r28, 0x06	; 6
    23e4:	0f b6       	in	r0, 0x3f	; 63
    23e6:	f8 94       	cli
    23e8:	de bf       	out	0x3e, r29	; 62
    23ea:	0f be       	out	0x3f, r0	; 63
    23ec:	cd bf       	out	0x3d, r28	; 61
    23ee:	df 91       	pop	r29
    23f0:	cf 91       	pop	r28
    23f2:	08 95       	ret

000023f4 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    23f4:	cf 93       	push	r28
    23f6:	df 93       	push	r29
    23f8:	00 d0       	rcall	.+0      	; 0x23fa <vEventGroupSetBitsCallback+0x6>
    23fa:	00 d0       	rcall	.+0      	; 0x23fc <vEventGroupSetBitsCallback+0x8>
    23fc:	cd b7       	in	r28, 0x3d	; 61
    23fe:	de b7       	in	r29, 0x3e	; 62
    2400:	9a 83       	std	Y+2, r25	; 0x02
    2402:	89 83       	std	Y+1, r24	; 0x01
    2404:	4b 83       	std	Y+3, r20	; 0x03
    2406:	5c 83       	std	Y+4, r21	; 0x04
    2408:	6d 83       	std	Y+5, r22	; 0x05
    240a:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    240c:	2b 81       	ldd	r18, Y+3	; 0x03
    240e:	3c 81       	ldd	r19, Y+4	; 0x04
    2410:	89 81       	ldd	r24, Y+1	; 0x01
    2412:	9a 81       	ldd	r25, Y+2	; 0x02
    2414:	b9 01       	movw	r22, r18
    2416:	0e 94 0b 11 	call	0x2216	; 0x2216 <xEventGroupSetBits>
}
    241a:	26 96       	adiw	r28, 0x06	; 6
    241c:	0f b6       	in	r0, 0x3f	; 63
    241e:	f8 94       	cli
    2420:	de bf       	out	0x3e, r29	; 62
    2422:	0f be       	out	0x3f, r0	; 63
    2424:	cd bf       	out	0x3d, r28	; 61
    2426:	df 91       	pop	r29
    2428:	cf 91       	pop	r28
    242a:	08 95       	ret

0000242c <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    242c:	cf 93       	push	r28
    242e:	df 93       	push	r29
    2430:	00 d0       	rcall	.+0      	; 0x2432 <vEventGroupClearBitsCallback+0x6>
    2432:	00 d0       	rcall	.+0      	; 0x2434 <vEventGroupClearBitsCallback+0x8>
    2434:	cd b7       	in	r28, 0x3d	; 61
    2436:	de b7       	in	r29, 0x3e	; 62
    2438:	9a 83       	std	Y+2, r25	; 0x02
    243a:	89 83       	std	Y+1, r24	; 0x01
    243c:	4b 83       	std	Y+3, r20	; 0x03
    243e:	5c 83       	std	Y+4, r21	; 0x04
    2440:	6d 83       	std	Y+5, r22	; 0x05
    2442:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    2444:	2b 81       	ldd	r18, Y+3	; 0x03
    2446:	3c 81       	ldd	r19, Y+4	; 0x04
    2448:	89 81       	ldd	r24, Y+1	; 0x01
    244a:	9a 81       	ldd	r25, Y+2	; 0x02
    244c:	b9 01       	movw	r22, r18
    244e:	0e 94 af 10 	call	0x215e	; 0x215e <xEventGroupClearBits>
}
    2452:	26 96       	adiw	r28, 0x06	; 6
    2454:	0f b6       	in	r0, 0x3f	; 63
    2456:	f8 94       	cli
    2458:	de bf       	out	0x3e, r29	; 62
    245a:	0f be       	out	0x3f, r0	; 63
    245c:	cd bf       	out	0x3d, r28	; 61
    245e:	df 91       	pop	r29
    2460:	cf 91       	pop	r28
    2462:	08 95       	ret

00002464 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    2464:	cf 93       	push	r28
    2466:	df 93       	push	r29
    2468:	00 d0       	rcall	.+0      	; 0x246a <prvTestWaitCondition+0x6>
    246a:	00 d0       	rcall	.+0      	; 0x246c <prvTestWaitCondition+0x8>
    246c:	cd b7       	in	r28, 0x3d	; 61
    246e:	de b7       	in	r29, 0x3e	; 62
    2470:	9b 83       	std	Y+3, r25	; 0x03
    2472:	8a 83       	std	Y+2, r24	; 0x02
    2474:	7d 83       	std	Y+5, r23	; 0x05
    2476:	6c 83       	std	Y+4, r22	; 0x04
    2478:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    247a:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    247c:	8e 81       	ldd	r24, Y+6	; 0x06
    247e:	88 23       	and	r24, r24
    2480:	59 f4       	brne	.+22     	; 0x2498 <prvTestWaitCondition+0x34>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    2482:	2a 81       	ldd	r18, Y+2	; 0x02
    2484:	3b 81       	ldd	r19, Y+3	; 0x03
    2486:	8c 81       	ldd	r24, Y+4	; 0x04
    2488:	9d 81       	ldd	r25, Y+5	; 0x05
    248a:	82 23       	and	r24, r18
    248c:	93 23       	and	r25, r19
    248e:	89 2b       	or	r24, r25
    2490:	81 f0       	breq	.+32     	; 0x24b2 <prvTestWaitCondition+0x4e>
		{
			xWaitConditionMet = pdTRUE;
    2492:	81 e0       	ldi	r24, 0x01	; 1
    2494:	89 83       	std	Y+1, r24	; 0x01
    2496:	0d c0       	rjmp	.+26     	; 0x24b2 <prvTestWaitCondition+0x4e>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2498:	2a 81       	ldd	r18, Y+2	; 0x02
    249a:	3b 81       	ldd	r19, Y+3	; 0x03
    249c:	8c 81       	ldd	r24, Y+4	; 0x04
    249e:	9d 81       	ldd	r25, Y+5	; 0x05
    24a0:	28 23       	and	r18, r24
    24a2:	39 23       	and	r19, r25
    24a4:	8c 81       	ldd	r24, Y+4	; 0x04
    24a6:	9d 81       	ldd	r25, Y+5	; 0x05
    24a8:	28 17       	cp	r18, r24
    24aa:	39 07       	cpc	r19, r25
    24ac:	11 f4       	brne	.+4      	; 0x24b2 <prvTestWaitCondition+0x4e>
		{
			xWaitConditionMet = pdTRUE;
    24ae:	81 e0       	ldi	r24, 0x01	; 1
    24b0:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    24b2:	89 81       	ldd	r24, Y+1	; 0x01
}
    24b4:	26 96       	adiw	r28, 0x06	; 6
    24b6:	0f b6       	in	r0, 0x3f	; 63
    24b8:	f8 94       	cli
    24ba:	de bf       	out	0x3e, r29	; 62
    24bc:	0f be       	out	0x3f, r0	; 63
    24be:	cd bf       	out	0x3d, r28	; 61
    24c0:	df 91       	pop	r29
    24c2:	cf 91       	pop	r28
    24c4:	08 95       	ret

000024c6 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    24c6:	cf 93       	push	r28
    24c8:	df 93       	push	r29
    24ca:	00 d0       	rcall	.+0      	; 0x24cc <pvPortMalloc+0x6>
    24cc:	1f 92       	push	r1
    24ce:	cd b7       	in	r28, 0x3d	; 61
    24d0:	de b7       	in	r29, 0x3e	; 62
    24d2:	9c 83       	std	Y+4, r25	; 0x04
    24d4:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn;

	vTaskSuspendAll();
    24d6:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    24da:	8b 81       	ldd	r24, Y+3	; 0x03
    24dc:	9c 81       	ldd	r25, Y+4	; 0x04
    24de:	0e 94 a1 35 	call	0x6b42	; 0x6b42 <malloc>
    24e2:	9a 83       	std	Y+2, r25	; 0x02
    24e4:	89 83       	std	Y+1, r24	; 0x01
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    24e6:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
    24ea:	89 81       	ldd	r24, Y+1	; 0x01
    24ec:	9a 81       	ldd	r25, Y+2	; 0x02
    24ee:	89 2b       	or	r24, r25
    24f0:	11 f4       	brne	.+4      	; 0x24f6 <pvPortMalloc+0x30>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
    24f2:	0e 94 e6 12 	call	0x25cc	; 0x25cc <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
    24f6:	89 81       	ldd	r24, Y+1	; 0x01
    24f8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    24fa:	0f 90       	pop	r0
    24fc:	0f 90       	pop	r0
    24fe:	0f 90       	pop	r0
    2500:	0f 90       	pop	r0
    2502:	df 91       	pop	r29
    2504:	cf 91       	pop	r28
    2506:	08 95       	ret

00002508 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2508:	cf 93       	push	r28
    250a:	df 93       	push	r29
    250c:	1f 92       	push	r1
    250e:	1f 92       	push	r1
    2510:	cd b7       	in	r28, 0x3d	; 61
    2512:	de b7       	in	r29, 0x3e	; 62
    2514:	9a 83       	std	Y+2, r25	; 0x02
    2516:	89 83       	std	Y+1, r24	; 0x01
	if( pv )
    2518:	89 81       	ldd	r24, Y+1	; 0x01
    251a:	9a 81       	ldd	r25, Y+2	; 0x02
    251c:	89 2b       	or	r24, r25
    251e:	41 f0       	breq	.+16     	; 0x2530 <vPortFree+0x28>
	{
		vTaskSuspendAll();
    2520:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <vTaskSuspendAll>
		{
			free( pv );
    2524:	89 81       	ldd	r24, Y+1	; 0x01
    2526:	9a 81       	ldd	r25, Y+2	; 0x02
    2528:	0e 94 36 36 	call	0x6c6c	; 0x6c6c <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    252c:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>
	}
}
    2530:	0f 90       	pop	r0
    2532:	0f 90       	pop	r0
    2534:	df 91       	pop	r29
    2536:	cf 91       	pop	r28
    2538:	08 95       	ret

0000253a <vApplicationIdleHook>:
#if defined( configUSE_IDLE_HOOK )

void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    253a:	cf 93       	push	r28
    253c:	df 93       	push	r29
    253e:	cd b7       	in	r28, 0x3d	; 61
    2540:	de b7       	in	r29, 0x3e	; 62
	// SLEEP_MODE_PWR_DOWN     _BV(SM1)
	// SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
	// SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
	// SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

	set_sleep_mode( SLEEP_MODE_IDLE );
    2542:	83 e5       	ldi	r24, 0x53	; 83
    2544:	90 e0       	ldi	r25, 0x00	; 0
    2546:	23 e5       	ldi	r18, 0x53	; 83
    2548:	30 e0       	ldi	r19, 0x00	; 0
    254a:	f9 01       	movw	r30, r18
    254c:	20 81       	ld	r18, Z
    254e:	21 7f       	andi	r18, 0xF1	; 241
    2550:	fc 01       	movw	r30, r24
    2552:	20 83       	st	Z, r18
	// When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
	// This bit can be set at any time to turn off the Analogue Comparator.
	// This will reduce power consumption in Active and Idle mode.
	// When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
	// Otherwise an interrupt can occur when the ACD bit is changed.
	ACSR &= ~_BV(ACIE);
    2554:	80 e5       	ldi	r24, 0x50	; 80
    2556:	90 e0       	ldi	r25, 0x00	; 0
    2558:	20 e5       	ldi	r18, 0x50	; 80
    255a:	30 e0       	ldi	r19, 0x00	; 0
    255c:	f9 01       	movw	r30, r18
    255e:	20 81       	ld	r18, Z
    2560:	27 7f       	andi	r18, 0xF7	; 247
    2562:	fc 01       	movw	r30, r24
    2564:	20 83       	st	Z, r18
	ACSR |=  _BV(ACD);
    2566:	80 e5       	ldi	r24, 0x50	; 80
    2568:	90 e0       	ldi	r25, 0x00	; 0
    256a:	20 e5       	ldi	r18, 0x50	; 80
    256c:	30 e0       	ldi	r19, 0x00	; 0
    256e:	f9 01       	movw	r30, r18
    2570:	20 81       	ld	r18, Z
    2572:	20 68       	ori	r18, 0x80	; 128
    2574:	fc 01       	movw	r30, r24
    2576:	20 83       	st	Z, r18
	// The corresponding PIN Register bit will always read as zero when this bit is set. When an
	// analogue signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this
	// bit should be written logic one to reduce power consumption in the digital input buffer.

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DIDR0 = 0xFF;
    2578:	8e e7       	ldi	r24, 0x7E	; 126
    257a:	90 e0       	ldi	r25, 0x00	; 0
    257c:	2f ef       	ldi	r18, 0xFF	; 255
    257e:	fc 01       	movw	r30, r24
    2580:	20 83       	st	Z, r18
	DIDR1 = 0x03;
    2582:	8f e7       	ldi	r24, 0x7F	; 127
    2584:	90 e0       	ldi	r25, 0x00	; 0
    2586:	23 e0       	ldi	r18, 0x03	; 3
    2588:	fc 01       	movw	r30, r24
    258a:	20 83       	st	Z, r18
	DIDR2 = 0xFF;
    258c:	8d e7       	ldi	r24, 0x7D	; 125
    258e:	90 e0       	ldi	r25, 0x00	; 0
    2590:	2f ef       	ldi	r18, 0xFF	; 255
    2592:	fc 01       	movw	r30, r24
    2594:	20 83       	st	Z, r18
	DIDR1 = 0x01;
	DIDR2 = 0x3F;

#endif

	portENTER_CRITICAL();
    2596:	0f b6       	in	r0, 0x3f	; 63
    2598:	f8 94       	cli
    259a:	0f 92       	push	r0
	sleep_enable();
    259c:	83 e5       	ldi	r24, 0x53	; 83
    259e:	90 e0       	ldi	r25, 0x00	; 0
    25a0:	23 e5       	ldi	r18, 0x53	; 83
    25a2:	30 e0       	ldi	r19, 0x00	; 0
    25a4:	f9 01       	movw	r30, r18
    25a6:	20 81       	ld	r18, Z
    25a8:	21 60       	ori	r18, 0x01	; 1
    25aa:	fc 01       	movw	r30, r24
    25ac:	20 83       	st	Z, r18

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
	sleep_bod_disable();
#endif

	portEXIT_CRITICAL();
    25ae:	0f 90       	pop	r0
    25b0:	0f be       	out	0x3f, r0	; 63
	sleep_cpu();		// good night.
    25b2:	88 95       	sleep

	// Uhh. I was woken up, so now disable sleep_mode.
	sleep_disable();
    25b4:	83 e5       	ldi	r24, 0x53	; 83
    25b6:	90 e0       	ldi	r25, 0x00	; 0
    25b8:	23 e5       	ldi	r18, 0x53	; 83
    25ba:	30 e0       	ldi	r19, 0x00	; 0
    25bc:	f9 01       	movw	r30, r18
    25be:	20 81       	ld	r18, Z
    25c0:	2e 7f       	andi	r18, 0xFE	; 254
    25c2:	fc 01       	movw	r30, r24
    25c4:	20 83       	st	Z, r18
}
    25c6:	df 91       	pop	r29
    25c8:	cf 91       	pop	r28
    25ca:	08 95       	ret

000025cc <vApplicationMallocFailedHook>:
#if defined( configUSE_MALLOC_FAILED_HOOK)

void vApplicationMallocFailedHook( void ) __attribute__((weak));

void vApplicationMallocFailedHook( void )
{
    25cc:	cf 93       	push	r28
    25ce:	df 93       	push	r29
    25d0:	cd b7       	in	r28, 0x3d	; 61
    25d2:	de b7       	in	r29, 0x3e	; 62
    25d4:	2e 97       	sbiw	r28, 0x0e	; 14
    25d6:	0f b6       	in	r0, 0x3f	; 63
    25d8:	f8 94       	cli
    25da:	de bf       	out	0x3e, r29	; 62
    25dc:	0f be       	out	0x3f, r0	; 63
    25de:	cd bf       	out	0x3d, r28	; 61
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DDRB  |= _BV(DDB7);
    25e0:	84 e2       	ldi	r24, 0x24	; 36
    25e2:	90 e0       	ldi	r25, 0x00	; 0
    25e4:	24 e2       	ldi	r18, 0x24	; 36
    25e6:	30 e0       	ldi	r19, 0x00	; 0
    25e8:	f9 01       	movw	r30, r18
    25ea:	20 81       	ld	r18, Z
    25ec:	20 68       	ori	r18, 0x80	; 128
    25ee:	fc 01       	movw	r30, r24
    25f0:	20 83       	st	Z, r18
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    25f2:	85 e2       	ldi	r24, 0x25	; 37
    25f4:	90 e0       	ldi	r25, 0x00	; 0
    25f6:	25 e2       	ldi	r18, 0x25	; 37
    25f8:	30 e0       	ldi	r19, 0x00	; 0
    25fa:	f9 01       	movw	r30, r18
    25fc:	20 81       	ld	r18, Z
    25fe:	20 68       	ori	r18, 0x80	; 128
    2600:	fc 01       	movw	r30, r24
    2602:	20 83       	st	Z, r18
    2604:	80 e0       	ldi	r24, 0x00	; 0
    2606:	90 e0       	ldi	r25, 0x00	; 0
    2608:	a8 e4       	ldi	r26, 0x48	; 72
    260a:	b2 e4       	ldi	r27, 0x42	; 66
    260c:	89 83       	std	Y+1, r24	; 0x01
    260e:	9a 83       	std	Y+2, r25	; 0x02
    2610:	ab 83       	std	Y+3, r26	; 0x03
    2612:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    2614:	20 e0       	ldi	r18, 0x00	; 0
    2616:	30 e0       	ldi	r19, 0x00	; 0
    2618:	4a e7       	ldi	r20, 0x7A	; 122
    261a:	55 e4       	ldi	r21, 0x45	; 69
    261c:	69 81       	ldd	r22, Y+1	; 0x01
    261e:	7a 81       	ldd	r23, Y+2	; 0x02
    2620:	8b 81       	ldd	r24, Y+3	; 0x03
    2622:	9c 81       	ldd	r25, Y+4	; 0x04
    2624:	0e 94 6d 33 	call	0x66da	; 0x66da <__mulsf3>
    2628:	dc 01       	movw	r26, r24
    262a:	cb 01       	movw	r24, r22
    262c:	8d 83       	std	Y+5, r24	; 0x05
    262e:	9e 83       	std	Y+6, r25	; 0x06
    2630:	af 83       	std	Y+7, r26	; 0x07
    2632:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    2634:	20 e0       	ldi	r18, 0x00	; 0
    2636:	30 e0       	ldi	r19, 0x00	; 0
    2638:	40 e8       	ldi	r20, 0x80	; 128
    263a:	5f e3       	ldi	r21, 0x3F	; 63
    263c:	6d 81       	ldd	r22, Y+5	; 0x05
    263e:	7e 81       	ldd	r23, Y+6	; 0x06
    2640:	8f 81       	ldd	r24, Y+7	; 0x07
    2642:	98 85       	ldd	r25, Y+8	; 0x08
    2644:	0e 94 e1 31 	call	0x63c2	; 0x63c2 <__cmpsf2>
    2648:	88 23       	and	r24, r24
    264a:	2c f4       	brge	.+10     	; 0x2656 <vApplicationMallocFailedHook+0x8a>
		__ticks = 1;
    264c:	81 e0       	ldi	r24, 0x01	; 1
    264e:	90 e0       	ldi	r25, 0x00	; 0
    2650:	9a 87       	std	Y+10, r25	; 0x0a
    2652:	89 87       	std	Y+9, r24	; 0x09
    2654:	3f c0       	rjmp	.+126    	; 0x26d4 <vApplicationMallocFailedHook+0x108>
	else if (__tmp > 65535)
    2656:	20 e0       	ldi	r18, 0x00	; 0
    2658:	3f ef       	ldi	r19, 0xFF	; 255
    265a:	4f e7       	ldi	r20, 0x7F	; 127
    265c:	57 e4       	ldi	r21, 0x47	; 71
    265e:	6d 81       	ldd	r22, Y+5	; 0x05
    2660:	7e 81       	ldd	r23, Y+6	; 0x06
    2662:	8f 81       	ldd	r24, Y+7	; 0x07
    2664:	98 85       	ldd	r25, Y+8	; 0x08
    2666:	0e 94 60 33 	call	0x66c0	; 0x66c0 <__gesf2>
    266a:	18 16       	cp	r1, r24
    266c:	4c f5       	brge	.+82     	; 0x26c0 <vApplicationMallocFailedHook+0xf4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    266e:	20 e0       	ldi	r18, 0x00	; 0
    2670:	30 e0       	ldi	r19, 0x00	; 0
    2672:	40 e2       	ldi	r20, 0x20	; 32
    2674:	51 e4       	ldi	r21, 0x41	; 65
    2676:	69 81       	ldd	r22, Y+1	; 0x01
    2678:	7a 81       	ldd	r23, Y+2	; 0x02
    267a:	8b 81       	ldd	r24, Y+3	; 0x03
    267c:	9c 81       	ldd	r25, Y+4	; 0x04
    267e:	0e 94 6d 33 	call	0x66da	; 0x66da <__mulsf3>
    2682:	dc 01       	movw	r26, r24
    2684:	cb 01       	movw	r24, r22
    2686:	bc 01       	movw	r22, r24
    2688:	cd 01       	movw	r24, r26
    268a:	0e 94 58 32 	call	0x64b0	; 0x64b0 <__fixunssfsi>
    268e:	dc 01       	movw	r26, r24
    2690:	cb 01       	movw	r24, r22
    2692:	9a 87       	std	Y+10, r25	; 0x0a
    2694:	89 87       	std	Y+9, r24	; 0x09
    2696:	0f c0       	rjmp	.+30     	; 0x26b6 <vApplicationMallocFailedHook+0xea>
    2698:	80 e9       	ldi	r24, 0x90	; 144
    269a:	91 e0       	ldi	r25, 0x01	; 1
    269c:	9c 87       	std	Y+12, r25	; 0x0c
    269e:	8b 87       	std	Y+11, r24	; 0x0b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    26a0:	8b 85       	ldd	r24, Y+11	; 0x0b
    26a2:	9c 85       	ldd	r25, Y+12	; 0x0c
    26a4:	01 97       	sbiw	r24, 0x01	; 1
    26a6:	f1 f7       	brne	.-4      	; 0x26a4 <vApplicationMallocFailedHook+0xd8>
    26a8:	9c 87       	std	Y+12, r25	; 0x0c
    26aa:	8b 87       	std	Y+11, r24	; 0x0b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    26ac:	89 85       	ldd	r24, Y+9	; 0x09
    26ae:	9a 85       	ldd	r25, Y+10	; 0x0a
    26b0:	01 97       	sbiw	r24, 0x01	; 1
    26b2:	9a 87       	std	Y+10, r25	; 0x0a
    26b4:	89 87       	std	Y+9, r24	; 0x09
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    26b6:	89 85       	ldd	r24, Y+9	; 0x09
    26b8:	9a 85       	ldd	r25, Y+10	; 0x0a
    26ba:	89 2b       	or	r24, r25
    26bc:	69 f7       	brne	.-38     	; 0x2698 <vApplicationMallocFailedHook+0xcc>
    26be:	14 c0       	rjmp	.+40     	; 0x26e8 <vApplicationMallocFailedHook+0x11c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    26c0:	6d 81       	ldd	r22, Y+5	; 0x05
    26c2:	7e 81       	ldd	r23, Y+6	; 0x06
    26c4:	8f 81       	ldd	r24, Y+7	; 0x07
    26c6:	98 85       	ldd	r25, Y+8	; 0x08
    26c8:	0e 94 58 32 	call	0x64b0	; 0x64b0 <__fixunssfsi>
    26cc:	dc 01       	movw	r26, r24
    26ce:	cb 01       	movw	r24, r22
    26d0:	9a 87       	std	Y+10, r25	; 0x0a
    26d2:	89 87       	std	Y+9, r24	; 0x09
    26d4:	89 85       	ldd	r24, Y+9	; 0x09
    26d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    26d8:	9e 87       	std	Y+14, r25	; 0x0e
    26da:	8d 87       	std	Y+13, r24	; 0x0d
    26dc:	8d 85       	ldd	r24, Y+13	; 0x0d
    26de:	9e 85       	ldd	r25, Y+14	; 0x0e
    26e0:	01 97       	sbiw	r24, 0x01	; 1
    26e2:	f1 f7       	brne	.-4      	; 0x26e0 <vApplicationMallocFailedHook+0x114>
    26e4:	9e 87       	std	Y+14, r25	; 0x0e
    26e6:	8d 87       	std	Y+13, r24	; 0x0d

	for(;;)
	{
		_delay_ms(50);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.
    26e8:	83 e2       	ldi	r24, 0x23	; 35
    26ea:	90 e0       	ldi	r25, 0x00	; 0
    26ec:	23 e2       	ldi	r18, 0x23	; 35
    26ee:	30 e0       	ldi	r19, 0x00	; 0
    26f0:	f9 01       	movw	r30, r18
    26f2:	20 81       	ld	r18, Z
    26f4:	20 68       	ori	r18, 0x80	; 128
    26f6:	fc 01       	movw	r30, r24
    26f8:	20 83       	st	Z, r18
#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
		PINC  |= _BV(PINC7);       // Main (red PC7) LED toggle. Main LED fast blink.

#endif

	}
    26fa:	84 cf       	rjmp	.-248    	; 0x2604 <vApplicationMallocFailedHook+0x38>

000026fc <vApplicationStackOverflowHook>:
#if defined( configCHECK_FOR_STACK_OVERFLOW )

void vApplicationStackOverflowHook( TaskHandle_t xTask, portCHAR *pcTaskName ) __attribute__((weak));

void vApplicationStackOverflowHook( TaskHandle_t xTask __attribute__((unused)), portCHAR *pcTaskName __attribute__((unused)) )
{
    26fc:	cf 93       	push	r28
    26fe:	df 93       	push	r29
    2700:	cd b7       	in	r28, 0x3d	; 61
    2702:	de b7       	in	r29, 0x3e	; 62
    2704:	62 97       	sbiw	r28, 0x12	; 18
    2706:	0f b6       	in	r0, 0x3f	; 63
    2708:	f8 94       	cli
    270a:	de bf       	out	0x3e, r29	; 62
    270c:	0f be       	out	0x3f, r0	; 63
    270e:	cd bf       	out	0x3d, r28	; 61
    2710:	98 8b       	std	Y+16, r25	; 0x10
    2712:	8f 87       	std	Y+15, r24	; 0x0f
    2714:	7a 8b       	std	Y+18, r23	; 0x12
    2716:	69 8b       	std	Y+17, r22	; 0x11
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Mega with 2560
	DDRB  |= _BV(DDB7);
    2718:	84 e2       	ldi	r24, 0x24	; 36
    271a:	90 e0       	ldi	r25, 0x00	; 0
    271c:	24 e2       	ldi	r18, 0x24	; 36
    271e:	30 e0       	ldi	r19, 0x00	; 0
    2720:	f9 01       	movw	r30, r18
    2722:	20 81       	ld	r18, Z
    2724:	20 68       	ori	r18, 0x80	; 128
    2726:	fc 01       	movw	r30, r24
    2728:	20 83       	st	Z, r18
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    272a:	85 e2       	ldi	r24, 0x25	; 37
    272c:	90 e0       	ldi	r25, 0x00	; 0
    272e:	25 e2       	ldi	r18, 0x25	; 37
    2730:	30 e0       	ldi	r19, 0x00	; 0
    2732:	f9 01       	movw	r30, r18
    2734:	20 81       	ld	r18, Z
    2736:	20 68       	ori	r18, 0x80	; 128
    2738:	fc 01       	movw	r30, r24
    273a:	20 83       	st	Z, r18
    273c:	80 e0       	ldi	r24, 0x00	; 0
    273e:	90 e0       	ldi	r25, 0x00	; 0
    2740:	aa ef       	ldi	r26, 0xFA	; 250
    2742:	b4 e4       	ldi	r27, 0x44	; 68
    2744:	89 83       	std	Y+1, r24	; 0x01
    2746:	9a 83       	std	Y+2, r25	; 0x02
    2748:	ab 83       	std	Y+3, r26	; 0x03
    274a:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    274c:	20 e0       	ldi	r18, 0x00	; 0
    274e:	30 e0       	ldi	r19, 0x00	; 0
    2750:	4a e7       	ldi	r20, 0x7A	; 122
    2752:	55 e4       	ldi	r21, 0x45	; 69
    2754:	69 81       	ldd	r22, Y+1	; 0x01
    2756:	7a 81       	ldd	r23, Y+2	; 0x02
    2758:	8b 81       	ldd	r24, Y+3	; 0x03
    275a:	9c 81       	ldd	r25, Y+4	; 0x04
    275c:	0e 94 6d 33 	call	0x66da	; 0x66da <__mulsf3>
    2760:	dc 01       	movw	r26, r24
    2762:	cb 01       	movw	r24, r22
    2764:	8d 83       	std	Y+5, r24	; 0x05
    2766:	9e 83       	std	Y+6, r25	; 0x06
    2768:	af 83       	std	Y+7, r26	; 0x07
    276a:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    276c:	20 e0       	ldi	r18, 0x00	; 0
    276e:	30 e0       	ldi	r19, 0x00	; 0
    2770:	40 e8       	ldi	r20, 0x80	; 128
    2772:	5f e3       	ldi	r21, 0x3F	; 63
    2774:	6d 81       	ldd	r22, Y+5	; 0x05
    2776:	7e 81       	ldd	r23, Y+6	; 0x06
    2778:	8f 81       	ldd	r24, Y+7	; 0x07
    277a:	98 85       	ldd	r25, Y+8	; 0x08
    277c:	0e 94 e1 31 	call	0x63c2	; 0x63c2 <__cmpsf2>
    2780:	88 23       	and	r24, r24
    2782:	2c f4       	brge	.+10     	; 0x278e <vApplicationStackOverflowHook+0x92>
		__ticks = 1;
    2784:	81 e0       	ldi	r24, 0x01	; 1
    2786:	90 e0       	ldi	r25, 0x00	; 0
    2788:	9a 87       	std	Y+10, r25	; 0x0a
    278a:	89 87       	std	Y+9, r24	; 0x09
    278c:	3f c0       	rjmp	.+126    	; 0x280c <vApplicationStackOverflowHook+0x110>
	else if (__tmp > 65535)
    278e:	20 e0       	ldi	r18, 0x00	; 0
    2790:	3f ef       	ldi	r19, 0xFF	; 255
    2792:	4f e7       	ldi	r20, 0x7F	; 127
    2794:	57 e4       	ldi	r21, 0x47	; 71
    2796:	6d 81       	ldd	r22, Y+5	; 0x05
    2798:	7e 81       	ldd	r23, Y+6	; 0x06
    279a:	8f 81       	ldd	r24, Y+7	; 0x07
    279c:	98 85       	ldd	r25, Y+8	; 0x08
    279e:	0e 94 60 33 	call	0x66c0	; 0x66c0 <__gesf2>
    27a2:	18 16       	cp	r1, r24
    27a4:	4c f5       	brge	.+82     	; 0x27f8 <vApplicationStackOverflowHook+0xfc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    27a6:	20 e0       	ldi	r18, 0x00	; 0
    27a8:	30 e0       	ldi	r19, 0x00	; 0
    27aa:	40 e2       	ldi	r20, 0x20	; 32
    27ac:	51 e4       	ldi	r21, 0x41	; 65
    27ae:	69 81       	ldd	r22, Y+1	; 0x01
    27b0:	7a 81       	ldd	r23, Y+2	; 0x02
    27b2:	8b 81       	ldd	r24, Y+3	; 0x03
    27b4:	9c 81       	ldd	r25, Y+4	; 0x04
    27b6:	0e 94 6d 33 	call	0x66da	; 0x66da <__mulsf3>
    27ba:	dc 01       	movw	r26, r24
    27bc:	cb 01       	movw	r24, r22
    27be:	bc 01       	movw	r22, r24
    27c0:	cd 01       	movw	r24, r26
    27c2:	0e 94 58 32 	call	0x64b0	; 0x64b0 <__fixunssfsi>
    27c6:	dc 01       	movw	r26, r24
    27c8:	cb 01       	movw	r24, r22
    27ca:	9a 87       	std	Y+10, r25	; 0x0a
    27cc:	89 87       	std	Y+9, r24	; 0x09
    27ce:	0f c0       	rjmp	.+30     	; 0x27ee <vApplicationStackOverflowHook+0xf2>
    27d0:	80 e9       	ldi	r24, 0x90	; 144
    27d2:	91 e0       	ldi	r25, 0x01	; 1
    27d4:	9c 87       	std	Y+12, r25	; 0x0c
    27d6:	8b 87       	std	Y+11, r24	; 0x0b
    27d8:	8b 85       	ldd	r24, Y+11	; 0x0b
    27da:	9c 85       	ldd	r25, Y+12	; 0x0c
    27dc:	01 97       	sbiw	r24, 0x01	; 1
    27de:	f1 f7       	brne	.-4      	; 0x27dc <vApplicationStackOverflowHook+0xe0>
    27e0:	9c 87       	std	Y+12, r25	; 0x0c
    27e2:	8b 87       	std	Y+11, r24	; 0x0b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    27e4:	89 85       	ldd	r24, Y+9	; 0x09
    27e6:	9a 85       	ldd	r25, Y+10	; 0x0a
    27e8:	01 97       	sbiw	r24, 0x01	; 1
    27ea:	9a 87       	std	Y+10, r25	; 0x0a
    27ec:	89 87       	std	Y+9, r24	; 0x09
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    27ee:	89 85       	ldd	r24, Y+9	; 0x09
    27f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    27f2:	89 2b       	or	r24, r25
    27f4:	69 f7       	brne	.-38     	; 0x27d0 <vApplicationStackOverflowHook+0xd4>
    27f6:	14 c0       	rjmp	.+40     	; 0x2820 <vApplicationStackOverflowHook+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    27f8:	6d 81       	ldd	r22, Y+5	; 0x05
    27fa:	7e 81       	ldd	r23, Y+6	; 0x06
    27fc:	8f 81       	ldd	r24, Y+7	; 0x07
    27fe:	98 85       	ldd	r25, Y+8	; 0x08
    2800:	0e 94 58 32 	call	0x64b0	; 0x64b0 <__fixunssfsi>
    2804:	dc 01       	movw	r26, r24
    2806:	cb 01       	movw	r24, r22
    2808:	9a 87       	std	Y+10, r25	; 0x0a
    280a:	89 87       	std	Y+9, r24	; 0x09
    280c:	89 85       	ldd	r24, Y+9	; 0x09
    280e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2810:	9e 87       	std	Y+14, r25	; 0x0e
    2812:	8d 87       	std	Y+13, r24	; 0x0d
    2814:	8d 85       	ldd	r24, Y+13	; 0x0d
    2816:	9e 85       	ldd	r25, Y+14	; 0x0e
    2818:	01 97       	sbiw	r24, 0x01	; 1
    281a:	f1 f7       	brne	.-4      	; 0x2818 <vApplicationStackOverflowHook+0x11c>
    281c:	9e 87       	std	Y+14, r25	; 0x0e
    281e:	8d 87       	std	Y+13, r24	; 0x0d

	for(;;)
	{
		_delay_ms(2000);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    2820:	83 e2       	ldi	r24, 0x23	; 35
    2822:	90 e0       	ldi	r25, 0x00	; 0
    2824:	23 e2       	ldi	r18, 0x23	; 35
    2826:	30 e0       	ldi	r19, 0x00	; 0
    2828:	f9 01       	movw	r30, r18
    282a:	20 81       	ld	r18, Z
    282c:	20 68       	ori	r18, 0x80	; 128
    282e:	fc 01       	movw	r30, r24
    2830:	20 83       	st	Z, r18
#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
		PINC  |= _BV(PINC7);       // Main (red PC7) LED toggle. Main LED slow blink.

#endif

	}
    2832:	84 cf       	rjmp	.-248    	; 0x273c <vApplicationStackOverflowHook+0x40>

00002834 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2834:	cf 93       	push	r28
    2836:	df 93       	push	r29
    2838:	1f 92       	push	r1
    283a:	1f 92       	push	r1
    283c:	cd b7       	in	r28, 0x3d	; 61
    283e:	de b7       	in	r29, 0x3e	; 62
    2840:	9a 83       	std	Y+2, r25	; 0x02
    2842:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2844:	89 81       	ldd	r24, Y+1	; 0x01
    2846:	9a 81       	ldd	r25, Y+2	; 0x02
    2848:	9c 01       	movw	r18, r24
    284a:	2d 5f       	subi	r18, 0xFD	; 253
    284c:	3f 4f       	sbci	r19, 0xFF	; 255
    284e:	89 81       	ldd	r24, Y+1	; 0x01
    2850:	9a 81       	ldd	r25, Y+2	; 0x02
    2852:	fc 01       	movw	r30, r24
    2854:	32 83       	std	Z+2, r19	; 0x02
    2856:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2858:	89 81       	ldd	r24, Y+1	; 0x01
    285a:	9a 81       	ldd	r25, Y+2	; 0x02
    285c:	2f ef       	ldi	r18, 0xFF	; 255
    285e:	3f ef       	ldi	r19, 0xFF	; 255
    2860:	fc 01       	movw	r30, r24
    2862:	34 83       	std	Z+4, r19	; 0x04
    2864:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2866:	89 81       	ldd	r24, Y+1	; 0x01
    2868:	9a 81       	ldd	r25, Y+2	; 0x02
    286a:	9c 01       	movw	r18, r24
    286c:	2d 5f       	subi	r18, 0xFD	; 253
    286e:	3f 4f       	sbci	r19, 0xFF	; 255
    2870:	89 81       	ldd	r24, Y+1	; 0x01
    2872:	9a 81       	ldd	r25, Y+2	; 0x02
    2874:	fc 01       	movw	r30, r24
    2876:	36 83       	std	Z+6, r19	; 0x06
    2878:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    287a:	89 81       	ldd	r24, Y+1	; 0x01
    287c:	9a 81       	ldd	r25, Y+2	; 0x02
    287e:	9c 01       	movw	r18, r24
    2880:	2d 5f       	subi	r18, 0xFD	; 253
    2882:	3f 4f       	sbci	r19, 0xFF	; 255
    2884:	89 81       	ldd	r24, Y+1	; 0x01
    2886:	9a 81       	ldd	r25, Y+2	; 0x02
    2888:	fc 01       	movw	r30, r24
    288a:	30 87       	std	Z+8, r19	; 0x08
    288c:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    288e:	89 81       	ldd	r24, Y+1	; 0x01
    2890:	9a 81       	ldd	r25, Y+2	; 0x02
    2892:	fc 01       	movw	r30, r24
    2894:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    2896:	0f 90       	pop	r0
    2898:	0f 90       	pop	r0
    289a:	df 91       	pop	r29
    289c:	cf 91       	pop	r28
    289e:	08 95       	ret

000028a0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    28a0:	cf 93       	push	r28
    28a2:	df 93       	push	r29
    28a4:	1f 92       	push	r1
    28a6:	1f 92       	push	r1
    28a8:	cd b7       	in	r28, 0x3d	; 61
    28aa:	de b7       	in	r29, 0x3e	; 62
    28ac:	9a 83       	std	Y+2, r25	; 0x02
    28ae:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    28b0:	89 81       	ldd	r24, Y+1	; 0x01
    28b2:	9a 81       	ldd	r25, Y+2	; 0x02
    28b4:	fc 01       	movw	r30, r24
    28b6:	11 86       	std	Z+9, r1	; 0x09
    28b8:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    28ba:	0f 90       	pop	r0
    28bc:	0f 90       	pop	r0
    28be:	df 91       	pop	r29
    28c0:	cf 91       	pop	r28
    28c2:	08 95       	ret

000028c4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    28c4:	cf 93       	push	r28
    28c6:	df 93       	push	r29
    28c8:	00 d0       	rcall	.+0      	; 0x28ca <vListInsertEnd+0x6>
    28ca:	00 d0       	rcall	.+0      	; 0x28cc <vListInsertEnd+0x8>
    28cc:	cd b7       	in	r28, 0x3d	; 61
    28ce:	de b7       	in	r29, 0x3e	; 62
    28d0:	9c 83       	std	Y+4, r25	; 0x04
    28d2:	8b 83       	std	Y+3, r24	; 0x03
    28d4:	7e 83       	std	Y+6, r23	; 0x06
    28d6:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    28d8:	8b 81       	ldd	r24, Y+3	; 0x03
    28da:	9c 81       	ldd	r25, Y+4	; 0x04
    28dc:	fc 01       	movw	r30, r24
    28de:	81 81       	ldd	r24, Z+1	; 0x01
    28e0:	92 81       	ldd	r25, Z+2	; 0x02
    28e2:	9a 83       	std	Y+2, r25	; 0x02
    28e4:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    28e6:	8d 81       	ldd	r24, Y+5	; 0x05
    28e8:	9e 81       	ldd	r25, Y+6	; 0x06
    28ea:	29 81       	ldd	r18, Y+1	; 0x01
    28ec:	3a 81       	ldd	r19, Y+2	; 0x02
    28ee:	fc 01       	movw	r30, r24
    28f0:	33 83       	std	Z+3, r19	; 0x03
    28f2:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    28f4:	89 81       	ldd	r24, Y+1	; 0x01
    28f6:	9a 81       	ldd	r25, Y+2	; 0x02
    28f8:	fc 01       	movw	r30, r24
    28fa:	24 81       	ldd	r18, Z+4	; 0x04
    28fc:	35 81       	ldd	r19, Z+5	; 0x05
    28fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2900:	9e 81       	ldd	r25, Y+6	; 0x06
    2902:	fc 01       	movw	r30, r24
    2904:	35 83       	std	Z+5, r19	; 0x05
    2906:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2908:	89 81       	ldd	r24, Y+1	; 0x01
    290a:	9a 81       	ldd	r25, Y+2	; 0x02
    290c:	fc 01       	movw	r30, r24
    290e:	84 81       	ldd	r24, Z+4	; 0x04
    2910:	95 81       	ldd	r25, Z+5	; 0x05
    2912:	2d 81       	ldd	r18, Y+5	; 0x05
    2914:	3e 81       	ldd	r19, Y+6	; 0x06
    2916:	fc 01       	movw	r30, r24
    2918:	33 83       	std	Z+3, r19	; 0x03
    291a:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    291c:	89 81       	ldd	r24, Y+1	; 0x01
    291e:	9a 81       	ldd	r25, Y+2	; 0x02
    2920:	2d 81       	ldd	r18, Y+5	; 0x05
    2922:	3e 81       	ldd	r19, Y+6	; 0x06
    2924:	fc 01       	movw	r30, r24
    2926:	35 83       	std	Z+5, r19	; 0x05
    2928:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    292a:	8d 81       	ldd	r24, Y+5	; 0x05
    292c:	9e 81       	ldd	r25, Y+6	; 0x06
    292e:	2b 81       	ldd	r18, Y+3	; 0x03
    2930:	3c 81       	ldd	r19, Y+4	; 0x04
    2932:	fc 01       	movw	r30, r24
    2934:	31 87       	std	Z+9, r19	; 0x09
    2936:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2938:	8b 81       	ldd	r24, Y+3	; 0x03
    293a:	9c 81       	ldd	r25, Y+4	; 0x04
    293c:	fc 01       	movw	r30, r24
    293e:	80 81       	ld	r24, Z
    2940:	21 e0       	ldi	r18, 0x01	; 1
    2942:	28 0f       	add	r18, r24
    2944:	8b 81       	ldd	r24, Y+3	; 0x03
    2946:	9c 81       	ldd	r25, Y+4	; 0x04
    2948:	fc 01       	movw	r30, r24
    294a:	20 83       	st	Z, r18
}
    294c:	26 96       	adiw	r28, 0x06	; 6
    294e:	0f b6       	in	r0, 0x3f	; 63
    2950:	f8 94       	cli
    2952:	de bf       	out	0x3e, r29	; 62
    2954:	0f be       	out	0x3f, r0	; 63
    2956:	cd bf       	out	0x3d, r28	; 61
    2958:	df 91       	pop	r29
    295a:	cf 91       	pop	r28
    295c:	08 95       	ret

0000295e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    295e:	cf 93       	push	r28
    2960:	df 93       	push	r29
    2962:	cd b7       	in	r28, 0x3d	; 61
    2964:	de b7       	in	r29, 0x3e	; 62
    2966:	28 97       	sbiw	r28, 0x08	; 8
    2968:	0f b6       	in	r0, 0x3f	; 63
    296a:	f8 94       	cli
    296c:	de bf       	out	0x3e, r29	; 62
    296e:	0f be       	out	0x3f, r0	; 63
    2970:	cd bf       	out	0x3d, r28	; 61
    2972:	9e 83       	std	Y+6, r25	; 0x06
    2974:	8d 83       	std	Y+5, r24	; 0x05
    2976:	78 87       	std	Y+8, r23	; 0x08
    2978:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    297a:	8f 81       	ldd	r24, Y+7	; 0x07
    297c:	98 85       	ldd	r25, Y+8	; 0x08
    297e:	fc 01       	movw	r30, r24
    2980:	80 81       	ld	r24, Z
    2982:	91 81       	ldd	r25, Z+1	; 0x01
    2984:	9c 83       	std	Y+4, r25	; 0x04
    2986:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2988:	8b 81       	ldd	r24, Y+3	; 0x03
    298a:	9c 81       	ldd	r25, Y+4	; 0x04
    298c:	01 96       	adiw	r24, 0x01	; 1
    298e:	41 f4       	brne	.+16     	; 0x29a0 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2990:	8d 81       	ldd	r24, Y+5	; 0x05
    2992:	9e 81       	ldd	r25, Y+6	; 0x06
    2994:	fc 01       	movw	r30, r24
    2996:	87 81       	ldd	r24, Z+7	; 0x07
    2998:	90 85       	ldd	r25, Z+8	; 0x08
    299a:	9a 83       	std	Y+2, r25	; 0x02
    299c:	89 83       	std	Y+1, r24	; 0x01
    299e:	1a c0       	rjmp	.+52     	; 0x29d4 <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    29a0:	8d 81       	ldd	r24, Y+5	; 0x05
    29a2:	9e 81       	ldd	r25, Y+6	; 0x06
    29a4:	03 96       	adiw	r24, 0x03	; 3
    29a6:	9a 83       	std	Y+2, r25	; 0x02
    29a8:	89 83       	std	Y+1, r24	; 0x01
    29aa:	07 c0       	rjmp	.+14     	; 0x29ba <vListInsert+0x5c>
    29ac:	89 81       	ldd	r24, Y+1	; 0x01
    29ae:	9a 81       	ldd	r25, Y+2	; 0x02
    29b0:	fc 01       	movw	r30, r24
    29b2:	82 81       	ldd	r24, Z+2	; 0x02
    29b4:	93 81       	ldd	r25, Z+3	; 0x03
    29b6:	9a 83       	std	Y+2, r25	; 0x02
    29b8:	89 83       	std	Y+1, r24	; 0x01
    29ba:	89 81       	ldd	r24, Y+1	; 0x01
    29bc:	9a 81       	ldd	r25, Y+2	; 0x02
    29be:	fc 01       	movw	r30, r24
    29c0:	82 81       	ldd	r24, Z+2	; 0x02
    29c2:	93 81       	ldd	r25, Z+3	; 0x03
    29c4:	fc 01       	movw	r30, r24
    29c6:	20 81       	ld	r18, Z
    29c8:	31 81       	ldd	r19, Z+1	; 0x01
    29ca:	8b 81       	ldd	r24, Y+3	; 0x03
    29cc:	9c 81       	ldd	r25, Y+4	; 0x04
    29ce:	82 17       	cp	r24, r18
    29d0:	93 07       	cpc	r25, r19
    29d2:	60 f7       	brcc	.-40     	; 0x29ac <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    29d4:	89 81       	ldd	r24, Y+1	; 0x01
    29d6:	9a 81       	ldd	r25, Y+2	; 0x02
    29d8:	fc 01       	movw	r30, r24
    29da:	22 81       	ldd	r18, Z+2	; 0x02
    29dc:	33 81       	ldd	r19, Z+3	; 0x03
    29de:	8f 81       	ldd	r24, Y+7	; 0x07
    29e0:	98 85       	ldd	r25, Y+8	; 0x08
    29e2:	fc 01       	movw	r30, r24
    29e4:	33 83       	std	Z+3, r19	; 0x03
    29e6:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    29e8:	8f 81       	ldd	r24, Y+7	; 0x07
    29ea:	98 85       	ldd	r25, Y+8	; 0x08
    29ec:	fc 01       	movw	r30, r24
    29ee:	82 81       	ldd	r24, Z+2	; 0x02
    29f0:	93 81       	ldd	r25, Z+3	; 0x03
    29f2:	2f 81       	ldd	r18, Y+7	; 0x07
    29f4:	38 85       	ldd	r19, Y+8	; 0x08
    29f6:	fc 01       	movw	r30, r24
    29f8:	35 83       	std	Z+5, r19	; 0x05
    29fa:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    29fc:	8f 81       	ldd	r24, Y+7	; 0x07
    29fe:	98 85       	ldd	r25, Y+8	; 0x08
    2a00:	29 81       	ldd	r18, Y+1	; 0x01
    2a02:	3a 81       	ldd	r19, Y+2	; 0x02
    2a04:	fc 01       	movw	r30, r24
    2a06:	35 83       	std	Z+5, r19	; 0x05
    2a08:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2a0a:	89 81       	ldd	r24, Y+1	; 0x01
    2a0c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a0e:	2f 81       	ldd	r18, Y+7	; 0x07
    2a10:	38 85       	ldd	r19, Y+8	; 0x08
    2a12:	fc 01       	movw	r30, r24
    2a14:	33 83       	std	Z+3, r19	; 0x03
    2a16:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2a18:	8f 81       	ldd	r24, Y+7	; 0x07
    2a1a:	98 85       	ldd	r25, Y+8	; 0x08
    2a1c:	2d 81       	ldd	r18, Y+5	; 0x05
    2a1e:	3e 81       	ldd	r19, Y+6	; 0x06
    2a20:	fc 01       	movw	r30, r24
    2a22:	31 87       	std	Z+9, r19	; 0x09
    2a24:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2a26:	8d 81       	ldd	r24, Y+5	; 0x05
    2a28:	9e 81       	ldd	r25, Y+6	; 0x06
    2a2a:	fc 01       	movw	r30, r24
    2a2c:	80 81       	ld	r24, Z
    2a2e:	21 e0       	ldi	r18, 0x01	; 1
    2a30:	28 0f       	add	r18, r24
    2a32:	8d 81       	ldd	r24, Y+5	; 0x05
    2a34:	9e 81       	ldd	r25, Y+6	; 0x06
    2a36:	fc 01       	movw	r30, r24
    2a38:	20 83       	st	Z, r18
}
    2a3a:	28 96       	adiw	r28, 0x08	; 8
    2a3c:	0f b6       	in	r0, 0x3f	; 63
    2a3e:	f8 94       	cli
    2a40:	de bf       	out	0x3e, r29	; 62
    2a42:	0f be       	out	0x3f, r0	; 63
    2a44:	cd bf       	out	0x3d, r28	; 61
    2a46:	df 91       	pop	r29
    2a48:	cf 91       	pop	r28
    2a4a:	08 95       	ret

00002a4c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2a4c:	cf 93       	push	r28
    2a4e:	df 93       	push	r29
    2a50:	00 d0       	rcall	.+0      	; 0x2a52 <uxListRemove+0x6>
    2a52:	1f 92       	push	r1
    2a54:	cd b7       	in	r28, 0x3d	; 61
    2a56:	de b7       	in	r29, 0x3e	; 62
    2a58:	9c 83       	std	Y+4, r25	; 0x04
    2a5a:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    2a5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a60:	fc 01       	movw	r30, r24
    2a62:	80 85       	ldd	r24, Z+8	; 0x08
    2a64:	91 85       	ldd	r25, Z+9	; 0x09
    2a66:	9a 83       	std	Y+2, r25	; 0x02
    2a68:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a6e:	fc 01       	movw	r30, r24
    2a70:	82 81       	ldd	r24, Z+2	; 0x02
    2a72:	93 81       	ldd	r25, Z+3	; 0x03
    2a74:	2b 81       	ldd	r18, Y+3	; 0x03
    2a76:	3c 81       	ldd	r19, Y+4	; 0x04
    2a78:	f9 01       	movw	r30, r18
    2a7a:	24 81       	ldd	r18, Z+4	; 0x04
    2a7c:	35 81       	ldd	r19, Z+5	; 0x05
    2a7e:	fc 01       	movw	r30, r24
    2a80:	35 83       	std	Z+5, r19	; 0x05
    2a82:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2a84:	8b 81       	ldd	r24, Y+3	; 0x03
    2a86:	9c 81       	ldd	r25, Y+4	; 0x04
    2a88:	fc 01       	movw	r30, r24
    2a8a:	84 81       	ldd	r24, Z+4	; 0x04
    2a8c:	95 81       	ldd	r25, Z+5	; 0x05
    2a8e:	2b 81       	ldd	r18, Y+3	; 0x03
    2a90:	3c 81       	ldd	r19, Y+4	; 0x04
    2a92:	f9 01       	movw	r30, r18
    2a94:	22 81       	ldd	r18, Z+2	; 0x02
    2a96:	33 81       	ldd	r19, Z+3	; 0x03
    2a98:	fc 01       	movw	r30, r24
    2a9a:	33 83       	std	Z+3, r19	; 0x03
    2a9c:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2a9e:	89 81       	ldd	r24, Y+1	; 0x01
    2aa0:	9a 81       	ldd	r25, Y+2	; 0x02
    2aa2:	fc 01       	movw	r30, r24
    2aa4:	21 81       	ldd	r18, Z+1	; 0x01
    2aa6:	32 81       	ldd	r19, Z+2	; 0x02
    2aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    2aaa:	9c 81       	ldd	r25, Y+4	; 0x04
    2aac:	28 17       	cp	r18, r24
    2aae:	39 07       	cpc	r19, r25
    2ab0:	51 f4       	brne	.+20     	; 0x2ac6 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2ab2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab6:	fc 01       	movw	r30, r24
    2ab8:	24 81       	ldd	r18, Z+4	; 0x04
    2aba:	35 81       	ldd	r19, Z+5	; 0x05
    2abc:	89 81       	ldd	r24, Y+1	; 0x01
    2abe:	9a 81       	ldd	r25, Y+2	; 0x02
    2ac0:	fc 01       	movw	r30, r24
    2ac2:	32 83       	std	Z+2, r19	; 0x02
    2ac4:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    2ac6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac8:	9c 81       	ldd	r25, Y+4	; 0x04
    2aca:	fc 01       	movw	r30, r24
    2acc:	11 86       	std	Z+9, r1	; 0x09
    2ace:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2ad0:	89 81       	ldd	r24, Y+1	; 0x01
    2ad2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ad4:	fc 01       	movw	r30, r24
    2ad6:	80 81       	ld	r24, Z
    2ad8:	2f ef       	ldi	r18, 0xFF	; 255
    2ada:	28 0f       	add	r18, r24
    2adc:	89 81       	ldd	r24, Y+1	; 0x01
    2ade:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae0:	fc 01       	movw	r30, r24
    2ae2:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    2ae4:	89 81       	ldd	r24, Y+1	; 0x01
    2ae6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae8:	fc 01       	movw	r30, r24
    2aea:	80 81       	ld	r24, Z
}
    2aec:	0f 90       	pop	r0
    2aee:	0f 90       	pop	r0
    2af0:	0f 90       	pop	r0
    2af2:	0f 90       	pop	r0
    2af4:	df 91       	pop	r29
    2af6:	cf 91       	pop	r28
    2af8:	08 95       	ret

00002afa <main>:

/* Main program loop */
int main(void) __attribute__((OS_main));

int main(void)
{
    2afa:	cd b7       	in	r28, 0x3d	; 61
    2afc:	de b7       	in	r29, 0x3e	; 62
	usart_init();
    2afe:	0e 94 9f 01 	call	0x33e	; 0x33e <usart_init>

    xTaskCreate(
    2b02:	a1 2c       	mov	r10, r1
    2b04:	b1 2c       	mov	r11, r1
    2b06:	c1 2c       	mov	r12, r1
    2b08:	d1 2c       	mov	r13, r1
    2b0a:	e1 2c       	mov	r14, r1
    2b0c:	f1 2c       	mov	r15, r1
    2b0e:	03 e0       	ldi	r16, 0x03	; 3
    2b10:	20 e0       	ldi	r18, 0x00	; 0
    2b12:	30 e0       	ldi	r19, 0x00	; 0
    2b14:	40 e0       	ldi	r20, 0x00	; 0
    2b16:	51 e0       	ldi	r21, 0x01	; 1
    2b18:	68 e0       	ldi	r22, 0x08	; 8
    2b1a:	72 e0       	ldi	r23, 0x02	; 2
    2b1c:	8b ed       	ldi	r24, 0xDB	; 219
    2b1e:	95 e1       	ldi	r25, 0x15	; 21
    2b20:	0e 94 8a 20 	call	0x4114	; 0x4114 <xTaskGenericCreate>
		,  NULL
		,  3
		,  NULL ); // */


	vTaskStartScheduler();
    2b24:	0e 94 f6 24 	call	0x49ec	; 0x49ec <vTaskStartScheduler>
    2b28:	80 e0       	ldi	r24, 0x00	; 0
    2b2a:	90 e0       	ldi	r25, 0x00	; 0


}
    2b2c:	08 95       	ret

00002b2e <Led>:

/*-----------------------------------------------------------*/
static void Led(void *pvParameters){
    2b2e:	cf 93       	push	r28
    2b30:	df 93       	push	r29
    2b32:	00 d0       	rcall	.+0      	; 0x2b34 <Led+0x6>
    2b34:	1f 92       	push	r1
    2b36:	cd b7       	in	r28, 0x3d	; 61
    2b38:	de b7       	in	r29, 0x3e	; 62
    2b3a:	9c 83       	std	Y+4, r25	; 0x04
    2b3c:	8b 83       	std	Y+3, r24	; 0x03
    TickType_t xLastWakeTime;
	/* The xLastWakeTime variable needs to be initialised with the current tick
	count.  Note that this is the only time we access this variable.  From this
	point on xLastWakeTime is managed automatically by the vTaskDelayUntil()
	API function. */
	xLastWakeTime = xTaskGetTickCount();
    2b3e:	0e 94 d8 25 	call	0x4bb0	; 0x4bb0 <xTaskGetTickCount>
    2b42:	9a 83       	std	Y+2, r25	; 0x02
    2b44:	89 83       	std	Y+1, r24	; 0x01

	DDRB |= 0xF0;
    2b46:	84 e2       	ldi	r24, 0x24	; 36
    2b48:	90 e0       	ldi	r25, 0x00	; 0
    2b4a:	24 e2       	ldi	r18, 0x24	; 36
    2b4c:	30 e0       	ldi	r19, 0x00	; 0
    2b4e:	f9 01       	movw	r30, r18
    2b50:	20 81       	ld	r18, Z
    2b52:	20 6f       	ori	r18, 0xF0	; 240
    2b54:	fc 01       	movw	r30, r24
    2b56:	20 83       	st	Z, r18

    while(1)
    {
    	sei();
    2b58:	78 94       	sei

		DDRB |= _BV(DDB5);
    2b5a:	84 e2       	ldi	r24, 0x24	; 36
    2b5c:	90 e0       	ldi	r25, 0x00	; 0
    2b5e:	24 e2       	ldi	r18, 0x24	; 36
    2b60:	30 e0       	ldi	r19, 0x00	; 0
    2b62:	f9 01       	movw	r30, r18
    2b64:	20 81       	ld	r18, Z
    2b66:	20 62       	ori	r18, 0x20	; 32
    2b68:	fc 01       	movw	r30, r24
    2b6a:	20 83       	st	Z, r18

		    while(1)
		    {
		    	PORTB |=  _BV(PORTB7);       // main (red PB5) LED on. Arduino LED on
    2b6c:	85 e2       	ldi	r24, 0x25	; 37
    2b6e:	90 e0       	ldi	r25, 0x00	; 0
    2b70:	25 e2       	ldi	r18, 0x25	; 37
    2b72:	30 e0       	ldi	r19, 0x00	; 0
    2b74:	f9 01       	movw	r30, r18
    2b76:	20 81       	ld	r18, Z
    2b78:	20 68       	ori	r18, 0x80	; 128
    2b7a:	fc 01       	movw	r30, r24
    2b7c:	20 83       	st	Z, r18

				vTaskDelayUntil( &xLastWakeTime, ( 1000 / portTICK_PERIOD_MS ) );
    2b7e:	6e e3       	ldi	r22, 0x3E	; 62
    2b80:	70 e0       	ldi	r23, 0x00	; 0
    2b82:	ce 01       	movw	r24, r28
    2b84:	01 96       	adiw	r24, 0x01	; 1
    2b86:	0e 94 cb 21 	call	0x4396	; 0x4396 <vTaskDelayUntil>

				PORTB &= ~_BV(PORTB7);       // main (red PB5) LED off. Arduino LED off
    2b8a:	85 e2       	ldi	r24, 0x25	; 37
    2b8c:	90 e0       	ldi	r25, 0x00	; 0
    2b8e:	25 e2       	ldi	r18, 0x25	; 37
    2b90:	30 e0       	ldi	r19, 0x00	; 0
    2b92:	f9 01       	movw	r30, r18
    2b94:	20 81       	ld	r18, Z
    2b96:	2f 77       	andi	r18, 0x7F	; 127
    2b98:	fc 01       	movw	r30, r24
    2b9a:	20 83       	st	Z, r18

				vTaskDelayUntil( &xLastWakeTime, ( 1000 / portTICK_PERIOD_MS ) );
    2b9c:	6e e3       	ldi	r22, 0x3E	; 62
    2b9e:	70 e0       	ldi	r23, 0x00	; 0
    2ba0:	ce 01       	movw	r24, r28
    2ba2:	01 96       	adiw	r24, 0x01	; 1
    2ba4:	0e 94 cb 21 	call	0x4396	; 0x4396 <vTaskDelayUntil>

				put_float(2.3);
    2ba8:	63 e3       	ldi	r22, 0x33	; 51
    2baa:	73 e3       	ldi	r23, 0x33	; 51
    2bac:	83 e1       	ldi	r24, 0x13	; 19
    2bae:	90 e4       	ldi	r25, 0x40	; 64
    2bb0:	0e 94 4b 02 	call	0x496	; 0x496 <put_float>
		    }
    2bb4:	db cf       	rjmp	.-74     	; 0x2b6c <Led+0x3e>

00002bb6 <LecturaMPU6050>:

    }
}

static void LecturaMPU6050(void *pvParameters) // Main Red LED Flash
{
    2bb6:	0f 93       	push	r16
    2bb8:	1f 93       	push	r17
    2bba:	cf 93       	push	r28
    2bbc:	df 93       	push	r29
    2bbe:	cd b7       	in	r28, 0x3d	; 61
    2bc0:	de b7       	in	r29, 0x3e	; 62
    2bc2:	2c 97       	sbiw	r28, 0x0c	; 12
    2bc4:	0f b6       	in	r0, 0x3f	; 63
    2bc6:	f8 94       	cli
    2bc8:	de bf       	out	0x3e, r29	; 62
    2bca:	0f be       	out	0x3f, r0	; 63
    2bcc:	cd bf       	out	0x3d, r28	; 61
    2bce:	9c 87       	std	Y+12, r25	; 0x0c
    2bd0:	8b 87       	std	Y+11, r24	; 0x0b
    TickType_t xLastWakeTime;
	/* The xLastWakeTime variable needs to be initialised with the current tick
	count.  Note that this is the only time we access this variable.  From this
	point on xLastWakeTime is managed automatically by the vTaskDelayUntil()
	API function. */
	xLastWakeTime = xTaskGetTickCount();
    2bd2:	0e 94 d8 25 	call	0x4bb0	; 0x4bb0 <xTaskGetTickCount>
    2bd6:	9a 83       	std	Y+2, r25	; 0x02
    2bd8:	89 83       	std	Y+1, r24	; 0x01

	DDRB |= 1<<7;
    2bda:	84 e2       	ldi	r24, 0x24	; 36
    2bdc:	90 e0       	ldi	r25, 0x00	; 0
    2bde:	24 e2       	ldi	r18, 0x24	; 36
    2be0:	30 e0       	ldi	r19, 0x00	; 0
    2be2:	f9 01       	movw	r30, r18
    2be4:	20 81       	ld	r18, Z
    2be6:	20 68       	ori	r18, 0x80	; 128
    2be8:	fc 01       	movw	r30, r24
    2bea:	20 83       	st	Z, r18
	PORTB |= 1<<7;
    2bec:	85 e2       	ldi	r24, 0x25	; 37
    2bee:	90 e0       	ldi	r25, 0x00	; 0
    2bf0:	25 e2       	ldi	r18, 0x25	; 37
    2bf2:	30 e0       	ldi	r19, 0x00	; 0
    2bf4:	f9 01       	movw	r30, r18
    2bf6:	20 81       	ld	r18, Z
    2bf8:	20 68       	ori	r18, 0x80	; 128
    2bfa:	fc 01       	movw	r30, r24
    2bfc:	20 83       	st	Z, r18

	//init interrupt
	sei();
    2bfe:	78 94       	sei

	//init mpu6050
	mpu6050_init();
    2c00:	0e 94 20 0c 	call	0x1840	; 0x1840 <mpu6050_init>

	double Roll = 0.0;
    2c04:	1b 82       	std	Y+3, r1	; 0x03
    2c06:	1c 82       	std	Y+4, r1	; 0x04
    2c08:	1d 82       	std	Y+5, r1	; 0x05
    2c0a:	1e 82       	std	Y+6, r1	; 0x06
	double Pitch = 0.0;
    2c0c:	1f 82       	std	Y+7, r1	; 0x07
    2c0e:	18 86       	std	Y+8, r1	; 0x08
    2c10:	19 86       	std	Y+9, r1	; 0x09
    2c12:	1a 86       	std	Y+10, r1	; 0x0a
		//_delay_ms(50);
    	//mpu6050_getRawData(&ax, &ay, &az, &gx, &gy, &gz);
    	//mpu6050_getConvData(&axg, &ayg, &azg, &gxds, &gyds, &gzds);
		//getConvData(&axg, &ayg, &azg, &gxds, &gyds, &gzds);
    	//getTemperature(&temp);
		getAttitudeData(&ax, &ay, &az, &Roll, &Pitch);
    2c14:	9e 01       	movw	r18, r28
    2c16:	29 5f       	subi	r18, 0xF9	; 249
    2c18:	3f 4f       	sbci	r19, 0xFF	; 255
    2c1a:	ce 01       	movw	r24, r28
    2c1c:	03 96       	adiw	r24, 0x03	; 3
    2c1e:	89 01       	movw	r16, r18
    2c20:	9c 01       	movw	r18, r24
    2c22:	4c e1       	ldi	r20, 0x1C	; 28
    2c24:	52 e0       	ldi	r21, 0x02	; 2
    2c26:	6a e1       	ldi	r22, 0x1A	; 26
    2c28:	72 e0       	ldi	r23, 0x02	; 2
    2c2a:	88 e1       	ldi	r24, 0x18	; 24
    2c2c:	92 e0       	ldi	r25, 0x02	; 2
    2c2e:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <getAttitudeData>

		put_float(Roll);
    2c32:	8b 81       	ldd	r24, Y+3	; 0x03
    2c34:	9c 81       	ldd	r25, Y+4	; 0x04
    2c36:	ad 81       	ldd	r26, Y+5	; 0x05
    2c38:	be 81       	ldd	r27, Y+6	; 0x06
    2c3a:	bc 01       	movw	r22, r24
    2c3c:	cd 01       	movw	r24, r26
    2c3e:	0e 94 4b 02 	call	0x496	; 0x496 <put_float>
		put_float(Pitch);
    2c42:	8f 81       	ldd	r24, Y+7	; 0x07
    2c44:	98 85       	ldd	r25, Y+8	; 0x08
    2c46:	a9 85       	ldd	r26, Y+9	; 0x09
    2c48:	ba 85       	ldd	r27, Y+10	; 0x0a
    2c4a:	bc 01       	movw	r22, r24
    2c4c:	cd 01       	movw	r24, r26
    2c4e:	0e 94 4b 02 	call	0x496	; 0x496 <put_float>
		put_string("\n");
    2c52:	80 e1       	ldi	r24, 0x10	; 16
    2c54:	92 e0       	ldi	r25, 0x02	; 2
    2c56:	0e 94 df 01 	call	0x3be	; 0x3be <put_string>

    	// delay 10ms
    	vTaskDelay(10/portTICK_PERIOD_MS);
    2c5a:	80 e0       	ldi	r24, 0x00	; 0
    2c5c:	90 e0       	ldi	r25, 0x00	; 0
    2c5e:	0e 94 44 22 	call	0x4488	; 0x4488 <vTaskDelay>

    }
    2c62:	d8 cf       	rjmp	.-80     	; 0x2c14 <LecturaMPU6050+0x5e>

00002c64 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2c64:	cf 93       	push	r28
    2c66:	df 93       	push	r29
    2c68:	cd b7       	in	r28, 0x3d	; 61
    2c6a:	de b7       	in	r29, 0x3e	; 62
    2c6c:	28 97       	sbiw	r28, 0x08	; 8
    2c6e:	0f b6       	in	r0, 0x3f	; 63
    2c70:	f8 94       	cli
    2c72:	de bf       	out	0x3e, r29	; 62
    2c74:	0f be       	out	0x3f, r0	; 63
    2c76:	cd bf       	out	0x3d, r28	; 61
    2c78:	9c 83       	std	Y+4, r25	; 0x04
    2c7a:	8b 83       	std	Y+3, r24	; 0x03
    2c7c:	7e 83       	std	Y+6, r23	; 0x06
    2c7e:	6d 83       	std	Y+5, r22	; 0x05
    2c80:	58 87       	std	Y+8, r21	; 0x08
    2c82:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2c84:	8b 81       	ldd	r24, Y+3	; 0x03
    2c86:	9c 81       	ldd	r25, Y+4	; 0x04
    2c88:	21 e1       	ldi	r18, 0x11	; 17
    2c8a:	fc 01       	movw	r30, r24
    2c8c:	20 83       	st	Z, r18
	pxTopOfStack--;
    2c8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c90:	9c 81       	ldd	r25, Y+4	; 0x04
    2c92:	01 97       	sbiw	r24, 0x01	; 1
    2c94:	9c 83       	std	Y+4, r25	; 0x04
    2c96:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2c98:	8b 81       	ldd	r24, Y+3	; 0x03
    2c9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c9c:	22 e2       	ldi	r18, 0x22	; 34
    2c9e:	fc 01       	movw	r30, r24
    2ca0:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ca2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ca4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ca6:	01 97       	sbiw	r24, 0x01	; 1
    2ca8:	9c 83       	std	Y+4, r25	; 0x04
    2caa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2cac:	8b 81       	ldd	r24, Y+3	; 0x03
    2cae:	9c 81       	ldd	r25, Y+4	; 0x04
    2cb0:	23 e3       	ldi	r18, 0x33	; 51
    2cb2:	fc 01       	movw	r30, r24
    2cb4:	20 83       	st	Z, r18
	pxTopOfStack--;
    2cb6:	8b 81       	ldd	r24, Y+3	; 0x03
    2cb8:	9c 81       	ldd	r25, Y+4	; 0x04
    2cba:	01 97       	sbiw	r24, 0x01	; 1
    2cbc:	9c 83       	std	Y+4, r25	; 0x04
    2cbe:	8b 83       	std	Y+3, r24	; 0x03
	 * of flash. We do this by using the .lowtext label in the linker script.
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( uint16_t ) pxCode;
    2cc0:	8d 81       	ldd	r24, Y+5	; 0x05
    2cc2:	9e 81       	ldd	r25, Y+6	; 0x06
    2cc4:	9a 83       	std	Y+2, r25	; 0x02
    2cc6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2cc8:	29 81       	ldd	r18, Y+1	; 0x01
    2cca:	8b 81       	ldd	r24, Y+3	; 0x03
    2ccc:	9c 81       	ldd	r25, Y+4	; 0x04
    2cce:	fc 01       	movw	r30, r24
    2cd0:	20 83       	st	Z, r18
	pxTopOfStack--;
    2cd2:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd4:	9c 81       	ldd	r25, Y+4	; 0x04
    2cd6:	01 97       	sbiw	r24, 0x01	; 1
    2cd8:	9c 83       	std	Y+4, r25	; 0x04
    2cda:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2cdc:	89 81       	ldd	r24, Y+1	; 0x01
    2cde:	9a 81       	ldd	r25, Y+2	; 0x02
    2ce0:	89 2f       	mov	r24, r25
    2ce2:	99 27       	eor	r25, r25
    2ce4:	9a 83       	std	Y+2, r25	; 0x02
    2ce6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2ce8:	29 81       	ldd	r18, Y+1	; 0x01
    2cea:	8b 81       	ldd	r24, Y+3	; 0x03
    2cec:	9c 81       	ldd	r25, Y+4	; 0x04
    2cee:	fc 01       	movw	r30, r24
    2cf0:	20 83       	st	Z, r18
	pxTopOfStack--;
    2cf2:	8b 81       	ldd	r24, Y+3	; 0x03
    2cf4:	9c 81       	ldd	r25, Y+4	; 0x04
    2cf6:	01 97       	sbiw	r24, 0x01	; 1
    2cf8:	9c 83       	std	Y+4, r25	; 0x04
    2cfa:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = 0;
    2cfc:	8b 81       	ldd	r24, Y+3	; 0x03
    2cfe:	9c 81       	ldd	r25, Y+4	; 0x04
    2d00:	fc 01       	movw	r30, r24
    2d02:	10 82       	st	Z, r1
	pxTopOfStack--;
    2d04:	8b 81       	ldd	r24, Y+3	; 0x03
    2d06:	9c 81       	ldd	r25, Y+4	; 0x04
    2d08:	01 97       	sbiw	r24, 0x01	; 1
    2d0a:	9c 83       	std	Y+4, r25	; 0x04
    2d0c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d10:	9c 81       	ldd	r25, Y+4	; 0x04
    2d12:	fc 01       	movw	r30, r24
    2d14:	10 82       	st	Z, r1
	pxTopOfStack--;
    2d16:	8b 81       	ldd	r24, Y+3	; 0x03
    2d18:	9c 81       	ldd	r25, Y+4	; 0x04
    2d1a:	01 97       	sbiw	r24, 0x01	; 1
    2d1c:	9c 83       	std	Y+4, r25	; 0x04
    2d1e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2d20:	8b 81       	ldd	r24, Y+3	; 0x03
    2d22:	9c 81       	ldd	r25, Y+4	; 0x04
    2d24:	20 e8       	ldi	r18, 0x80	; 128
    2d26:	fc 01       	movw	r30, r24
    2d28:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d2e:	01 97       	sbiw	r24, 0x01	; 1
    2d30:	9c 83       	std	Y+4, r25	; 0x04
    2d32:	8b 83       	std	Y+3, r24	; 0x03
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* EIND */
    2d34:	8b 81       	ldd	r24, Y+3	; 0x03
    2d36:	9c 81       	ldd	r25, Y+4	; 0x04
    2d38:	fc 01       	movw	r30, r24
    2d3a:	10 82       	st	Z, r1
	pxTopOfStack--;
    2d3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d40:	01 97       	sbiw	r24, 0x01	; 1
    2d42:	9c 83       	std	Y+4, r25	; 0x04
    2d44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x00;	/* RAMPZ */
    2d46:	8b 81       	ldd	r24, Y+3	; 0x03
    2d48:	9c 81       	ldd	r25, Y+4	; 0x04
    2d4a:	fc 01       	movw	r30, r24
    2d4c:	10 82       	st	Z, r1
	pxTopOfStack--;
    2d4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d50:	9c 81       	ldd	r25, Y+4	; 0x04
    2d52:	01 97       	sbiw	r24, 0x01	; 1
    2d54:	9c 83       	std	Y+4, r25	; 0x04
    2d56:	8b 83       	std	Y+3, r24	; 0x03

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2d58:	8b 81       	ldd	r24, Y+3	; 0x03
    2d5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d5c:	fc 01       	movw	r30, r24
    2d5e:	10 82       	st	Z, r1
	pxTopOfStack--;
    2d60:	8b 81       	ldd	r24, Y+3	; 0x03
    2d62:	9c 81       	ldd	r25, Y+4	; 0x04
    2d64:	01 97       	sbiw	r24, 0x01	; 1
    2d66:	9c 83       	std	Y+4, r25	; 0x04
    2d68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2d6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d6e:	22 e0       	ldi	r18, 0x02	; 2
    2d70:	fc 01       	movw	r30, r24
    2d72:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d74:	8b 81       	ldd	r24, Y+3	; 0x03
    2d76:	9c 81       	ldd	r25, Y+4	; 0x04
    2d78:	01 97       	sbiw	r24, 0x01	; 1
    2d7a:	9c 83       	std	Y+4, r25	; 0x04
    2d7c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2d7e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d80:	9c 81       	ldd	r25, Y+4	; 0x04
    2d82:	23 e0       	ldi	r18, 0x03	; 3
    2d84:	fc 01       	movw	r30, r24
    2d86:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d88:	8b 81       	ldd	r24, Y+3	; 0x03
    2d8a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d8c:	01 97       	sbiw	r24, 0x01	; 1
    2d8e:	9c 83       	std	Y+4, r25	; 0x04
    2d90:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2d92:	8b 81       	ldd	r24, Y+3	; 0x03
    2d94:	9c 81       	ldd	r25, Y+4	; 0x04
    2d96:	24 e0       	ldi	r18, 0x04	; 4
    2d98:	fc 01       	movw	r30, r24
    2d9a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2d9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d9e:	9c 81       	ldd	r25, Y+4	; 0x04
    2da0:	01 97       	sbiw	r24, 0x01	; 1
    2da2:	9c 83       	std	Y+4, r25	; 0x04
    2da4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2da6:	8b 81       	ldd	r24, Y+3	; 0x03
    2da8:	9c 81       	ldd	r25, Y+4	; 0x04
    2daa:	25 e0       	ldi	r18, 0x05	; 5
    2dac:	fc 01       	movw	r30, r24
    2dae:	20 83       	st	Z, r18
	pxTopOfStack--;
    2db0:	8b 81       	ldd	r24, Y+3	; 0x03
    2db2:	9c 81       	ldd	r25, Y+4	; 0x04
    2db4:	01 97       	sbiw	r24, 0x01	; 1
    2db6:	9c 83       	std	Y+4, r25	; 0x04
    2db8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2dba:	8b 81       	ldd	r24, Y+3	; 0x03
    2dbc:	9c 81       	ldd	r25, Y+4	; 0x04
    2dbe:	26 e0       	ldi	r18, 0x06	; 6
    2dc0:	fc 01       	movw	r30, r24
    2dc2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2dc4:	8b 81       	ldd	r24, Y+3	; 0x03
    2dc6:	9c 81       	ldd	r25, Y+4	; 0x04
    2dc8:	01 97       	sbiw	r24, 0x01	; 1
    2dca:	9c 83       	std	Y+4, r25	; 0x04
    2dcc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2dce:	8b 81       	ldd	r24, Y+3	; 0x03
    2dd0:	9c 81       	ldd	r25, Y+4	; 0x04
    2dd2:	27 e0       	ldi	r18, 0x07	; 7
    2dd4:	fc 01       	movw	r30, r24
    2dd6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2dd8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dda:	9c 81       	ldd	r25, Y+4	; 0x04
    2ddc:	01 97       	sbiw	r24, 0x01	; 1
    2dde:	9c 83       	std	Y+4, r25	; 0x04
    2de0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2de2:	8b 81       	ldd	r24, Y+3	; 0x03
    2de4:	9c 81       	ldd	r25, Y+4	; 0x04
    2de6:	28 e0       	ldi	r18, 0x08	; 8
    2de8:	fc 01       	movw	r30, r24
    2dea:	20 83       	st	Z, r18
	pxTopOfStack--;
    2dec:	8b 81       	ldd	r24, Y+3	; 0x03
    2dee:	9c 81       	ldd	r25, Y+4	; 0x04
    2df0:	01 97       	sbiw	r24, 0x01	; 1
    2df2:	9c 83       	std	Y+4, r25	; 0x04
    2df4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2df6:	8b 81       	ldd	r24, Y+3	; 0x03
    2df8:	9c 81       	ldd	r25, Y+4	; 0x04
    2dfa:	29 e0       	ldi	r18, 0x09	; 9
    2dfc:	fc 01       	movw	r30, r24
    2dfe:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e00:	8b 81       	ldd	r24, Y+3	; 0x03
    2e02:	9c 81       	ldd	r25, Y+4	; 0x04
    2e04:	01 97       	sbiw	r24, 0x01	; 1
    2e06:	9c 83       	std	Y+4, r25	; 0x04
    2e08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2e0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e0e:	20 e1       	ldi	r18, 0x10	; 16
    2e10:	fc 01       	movw	r30, r24
    2e12:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e14:	8b 81       	ldd	r24, Y+3	; 0x03
    2e16:	9c 81       	ldd	r25, Y+4	; 0x04
    2e18:	01 97       	sbiw	r24, 0x01	; 1
    2e1a:	9c 83       	std	Y+4, r25	; 0x04
    2e1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2e1e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e20:	9c 81       	ldd	r25, Y+4	; 0x04
    2e22:	21 e1       	ldi	r18, 0x11	; 17
    2e24:	fc 01       	movw	r30, r24
    2e26:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e28:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e2c:	01 97       	sbiw	r24, 0x01	; 1
    2e2e:	9c 83       	std	Y+4, r25	; 0x04
    2e30:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2e32:	8b 81       	ldd	r24, Y+3	; 0x03
    2e34:	9c 81       	ldd	r25, Y+4	; 0x04
    2e36:	22 e1       	ldi	r18, 0x12	; 18
    2e38:	fc 01       	movw	r30, r24
    2e3a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e40:	01 97       	sbiw	r24, 0x01	; 1
    2e42:	9c 83       	std	Y+4, r25	; 0x04
    2e44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2e46:	8b 81       	ldd	r24, Y+3	; 0x03
    2e48:	9c 81       	ldd	r25, Y+4	; 0x04
    2e4a:	23 e1       	ldi	r18, 0x13	; 19
    2e4c:	fc 01       	movw	r30, r24
    2e4e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e50:	8b 81       	ldd	r24, Y+3	; 0x03
    2e52:	9c 81       	ldd	r25, Y+4	; 0x04
    2e54:	01 97       	sbiw	r24, 0x01	; 1
    2e56:	9c 83       	std	Y+4, r25	; 0x04
    2e58:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2e5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e5e:	24 e1       	ldi	r18, 0x14	; 20
    2e60:	fc 01       	movw	r30, r24
    2e62:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e64:	8b 81       	ldd	r24, Y+3	; 0x03
    2e66:	9c 81       	ldd	r25, Y+4	; 0x04
    2e68:	01 97       	sbiw	r24, 0x01	; 1
    2e6a:	9c 83       	std	Y+4, r25	; 0x04
    2e6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2e6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e70:	9c 81       	ldd	r25, Y+4	; 0x04
    2e72:	25 e1       	ldi	r18, 0x15	; 21
    2e74:	fc 01       	movw	r30, r24
    2e76:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e78:	8b 81       	ldd	r24, Y+3	; 0x03
    2e7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e7c:	01 97       	sbiw	r24, 0x01	; 1
    2e7e:	9c 83       	std	Y+4, r25	; 0x04
    2e80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2e82:	8b 81       	ldd	r24, Y+3	; 0x03
    2e84:	9c 81       	ldd	r25, Y+4	; 0x04
    2e86:	26 e1       	ldi	r18, 0x16	; 22
    2e88:	fc 01       	movw	r30, r24
    2e8a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2e8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e8e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e90:	01 97       	sbiw	r24, 0x01	; 1
    2e92:	9c 83       	std	Y+4, r25	; 0x04
    2e94:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2e96:	8b 81       	ldd	r24, Y+3	; 0x03
    2e98:	9c 81       	ldd	r25, Y+4	; 0x04
    2e9a:	27 e1       	ldi	r18, 0x17	; 23
    2e9c:	fc 01       	movw	r30, r24
    2e9e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ea4:	01 97       	sbiw	r24, 0x01	; 1
    2ea6:	9c 83       	std	Y+4, r25	; 0x04
    2ea8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2eaa:	8b 81       	ldd	r24, Y+3	; 0x03
    2eac:	9c 81       	ldd	r25, Y+4	; 0x04
    2eae:	28 e1       	ldi	r18, 0x18	; 24
    2eb0:	fc 01       	movw	r30, r24
    2eb2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2eb4:	8b 81       	ldd	r24, Y+3	; 0x03
    2eb6:	9c 81       	ldd	r25, Y+4	; 0x04
    2eb8:	01 97       	sbiw	r24, 0x01	; 1
    2eba:	9c 83       	std	Y+4, r25	; 0x04
    2ebc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ec2:	29 e1       	ldi	r18, 0x19	; 25
    2ec4:	fc 01       	movw	r30, r24
    2ec6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ec8:	8b 81       	ldd	r24, Y+3	; 0x03
    2eca:	9c 81       	ldd	r25, Y+4	; 0x04
    2ecc:	01 97       	sbiw	r24, 0x01	; 1
    2ece:	9c 83       	std	Y+4, r25	; 0x04
    2ed0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2ed2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed6:	20 e2       	ldi	r18, 0x20	; 32
    2ed8:	fc 01       	movw	r30, r24
    2eda:	20 83       	st	Z, r18
	pxTopOfStack--;
    2edc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ede:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee0:	01 97       	sbiw	r24, 0x01	; 1
    2ee2:	9c 83       	std	Y+4, r25	; 0x04
    2ee4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2ee6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ee8:	9c 81       	ldd	r25, Y+4	; 0x04
    2eea:	21 e2       	ldi	r18, 0x21	; 33
    2eec:	fc 01       	movw	r30, r24
    2eee:	20 83       	st	Z, r18
	pxTopOfStack--;
    2ef0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ef2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ef4:	01 97       	sbiw	r24, 0x01	; 1
    2ef6:	9c 83       	std	Y+4, r25	; 0x04
    2ef8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2efa:	8b 81       	ldd	r24, Y+3	; 0x03
    2efc:	9c 81       	ldd	r25, Y+4	; 0x04
    2efe:	22 e2       	ldi	r18, 0x22	; 34
    2f00:	fc 01       	movw	r30, r24
    2f02:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f04:	8b 81       	ldd	r24, Y+3	; 0x03
    2f06:	9c 81       	ldd	r25, Y+4	; 0x04
    2f08:	01 97       	sbiw	r24, 0x01	; 1
    2f0a:	9c 83       	std	Y+4, r25	; 0x04
    2f0c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2f0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f10:	9c 81       	ldd	r25, Y+4	; 0x04
    2f12:	23 e2       	ldi	r18, 0x23	; 35
    2f14:	fc 01       	movw	r30, r24
    2f16:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f18:	8b 81       	ldd	r24, Y+3	; 0x03
    2f1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f1c:	01 97       	sbiw	r24, 0x01	; 1
    2f1e:	9c 83       	std	Y+4, r25	; 0x04
    2f20:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2f22:	8f 81       	ldd	r24, Y+7	; 0x07
    2f24:	98 85       	ldd	r25, Y+8	; 0x08
    2f26:	9a 83       	std	Y+2, r25	; 0x02
    2f28:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2f2a:	29 81       	ldd	r18, Y+1	; 0x01
    2f2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f30:	fc 01       	movw	r30, r24
    2f32:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f34:	8b 81       	ldd	r24, Y+3	; 0x03
    2f36:	9c 81       	ldd	r25, Y+4	; 0x04
    2f38:	01 97       	sbiw	r24, 0x01	; 1
    2f3a:	9c 83       	std	Y+4, r25	; 0x04
    2f3c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2f3e:	89 81       	ldd	r24, Y+1	; 0x01
    2f40:	9a 81       	ldd	r25, Y+2	; 0x02
    2f42:	89 2f       	mov	r24, r25
    2f44:	99 27       	eor	r25, r25
    2f46:	9a 83       	std	Y+2, r25	; 0x02
    2f48:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2f4a:	29 81       	ldd	r18, Y+1	; 0x01
    2f4c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f4e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f50:	fc 01       	movw	r30, r24
    2f52:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f54:	8b 81       	ldd	r24, Y+3	; 0x03
    2f56:	9c 81       	ldd	r25, Y+4	; 0x04
    2f58:	01 97       	sbiw	r24, 0x01	; 1
    2f5a:	9c 83       	std	Y+4, r25	; 0x04
    2f5c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2f5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f60:	9c 81       	ldd	r25, Y+4	; 0x04
    2f62:	26 e2       	ldi	r18, 0x26	; 38
    2f64:	fc 01       	movw	r30, r24
    2f66:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f68:	8b 81       	ldd	r24, Y+3	; 0x03
    2f6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f6c:	01 97       	sbiw	r24, 0x01	; 1
    2f6e:	9c 83       	std	Y+4, r25	; 0x04
    2f70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2f72:	8b 81       	ldd	r24, Y+3	; 0x03
    2f74:	9c 81       	ldd	r25, Y+4	; 0x04
    2f76:	27 e2       	ldi	r18, 0x27	; 39
    2f78:	fc 01       	movw	r30, r24
    2f7a:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f80:	01 97       	sbiw	r24, 0x01	; 1
    2f82:	9c 83       	std	Y+4, r25	; 0x04
    2f84:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2f86:	8b 81       	ldd	r24, Y+3	; 0x03
    2f88:	9c 81       	ldd	r25, Y+4	; 0x04
    2f8a:	28 e2       	ldi	r18, 0x28	; 40
    2f8c:	fc 01       	movw	r30, r24
    2f8e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2f90:	8b 81       	ldd	r24, Y+3	; 0x03
    2f92:	9c 81       	ldd	r25, Y+4	; 0x04
    2f94:	01 97       	sbiw	r24, 0x01	; 1
    2f96:	9c 83       	std	Y+4, r25	; 0x04
    2f98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f9c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f9e:	29 e2       	ldi	r18, 0x29	; 41
    2fa0:	fc 01       	movw	r30, r24
    2fa2:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fa4:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa6:	9c 81       	ldd	r25, Y+4	; 0x04
    2fa8:	01 97       	sbiw	r24, 0x01	; 1
    2faa:	9c 83       	std	Y+4, r25	; 0x04
    2fac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2fae:	8b 81       	ldd	r24, Y+3	; 0x03
    2fb0:	9c 81       	ldd	r25, Y+4	; 0x04
    2fb2:	20 e3       	ldi	r18, 0x30	; 48
    2fb4:	fc 01       	movw	r30, r24
    2fb6:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fb8:	8b 81       	ldd	r24, Y+3	; 0x03
    2fba:	9c 81       	ldd	r25, Y+4	; 0x04
    2fbc:	01 97       	sbiw	r24, 0x01	; 1
    2fbe:	9c 83       	std	Y+4, r25	; 0x04
    2fc0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2fc2:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc4:	9c 81       	ldd	r25, Y+4	; 0x04
    2fc6:	21 e3       	ldi	r18, 0x31	; 49
    2fc8:	fc 01       	movw	r30, r24
    2fca:	20 83       	st	Z, r18
	pxTopOfStack--;
    2fcc:	8b 81       	ldd	r24, Y+3	; 0x03
    2fce:	9c 81       	ldd	r25, Y+4	; 0x04
    2fd0:	01 97       	sbiw	r24, 0x01	; 1
    2fd2:	9c 83       	std	Y+4, r25	; 0x04
    2fd4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2fd6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fd8:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2fda:	28 96       	adiw	r28, 0x08	; 8
    2fdc:	0f b6       	in	r0, 0x3f	; 63
    2fde:	f8 94       	cli
    2fe0:	de bf       	out	0x3e, r29	; 62
    2fe2:	0f be       	out	0x3f, r0	; 63
    2fe4:	cd bf       	out	0x3d, r28	; 61
    2fe6:	df 91       	pop	r29
    2fe8:	cf 91       	pop	r28
    2fea:	08 95       	ret

00002fec <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2fec:	cf 93       	push	r28
    2fee:	df 93       	push	r29
    2ff0:	cd b7       	in	r28, 0x3d	; 61
    2ff2:	de b7       	in	r29, 0x3e	; 62

	/* Setup the relevant timer hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2ff4:	0e 94 07 19 	call	0x320e	; 0x320e <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2ff8:	a0 91 40 02 	lds	r26, 0x0240
    2ffc:	b0 91 41 02 	lds	r27, 0x0241
    3000:	cd 91       	ld	r28, X+
    3002:	cd bf       	out	0x3d, r28	; 61
    3004:	dd 91       	ld	r29, X+
    3006:	de bf       	out	0x3e, r29	; 62
    3008:	ff 91       	pop	r31
    300a:	ef 91       	pop	r30
    300c:	df 91       	pop	r29
    300e:	cf 91       	pop	r28
    3010:	bf 91       	pop	r27
    3012:	af 91       	pop	r26
    3014:	9f 91       	pop	r25
    3016:	8f 91       	pop	r24
    3018:	7f 91       	pop	r23
    301a:	6f 91       	pop	r22
    301c:	5f 91       	pop	r21
    301e:	4f 91       	pop	r20
    3020:	3f 91       	pop	r19
    3022:	2f 91       	pop	r18
    3024:	1f 91       	pop	r17
    3026:	0f 91       	pop	r16
    3028:	ff 90       	pop	r15
    302a:	ef 90       	pop	r14
    302c:	df 90       	pop	r13
    302e:	cf 90       	pop	r12
    3030:	bf 90       	pop	r11
    3032:	af 90       	pop	r10
    3034:	9f 90       	pop	r9
    3036:	8f 90       	pop	r8
    3038:	7f 90       	pop	r7
    303a:	6f 90       	pop	r6
    303c:	5f 90       	pop	r5
    303e:	4f 90       	pop	r4
    3040:	3f 90       	pop	r3
    3042:	2f 90       	pop	r2
    3044:	1f 90       	pop	r1
    3046:	0f 90       	pop	r0
    3048:	0c be       	out	0x3c, r0	; 60
    304a:	0f 90       	pop	r0
    304c:	0b be       	out	0x3b, r0	; 59
    304e:	0f 90       	pop	r0
    3050:	0f be       	out	0x3f, r0	; 63
    3052:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	__asm__ __volatile__ ( "ret" );
    3054:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    3056:	81 e0       	ldi	r24, 0x01	; 1
}
    3058:	df 91       	pop	r29
    305a:	cf 91       	pop	r28
    305c:	08 95       	ret

0000305e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    305e:	cf 93       	push	r28
    3060:	df 93       	push	r29
    3062:	cd b7       	in	r28, 0x3d	; 61
    3064:	de b7       	in	r29, 0x3e	; 62
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    3066:	0f b6       	in	r0, 0x3f	; 63
    3068:	f8 94       	cli
    306a:	a8 95       	wdr
    306c:	80 91 60 00 	lds	r24, 0x0060
    3070:	88 61       	ori	r24, 0x18	; 24
    3072:	80 93 60 00 	sts	0x0060, r24
    3076:	10 92 60 00 	sts	0x0060, r1
    307a:	0f be       	out	0x3f, r0	; 63
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */

	wdt_disable();											// disable Watchdog Timer
}
    307c:	df 91       	pop	r29
    307e:	cf 91       	pop	r28
    3080:	08 95       	ret

00003082 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3082:	0f 92       	push	r0
    3084:	0f b6       	in	r0, 0x3f	; 63
    3086:	f8 94       	cli
    3088:	0f 92       	push	r0
    308a:	0b b6       	in	r0, 0x3b	; 59
    308c:	0f 92       	push	r0
    308e:	0c b6       	in	r0, 0x3c	; 60
    3090:	0f 92       	push	r0
    3092:	1f 92       	push	r1
    3094:	11 24       	eor	r1, r1
    3096:	2f 92       	push	r2
    3098:	3f 92       	push	r3
    309a:	4f 92       	push	r4
    309c:	5f 92       	push	r5
    309e:	6f 92       	push	r6
    30a0:	7f 92       	push	r7
    30a2:	8f 92       	push	r8
    30a4:	9f 92       	push	r9
    30a6:	af 92       	push	r10
    30a8:	bf 92       	push	r11
    30aa:	cf 92       	push	r12
    30ac:	df 92       	push	r13
    30ae:	ef 92       	push	r14
    30b0:	ff 92       	push	r15
    30b2:	0f 93       	push	r16
    30b4:	1f 93       	push	r17
    30b6:	2f 93       	push	r18
    30b8:	3f 93       	push	r19
    30ba:	4f 93       	push	r20
    30bc:	5f 93       	push	r21
    30be:	6f 93       	push	r22
    30c0:	7f 93       	push	r23
    30c2:	8f 93       	push	r24
    30c4:	9f 93       	push	r25
    30c6:	af 93       	push	r26
    30c8:	bf 93       	push	r27
    30ca:	cf 93       	push	r28
    30cc:	df 93       	push	r29
    30ce:	ef 93       	push	r30
    30d0:	ff 93       	push	r31
    30d2:	a0 91 40 02 	lds	r26, 0x0240
    30d6:	b0 91 41 02 	lds	r27, 0x0241
    30da:	0d b6       	in	r0, 0x3d	; 61
    30dc:	0d 92       	st	X+, r0
    30de:	0e b6       	in	r0, 0x3e	; 62
    30e0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    30e2:	0e 94 fb 26 	call	0x4df6	; 0x4df6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    30e6:	a0 91 40 02 	lds	r26, 0x0240
    30ea:	b0 91 41 02 	lds	r27, 0x0241
    30ee:	cd 91       	ld	r28, X+
    30f0:	cd bf       	out	0x3d, r28	; 61
    30f2:	dd 91       	ld	r29, X+
    30f4:	de bf       	out	0x3e, r29	; 62
    30f6:	ff 91       	pop	r31
    30f8:	ef 91       	pop	r30
    30fa:	df 91       	pop	r29
    30fc:	cf 91       	pop	r28
    30fe:	bf 91       	pop	r27
    3100:	af 91       	pop	r26
    3102:	9f 91       	pop	r25
    3104:	8f 91       	pop	r24
    3106:	7f 91       	pop	r23
    3108:	6f 91       	pop	r22
    310a:	5f 91       	pop	r21
    310c:	4f 91       	pop	r20
    310e:	3f 91       	pop	r19
    3110:	2f 91       	pop	r18
    3112:	1f 91       	pop	r17
    3114:	0f 91       	pop	r16
    3116:	ff 90       	pop	r15
    3118:	ef 90       	pop	r14
    311a:	df 90       	pop	r13
    311c:	cf 90       	pop	r12
    311e:	bf 90       	pop	r11
    3120:	af 90       	pop	r10
    3122:	9f 90       	pop	r9
    3124:	8f 90       	pop	r8
    3126:	7f 90       	pop	r7
    3128:	6f 90       	pop	r6
    312a:	5f 90       	pop	r5
    312c:	4f 90       	pop	r4
    312e:	3f 90       	pop	r3
    3130:	2f 90       	pop	r2
    3132:	1f 90       	pop	r1
    3134:	0f 90       	pop	r0
    3136:	0c be       	out	0x3c, r0	; 60
    3138:	0f 90       	pop	r0
    313a:	0b be       	out	0x3b, r0	; 59
    313c:	0f 90       	pop	r0
    313e:	0f be       	out	0x3f, r0	; 63
    3140:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    3142:	08 95       	ret

00003144 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3144:	0f 92       	push	r0
    3146:	0f b6       	in	r0, 0x3f	; 63
    3148:	f8 94       	cli
    314a:	0f 92       	push	r0
    314c:	0b b6       	in	r0, 0x3b	; 59
    314e:	0f 92       	push	r0
    3150:	0c b6       	in	r0, 0x3c	; 60
    3152:	0f 92       	push	r0
    3154:	1f 92       	push	r1
    3156:	11 24       	eor	r1, r1
    3158:	2f 92       	push	r2
    315a:	3f 92       	push	r3
    315c:	4f 92       	push	r4
    315e:	5f 92       	push	r5
    3160:	6f 92       	push	r6
    3162:	7f 92       	push	r7
    3164:	8f 92       	push	r8
    3166:	9f 92       	push	r9
    3168:	af 92       	push	r10
    316a:	bf 92       	push	r11
    316c:	cf 92       	push	r12
    316e:	df 92       	push	r13
    3170:	ef 92       	push	r14
    3172:	ff 92       	push	r15
    3174:	0f 93       	push	r16
    3176:	1f 93       	push	r17
    3178:	2f 93       	push	r18
    317a:	3f 93       	push	r19
    317c:	4f 93       	push	r20
    317e:	5f 93       	push	r21
    3180:	6f 93       	push	r22
    3182:	7f 93       	push	r23
    3184:	8f 93       	push	r24
    3186:	9f 93       	push	r25
    3188:	af 93       	push	r26
    318a:	bf 93       	push	r27
    318c:	cf 93       	push	r28
    318e:	df 93       	push	r29
    3190:	ef 93       	push	r30
    3192:	ff 93       	push	r31
    3194:	a0 91 40 02 	lds	r26, 0x0240
    3198:	b0 91 41 02 	lds	r27, 0x0241
    319c:	0d b6       	in	r0, 0x3d	; 61
    319e:	0d 92       	st	X+, r0
    31a0:	0e b6       	in	r0, 0x3e	; 62
    31a2:	0d 92       	st	X+, r0

	if( xTaskIncrementTick() != pdFALSE )
    31a4:	0e 94 0d 26 	call	0x4c1a	; 0x4c1a <xTaskIncrementTick>
    31a8:	88 23       	and	r24, r24
    31aa:	11 f0       	breq	.+4      	; 0x31b0 <vPortYieldFromTick+0x6c>
	{
		vTaskSwitchContext();
    31ac:	0e 94 fb 26 	call	0x4df6	; 0x4df6 <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
    31b0:	a0 91 40 02 	lds	r26, 0x0240
    31b4:	b0 91 41 02 	lds	r27, 0x0241
    31b8:	cd 91       	ld	r28, X+
    31ba:	cd bf       	out	0x3d, r28	; 61
    31bc:	dd 91       	ld	r29, X+
    31be:	de bf       	out	0x3e, r29	; 62
    31c0:	ff 91       	pop	r31
    31c2:	ef 91       	pop	r30
    31c4:	df 91       	pop	r29
    31c6:	cf 91       	pop	r28
    31c8:	bf 91       	pop	r27
    31ca:	af 91       	pop	r26
    31cc:	9f 91       	pop	r25
    31ce:	8f 91       	pop	r24
    31d0:	7f 91       	pop	r23
    31d2:	6f 91       	pop	r22
    31d4:	5f 91       	pop	r21
    31d6:	4f 91       	pop	r20
    31d8:	3f 91       	pop	r19
    31da:	2f 91       	pop	r18
    31dc:	1f 91       	pop	r17
    31de:	0f 91       	pop	r16
    31e0:	ff 90       	pop	r15
    31e2:	ef 90       	pop	r14
    31e4:	df 90       	pop	r13
    31e6:	cf 90       	pop	r12
    31e8:	bf 90       	pop	r11
    31ea:	af 90       	pop	r10
    31ec:	9f 90       	pop	r9
    31ee:	8f 90       	pop	r8
    31f0:	7f 90       	pop	r7
    31f2:	6f 90       	pop	r6
    31f4:	5f 90       	pop	r5
    31f6:	4f 90       	pop	r4
    31f8:	3f 90       	pop	r3
    31fa:	2f 90       	pop	r2
    31fc:	1f 90       	pop	r1
    31fe:	0f 90       	pop	r0
    3200:	0c be       	out	0x3c, r0	; 60
    3202:	0f 90       	pop	r0
    3204:	0b be       	out	0x3b, r0	; 59
    3206:	0f 90       	pop	r0
    3208:	0f be       	out	0x3f, r0	; 63
    320a:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    320c:	08 95       	ret

0000320e <prvSetupTimerInterrupt>:
}
/*-----------------------------------------------------------*/

//initialize watchdog
void prvSetupTimerInterrupt( void )
{
    320e:	cf 93       	push	r28
    3210:	df 93       	push	r29
    3212:	cd b7       	in	r28, 0x3d	; 61
    3214:	de b7       	in	r29, 0x3e	; 62
	//reset watchdog
	wdt_reset();
    3216:	a8 95       	wdr

	//set up WDT Interrupt (rather than the WDT Reset).
	wdt_interrupt_enable( portUSE_WDTO );
    3218:	88 e1       	ldi	r24, 0x18	; 24
    321a:	90 e0       	ldi	r25, 0x00	; 0
    321c:	20 ec       	ldi	r18, 0xC0	; 192
    321e:	0f b6       	in	r0, 0x3f	; 63
    3220:	f8 94       	cli
    3222:	a8 95       	wdr
    3224:	80 93 60 00 	sts	0x0060, r24
    3228:	0f be       	out	0x3f, r0	; 63
    322a:	20 93 60 00 	sts	0x0060, r18
}
    322e:	df 91       	pop	r29
    3230:	cf 91       	pop	r28
    3232:	08 95       	ret

00003234 <__vector_12>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED)
	{
		vPortYieldFromTick();
    3234:	0e 94 a2 18 	call	0x3144	; 0x3144 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    3238:	18 95       	reti

0000323a <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    323a:	cf 93       	push	r28
    323c:	df 93       	push	r29
    323e:	00 d0       	rcall	.+0      	; 0x3240 <xQueueGenericReset+0x6>
    3240:	1f 92       	push	r1
    3242:	1f 92       	push	r1
    3244:	cd b7       	in	r28, 0x3d	; 61
    3246:	de b7       	in	r29, 0x3e	; 62
    3248:	9c 83       	std	Y+4, r25	; 0x04
    324a:	8b 83       	std	Y+3, r24	; 0x03
    324c:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    324e:	8b 81       	ldd	r24, Y+3	; 0x03
    3250:	9c 81       	ldd	r25, Y+4	; 0x04
    3252:	9a 83       	std	Y+2, r25	; 0x02
    3254:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3256:	0f b6       	in	r0, 0x3f	; 63
    3258:	f8 94       	cli
    325a:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    325c:	89 81       	ldd	r24, Y+1	; 0x01
    325e:	9a 81       	ldd	r25, Y+2	; 0x02
    3260:	fc 01       	movw	r30, r24
    3262:	80 81       	ld	r24, Z
    3264:	91 81       	ldd	r25, Z+1	; 0x01
    3266:	29 81       	ldd	r18, Y+1	; 0x01
    3268:	3a 81       	ldd	r19, Y+2	; 0x02
    326a:	f9 01       	movw	r30, r18
    326c:	23 8d       	ldd	r18, Z+27	; 0x1b
    326e:	42 2f       	mov	r20, r18
    3270:	50 e0       	ldi	r21, 0x00	; 0
    3272:	29 81       	ldd	r18, Y+1	; 0x01
    3274:	3a 81       	ldd	r19, Y+2	; 0x02
    3276:	f9 01       	movw	r30, r18
    3278:	24 8d       	ldd	r18, Z+28	; 0x1c
    327a:	22 2f       	mov	r18, r18
    327c:	30 e0       	ldi	r19, 0x00	; 0
    327e:	42 9f       	mul	r20, r18
    3280:	b0 01       	movw	r22, r0
    3282:	43 9f       	mul	r20, r19
    3284:	70 0d       	add	r23, r0
    3286:	52 9f       	mul	r21, r18
    3288:	70 0d       	add	r23, r0
    328a:	11 24       	eor	r1, r1
    328c:	9b 01       	movw	r18, r22
    328e:	28 0f       	add	r18, r24
    3290:	39 1f       	adc	r19, r25
    3292:	89 81       	ldd	r24, Y+1	; 0x01
    3294:	9a 81       	ldd	r25, Y+2	; 0x02
    3296:	fc 01       	movw	r30, r24
    3298:	33 83       	std	Z+3, r19	; 0x03
    329a:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    329c:	89 81       	ldd	r24, Y+1	; 0x01
    329e:	9a 81       	ldd	r25, Y+2	; 0x02
    32a0:	fc 01       	movw	r30, r24
    32a2:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    32a4:	89 81       	ldd	r24, Y+1	; 0x01
    32a6:	9a 81       	ldd	r25, Y+2	; 0x02
    32a8:	fc 01       	movw	r30, r24
    32aa:	20 81       	ld	r18, Z
    32ac:	31 81       	ldd	r19, Z+1	; 0x01
    32ae:	89 81       	ldd	r24, Y+1	; 0x01
    32b0:	9a 81       	ldd	r25, Y+2	; 0x02
    32b2:	fc 01       	movw	r30, r24
    32b4:	35 83       	std	Z+5, r19	; 0x05
    32b6:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    32b8:	89 81       	ldd	r24, Y+1	; 0x01
    32ba:	9a 81       	ldd	r25, Y+2	; 0x02
    32bc:	fc 01       	movw	r30, r24
    32be:	80 81       	ld	r24, Z
    32c0:	91 81       	ldd	r25, Z+1	; 0x01
    32c2:	29 81       	ldd	r18, Y+1	; 0x01
    32c4:	3a 81       	ldd	r19, Y+2	; 0x02
    32c6:	f9 01       	movw	r30, r18
    32c8:	23 8d       	ldd	r18, Z+27	; 0x1b
    32ca:	22 2f       	mov	r18, r18
    32cc:	30 e0       	ldi	r19, 0x00	; 0
    32ce:	a9 01       	movw	r20, r18
    32d0:	41 50       	subi	r20, 0x01	; 1
    32d2:	51 09       	sbc	r21, r1
    32d4:	29 81       	ldd	r18, Y+1	; 0x01
    32d6:	3a 81       	ldd	r19, Y+2	; 0x02
    32d8:	f9 01       	movw	r30, r18
    32da:	24 8d       	ldd	r18, Z+28	; 0x1c
    32dc:	22 2f       	mov	r18, r18
    32de:	30 e0       	ldi	r19, 0x00	; 0
    32e0:	42 9f       	mul	r20, r18
    32e2:	b0 01       	movw	r22, r0
    32e4:	43 9f       	mul	r20, r19
    32e6:	70 0d       	add	r23, r0
    32e8:	52 9f       	mul	r21, r18
    32ea:	70 0d       	add	r23, r0
    32ec:	11 24       	eor	r1, r1
    32ee:	9b 01       	movw	r18, r22
    32f0:	28 0f       	add	r18, r24
    32f2:	39 1f       	adc	r19, r25
    32f4:	89 81       	ldd	r24, Y+1	; 0x01
    32f6:	9a 81       	ldd	r25, Y+2	; 0x02
    32f8:	fc 01       	movw	r30, r24
    32fa:	37 83       	std	Z+7, r19	; 0x07
    32fc:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    32fe:	89 81       	ldd	r24, Y+1	; 0x01
    3300:	9a 81       	ldd	r25, Y+2	; 0x02
    3302:	2f ef       	ldi	r18, 0xFF	; 255
    3304:	fc 01       	movw	r30, r24
    3306:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    3308:	89 81       	ldd	r24, Y+1	; 0x01
    330a:	9a 81       	ldd	r25, Y+2	; 0x02
    330c:	2f ef       	ldi	r18, 0xFF	; 255
    330e:	fc 01       	movw	r30, r24
    3310:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    3312:	8d 81       	ldd	r24, Y+5	; 0x05
    3314:	88 23       	and	r24, r24
    3316:	81 f4       	brne	.+32     	; 0x3338 <xQueueGenericReset+0xfe>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3318:	89 81       	ldd	r24, Y+1	; 0x01
    331a:	9a 81       	ldd	r25, Y+2	; 0x02
    331c:	fc 01       	movw	r30, r24
    331e:	80 85       	ldd	r24, Z+8	; 0x08
    3320:	88 23       	and	r24, r24
    3322:	a1 f0       	breq	.+40     	; 0x334c <xQueueGenericReset+0x112>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3324:	89 81       	ldd	r24, Y+1	; 0x01
    3326:	9a 81       	ldd	r25, Y+2	; 0x02
    3328:	08 96       	adiw	r24, 0x08	; 8
    332a:	0e 94 20 28 	call	0x5040	; 0x5040 <xTaskRemoveFromEventList>
    332e:	81 30       	cpi	r24, 0x01	; 1
    3330:	69 f4       	brne	.+26     	; 0x334c <xQueueGenericReset+0x112>
				{
					queueYIELD_IF_USING_PREEMPTION();
    3332:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
    3336:	0a c0       	rjmp	.+20     	; 0x334c <xQueueGenericReset+0x112>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    3338:	89 81       	ldd	r24, Y+1	; 0x01
    333a:	9a 81       	ldd	r25, Y+2	; 0x02
    333c:	08 96       	adiw	r24, 0x08	; 8
    333e:	0e 94 1a 14 	call	0x2834	; 0x2834 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    3342:	89 81       	ldd	r24, Y+1	; 0x01
    3344:	9a 81       	ldd	r25, Y+2	; 0x02
    3346:	41 96       	adiw	r24, 0x11	; 17
    3348:	0e 94 1a 14 	call	0x2834	; 0x2834 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    334c:	0f 90       	pop	r0
    334e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    3350:	81 e0       	ldi	r24, 0x01	; 1
}
    3352:	0f 90       	pop	r0
    3354:	0f 90       	pop	r0
    3356:	0f 90       	pop	r0
    3358:	0f 90       	pop	r0
    335a:	0f 90       	pop	r0
    335c:	df 91       	pop	r29
    335e:	cf 91       	pop	r28
    3360:	08 95       	ret

00003362 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    3362:	cf 93       	push	r28
    3364:	df 93       	push	r29
    3366:	cd b7       	in	r28, 0x3d	; 61
    3368:	de b7       	in	r29, 0x3e	; 62
    336a:	29 97       	sbiw	r28, 0x09	; 9
    336c:	0f b6       	in	r0, 0x3f	; 63
    336e:	f8 94       	cli
    3370:	de bf       	out	0x3e, r29	; 62
    3372:	0f be       	out	0x3f, r0	; 63
    3374:	cd bf       	out	0x3d, r28	; 61
    3376:	8f 83       	std	Y+7, r24	; 0x07
    3378:	68 87       	std	Y+8, r22	; 0x08
    337a:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    337c:	1c 82       	std	Y+4, r1	; 0x04
    337e:	1b 82       	std	Y+3, r1	; 0x03
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
    3380:	88 85       	ldd	r24, Y+8	; 0x08
    3382:	88 23       	and	r24, r24
    3384:	19 f4       	brne	.+6      	; 0x338c <xQueueGenericCreate+0x2a>
	{
		/* There is not going to be a queue storage area. */
		xQueueSizeInBytes = ( size_t ) 0;
    3386:	1a 82       	std	Y+2, r1	; 0x02
    3388:	19 82       	std	Y+1, r1	; 0x01
    338a:	11 c0       	rjmp	.+34     	; 0x33ae <xQueueGenericCreate+0x4c>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    338c:	8f 81       	ldd	r24, Y+7	; 0x07
    338e:	28 2f       	mov	r18, r24
    3390:	30 e0       	ldi	r19, 0x00	; 0
    3392:	88 85       	ldd	r24, Y+8	; 0x08
    3394:	88 2f       	mov	r24, r24
    3396:	90 e0       	ldi	r25, 0x00	; 0
    3398:	28 9f       	mul	r18, r24
    339a:	a0 01       	movw	r20, r0
    339c:	29 9f       	mul	r18, r25
    339e:	50 0d       	add	r21, r0
    33a0:	38 9f       	mul	r19, r24
    33a2:	50 0d       	add	r21, r0
    33a4:	11 24       	eor	r1, r1
    33a6:	ca 01       	movw	r24, r20
    33a8:	01 96       	adiw	r24, 0x01	; 1
    33aa:	9a 83       	std	Y+2, r25	; 0x02
    33ac:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    33ae:	89 81       	ldd	r24, Y+1	; 0x01
    33b0:	9a 81       	ldd	r25, Y+2	; 0x02
    33b2:	4f 96       	adiw	r24, 0x1f	; 31
    33b4:	0e 94 63 12 	call	0x24c6	; 0x24c6 <pvPortMalloc>
    33b8:	9e 83       	std	Y+6, r25	; 0x06
    33ba:	8d 83       	std	Y+5, r24	; 0x05

	if( pxNewQueue != NULL )
    33bc:	8d 81       	ldd	r24, Y+5	; 0x05
    33be:	9e 81       	ldd	r25, Y+6	; 0x06
    33c0:	89 2b       	or	r24, r25
    33c2:	41 f1       	breq	.+80     	; 0x3414 <xQueueGenericCreate+0xb2>
	{
		if( uxItemSize == ( UBaseType_t ) 0 )
    33c4:	88 85       	ldd	r24, Y+8	; 0x08
    33c6:	88 23       	and	r24, r24
    33c8:	41 f4       	brne	.+16     	; 0x33da <xQueueGenericCreate+0x78>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    33ca:	8d 81       	ldd	r24, Y+5	; 0x05
    33cc:	9e 81       	ldd	r25, Y+6	; 0x06
    33ce:	2d 81       	ldd	r18, Y+5	; 0x05
    33d0:	3e 81       	ldd	r19, Y+6	; 0x06
    33d2:	fc 01       	movw	r30, r24
    33d4:	31 83       	std	Z+1, r19	; 0x01
    33d6:	20 83       	st	Z, r18
    33d8:	0a c0       	rjmp	.+20     	; 0x33ee <xQueueGenericCreate+0x8c>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
    33da:	8d 81       	ldd	r24, Y+5	; 0x05
    33dc:	9e 81       	ldd	r25, Y+6	; 0x06
    33de:	9c 01       	movw	r18, r24
    33e0:	21 5e       	subi	r18, 0xE1	; 225
    33e2:	3f 4f       	sbci	r19, 0xFF	; 255
    33e4:	8d 81       	ldd	r24, Y+5	; 0x05
    33e6:	9e 81       	ldd	r25, Y+6	; 0x06
    33e8:	fc 01       	movw	r30, r24
    33ea:	31 83       	std	Z+1, r19	; 0x01
    33ec:	20 83       	st	Z, r18
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
    33ee:	8d 81       	ldd	r24, Y+5	; 0x05
    33f0:	9e 81       	ldd	r25, Y+6	; 0x06
    33f2:	2f 81       	ldd	r18, Y+7	; 0x07
    33f4:	fc 01       	movw	r30, r24
    33f6:	23 8f       	std	Z+27, r18	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
    33f8:	8d 81       	ldd	r24, Y+5	; 0x05
    33fa:	9e 81       	ldd	r25, Y+6	; 0x06
    33fc:	28 85       	ldd	r18, Y+8	; 0x08
    33fe:	fc 01       	movw	r30, r24
    3400:	24 8f       	std	Z+28, r18	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    3402:	8d 81       	ldd	r24, Y+5	; 0x05
    3404:	9e 81       	ldd	r25, Y+6	; 0x06
    3406:	61 e0       	ldi	r22, 0x01	; 1
    3408:	0e 94 1d 19 	call	0x323a	; 0x323a <xQueueGenericReset>
			pxNewQueue->pxQueueSetContainer = NULL;
		}
		#endif /* configUSE_QUEUE_SETS */

		traceQUEUE_CREATE( pxNewQueue );
		xReturn = pxNewQueue;
    340c:	8d 81       	ldd	r24, Y+5	; 0x05
    340e:	9e 81       	ldd	r25, Y+6	; 0x06
    3410:	9c 83       	std	Y+4, r25	; 0x04
    3412:	8b 83       	std	Y+3, r24	; 0x03
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    3414:	8b 81       	ldd	r24, Y+3	; 0x03
    3416:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3418:	29 96       	adiw	r28, 0x09	; 9
    341a:	0f b6       	in	r0, 0x3f	; 63
    341c:	f8 94       	cli
    341e:	de bf       	out	0x3e, r29	; 62
    3420:	0f be       	out	0x3f, r0	; 63
    3422:	cd bf       	out	0x3d, r28	; 61
    3424:	df 91       	pop	r29
    3426:	cf 91       	pop	r28
    3428:	08 95       	ret

0000342a <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    342a:	cf 93       	push	r28
    342c:	df 93       	push	r29
    342e:	00 d0       	rcall	.+0      	; 0x3430 <xQueueCreateMutex+0x6>
    3430:	cd b7       	in	r28, 0x3d	; 61
    3432:	de b7       	in	r29, 0x3e	; 62
    3434:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    3436:	8f e1       	ldi	r24, 0x1F	; 31
    3438:	90 e0       	ldi	r25, 0x00	; 0
    343a:	0e 94 63 12 	call	0x24c6	; 0x24c6 <pvPortMalloc>
    343e:	9a 83       	std	Y+2, r25	; 0x02
    3440:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    3442:	89 81       	ldd	r24, Y+1	; 0x01
    3444:	9a 81       	ldd	r25, Y+2	; 0x02
    3446:	89 2b       	or	r24, r25
    3448:	d9 f1       	breq	.+118    	; 0x34c0 <xQueueCreateMutex+0x96>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    344a:	89 81       	ldd	r24, Y+1	; 0x01
    344c:	9a 81       	ldd	r25, Y+2	; 0x02
    344e:	fc 01       	movw	r30, r24
    3450:	13 82       	std	Z+3, r1	; 0x03
    3452:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    3454:	89 81       	ldd	r24, Y+1	; 0x01
    3456:	9a 81       	ldd	r25, Y+2	; 0x02
    3458:	fc 01       	movw	r30, r24
    345a:	11 82       	std	Z+1, r1	; 0x01
    345c:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    345e:	89 81       	ldd	r24, Y+1	; 0x01
    3460:	9a 81       	ldd	r25, Y+2	; 0x02
    3462:	fc 01       	movw	r30, r24
    3464:	15 82       	std	Z+5, r1	; 0x05
    3466:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    3468:	89 81       	ldd	r24, Y+1	; 0x01
    346a:	9a 81       	ldd	r25, Y+2	; 0x02
    346c:	fc 01       	movw	r30, r24
    346e:	17 82       	std	Z+7, r1	; 0x07
    3470:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3472:	89 81       	ldd	r24, Y+1	; 0x01
    3474:	9a 81       	ldd	r25, Y+2	; 0x02
    3476:	fc 01       	movw	r30, r24
    3478:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    347a:	89 81       	ldd	r24, Y+1	; 0x01
    347c:	9a 81       	ldd	r25, Y+2	; 0x02
    347e:	21 e0       	ldi	r18, 0x01	; 1
    3480:	fc 01       	movw	r30, r24
    3482:	23 8f       	std	Z+27, r18	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    3484:	89 81       	ldd	r24, Y+1	; 0x01
    3486:	9a 81       	ldd	r25, Y+2	; 0x02
    3488:	fc 01       	movw	r30, r24
    348a:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    348c:	89 81       	ldd	r24, Y+1	; 0x01
    348e:	9a 81       	ldd	r25, Y+2	; 0x02
    3490:	2f ef       	ldi	r18, 0xFF	; 255
    3492:	fc 01       	movw	r30, r24
    3494:	25 8f       	std	Z+29, r18	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    3496:	89 81       	ldd	r24, Y+1	; 0x01
    3498:	9a 81       	ldd	r25, Y+2	; 0x02
    349a:	2f ef       	ldi	r18, 0xFF	; 255
    349c:	fc 01       	movw	r30, r24
    349e:	26 8f       	std	Z+30, r18	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    34a0:	89 81       	ldd	r24, Y+1	; 0x01
    34a2:	9a 81       	ldd	r25, Y+2	; 0x02
    34a4:	08 96       	adiw	r24, 0x08	; 8
    34a6:	0e 94 1a 14 	call	0x2834	; 0x2834 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    34aa:	89 81       	ldd	r24, Y+1	; 0x01
    34ac:	9a 81       	ldd	r25, Y+2	; 0x02
    34ae:	41 96       	adiw	r24, 0x11	; 17
    34b0:	0e 94 1a 14 	call	0x2834	; 0x2834 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			//( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
			( void ) xQueueGive( pxNewQueue, ( TickType_t ) 0U ); // xxx feilipu adjusted this.
    34b4:	89 81       	ldd	r24, Y+1	; 0x01
    34b6:	9a 81       	ldd	r25, Y+2	; 0x02
    34b8:	60 e0       	ldi	r22, 0x00	; 0
    34ba:	70 e0       	ldi	r23, 0x00	; 0
    34bc:	0e 94 1a 1b 	call	0x3634	; 0x3634 <xQueueGive>
		else
		{
			traceCREATE_MUTEX_FAILED();
		}

		return pxNewQueue;
    34c0:	89 81       	ldd	r24, Y+1	; 0x01
    34c2:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    34c4:	0f 90       	pop	r0
    34c6:	0f 90       	pop	r0
    34c8:	0f 90       	pop	r0
    34ca:	df 91       	pop	r29
    34cc:	cf 91       	pop	r28
    34ce:	08 95       	ret

000034d0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    34d0:	cf 93       	push	r28
    34d2:	df 93       	push	r29
    34d4:	cd b7       	in	r28, 0x3d	; 61
    34d6:	de b7       	in	r29, 0x3e	; 62
    34d8:	2e 97       	sbiw	r28, 0x0e	; 14
    34da:	0f b6       	in	r0, 0x3f	; 63
    34dc:	f8 94       	cli
    34de:	de bf       	out	0x3e, r29	; 62
    34e0:	0f be       	out	0x3f, r0	; 63
    34e2:	cd bf       	out	0x3d, r28	; 61
    34e4:	99 87       	std	Y+9, r25	; 0x09
    34e6:	88 87       	std	Y+8, r24	; 0x08
    34e8:	7b 87       	std	Y+11, r23	; 0x0b
    34ea:	6a 87       	std	Y+10, r22	; 0x0a
    34ec:	5d 87       	std	Y+13, r21	; 0x0d
    34ee:	4c 87       	std	Y+12, r20	; 0x0c
    34f0:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    34f2:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    34f4:	88 85       	ldd	r24, Y+8	; 0x08
    34f6:	99 85       	ldd	r25, Y+9	; 0x09
    34f8:	9b 83       	std	Y+3, r25	; 0x03
    34fa:	8a 83       	std	Y+2, r24	; 0x02
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    34fc:	0f b6       	in	r0, 0x3f	; 63
    34fe:	f8 94       	cli
    3500:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3502:	8a 81       	ldd	r24, Y+2	; 0x02
    3504:	9b 81       	ldd	r25, Y+3	; 0x03
    3506:	fc 01       	movw	r30, r24
    3508:	22 8d       	ldd	r18, Z+26	; 0x1a
    350a:	8a 81       	ldd	r24, Y+2	; 0x02
    350c:	9b 81       	ldd	r25, Y+3	; 0x03
    350e:	fc 01       	movw	r30, r24
    3510:	83 8d       	ldd	r24, Z+27	; 0x1b
    3512:	28 17       	cp	r18, r24
    3514:	18 f0       	brcs	.+6      	; 0x351c <xQueueGenericSend+0x4c>
    3516:	8e 85       	ldd	r24, Y+14	; 0x0e
    3518:	82 30       	cpi	r24, 0x02	; 2
    351a:	11 f5       	brne	.+68     	; 0x3560 <xQueueGenericSend+0x90>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    351c:	2a 85       	ldd	r18, Y+10	; 0x0a
    351e:	3b 85       	ldd	r19, Y+11	; 0x0b
    3520:	8a 81       	ldd	r24, Y+2	; 0x02
    3522:	9b 81       	ldd	r25, Y+3	; 0x03
    3524:	4e 85       	ldd	r20, Y+14	; 0x0e
    3526:	b9 01       	movw	r22, r18
    3528:	0e 94 8f 1e 	call	0x3d1e	; 0x3d1e <prvCopyDataToQueue>
    352c:	8c 83       	std	Y+4, r24	; 0x04
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    352e:	8a 81       	ldd	r24, Y+2	; 0x02
    3530:	9b 81       	ldd	r25, Y+3	; 0x03
    3532:	fc 01       	movw	r30, r24
    3534:	81 89       	ldd	r24, Z+17	; 0x11
    3536:	88 23       	and	r24, r24
    3538:	51 f0       	breq	.+20     	; 0x354e <xQueueGenericSend+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    353a:	8a 81       	ldd	r24, Y+2	; 0x02
    353c:	9b 81       	ldd	r25, Y+3	; 0x03
    353e:	41 96       	adiw	r24, 0x11	; 17
    3540:	0e 94 20 28 	call	0x5040	; 0x5040 <xTaskRemoveFromEventList>
    3544:	81 30       	cpi	r24, 0x01	; 1
    3546:	41 f4       	brne	.+16     	; 0x3558 <xQueueGenericSend+0x88>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    3548:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
    354c:	05 c0       	rjmp	.+10     	; 0x3558 <xQueueGenericSend+0x88>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    354e:	8c 81       	ldd	r24, Y+4	; 0x04
    3550:	88 23       	and	r24, r24
    3552:	11 f0       	breq	.+4      	; 0x3558 <xQueueGenericSend+0x88>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    3554:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    3558:	0f 90       	pop	r0
    355a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    355c:	81 e0       	ldi	r24, 0x01	; 1
    355e:	61 c0       	rjmp	.+194    	; 0x3622 <xQueueGenericSend+0x152>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3560:	8c 85       	ldd	r24, Y+12	; 0x0c
    3562:	9d 85       	ldd	r25, Y+13	; 0x0d
    3564:	89 2b       	or	r24, r25
    3566:	21 f4       	brne	.+8      	; 0x3570 <xQueueGenericSend+0xa0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3568:	0f 90       	pop	r0
    356a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    356c:	80 e0       	ldi	r24, 0x00	; 0
    356e:	59 c0       	rjmp	.+178    	; 0x3622 <xQueueGenericSend+0x152>
				}
				else if( xEntryTimeSet == pdFALSE )
    3570:	89 81       	ldd	r24, Y+1	; 0x01
    3572:	88 23       	and	r24, r24
    3574:	31 f4       	brne	.+12     	; 0x3582 <xQueueGenericSend+0xb2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3576:	ce 01       	movw	r24, r28
    3578:	05 96       	adiw	r24, 0x05	; 5
    357a:	0e 94 f8 28 	call	0x51f0	; 0x51f0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    357e:	81 e0       	ldi	r24, 0x01	; 1
    3580:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3582:	0f 90       	pop	r0
    3584:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3586:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    358a:	0f b6       	in	r0, 0x3f	; 63
    358c:	f8 94       	cli
    358e:	0f 92       	push	r0
    3590:	8a 81       	ldd	r24, Y+2	; 0x02
    3592:	9b 81       	ldd	r25, Y+3	; 0x03
    3594:	fc 01       	movw	r30, r24
    3596:	85 8d       	ldd	r24, Z+29	; 0x1d
    3598:	8f 3f       	cpi	r24, 0xFF	; 255
    359a:	21 f4       	brne	.+8      	; 0x35a4 <xQueueGenericSend+0xd4>
    359c:	8a 81       	ldd	r24, Y+2	; 0x02
    359e:	9b 81       	ldd	r25, Y+3	; 0x03
    35a0:	fc 01       	movw	r30, r24
    35a2:	15 8e       	std	Z+29, r1	; 0x1d
    35a4:	8a 81       	ldd	r24, Y+2	; 0x02
    35a6:	9b 81       	ldd	r25, Y+3	; 0x03
    35a8:	fc 01       	movw	r30, r24
    35aa:	86 8d       	ldd	r24, Z+30	; 0x1e
    35ac:	8f 3f       	cpi	r24, 0xFF	; 255
    35ae:	21 f4       	brne	.+8      	; 0x35b8 <xQueueGenericSend+0xe8>
    35b0:	8a 81       	ldd	r24, Y+2	; 0x02
    35b2:	9b 81       	ldd	r25, Y+3	; 0x03
    35b4:	fc 01       	movw	r30, r24
    35b6:	16 8e       	std	Z+30, r1	; 0x1e
    35b8:	0f 90       	pop	r0
    35ba:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    35bc:	9e 01       	movw	r18, r28
    35be:	24 5f       	subi	r18, 0xF4	; 244
    35c0:	3f 4f       	sbci	r19, 0xFF	; 255
    35c2:	ce 01       	movw	r24, r28
    35c4:	05 96       	adiw	r24, 0x05	; 5
    35c6:	b9 01       	movw	r22, r18
    35c8:	0e 94 14 29 	call	0x5228	; 0x5228 <xTaskCheckForTimeOut>
    35cc:	88 23       	and	r24, r24
    35ce:	01 f5       	brne	.+64     	; 0x3610 <xQueueGenericSend+0x140>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    35d0:	8a 81       	ldd	r24, Y+2	; 0x02
    35d2:	9b 81       	ldd	r25, Y+3	; 0x03
    35d4:	0e 94 4d 20 	call	0x409a	; 0x409a <prvIsQueueFull>
    35d8:	88 23       	and	r24, r24
    35da:	99 f0       	breq	.+38     	; 0x3602 <xQueueGenericSend+0x132>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    35dc:	2c 85       	ldd	r18, Y+12	; 0x0c
    35de:	3d 85       	ldd	r19, Y+13	; 0x0d
    35e0:	8a 81       	ldd	r24, Y+2	; 0x02
    35e2:	9b 81       	ldd	r25, Y+3	; 0x03
    35e4:	08 96       	adiw	r24, 0x08	; 8
    35e6:	b9 01       	movw	r22, r18
    35e8:	0e 94 8a 27 	call	0x4f14	; 0x4f14 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    35ec:	8a 81       	ldd	r24, Y+2	; 0x02
    35ee:	9b 81       	ldd	r25, Y+3	; 0x03
    35f0:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    35f4:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>
    35f8:	88 23       	and	r24, r24
    35fa:	91 f4       	brne	.+36     	; 0x3620 <xQueueGenericSend+0x150>
				{
					portYIELD_WITHIN_API();
    35fc:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
    3600:	0f c0       	rjmp	.+30     	; 0x3620 <xQueueGenericSend+0x150>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3602:	8a 81       	ldd	r24, Y+2	; 0x02
    3604:	9b 81       	ldd	r25, Y+3	; 0x03
    3606:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    360a:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>
    360e:	76 cf       	rjmp	.-276    	; 0x34fc <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3610:	8a 81       	ldd	r24, Y+2	; 0x02
    3612:	9b 81       	ldd	r25, Y+3	; 0x03
    3614:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3618:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    361c:	80 e0       	ldi	r24, 0x00	; 0
    361e:	01 c0       	rjmp	.+2      	; 0x3622 <xQueueGenericSend+0x152>
		}
	}
    3620:	6d cf       	rjmp	.-294    	; 0x34fc <xQueueGenericSend+0x2c>
}
    3622:	2e 96       	adiw	r28, 0x0e	; 14
    3624:	0f b6       	in	r0, 0x3f	; 63
    3626:	f8 94       	cli
    3628:	de bf       	out	0x3e, r29	; 62
    362a:	0f be       	out	0x3f, r0	; 63
    362c:	cd bf       	out	0x3d, r28	; 61
    362e:	df 91       	pop	r29
    3630:	cf 91       	pop	r28
    3632:	08 95       	ret

00003634 <xQueueGive>:
/*-----------------------------------------------------------*/

// xxx feilipu created xQueueGive() to parallel the xQueueGiveFromISR() function, new in v8.2.0
// Seems to work as expected. And has same performance improvement as quoted for xQueueGiveFromISR
BaseType_t xQueueGive( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    3634:	cf 93       	push	r28
    3636:	df 93       	push	r29
    3638:	cd b7       	in	r28, 0x3d	; 61
    363a:	de b7       	in	r29, 0x3e	; 62
    363c:	2b 97       	sbiw	r28, 0x0b	; 11
    363e:	0f b6       	in	r0, 0x3f	; 63
    3640:	f8 94       	cli
    3642:	de bf       	out	0x3e, r29	; 62
    3644:	0f be       	out	0x3f, r0	; 63
    3646:	cd bf       	out	0x3d, r28	; 61
    3648:	99 87       	std	Y+9, r25	; 0x09
    364a:	88 87       	std	Y+8, r24	; 0x08
    364c:	7b 87       	std	Y+11, r23	; 0x0b
    364e:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired = pdFALSE;
    3650:	19 82       	std	Y+1, r1	; 0x01
    3652:	1a 82       	std	Y+2, r1	; 0x02
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3654:	88 85       	ldd	r24, Y+8	; 0x08
    3656:	99 85       	ldd	r25, Y+9	; 0x09
    3658:	9c 83       	std	Y+4, r25	; 0x04
    365a:	8b 83       	std	Y+3, r24	; 0x03
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    365c:	0f b6       	in	r0, 0x3f	; 63
    365e:	f8 94       	cli
    3660:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3662:	8b 81       	ldd	r24, Y+3	; 0x03
    3664:	9c 81       	ldd	r25, Y+4	; 0x04
    3666:	fc 01       	movw	r30, r24
    3668:	22 8d       	ldd	r18, Z+26	; 0x1a
    366a:	8b 81       	ldd	r24, Y+3	; 0x03
    366c:	9c 81       	ldd	r25, Y+4	; 0x04
    366e:	fc 01       	movw	r30, r24
    3670:	83 8d       	ldd	r24, Z+27	; 0x1b
    3672:	28 17       	cp	r18, r24
    3674:	b8 f5       	brcc	.+110    	; 0x36e4 <xQueueGive+0xb0>
			{
				traceQUEUE_SEND( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3676:	8b 81       	ldd	r24, Y+3	; 0x03
    3678:	9c 81       	ldd	r25, Y+4	; 0x04
    367a:	fc 01       	movw	r30, r24
    367c:	80 81       	ld	r24, Z
    367e:	91 81       	ldd	r25, Z+1	; 0x01
    3680:	89 2b       	or	r24, r25
    3682:	69 f4       	brne	.+26     	; 0x369e <xQueueGive+0x6a>
					{
						/* The mutex is no longer being held. */
						xYieldRequired = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    3684:	8b 81       	ldd	r24, Y+3	; 0x03
    3686:	9c 81       	ldd	r25, Y+4	; 0x04
    3688:	fc 01       	movw	r30, r24
    368a:	82 81       	ldd	r24, Z+2	; 0x02
    368c:	93 81       	ldd	r25, Z+3	; 0x03
    368e:	0e 94 88 2c 	call	0x5910	; 0x5910 <xTaskPriorityDisinherit>
    3692:	8a 83       	std	Y+2, r24	; 0x02
						pxQueue->pxMutexHolder = NULL;
    3694:	8b 81       	ldd	r24, Y+3	; 0x03
    3696:	9c 81       	ldd	r25, Y+4	; 0x04
    3698:	fc 01       	movw	r30, r24
    369a:	13 82       	std	Z+3, r1	; 0x03
    369c:	12 82       	std	Z+2, r1	; 0x02
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_MUTEXES */
				
				++( pxQueue->uxMessagesWaiting );
    369e:	8b 81       	ldd	r24, Y+3	; 0x03
    36a0:	9c 81       	ldd	r25, Y+4	; 0x04
    36a2:	fc 01       	movw	r30, r24
    36a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    36a6:	21 e0       	ldi	r18, 0x01	; 1
    36a8:	28 0f       	add	r18, r24
    36aa:	8b 81       	ldd	r24, Y+3	; 0x03
    36ac:	9c 81       	ldd	r25, Y+4	; 0x04
    36ae:	fc 01       	movw	r30, r24
    36b0:	22 8f       	std	Z+26, r18	; 0x1a
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    36b2:	8b 81       	ldd	r24, Y+3	; 0x03
    36b4:	9c 81       	ldd	r25, Y+4	; 0x04
    36b6:	fc 01       	movw	r30, r24
    36b8:	81 89       	ldd	r24, Z+17	; 0x11
    36ba:	88 23       	and	r24, r24
    36bc:	51 f0       	breq	.+20     	; 0x36d2 <xQueueGive+0x9e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    36be:	8b 81       	ldd	r24, Y+3	; 0x03
    36c0:	9c 81       	ldd	r25, Y+4	; 0x04
    36c2:	41 96       	adiw	r24, 0x11	; 17
    36c4:	0e 94 20 28 	call	0x5040	; 0x5040 <xTaskRemoveFromEventList>
    36c8:	81 30       	cpi	r24, 0x01	; 1
    36ca:	41 f4       	brne	.+16     	; 0x36dc <xQueueGive+0xa8>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    36cc:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
    36d0:	05 c0       	rjmp	.+10     	; 0x36dc <xQueueGive+0xa8>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    36d2:	8a 81       	ldd	r24, Y+2	; 0x02
    36d4:	88 23       	and	r24, r24
    36d6:	11 f0       	breq	.+4      	; 0x36dc <xQueueGive+0xa8>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    36d8:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    36dc:	0f 90       	pop	r0
    36de:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    36e0:	81 e0       	ldi	r24, 0x01	; 1
    36e2:	61 c0       	rjmp	.+194    	; 0x37a6 <xQueueGive+0x172>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    36e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    36e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    36e8:	89 2b       	or	r24, r25
    36ea:	21 f4       	brne	.+8      	; 0x36f4 <xQueueGive+0xc0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    36ec:	0f 90       	pop	r0
    36ee:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    36f0:	80 e0       	ldi	r24, 0x00	; 0
    36f2:	59 c0       	rjmp	.+178    	; 0x37a6 <xQueueGive+0x172>
				}
				else if( xEntryTimeSet == pdFALSE )
    36f4:	89 81       	ldd	r24, Y+1	; 0x01
    36f6:	88 23       	and	r24, r24
    36f8:	31 f4       	brne	.+12     	; 0x3706 <xQueueGive+0xd2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    36fa:	ce 01       	movw	r24, r28
    36fc:	05 96       	adiw	r24, 0x05	; 5
    36fe:	0e 94 f8 28 	call	0x51f0	; 0x51f0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3702:	81 e0       	ldi	r24, 0x01	; 1
    3704:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3706:	0f 90       	pop	r0
    3708:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    370a:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    370e:	0f b6       	in	r0, 0x3f	; 63
    3710:	f8 94       	cli
    3712:	0f 92       	push	r0
    3714:	8b 81       	ldd	r24, Y+3	; 0x03
    3716:	9c 81       	ldd	r25, Y+4	; 0x04
    3718:	fc 01       	movw	r30, r24
    371a:	85 8d       	ldd	r24, Z+29	; 0x1d
    371c:	8f 3f       	cpi	r24, 0xFF	; 255
    371e:	21 f4       	brne	.+8      	; 0x3728 <xQueueGive+0xf4>
    3720:	8b 81       	ldd	r24, Y+3	; 0x03
    3722:	9c 81       	ldd	r25, Y+4	; 0x04
    3724:	fc 01       	movw	r30, r24
    3726:	15 8e       	std	Z+29, r1	; 0x1d
    3728:	8b 81       	ldd	r24, Y+3	; 0x03
    372a:	9c 81       	ldd	r25, Y+4	; 0x04
    372c:	fc 01       	movw	r30, r24
    372e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3730:	8f 3f       	cpi	r24, 0xFF	; 255
    3732:	21 f4       	brne	.+8      	; 0x373c <xQueueGive+0x108>
    3734:	8b 81       	ldd	r24, Y+3	; 0x03
    3736:	9c 81       	ldd	r25, Y+4	; 0x04
    3738:	fc 01       	movw	r30, r24
    373a:	16 8e       	std	Z+30, r1	; 0x1e
    373c:	0f 90       	pop	r0
    373e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3740:	9e 01       	movw	r18, r28
    3742:	26 5f       	subi	r18, 0xF6	; 246
    3744:	3f 4f       	sbci	r19, 0xFF	; 255
    3746:	ce 01       	movw	r24, r28
    3748:	05 96       	adiw	r24, 0x05	; 5
    374a:	b9 01       	movw	r22, r18
    374c:	0e 94 14 29 	call	0x5228	; 0x5228 <xTaskCheckForTimeOut>
    3750:	88 23       	and	r24, r24
    3752:	01 f5       	brne	.+64     	; 0x3794 <xQueueGive+0x160>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3754:	8b 81       	ldd	r24, Y+3	; 0x03
    3756:	9c 81       	ldd	r25, Y+4	; 0x04
    3758:	0e 94 4d 20 	call	0x409a	; 0x409a <prvIsQueueFull>
    375c:	88 23       	and	r24, r24
    375e:	99 f0       	breq	.+38     	; 0x3786 <xQueueGive+0x152>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3760:	2a 85       	ldd	r18, Y+10	; 0x0a
    3762:	3b 85       	ldd	r19, Y+11	; 0x0b
    3764:	8b 81       	ldd	r24, Y+3	; 0x03
    3766:	9c 81       	ldd	r25, Y+4	; 0x04
    3768:	08 96       	adiw	r24, 0x08	; 8
    376a:	b9 01       	movw	r22, r18
    376c:	0e 94 8a 27 	call	0x4f14	; 0x4f14 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3770:	8b 81       	ldd	r24, Y+3	; 0x03
    3772:	9c 81       	ldd	r25, Y+4	; 0x04
    3774:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3778:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>
    377c:	88 23       	and	r24, r24
    377e:	91 f4       	brne	.+36     	; 0x37a4 <xQueueGive+0x170>
				{
					portYIELD_WITHIN_API();
    3780:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
    3784:	0f c0       	rjmp	.+30     	; 0x37a4 <xQueueGive+0x170>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3786:	8b 81       	ldd	r24, Y+3	; 0x03
    3788:	9c 81       	ldd	r25, Y+4	; 0x04
    378a:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    378e:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>
    3792:	64 cf       	rjmp	.-312    	; 0x365c <xQueueGive+0x28>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3794:	8b 81       	ldd	r24, Y+3	; 0x03
    3796:	9c 81       	ldd	r25, Y+4	; 0x04
    3798:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    379c:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    37a0:	80 e0       	ldi	r24, 0x00	; 0
    37a2:	01 c0       	rjmp	.+2      	; 0x37a6 <xQueueGive+0x172>
		}
	}
    37a4:	5b cf       	rjmp	.-330    	; 0x365c <xQueueGive+0x28>
}
    37a6:	2b 96       	adiw	r28, 0x0b	; 11
    37a8:	0f b6       	in	r0, 0x3f	; 63
    37aa:	f8 94       	cli
    37ac:	de bf       	out	0x3e, r29	; 62
    37ae:	0f be       	out	0x3f, r0	; 63
    37b0:	cd bf       	out	0x3d, r28	; 61
    37b2:	df 91       	pop	r29
    37b4:	cf 91       	pop	r28
    37b6:	08 95       	ret

000037b8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    37b8:	cf 93       	push	r28
    37ba:	df 93       	push	r29
    37bc:	cd b7       	in	r28, 0x3d	; 61
    37be:	de b7       	in	r29, 0x3e	; 62
    37c0:	2b 97       	sbiw	r28, 0x0b	; 11
    37c2:	0f b6       	in	r0, 0x3f	; 63
    37c4:	f8 94       	cli
    37c6:	de bf       	out	0x3e, r29	; 62
    37c8:	0f be       	out	0x3f, r0	; 63
    37ca:	cd bf       	out	0x3d, r28	; 61
    37cc:	9e 83       	std	Y+6, r25	; 0x06
    37ce:	8d 83       	std	Y+5, r24	; 0x05
    37d0:	78 87       	std	Y+8, r23	; 0x08
    37d2:	6f 83       	std	Y+7, r22	; 0x07
    37d4:	5a 87       	std	Y+10, r21	; 0x0a
    37d6:	49 87       	std	Y+9, r20	; 0x09
    37d8:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    37da:	8d 81       	ldd	r24, Y+5	; 0x05
    37dc:	9e 81       	ldd	r25, Y+6	; 0x06
    37de:	9b 83       	std	Y+3, r25	; 0x03
    37e0:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    37e2:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    37e4:	8a 81       	ldd	r24, Y+2	; 0x02
    37e6:	9b 81       	ldd	r25, Y+3	; 0x03
    37e8:	fc 01       	movw	r30, r24
    37ea:	22 8d       	ldd	r18, Z+26	; 0x1a
    37ec:	8a 81       	ldd	r24, Y+2	; 0x02
    37ee:	9b 81       	ldd	r25, Y+3	; 0x03
    37f0:	fc 01       	movw	r30, r24
    37f2:	83 8d       	ldd	r24, Z+27	; 0x1b
    37f4:	28 17       	cp	r18, r24
    37f6:	18 f0       	brcs	.+6      	; 0x37fe <xQueueGenericSendFromISR+0x46>
    37f8:	8b 85       	ldd	r24, Y+11	; 0x0b
    37fa:	82 30       	cpi	r24, 0x02	; 2
    37fc:	91 f5       	brne	.+100    	; 0x3862 <xQueueGenericSendFromISR+0xaa>
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    37fe:	2f 81       	ldd	r18, Y+7	; 0x07
    3800:	38 85       	ldd	r19, Y+8	; 0x08
    3802:	8a 81       	ldd	r24, Y+2	; 0x02
    3804:	9b 81       	ldd	r25, Y+3	; 0x03
    3806:	4b 85       	ldd	r20, Y+11	; 0x0b
    3808:	b9 01       	movw	r22, r18
    380a:	0e 94 8f 1e 	call	0x3d1e	; 0x3d1e <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    380e:	8a 81       	ldd	r24, Y+2	; 0x02
    3810:	9b 81       	ldd	r25, Y+3	; 0x03
    3812:	fc 01       	movw	r30, r24
    3814:	86 8d       	ldd	r24, Z+30	; 0x1e
    3816:	8f 3f       	cpi	r24, 0xFF	; 255
    3818:	b9 f4       	brne	.+46     	; 0x3848 <xQueueGenericSendFromISR+0x90>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    381a:	8a 81       	ldd	r24, Y+2	; 0x02
    381c:	9b 81       	ldd	r25, Y+3	; 0x03
    381e:	fc 01       	movw	r30, r24
    3820:	81 89       	ldd	r24, Z+17	; 0x11
    3822:	88 23       	and	r24, r24
    3824:	d9 f0       	breq	.+54     	; 0x385c <xQueueGenericSendFromISR+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3826:	8a 81       	ldd	r24, Y+2	; 0x02
    3828:	9b 81       	ldd	r25, Y+3	; 0x03
    382a:	41 96       	adiw	r24, 0x11	; 17
    382c:	0e 94 20 28 	call	0x5040	; 0x5040 <xTaskRemoveFromEventList>
    3830:	88 23       	and	r24, r24
    3832:	a1 f0       	breq	.+40     	; 0x385c <xQueueGenericSendFromISR+0xa4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3834:	89 85       	ldd	r24, Y+9	; 0x09
    3836:	9a 85       	ldd	r25, Y+10	; 0x0a
    3838:	89 2b       	or	r24, r25
    383a:	81 f0       	breq	.+32     	; 0x385c <xQueueGenericSendFromISR+0xa4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    383c:	89 85       	ldd	r24, Y+9	; 0x09
    383e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3840:	21 e0       	ldi	r18, 0x01	; 1
    3842:	fc 01       	movw	r30, r24
    3844:	20 83       	st	Z, r18
    3846:	0a c0       	rjmp	.+20     	; 0x385c <xQueueGenericSendFromISR+0xa4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3848:	8a 81       	ldd	r24, Y+2	; 0x02
    384a:	9b 81       	ldd	r25, Y+3	; 0x03
    384c:	fc 01       	movw	r30, r24
    384e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3850:	8f 5f       	subi	r24, 0xFF	; 255
    3852:	28 2f       	mov	r18, r24
    3854:	8a 81       	ldd	r24, Y+2	; 0x02
    3856:	9b 81       	ldd	r25, Y+3	; 0x03
    3858:	fc 01       	movw	r30, r24
    385a:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    385c:	81 e0       	ldi	r24, 0x01	; 1
    385e:	89 83       	std	Y+1, r24	; 0x01
    3860:	01 c0       	rjmp	.+2      	; 0x3864 <xQueueGenericSendFromISR+0xac>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3862:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3864:	89 81       	ldd	r24, Y+1	; 0x01
}
    3866:	2b 96       	adiw	r28, 0x0b	; 11
    3868:	0f b6       	in	r0, 0x3f	; 63
    386a:	f8 94       	cli
    386c:	de bf       	out	0x3e, r29	; 62
    386e:	0f be       	out	0x3f, r0	; 63
    3870:	cd bf       	out	0x3d, r28	; 61
    3872:	df 91       	pop	r29
    3874:	cf 91       	pop	r28
    3876:	08 95       	ret

00003878 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3878:	cf 93       	push	r28
    387a:	df 93       	push	r29
    387c:	cd b7       	in	r28, 0x3d	; 61
    387e:	de b7       	in	r29, 0x3e	; 62
    3880:	28 97       	sbiw	r28, 0x08	; 8
    3882:	0f b6       	in	r0, 0x3f	; 63
    3884:	f8 94       	cli
    3886:	de bf       	out	0x3e, r29	; 62
    3888:	0f be       	out	0x3f, r0	; 63
    388a:	cd bf       	out	0x3d, r28	; 61
    388c:	9e 83       	std	Y+6, r25	; 0x06
    388e:	8d 83       	std	Y+5, r24	; 0x05
    3890:	78 87       	std	Y+8, r23	; 0x08
    3892:	6f 83       	std	Y+7, r22	; 0x07
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3894:	8d 81       	ldd	r24, Y+5	; 0x05
    3896:	9e 81       	ldd	r25, Y+6	; 0x06
    3898:	9b 83       	std	Y+3, r25	; 0x03
    389a:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    389c:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    389e:	8a 81       	ldd	r24, Y+2	; 0x02
    38a0:	9b 81       	ldd	r25, Y+3	; 0x03
    38a2:	fc 01       	movw	r30, r24
    38a4:	22 8d       	ldd	r18, Z+26	; 0x1a
    38a6:	8a 81       	ldd	r24, Y+2	; 0x02
    38a8:	9b 81       	ldd	r25, Y+3	; 0x03
    38aa:	fc 01       	movw	r30, r24
    38ac:	83 8d       	ldd	r24, Z+27	; 0x1b
    38ae:	28 17       	cp	r18, r24
    38b0:	a0 f5       	brcc	.+104    	; 0x391a <xQueueGiveFromISR+0xa2>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    38b2:	8a 81       	ldd	r24, Y+2	; 0x02
    38b4:	9b 81       	ldd	r25, Y+3	; 0x03
    38b6:	fc 01       	movw	r30, r24
    38b8:	82 8d       	ldd	r24, Z+26	; 0x1a
    38ba:	21 e0       	ldi	r18, 0x01	; 1
    38bc:	28 0f       	add	r18, r24
    38be:	8a 81       	ldd	r24, Y+2	; 0x02
    38c0:	9b 81       	ldd	r25, Y+3	; 0x03
    38c2:	fc 01       	movw	r30, r24
    38c4:	22 8f       	std	Z+26, r18	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    38c6:	8a 81       	ldd	r24, Y+2	; 0x02
    38c8:	9b 81       	ldd	r25, Y+3	; 0x03
    38ca:	fc 01       	movw	r30, r24
    38cc:	86 8d       	ldd	r24, Z+30	; 0x1e
    38ce:	8f 3f       	cpi	r24, 0xFF	; 255
    38d0:	b9 f4       	brne	.+46     	; 0x3900 <xQueueGiveFromISR+0x88>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    38d2:	8a 81       	ldd	r24, Y+2	; 0x02
    38d4:	9b 81       	ldd	r25, Y+3	; 0x03
    38d6:	fc 01       	movw	r30, r24
    38d8:	81 89       	ldd	r24, Z+17	; 0x11
    38da:	88 23       	and	r24, r24
    38dc:	d9 f0       	breq	.+54     	; 0x3914 <xQueueGiveFromISR+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    38de:	8a 81       	ldd	r24, Y+2	; 0x02
    38e0:	9b 81       	ldd	r25, Y+3	; 0x03
    38e2:	41 96       	adiw	r24, 0x11	; 17
    38e4:	0e 94 20 28 	call	0x5040	; 0x5040 <xTaskRemoveFromEventList>
    38e8:	88 23       	and	r24, r24
    38ea:	a1 f0       	breq	.+40     	; 0x3914 <xQueueGiveFromISR+0x9c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    38ec:	8f 81       	ldd	r24, Y+7	; 0x07
    38ee:	98 85       	ldd	r25, Y+8	; 0x08
    38f0:	89 2b       	or	r24, r25
    38f2:	81 f0       	breq	.+32     	; 0x3914 <xQueueGiveFromISR+0x9c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    38f4:	8f 81       	ldd	r24, Y+7	; 0x07
    38f6:	98 85       	ldd	r25, Y+8	; 0x08
    38f8:	21 e0       	ldi	r18, 0x01	; 1
    38fa:	fc 01       	movw	r30, r24
    38fc:	20 83       	st	Z, r18
    38fe:	0a c0       	rjmp	.+20     	; 0x3914 <xQueueGiveFromISR+0x9c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3900:	8a 81       	ldd	r24, Y+2	; 0x02
    3902:	9b 81       	ldd	r25, Y+3	; 0x03
    3904:	fc 01       	movw	r30, r24
    3906:	86 8d       	ldd	r24, Z+30	; 0x1e
    3908:	8f 5f       	subi	r24, 0xFF	; 255
    390a:	28 2f       	mov	r18, r24
    390c:	8a 81       	ldd	r24, Y+2	; 0x02
    390e:	9b 81       	ldd	r25, Y+3	; 0x03
    3910:	fc 01       	movw	r30, r24
    3912:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    3914:	81 e0       	ldi	r24, 0x01	; 1
    3916:	89 83       	std	Y+1, r24	; 0x01
    3918:	01 c0       	rjmp	.+2      	; 0x391c <xQueueGiveFromISR+0xa4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    391a:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    391c:	89 81       	ldd	r24, Y+1	; 0x01
}
    391e:	28 96       	adiw	r28, 0x08	; 8
    3920:	0f b6       	in	r0, 0x3f	; 63
    3922:	f8 94       	cli
    3924:	de bf       	out	0x3e, r29	; 62
    3926:	0f be       	out	0x3f, r0	; 63
    3928:	cd bf       	out	0x3d, r28	; 61
    392a:	df 91       	pop	r29
    392c:	cf 91       	pop	r28
    392e:	08 95       	ret

00003930 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    3930:	cf 93       	push	r28
    3932:	df 93       	push	r29
    3934:	cd b7       	in	r28, 0x3d	; 61
    3936:	de b7       	in	r29, 0x3e	; 62
    3938:	2f 97       	sbiw	r28, 0x0f	; 15
    393a:	0f b6       	in	r0, 0x3f	; 63
    393c:	f8 94       	cli
    393e:	de bf       	out	0x3e, r29	; 62
    3940:	0f be       	out	0x3f, r0	; 63
    3942:	cd bf       	out	0x3d, r28	; 61
    3944:	9a 87       	std	Y+10, r25	; 0x0a
    3946:	89 87       	std	Y+9, r24	; 0x09
    3948:	7c 87       	std	Y+12, r23	; 0x0c
    394a:	6b 87       	std	Y+11, r22	; 0x0b
    394c:	5e 87       	std	Y+14, r21	; 0x0e
    394e:	4d 87       	std	Y+13, r20	; 0x0d
    3950:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    3952:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3954:	89 85       	ldd	r24, Y+9	; 0x09
    3956:	9a 85       	ldd	r25, Y+10	; 0x0a
    3958:	9b 83       	std	Y+3, r25	; 0x03
    395a:	8a 83       	std	Y+2, r24	; 0x02
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    395c:	0f b6       	in	r0, 0x3f	; 63
    395e:	f8 94       	cli
    3960:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3962:	8a 81       	ldd	r24, Y+2	; 0x02
    3964:	9b 81       	ldd	r25, Y+3	; 0x03
    3966:	fc 01       	movw	r30, r24
    3968:	82 8d       	ldd	r24, Z+26	; 0x1a
    396a:	88 23       	and	r24, r24
    396c:	09 f4       	brne	.+2      	; 0x3970 <xQueueGenericReceive+0x40>
    396e:	54 c0       	rjmp	.+168    	; 0x3a18 <xQueueGenericReceive+0xe8>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    3970:	8a 81       	ldd	r24, Y+2	; 0x02
    3972:	9b 81       	ldd	r25, Y+3	; 0x03
    3974:	fc 01       	movw	r30, r24
    3976:	86 81       	ldd	r24, Z+6	; 0x06
    3978:	97 81       	ldd	r25, Z+7	; 0x07
    397a:	9d 83       	std	Y+5, r25	; 0x05
    397c:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    397e:	2b 85       	ldd	r18, Y+11	; 0x0b
    3980:	3c 85       	ldd	r19, Y+12	; 0x0c
    3982:	8a 81       	ldd	r24, Y+2	; 0x02
    3984:	9b 81       	ldd	r25, Y+3	; 0x03
    3986:	b9 01       	movw	r22, r18
    3988:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    398c:	8f 85       	ldd	r24, Y+15	; 0x0f
    398e:	88 23       	and	r24, r24
    3990:	49 f5       	brne	.+82     	; 0x39e4 <xQueueGenericReceive+0xb4>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    3992:	8a 81       	ldd	r24, Y+2	; 0x02
    3994:	9b 81       	ldd	r25, Y+3	; 0x03
    3996:	fc 01       	movw	r30, r24
    3998:	82 8d       	ldd	r24, Z+26	; 0x1a
    399a:	2f ef       	ldi	r18, 0xFF	; 255
    399c:	28 0f       	add	r18, r24
    399e:	8a 81       	ldd	r24, Y+2	; 0x02
    39a0:	9b 81       	ldd	r25, Y+3	; 0x03
    39a2:	fc 01       	movw	r30, r24
    39a4:	22 8f       	std	Z+26, r18	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    39a6:	8a 81       	ldd	r24, Y+2	; 0x02
    39a8:	9b 81       	ldd	r25, Y+3	; 0x03
    39aa:	fc 01       	movw	r30, r24
    39ac:	80 81       	ld	r24, Z
    39ae:	91 81       	ldd	r25, Z+1	; 0x01
    39b0:	89 2b       	or	r24, r25
    39b2:	41 f4       	brne	.+16     	; 0x39c4 <xQueueGenericReceive+0x94>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    39b4:	0e 94 30 2d 	call	0x5a60	; 0x5a60 <pvTaskIncrementMutexHeldCount>
    39b8:	9c 01       	movw	r18, r24
    39ba:	8a 81       	ldd	r24, Y+2	; 0x02
    39bc:	9b 81       	ldd	r25, Y+3	; 0x03
    39be:	fc 01       	movw	r30, r24
    39c0:	33 83       	std	Z+3, r19	; 0x03
    39c2:	22 83       	std	Z+2, r18	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    39c4:	8a 81       	ldd	r24, Y+2	; 0x02
    39c6:	9b 81       	ldd	r25, Y+3	; 0x03
    39c8:	fc 01       	movw	r30, r24
    39ca:	80 85       	ldd	r24, Z+8	; 0x08
    39cc:	88 23       	and	r24, r24
    39ce:	01 f1       	breq	.+64     	; 0x3a10 <xQueueGenericReceive+0xe0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    39d0:	8a 81       	ldd	r24, Y+2	; 0x02
    39d2:	9b 81       	ldd	r25, Y+3	; 0x03
    39d4:	08 96       	adiw	r24, 0x08	; 8
    39d6:	0e 94 20 28 	call	0x5040	; 0x5040 <xTaskRemoveFromEventList>
    39da:	81 30       	cpi	r24, 0x01	; 1
    39dc:	c9 f4       	brne	.+50     	; 0x3a10 <xQueueGenericReceive+0xe0>
						{
							queueYIELD_IF_USING_PREEMPTION();
    39de:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
    39e2:	16 c0       	rjmp	.+44     	; 0x3a10 <xQueueGenericReceive+0xe0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    39e4:	8a 81       	ldd	r24, Y+2	; 0x02
    39e6:	9b 81       	ldd	r25, Y+3	; 0x03
    39e8:	2c 81       	ldd	r18, Y+4	; 0x04
    39ea:	3d 81       	ldd	r19, Y+5	; 0x05
    39ec:	fc 01       	movw	r30, r24
    39ee:	37 83       	std	Z+7, r19	; 0x07
    39f0:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    39f2:	8a 81       	ldd	r24, Y+2	; 0x02
    39f4:	9b 81       	ldd	r25, Y+3	; 0x03
    39f6:	fc 01       	movw	r30, r24
    39f8:	81 89       	ldd	r24, Z+17	; 0x11
    39fa:	88 23       	and	r24, r24
    39fc:	49 f0       	breq	.+18     	; 0x3a10 <xQueueGenericReceive+0xe0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    39fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3a00:	9b 81       	ldd	r25, Y+3	; 0x03
    3a02:	41 96       	adiw	r24, 0x11	; 17
    3a04:	0e 94 20 28 	call	0x5040	; 0x5040 <xTaskRemoveFromEventList>
    3a08:	88 23       	and	r24, r24
    3a0a:	11 f0       	breq	.+4      	; 0x3a10 <xQueueGenericReceive+0xe0>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    3a0c:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    3a10:	0f 90       	pop	r0
    3a12:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3a14:	81 e0       	ldi	r24, 0x01	; 1
    3a16:	74 c0       	rjmp	.+232    	; 0x3b00 <xQueueGenericReceive+0x1d0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3a18:	8d 85       	ldd	r24, Y+13	; 0x0d
    3a1a:	9e 85       	ldd	r25, Y+14	; 0x0e
    3a1c:	89 2b       	or	r24, r25
    3a1e:	21 f4       	brne	.+8      	; 0x3a28 <xQueueGenericReceive+0xf8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3a20:	0f 90       	pop	r0
    3a22:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3a24:	80 e0       	ldi	r24, 0x00	; 0
    3a26:	6c c0       	rjmp	.+216    	; 0x3b00 <xQueueGenericReceive+0x1d0>
				}
				else if( xEntryTimeSet == pdFALSE )
    3a28:	89 81       	ldd	r24, Y+1	; 0x01
    3a2a:	88 23       	and	r24, r24
    3a2c:	31 f4       	brne	.+12     	; 0x3a3a <xQueueGenericReceive+0x10a>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3a2e:	ce 01       	movw	r24, r28
    3a30:	06 96       	adiw	r24, 0x06	; 6
    3a32:	0e 94 f8 28 	call	0x51f0	; 0x51f0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3a36:	81 e0       	ldi	r24, 0x01	; 1
    3a38:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3a3a:	0f 90       	pop	r0
    3a3c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3a3e:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3a42:	0f b6       	in	r0, 0x3f	; 63
    3a44:	f8 94       	cli
    3a46:	0f 92       	push	r0
    3a48:	8a 81       	ldd	r24, Y+2	; 0x02
    3a4a:	9b 81       	ldd	r25, Y+3	; 0x03
    3a4c:	fc 01       	movw	r30, r24
    3a4e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a50:	8f 3f       	cpi	r24, 0xFF	; 255
    3a52:	21 f4       	brne	.+8      	; 0x3a5c <xQueueGenericReceive+0x12c>
    3a54:	8a 81       	ldd	r24, Y+2	; 0x02
    3a56:	9b 81       	ldd	r25, Y+3	; 0x03
    3a58:	fc 01       	movw	r30, r24
    3a5a:	15 8e       	std	Z+29, r1	; 0x1d
    3a5c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a5e:	9b 81       	ldd	r25, Y+3	; 0x03
    3a60:	fc 01       	movw	r30, r24
    3a62:	86 8d       	ldd	r24, Z+30	; 0x1e
    3a64:	8f 3f       	cpi	r24, 0xFF	; 255
    3a66:	21 f4       	brne	.+8      	; 0x3a70 <xQueueGenericReceive+0x140>
    3a68:	8a 81       	ldd	r24, Y+2	; 0x02
    3a6a:	9b 81       	ldd	r25, Y+3	; 0x03
    3a6c:	fc 01       	movw	r30, r24
    3a6e:	16 8e       	std	Z+30, r1	; 0x1e
    3a70:	0f 90       	pop	r0
    3a72:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3a74:	9e 01       	movw	r18, r28
    3a76:	23 5f       	subi	r18, 0xF3	; 243
    3a78:	3f 4f       	sbci	r19, 0xFF	; 255
    3a7a:	ce 01       	movw	r24, r28
    3a7c:	06 96       	adiw	r24, 0x06	; 6
    3a7e:	b9 01       	movw	r22, r18
    3a80:	0e 94 14 29 	call	0x5228	; 0x5228 <xTaskCheckForTimeOut>
    3a84:	88 23       	and	r24, r24
    3a86:	99 f5       	brne	.+102    	; 0x3aee <xQueueGenericReceive+0x1be>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3a88:	8a 81       	ldd	r24, Y+2	; 0x02
    3a8a:	9b 81       	ldd	r25, Y+3	; 0x03
    3a8c:	0e 94 18 20 	call	0x4030	; 0x4030 <prvIsQueueEmpty>
    3a90:	88 23       	and	r24, r24
    3a92:	31 f1       	breq	.+76     	; 0x3ae0 <xQueueGenericReceive+0x1b0>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3a94:	8a 81       	ldd	r24, Y+2	; 0x02
    3a96:	9b 81       	ldd	r25, Y+3	; 0x03
    3a98:	fc 01       	movw	r30, r24
    3a9a:	80 81       	ld	r24, Z
    3a9c:	91 81       	ldd	r25, Z+1	; 0x01
    3a9e:	89 2b       	or	r24, r25
    3aa0:	61 f4       	brne	.+24     	; 0x3aba <xQueueGenericReceive+0x18a>
					{
						taskENTER_CRITICAL();
    3aa2:	0f b6       	in	r0, 0x3f	; 63
    3aa4:	f8 94       	cli
    3aa6:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    3aa8:	8a 81       	ldd	r24, Y+2	; 0x02
    3aaa:	9b 81       	ldd	r25, Y+3	; 0x03
    3aac:	fc 01       	movw	r30, r24
    3aae:	82 81       	ldd	r24, Z+2	; 0x02
    3ab0:	93 81       	ldd	r25, Z+3	; 0x03
    3ab2:	0e 94 f1 2b 	call	0x57e2	; 0x57e2 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    3ab6:	0f 90       	pop	r0
    3ab8:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3aba:	2d 85       	ldd	r18, Y+13	; 0x0d
    3abc:	3e 85       	ldd	r19, Y+14	; 0x0e
    3abe:	8a 81       	ldd	r24, Y+2	; 0x02
    3ac0:	9b 81       	ldd	r25, Y+3	; 0x03
    3ac2:	41 96       	adiw	r24, 0x11	; 17
    3ac4:	b9 01       	movw	r22, r18
    3ac6:	0e 94 8a 27 	call	0x4f14	; 0x4f14 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3aca:	8a 81       	ldd	r24, Y+2	; 0x02
    3acc:	9b 81       	ldd	r25, Y+3	; 0x03
    3ace:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3ad2:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>
    3ad6:	88 23       	and	r24, r24
    3ad8:	91 f4       	brne	.+36     	; 0x3afe <xQueueGenericReceive+0x1ce>
				{
					portYIELD_WITHIN_API();
    3ada:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
    3ade:	0f c0       	rjmp	.+30     	; 0x3afe <xQueueGenericReceive+0x1ce>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3ae0:	8a 81       	ldd	r24, Y+2	; 0x02
    3ae2:	9b 81       	ldd	r25, Y+3	; 0x03
    3ae4:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3ae8:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>
    3aec:	37 cf       	rjmp	.-402    	; 0x395c <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3aee:	8a 81       	ldd	r24, Y+2	; 0x02
    3af0:	9b 81       	ldd	r25, Y+3	; 0x03
    3af2:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3af6:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3afa:	80 e0       	ldi	r24, 0x00	; 0
    3afc:	01 c0       	rjmp	.+2      	; 0x3b00 <xQueueGenericReceive+0x1d0>
		}
	}
    3afe:	2e cf       	rjmp	.-420    	; 0x395c <xQueueGenericReceive+0x2c>
}
    3b00:	2f 96       	adiw	r28, 0x0f	; 15
    3b02:	0f b6       	in	r0, 0x3f	; 63
    3b04:	f8 94       	cli
    3b06:	de bf       	out	0x3e, r29	; 62
    3b08:	0f be       	out	0x3f, r0	; 63
    3b0a:	cd bf       	out	0x3d, r28	; 61
    3b0c:	df 91       	pop	r29
    3b0e:	cf 91       	pop	r28
    3b10:	08 95       	ret

00003b12 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3b12:	cf 93       	push	r28
    3b14:	df 93       	push	r29
    3b16:	cd b7       	in	r28, 0x3d	; 61
    3b18:	de b7       	in	r29, 0x3e	; 62
    3b1a:	2a 97       	sbiw	r28, 0x0a	; 10
    3b1c:	0f b6       	in	r0, 0x3f	; 63
    3b1e:	f8 94       	cli
    3b20:	de bf       	out	0x3e, r29	; 62
    3b22:	0f be       	out	0x3f, r0	; 63
    3b24:	cd bf       	out	0x3d, r28	; 61
    3b26:	9e 83       	std	Y+6, r25	; 0x06
    3b28:	8d 83       	std	Y+5, r24	; 0x05
    3b2a:	78 87       	std	Y+8, r23	; 0x08
    3b2c:	6f 83       	std	Y+7, r22	; 0x07
    3b2e:	5a 87       	std	Y+10, r21	; 0x0a
    3b30:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3b32:	8d 81       	ldd	r24, Y+5	; 0x05
    3b34:	9e 81       	ldd	r25, Y+6	; 0x06
    3b36:	9b 83       	std	Y+3, r25	; 0x03
    3b38:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3b3a:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3b3c:	8a 81       	ldd	r24, Y+2	; 0x02
    3b3e:	9b 81       	ldd	r25, Y+3	; 0x03
    3b40:	fc 01       	movw	r30, r24
    3b42:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b44:	88 23       	and	r24, r24
    3b46:	d9 f1       	breq	.+118    	; 0x3bbe <xQueueReceiveFromISR+0xac>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3b48:	2f 81       	ldd	r18, Y+7	; 0x07
    3b4a:	38 85       	ldd	r19, Y+8	; 0x08
    3b4c:	8a 81       	ldd	r24, Y+2	; 0x02
    3b4e:	9b 81       	ldd	r25, Y+3	; 0x03
    3b50:	b9 01       	movw	r22, r18
    3b52:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    3b56:	8a 81       	ldd	r24, Y+2	; 0x02
    3b58:	9b 81       	ldd	r25, Y+3	; 0x03
    3b5a:	fc 01       	movw	r30, r24
    3b5c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b5e:	2f ef       	ldi	r18, 0xFF	; 255
    3b60:	28 0f       	add	r18, r24
    3b62:	8a 81       	ldd	r24, Y+2	; 0x02
    3b64:	9b 81       	ldd	r25, Y+3	; 0x03
    3b66:	fc 01       	movw	r30, r24
    3b68:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    3b6a:	8a 81       	ldd	r24, Y+2	; 0x02
    3b6c:	9b 81       	ldd	r25, Y+3	; 0x03
    3b6e:	fc 01       	movw	r30, r24
    3b70:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b72:	8f 3f       	cpi	r24, 0xFF	; 255
    3b74:	b9 f4       	brne	.+46     	; 0x3ba4 <xQueueReceiveFromISR+0x92>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3b76:	8a 81       	ldd	r24, Y+2	; 0x02
    3b78:	9b 81       	ldd	r25, Y+3	; 0x03
    3b7a:	fc 01       	movw	r30, r24
    3b7c:	80 85       	ldd	r24, Z+8	; 0x08
    3b7e:	88 23       	and	r24, r24
    3b80:	d9 f0       	breq	.+54     	; 0x3bb8 <xQueueReceiveFromISR+0xa6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3b82:	8a 81       	ldd	r24, Y+2	; 0x02
    3b84:	9b 81       	ldd	r25, Y+3	; 0x03
    3b86:	08 96       	adiw	r24, 0x08	; 8
    3b88:	0e 94 20 28 	call	0x5040	; 0x5040 <xTaskRemoveFromEventList>
    3b8c:	88 23       	and	r24, r24
    3b8e:	a1 f0       	breq	.+40     	; 0x3bb8 <xQueueReceiveFromISR+0xa6>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    3b90:	89 85       	ldd	r24, Y+9	; 0x09
    3b92:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b94:	89 2b       	or	r24, r25
    3b96:	81 f0       	breq	.+32     	; 0x3bb8 <xQueueReceiveFromISR+0xa6>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    3b98:	89 85       	ldd	r24, Y+9	; 0x09
    3b9a:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b9c:	21 e0       	ldi	r18, 0x01	; 1
    3b9e:	fc 01       	movw	r30, r24
    3ba0:	20 83       	st	Z, r18
    3ba2:	0a c0       	rjmp	.+20     	; 0x3bb8 <xQueueReceiveFromISR+0xa6>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    3ba4:	8a 81       	ldd	r24, Y+2	; 0x02
    3ba6:	9b 81       	ldd	r25, Y+3	; 0x03
    3ba8:	fc 01       	movw	r30, r24
    3baa:	85 8d       	ldd	r24, Z+29	; 0x1d
    3bac:	8f 5f       	subi	r24, 0xFF	; 255
    3bae:	28 2f       	mov	r18, r24
    3bb0:	8a 81       	ldd	r24, Y+2	; 0x02
    3bb2:	9b 81       	ldd	r25, Y+3	; 0x03
    3bb4:	fc 01       	movw	r30, r24
    3bb6:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    3bb8:	81 e0       	ldi	r24, 0x01	; 1
    3bba:	89 83       	std	Y+1, r24	; 0x01
    3bbc:	01 c0       	rjmp	.+2      	; 0x3bc0 <xQueueReceiveFromISR+0xae>
		}
		else
		{
			xReturn = pdFAIL;
    3bbe:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3bc0:	89 81       	ldd	r24, Y+1	; 0x01
}
    3bc2:	2a 96       	adiw	r28, 0x0a	; 10
    3bc4:	0f b6       	in	r0, 0x3f	; 63
    3bc6:	f8 94       	cli
    3bc8:	de bf       	out	0x3e, r29	; 62
    3bca:	0f be       	out	0x3f, r0	; 63
    3bcc:	cd bf       	out	0x3d, r28	; 61
    3bce:	df 91       	pop	r29
    3bd0:	cf 91       	pop	r28
    3bd2:	08 95       	ret

00003bd4 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3bd4:	cf 93       	push	r28
    3bd6:	df 93       	push	r29
    3bd8:	cd b7       	in	r28, 0x3d	; 61
    3bda:	de b7       	in	r29, 0x3e	; 62
    3bdc:	2a 97       	sbiw	r28, 0x0a	; 10
    3bde:	0f b6       	in	r0, 0x3f	; 63
    3be0:	f8 94       	cli
    3be2:	de bf       	out	0x3e, r29	; 62
    3be4:	0f be       	out	0x3f, r0	; 63
    3be6:	cd bf       	out	0x3d, r28	; 61
    3be8:	98 87       	std	Y+8, r25	; 0x08
    3bea:	8f 83       	std	Y+7, r24	; 0x07
    3bec:	7a 87       	std	Y+10, r23	; 0x0a
    3bee:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3bf0:	8f 81       	ldd	r24, Y+7	; 0x07
    3bf2:	98 85       	ldd	r25, Y+8	; 0x08
    3bf4:	9b 83       	std	Y+3, r25	; 0x03
    3bf6:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3bf8:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3bfa:	8a 81       	ldd	r24, Y+2	; 0x02
    3bfc:	9b 81       	ldd	r25, Y+3	; 0x03
    3bfe:	fc 01       	movw	r30, r24
    3c00:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c02:	88 23       	and	r24, r24
    3c04:	c1 f0       	breq	.+48     	; 0x3c36 <xQueuePeekFromISR+0x62>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    3c06:	8a 81       	ldd	r24, Y+2	; 0x02
    3c08:	9b 81       	ldd	r25, Y+3	; 0x03
    3c0a:	fc 01       	movw	r30, r24
    3c0c:	86 81       	ldd	r24, Z+6	; 0x06
    3c0e:	97 81       	ldd	r25, Z+7	; 0x07
    3c10:	9e 83       	std	Y+6, r25	; 0x06
    3c12:	8d 83       	std	Y+5, r24	; 0x05
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3c14:	29 85       	ldd	r18, Y+9	; 0x09
    3c16:	3a 85       	ldd	r19, Y+10	; 0x0a
    3c18:	8a 81       	ldd	r24, Y+2	; 0x02
    3c1a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c1c:	b9 01       	movw	r22, r18
    3c1e:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    3c22:	8a 81       	ldd	r24, Y+2	; 0x02
    3c24:	9b 81       	ldd	r25, Y+3	; 0x03
    3c26:	2d 81       	ldd	r18, Y+5	; 0x05
    3c28:	3e 81       	ldd	r19, Y+6	; 0x06
    3c2a:	fc 01       	movw	r30, r24
    3c2c:	37 83       	std	Z+7, r19	; 0x07
    3c2e:	26 83       	std	Z+6, r18	; 0x06

			xReturn = pdPASS;
    3c30:	81 e0       	ldi	r24, 0x01	; 1
    3c32:	89 83       	std	Y+1, r24	; 0x01
    3c34:	01 c0       	rjmp	.+2      	; 0x3c38 <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
    3c36:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3c38:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c3a:	2a 96       	adiw	r28, 0x0a	; 10
    3c3c:	0f b6       	in	r0, 0x3f	; 63
    3c3e:	f8 94       	cli
    3c40:	de bf       	out	0x3e, r29	; 62
    3c42:	0f be       	out	0x3f, r0	; 63
    3c44:	cd bf       	out	0x3d, r28	; 61
    3c46:	df 91       	pop	r29
    3c48:	cf 91       	pop	r28
    3c4a:	08 95       	ret

00003c4c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    3c4c:	cf 93       	push	r28
    3c4e:	df 93       	push	r29
    3c50:	00 d0       	rcall	.+0      	; 0x3c52 <uxQueueMessagesWaiting+0x6>
    3c52:	cd b7       	in	r28, 0x3d	; 61
    3c54:	de b7       	in	r29, 0x3e	; 62
    3c56:	9b 83       	std	Y+3, r25	; 0x03
    3c58:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    3c5a:	0f b6       	in	r0, 0x3f	; 63
    3c5c:	f8 94       	cli
    3c5e:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3c60:	8a 81       	ldd	r24, Y+2	; 0x02
    3c62:	9b 81       	ldd	r25, Y+3	; 0x03
    3c64:	fc 01       	movw	r30, r24
    3c66:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c68:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3c6a:	0f 90       	pop	r0
    3c6c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3c6e:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3c70:	0f 90       	pop	r0
    3c72:	0f 90       	pop	r0
    3c74:	0f 90       	pop	r0
    3c76:	df 91       	pop	r29
    3c78:	cf 91       	pop	r28
    3c7a:	08 95       	ret

00003c7c <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3c7c:	cf 93       	push	r28
    3c7e:	df 93       	push	r29
    3c80:	00 d0       	rcall	.+0      	; 0x3c82 <uxQueueSpacesAvailable+0x6>
    3c82:	1f 92       	push	r1
    3c84:	1f 92       	push	r1
    3c86:	cd b7       	in	r28, 0x3d	; 61
    3c88:	de b7       	in	r29, 0x3e	; 62
    3c8a:	9d 83       	std	Y+5, r25	; 0x05
    3c8c:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    3c8e:	8c 81       	ldd	r24, Y+4	; 0x04
    3c90:	9d 81       	ldd	r25, Y+5	; 0x05
    3c92:	9a 83       	std	Y+2, r25	; 0x02
    3c94:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3c96:	0f b6       	in	r0, 0x3f	; 63
    3c98:	f8 94       	cli
    3c9a:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3c9c:	89 81       	ldd	r24, Y+1	; 0x01
    3c9e:	9a 81       	ldd	r25, Y+2	; 0x02
    3ca0:	fc 01       	movw	r30, r24
    3ca2:	23 8d       	ldd	r18, Z+27	; 0x1b
    3ca4:	89 81       	ldd	r24, Y+1	; 0x01
    3ca6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ca8:	fc 01       	movw	r30, r24
    3caa:	82 8d       	ldd	r24, Z+26	; 0x1a
    3cac:	f2 2f       	mov	r31, r18
    3cae:	f8 1b       	sub	r31, r24
    3cb0:	8f 2f       	mov	r24, r31
    3cb2:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    3cb4:	0f 90       	pop	r0
    3cb6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3cb8:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3cba:	0f 90       	pop	r0
    3cbc:	0f 90       	pop	r0
    3cbe:	0f 90       	pop	r0
    3cc0:	0f 90       	pop	r0
    3cc2:	0f 90       	pop	r0
    3cc4:	df 91       	pop	r29
    3cc6:	cf 91       	pop	r28
    3cc8:	08 95       	ret

00003cca <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3cca:	cf 93       	push	r28
    3ccc:	df 93       	push	r29
    3cce:	00 d0       	rcall	.+0      	; 0x3cd0 <uxQueueMessagesWaitingFromISR+0x6>
    3cd0:	cd b7       	in	r28, 0x3d	; 61
    3cd2:	de b7       	in	r29, 0x3e	; 62
    3cd4:	9b 83       	std	Y+3, r25	; 0x03
    3cd6:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3cd8:	8a 81       	ldd	r24, Y+2	; 0x02
    3cda:	9b 81       	ldd	r25, Y+3	; 0x03
    3cdc:	fc 01       	movw	r30, r24
    3cde:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ce0:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    3ce2:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3ce4:	0f 90       	pop	r0
    3ce6:	0f 90       	pop	r0
    3ce8:	0f 90       	pop	r0
    3cea:	df 91       	pop	r29
    3cec:	cf 91       	pop	r28
    3cee:	08 95       	ret

00003cf0 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3cf0:	cf 93       	push	r28
    3cf2:	df 93       	push	r29
    3cf4:	00 d0       	rcall	.+0      	; 0x3cf6 <vQueueDelete+0x6>
    3cf6:	1f 92       	push	r1
    3cf8:	cd b7       	in	r28, 0x3d	; 61
    3cfa:	de b7       	in	r29, 0x3e	; 62
    3cfc:	9c 83       	std	Y+4, r25	; 0x04
    3cfe:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3d00:	8b 81       	ldd	r24, Y+3	; 0x03
    3d02:	9c 81       	ldd	r25, Y+4	; 0x04
    3d04:	9a 83       	std	Y+2, r25	; 0x02
    3d06:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
    3d08:	89 81       	ldd	r24, Y+1	; 0x01
    3d0a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d0c:	0e 94 84 12 	call	0x2508	; 0x2508 <vPortFree>
}
    3d10:	0f 90       	pop	r0
    3d12:	0f 90       	pop	r0
    3d14:	0f 90       	pop	r0
    3d16:	0f 90       	pop	r0
    3d18:	df 91       	pop	r29
    3d1a:	cf 91       	pop	r28
    3d1c:	08 95       	ret

00003d1e <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    3d1e:	cf 93       	push	r28
    3d20:	df 93       	push	r29
    3d22:	00 d0       	rcall	.+0      	; 0x3d24 <prvCopyDataToQueue+0x6>
    3d24:	00 d0       	rcall	.+0      	; 0x3d26 <prvCopyDataToQueue+0x8>
    3d26:	cd b7       	in	r28, 0x3d	; 61
    3d28:	de b7       	in	r29, 0x3e	; 62
    3d2a:	9b 83       	std	Y+3, r25	; 0x03
    3d2c:	8a 83       	std	Y+2, r24	; 0x02
    3d2e:	7d 83       	std	Y+5, r23	; 0x05
    3d30:	6c 83       	std	Y+4, r22	; 0x04
    3d32:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    3d34:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3d36:	8a 81       	ldd	r24, Y+2	; 0x02
    3d38:	9b 81       	ldd	r25, Y+3	; 0x03
    3d3a:	fc 01       	movw	r30, r24
    3d3c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d3e:	88 23       	and	r24, r24
    3d40:	b1 f4       	brne	.+44     	; 0x3d6e <prvCopyDataToQueue+0x50>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3d42:	8a 81       	ldd	r24, Y+2	; 0x02
    3d44:	9b 81       	ldd	r25, Y+3	; 0x03
    3d46:	fc 01       	movw	r30, r24
    3d48:	80 81       	ld	r24, Z
    3d4a:	91 81       	ldd	r25, Z+1	; 0x01
    3d4c:	89 2b       	or	r24, r25
    3d4e:	09 f0       	breq	.+2      	; 0x3d52 <prvCopyDataToQueue+0x34>
    3d50:	a6 c0       	rjmp	.+332    	; 0x3e9e <prvCopyDataToQueue+0x180>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    3d52:	8a 81       	ldd	r24, Y+2	; 0x02
    3d54:	9b 81       	ldd	r25, Y+3	; 0x03
    3d56:	fc 01       	movw	r30, r24
    3d58:	82 81       	ldd	r24, Z+2	; 0x02
    3d5a:	93 81       	ldd	r25, Z+3	; 0x03
    3d5c:	0e 94 88 2c 	call	0x5910	; 0x5910 <xTaskPriorityDisinherit>
    3d60:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->pxMutexHolder = NULL;
    3d62:	8a 81       	ldd	r24, Y+2	; 0x02
    3d64:	9b 81       	ldd	r25, Y+3	; 0x03
    3d66:	fc 01       	movw	r30, r24
    3d68:	13 82       	std	Z+3, r1	; 0x03
    3d6a:	12 82       	std	Z+2, r1	; 0x02
    3d6c:	98 c0       	rjmp	.+304    	; 0x3e9e <prvCopyDataToQueue+0x180>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    3d6e:	8e 81       	ldd	r24, Y+6	; 0x06
    3d70:	88 23       	and	r24, r24
    3d72:	d9 f5       	brne	.+118    	; 0x3dea <prvCopyDataToQueue+0xcc>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
    3d74:	8a 81       	ldd	r24, Y+2	; 0x02
    3d76:	9b 81       	ldd	r25, Y+3	; 0x03
    3d78:	fc 01       	movw	r30, r24
    3d7a:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d7c:	48 2f       	mov	r20, r24
    3d7e:	50 e0       	ldi	r21, 0x00	; 0
    3d80:	8a 81       	ldd	r24, Y+2	; 0x02
    3d82:	9b 81       	ldd	r25, Y+3	; 0x03
    3d84:	fc 01       	movw	r30, r24
    3d86:	84 81       	ldd	r24, Z+4	; 0x04
    3d88:	95 81       	ldd	r25, Z+5	; 0x05
    3d8a:	2c 81       	ldd	r18, Y+4	; 0x04
    3d8c:	3d 81       	ldd	r19, Y+5	; 0x05
    3d8e:	b9 01       	movw	r22, r18
    3d90:	0e 94 f0 36 	call	0x6de0	; 0x6de0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3d94:	8a 81       	ldd	r24, Y+2	; 0x02
    3d96:	9b 81       	ldd	r25, Y+3	; 0x03
    3d98:	fc 01       	movw	r30, r24
    3d9a:	24 81       	ldd	r18, Z+4	; 0x04
    3d9c:	35 81       	ldd	r19, Z+5	; 0x05
    3d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    3da0:	9b 81       	ldd	r25, Y+3	; 0x03
    3da2:	fc 01       	movw	r30, r24
    3da4:	84 8d       	ldd	r24, Z+28	; 0x1c
    3da6:	88 2f       	mov	r24, r24
    3da8:	90 e0       	ldi	r25, 0x00	; 0
    3daa:	28 0f       	add	r18, r24
    3dac:	39 1f       	adc	r19, r25
    3dae:	8a 81       	ldd	r24, Y+2	; 0x02
    3db0:	9b 81       	ldd	r25, Y+3	; 0x03
    3db2:	fc 01       	movw	r30, r24
    3db4:	35 83       	std	Z+5, r19	; 0x05
    3db6:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    3db8:	8a 81       	ldd	r24, Y+2	; 0x02
    3dba:	9b 81       	ldd	r25, Y+3	; 0x03
    3dbc:	fc 01       	movw	r30, r24
    3dbe:	24 81       	ldd	r18, Z+4	; 0x04
    3dc0:	35 81       	ldd	r19, Z+5	; 0x05
    3dc2:	8a 81       	ldd	r24, Y+2	; 0x02
    3dc4:	9b 81       	ldd	r25, Y+3	; 0x03
    3dc6:	fc 01       	movw	r30, r24
    3dc8:	82 81       	ldd	r24, Z+2	; 0x02
    3dca:	93 81       	ldd	r25, Z+3	; 0x03
    3dcc:	28 17       	cp	r18, r24
    3dce:	39 07       	cpc	r19, r25
    3dd0:	08 f4       	brcc	.+2      	; 0x3dd4 <prvCopyDataToQueue+0xb6>
    3dd2:	65 c0       	rjmp	.+202    	; 0x3e9e <prvCopyDataToQueue+0x180>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3dd4:	8a 81       	ldd	r24, Y+2	; 0x02
    3dd6:	9b 81       	ldd	r25, Y+3	; 0x03
    3dd8:	fc 01       	movw	r30, r24
    3dda:	20 81       	ld	r18, Z
    3ddc:	31 81       	ldd	r19, Z+1	; 0x01
    3dde:	8a 81       	ldd	r24, Y+2	; 0x02
    3de0:	9b 81       	ldd	r25, Y+3	; 0x03
    3de2:	fc 01       	movw	r30, r24
    3de4:	35 83       	std	Z+5, r19	; 0x05
    3de6:	24 83       	std	Z+4, r18	; 0x04
    3de8:	5a c0       	rjmp	.+180    	; 0x3e9e <prvCopyDataToQueue+0x180>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
    3dea:	8a 81       	ldd	r24, Y+2	; 0x02
    3dec:	9b 81       	ldd	r25, Y+3	; 0x03
    3dee:	fc 01       	movw	r30, r24
    3df0:	84 8d       	ldd	r24, Z+28	; 0x1c
    3df2:	48 2f       	mov	r20, r24
    3df4:	50 e0       	ldi	r21, 0x00	; 0
    3df6:	8a 81       	ldd	r24, Y+2	; 0x02
    3df8:	9b 81       	ldd	r25, Y+3	; 0x03
    3dfa:	fc 01       	movw	r30, r24
    3dfc:	86 81       	ldd	r24, Z+6	; 0x06
    3dfe:	97 81       	ldd	r25, Z+7	; 0x07
    3e00:	2c 81       	ldd	r18, Y+4	; 0x04
    3e02:	3d 81       	ldd	r19, Y+5	; 0x05
    3e04:	b9 01       	movw	r22, r18
    3e06:	0e 94 f0 36 	call	0x6de0	; 0x6de0 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    3e0a:	8a 81       	ldd	r24, Y+2	; 0x02
    3e0c:	9b 81       	ldd	r25, Y+3	; 0x03
    3e0e:	fc 01       	movw	r30, r24
    3e10:	26 81       	ldd	r18, Z+6	; 0x06
    3e12:	37 81       	ldd	r19, Z+7	; 0x07
    3e14:	8a 81       	ldd	r24, Y+2	; 0x02
    3e16:	9b 81       	ldd	r25, Y+3	; 0x03
    3e18:	fc 01       	movw	r30, r24
    3e1a:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e1c:	88 2f       	mov	r24, r24
    3e1e:	90 e0       	ldi	r25, 0x00	; 0
    3e20:	91 95       	neg	r25
    3e22:	81 95       	neg	r24
    3e24:	91 09       	sbc	r25, r1
    3e26:	28 0f       	add	r18, r24
    3e28:	39 1f       	adc	r19, r25
    3e2a:	8a 81       	ldd	r24, Y+2	; 0x02
    3e2c:	9b 81       	ldd	r25, Y+3	; 0x03
    3e2e:	fc 01       	movw	r30, r24
    3e30:	37 83       	std	Z+7, r19	; 0x07
    3e32:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead )
    3e34:	8a 81       	ldd	r24, Y+2	; 0x02
    3e36:	9b 81       	ldd	r25, Y+3	; 0x03
    3e38:	fc 01       	movw	r30, r24
    3e3a:	26 81       	ldd	r18, Z+6	; 0x06
    3e3c:	37 81       	ldd	r19, Z+7	; 0x07
    3e3e:	8a 81       	ldd	r24, Y+2	; 0x02
    3e40:	9b 81       	ldd	r25, Y+3	; 0x03
    3e42:	fc 01       	movw	r30, r24
    3e44:	80 81       	ld	r24, Z
    3e46:	91 81       	ldd	r25, Z+1	; 0x01
    3e48:	28 17       	cp	r18, r24
    3e4a:	39 07       	cpc	r19, r25
    3e4c:	a8 f4       	brcc	.+42     	; 0x3e78 <prvCopyDataToQueue+0x15a>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    3e4e:	8a 81       	ldd	r24, Y+2	; 0x02
    3e50:	9b 81       	ldd	r25, Y+3	; 0x03
    3e52:	fc 01       	movw	r30, r24
    3e54:	22 81       	ldd	r18, Z+2	; 0x02
    3e56:	33 81       	ldd	r19, Z+3	; 0x03
    3e58:	8a 81       	ldd	r24, Y+2	; 0x02
    3e5a:	9b 81       	ldd	r25, Y+3	; 0x03
    3e5c:	fc 01       	movw	r30, r24
    3e5e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e60:	88 2f       	mov	r24, r24
    3e62:	90 e0       	ldi	r25, 0x00	; 0
    3e64:	91 95       	neg	r25
    3e66:	81 95       	neg	r24
    3e68:	91 09       	sbc	r25, r1
    3e6a:	28 0f       	add	r18, r24
    3e6c:	39 1f       	adc	r19, r25
    3e6e:	8a 81       	ldd	r24, Y+2	; 0x02
    3e70:	9b 81       	ldd	r25, Y+3	; 0x03
    3e72:	fc 01       	movw	r30, r24
    3e74:	37 83       	std	Z+7, r19	; 0x07
    3e76:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    3e78:	8e 81       	ldd	r24, Y+6	; 0x06
    3e7a:	82 30       	cpi	r24, 0x02	; 2
    3e7c:	81 f4       	brne	.+32     	; 0x3e9e <prvCopyDataToQueue+0x180>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    3e80:	9b 81       	ldd	r25, Y+3	; 0x03
    3e82:	fc 01       	movw	r30, r24
    3e84:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e86:	88 23       	and	r24, r24
    3e88:	51 f0       	breq	.+20     	; 0x3e9e <prvCopyDataToQueue+0x180>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    3e8a:	8a 81       	ldd	r24, Y+2	; 0x02
    3e8c:	9b 81       	ldd	r25, Y+3	; 0x03
    3e8e:	fc 01       	movw	r30, r24
    3e90:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e92:	2f ef       	ldi	r18, 0xFF	; 255
    3e94:	28 0f       	add	r18, r24
    3e96:	8a 81       	ldd	r24, Y+2	; 0x02
    3e98:	9b 81       	ldd	r25, Y+3	; 0x03
    3e9a:	fc 01       	movw	r30, r24
    3e9c:	22 8f       	std	Z+26, r18	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    3e9e:	8a 81       	ldd	r24, Y+2	; 0x02
    3ea0:	9b 81       	ldd	r25, Y+3	; 0x03
    3ea2:	fc 01       	movw	r30, r24
    3ea4:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ea6:	21 e0       	ldi	r18, 0x01	; 1
    3ea8:	28 0f       	add	r18, r24
    3eaa:	8a 81       	ldd	r24, Y+2	; 0x02
    3eac:	9b 81       	ldd	r25, Y+3	; 0x03
    3eae:	fc 01       	movw	r30, r24
    3eb0:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
    3eb2:	89 81       	ldd	r24, Y+1	; 0x01
}
    3eb4:	26 96       	adiw	r28, 0x06	; 6
    3eb6:	0f b6       	in	r0, 0x3f	; 63
    3eb8:	f8 94       	cli
    3eba:	de bf       	out	0x3e, r29	; 62
    3ebc:	0f be       	out	0x3f, r0	; 63
    3ebe:	cd bf       	out	0x3d, r28	; 61
    3ec0:	df 91       	pop	r29
    3ec2:	cf 91       	pop	r28
    3ec4:	08 95       	ret

00003ec6 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    3ec6:	cf 93       	push	r28
    3ec8:	df 93       	push	r29
    3eca:	00 d0       	rcall	.+0      	; 0x3ecc <prvCopyDataFromQueue+0x6>
    3ecc:	1f 92       	push	r1
    3ece:	cd b7       	in	r28, 0x3d	; 61
    3ed0:	de b7       	in	r29, 0x3e	; 62
    3ed2:	9a 83       	std	Y+2, r25	; 0x02
    3ed4:	89 83       	std	Y+1, r24	; 0x01
    3ed6:	7c 83       	std	Y+4, r23	; 0x04
    3ed8:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3eda:	89 81       	ldd	r24, Y+1	; 0x01
    3edc:	9a 81       	ldd	r25, Y+2	; 0x02
    3ede:	fc 01       	movw	r30, r24
    3ee0:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ee2:	88 23       	and	r24, r24
    3ee4:	c9 f1       	breq	.+114    	; 0x3f58 <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    3ee6:	89 81       	ldd	r24, Y+1	; 0x01
    3ee8:	9a 81       	ldd	r25, Y+2	; 0x02
    3eea:	fc 01       	movw	r30, r24
    3eec:	26 81       	ldd	r18, Z+6	; 0x06
    3eee:	37 81       	ldd	r19, Z+7	; 0x07
    3ef0:	89 81       	ldd	r24, Y+1	; 0x01
    3ef2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ef4:	fc 01       	movw	r30, r24
    3ef6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ef8:	88 2f       	mov	r24, r24
    3efa:	90 e0       	ldi	r25, 0x00	; 0
    3efc:	28 0f       	add	r18, r24
    3efe:	39 1f       	adc	r19, r25
    3f00:	89 81       	ldd	r24, Y+1	; 0x01
    3f02:	9a 81       	ldd	r25, Y+2	; 0x02
    3f04:	fc 01       	movw	r30, r24
    3f06:	37 83       	std	Z+7, r19	; 0x07
    3f08:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3f0a:	89 81       	ldd	r24, Y+1	; 0x01
    3f0c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f0e:	fc 01       	movw	r30, r24
    3f10:	26 81       	ldd	r18, Z+6	; 0x06
    3f12:	37 81       	ldd	r19, Z+7	; 0x07
    3f14:	89 81       	ldd	r24, Y+1	; 0x01
    3f16:	9a 81       	ldd	r25, Y+2	; 0x02
    3f18:	fc 01       	movw	r30, r24
    3f1a:	82 81       	ldd	r24, Z+2	; 0x02
    3f1c:	93 81       	ldd	r25, Z+3	; 0x03
    3f1e:	28 17       	cp	r18, r24
    3f20:	39 07       	cpc	r19, r25
    3f22:	50 f0       	brcs	.+20     	; 0x3f38 <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    3f24:	89 81       	ldd	r24, Y+1	; 0x01
    3f26:	9a 81       	ldd	r25, Y+2	; 0x02
    3f28:	fc 01       	movw	r30, r24
    3f2a:	20 81       	ld	r18, Z
    3f2c:	31 81       	ldd	r19, Z+1	; 0x01
    3f2e:	89 81       	ldd	r24, Y+1	; 0x01
    3f30:	9a 81       	ldd	r25, Y+2	; 0x02
    3f32:	fc 01       	movw	r30, r24
    3f34:	37 83       	std	Z+7, r19	; 0x07
    3f36:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    3f38:	89 81       	ldd	r24, Y+1	; 0x01
    3f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3f3c:	fc 01       	movw	r30, r24
    3f3e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f40:	48 2f       	mov	r20, r24
    3f42:	50 e0       	ldi	r21, 0x00	; 0
    3f44:	89 81       	ldd	r24, Y+1	; 0x01
    3f46:	9a 81       	ldd	r25, Y+2	; 0x02
    3f48:	fc 01       	movw	r30, r24
    3f4a:	26 81       	ldd	r18, Z+6	; 0x06
    3f4c:	37 81       	ldd	r19, Z+7	; 0x07
    3f4e:	8b 81       	ldd	r24, Y+3	; 0x03
    3f50:	9c 81       	ldd	r25, Y+4	; 0x04
    3f52:	b9 01       	movw	r22, r18
    3f54:	0e 94 f0 36 	call	0x6de0	; 0x6de0 <memcpy>
	}
}
    3f58:	0f 90       	pop	r0
    3f5a:	0f 90       	pop	r0
    3f5c:	0f 90       	pop	r0
    3f5e:	0f 90       	pop	r0
    3f60:	df 91       	pop	r29
    3f62:	cf 91       	pop	r28
    3f64:	08 95       	ret

00003f66 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3f66:	cf 93       	push	r28
    3f68:	df 93       	push	r29
    3f6a:	1f 92       	push	r1
    3f6c:	1f 92       	push	r1
    3f6e:	cd b7       	in	r28, 0x3d	; 61
    3f70:	de b7       	in	r29, 0x3e	; 62
    3f72:	9a 83       	std	Y+2, r25	; 0x02
    3f74:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3f76:	0f b6       	in	r0, 0x3f	; 63
    3f78:	f8 94       	cli
    3f7a:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3f7c:	1b c0       	rjmp	.+54     	; 0x3fb4 <prvUnlockQueue+0x4e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3f7e:	89 81       	ldd	r24, Y+1	; 0x01
    3f80:	9a 81       	ldd	r25, Y+2	; 0x02
    3f82:	fc 01       	movw	r30, r24
    3f84:	81 89       	ldd	r24, Z+17	; 0x11
    3f86:	88 23       	and	r24, r24
    3f88:	51 f0       	breq	.+20     	; 0x3f9e <prvUnlockQueue+0x38>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3f8a:	89 81       	ldd	r24, Y+1	; 0x01
    3f8c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f8e:	41 96       	adiw	r24, 0x11	; 17
    3f90:	0e 94 20 28 	call	0x5040	; 0x5040 <xTaskRemoveFromEventList>
    3f94:	88 23       	and	r24, r24
    3f96:	21 f0       	breq	.+8      	; 0x3fa0 <prvUnlockQueue+0x3a>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    3f98:	0e 94 85 29 	call	0x530a	; 0x530a <vTaskMissedYield>
    3f9c:	01 c0       	rjmp	.+2      	; 0x3fa0 <prvUnlockQueue+0x3a>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    3f9e:	10 c0       	rjmp	.+32     	; 0x3fc0 <prvUnlockQueue+0x5a>
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    3fa0:	89 81       	ldd	r24, Y+1	; 0x01
    3fa2:	9a 81       	ldd	r25, Y+2	; 0x02
    3fa4:	fc 01       	movw	r30, r24
    3fa6:	86 8d       	ldd	r24, Z+30	; 0x1e
    3fa8:	81 50       	subi	r24, 0x01	; 1
    3faa:	28 2f       	mov	r18, r24
    3fac:	89 81       	ldd	r24, Y+1	; 0x01
    3fae:	9a 81       	ldd	r25, Y+2	; 0x02
    3fb0:	fc 01       	movw	r30, r24
    3fb2:	26 8f       	std	Z+30, r18	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3fb4:	89 81       	ldd	r24, Y+1	; 0x01
    3fb6:	9a 81       	ldd	r25, Y+2	; 0x02
    3fb8:	fc 01       	movw	r30, r24
    3fba:	86 8d       	ldd	r24, Z+30	; 0x1e
    3fbc:	18 16       	cp	r1, r24
    3fbe:	fc f2       	brlt	.-66     	; 0x3f7e <prvUnlockQueue+0x18>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3fc0:	89 81       	ldd	r24, Y+1	; 0x01
    3fc2:	9a 81       	ldd	r25, Y+2	; 0x02
    3fc4:	2f ef       	ldi	r18, 0xFF	; 255
    3fc6:	fc 01       	movw	r30, r24
    3fc8:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    3fca:	0f 90       	pop	r0
    3fcc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3fce:	0f b6       	in	r0, 0x3f	; 63
    3fd0:	f8 94       	cli
    3fd2:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3fd4:	1b c0       	rjmp	.+54     	; 0x400c <prvUnlockQueue+0xa6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3fd6:	89 81       	ldd	r24, Y+1	; 0x01
    3fd8:	9a 81       	ldd	r25, Y+2	; 0x02
    3fda:	fc 01       	movw	r30, r24
    3fdc:	80 85       	ldd	r24, Z+8	; 0x08
    3fde:	88 23       	and	r24, r24
    3fe0:	a1 f0       	breq	.+40     	; 0x400a <prvUnlockQueue+0xa4>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3fe2:	89 81       	ldd	r24, Y+1	; 0x01
    3fe4:	9a 81       	ldd	r25, Y+2	; 0x02
    3fe6:	08 96       	adiw	r24, 0x08	; 8
    3fe8:	0e 94 20 28 	call	0x5040	; 0x5040 <xTaskRemoveFromEventList>
    3fec:	88 23       	and	r24, r24
    3fee:	11 f0       	breq	.+4      	; 0x3ff4 <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    3ff0:	0e 94 85 29 	call	0x530a	; 0x530a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    3ff4:	89 81       	ldd	r24, Y+1	; 0x01
    3ff6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ff8:	fc 01       	movw	r30, r24
    3ffa:	85 8d       	ldd	r24, Z+29	; 0x1d
    3ffc:	81 50       	subi	r24, 0x01	; 1
    3ffe:	28 2f       	mov	r18, r24
    4000:	89 81       	ldd	r24, Y+1	; 0x01
    4002:	9a 81       	ldd	r25, Y+2	; 0x02
    4004:	fc 01       	movw	r30, r24
    4006:	25 8f       	std	Z+29, r18	; 0x1d
    4008:	01 c0       	rjmp	.+2      	; 0x400c <prvUnlockQueue+0xa6>
			}
			else
			{
				break;
    400a:	06 c0       	rjmp	.+12     	; 0x4018 <prvUnlockQueue+0xb2>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    400c:	89 81       	ldd	r24, Y+1	; 0x01
    400e:	9a 81       	ldd	r25, Y+2	; 0x02
    4010:	fc 01       	movw	r30, r24
    4012:	85 8d       	ldd	r24, Z+29	; 0x1d
    4014:	18 16       	cp	r1, r24
    4016:	fc f2       	brlt	.-66     	; 0x3fd6 <prvUnlockQueue+0x70>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4018:	89 81       	ldd	r24, Y+1	; 0x01
    401a:	9a 81       	ldd	r25, Y+2	; 0x02
    401c:	2f ef       	ldi	r18, 0xFF	; 255
    401e:	fc 01       	movw	r30, r24
    4020:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    4022:	0f 90       	pop	r0
    4024:	0f be       	out	0x3f, r0	; 63
}
    4026:	0f 90       	pop	r0
    4028:	0f 90       	pop	r0
    402a:	df 91       	pop	r29
    402c:	cf 91       	pop	r28
    402e:	08 95       	ret

00004030 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    4030:	cf 93       	push	r28
    4032:	df 93       	push	r29
    4034:	00 d0       	rcall	.+0      	; 0x4036 <prvIsQueueEmpty+0x6>
    4036:	cd b7       	in	r28, 0x3d	; 61
    4038:	de b7       	in	r29, 0x3e	; 62
    403a:	9b 83       	std	Y+3, r25	; 0x03
    403c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    403e:	0f b6       	in	r0, 0x3f	; 63
    4040:	f8 94       	cli
    4042:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    4044:	8a 81       	ldd	r24, Y+2	; 0x02
    4046:	9b 81       	ldd	r25, Y+3	; 0x03
    4048:	fc 01       	movw	r30, r24
    404a:	82 8d       	ldd	r24, Z+26	; 0x1a
    404c:	88 23       	and	r24, r24
    404e:	19 f4       	brne	.+6      	; 0x4056 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    4050:	81 e0       	ldi	r24, 0x01	; 1
    4052:	89 83       	std	Y+1, r24	; 0x01
    4054:	01 c0       	rjmp	.+2      	; 0x4058 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    4056:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4058:	0f 90       	pop	r0
    405a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    405c:	89 81       	ldd	r24, Y+1	; 0x01
}
    405e:	0f 90       	pop	r0
    4060:	0f 90       	pop	r0
    4062:	0f 90       	pop	r0
    4064:	df 91       	pop	r29
    4066:	cf 91       	pop	r28
    4068:	08 95       	ret

0000406a <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    406a:	cf 93       	push	r28
    406c:	df 93       	push	r29
    406e:	00 d0       	rcall	.+0      	; 0x4070 <xQueueIsQueueEmptyFromISR+0x6>
    4070:	cd b7       	in	r28, 0x3d	; 61
    4072:	de b7       	in	r29, 0x3e	; 62
    4074:	9b 83       	std	Y+3, r25	; 0x03
    4076:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    4078:	8a 81       	ldd	r24, Y+2	; 0x02
    407a:	9b 81       	ldd	r25, Y+3	; 0x03
    407c:	fc 01       	movw	r30, r24
    407e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4080:	88 23       	and	r24, r24
    4082:	19 f4       	brne	.+6      	; 0x408a <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    4084:	81 e0       	ldi	r24, 0x01	; 1
    4086:	89 83       	std	Y+1, r24	; 0x01
    4088:	01 c0       	rjmp	.+2      	; 0x408c <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    408a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    408c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    408e:	0f 90       	pop	r0
    4090:	0f 90       	pop	r0
    4092:	0f 90       	pop	r0
    4094:	df 91       	pop	r29
    4096:	cf 91       	pop	r28
    4098:	08 95       	ret

0000409a <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    409a:	cf 93       	push	r28
    409c:	df 93       	push	r29
    409e:	00 d0       	rcall	.+0      	; 0x40a0 <prvIsQueueFull+0x6>
    40a0:	cd b7       	in	r28, 0x3d	; 61
    40a2:	de b7       	in	r29, 0x3e	; 62
    40a4:	9b 83       	std	Y+3, r25	; 0x03
    40a6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    40a8:	0f b6       	in	r0, 0x3f	; 63
    40aa:	f8 94       	cli
    40ac:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    40ae:	8a 81       	ldd	r24, Y+2	; 0x02
    40b0:	9b 81       	ldd	r25, Y+3	; 0x03
    40b2:	fc 01       	movw	r30, r24
    40b4:	22 8d       	ldd	r18, Z+26	; 0x1a
    40b6:	8a 81       	ldd	r24, Y+2	; 0x02
    40b8:	9b 81       	ldd	r25, Y+3	; 0x03
    40ba:	fc 01       	movw	r30, r24
    40bc:	83 8d       	ldd	r24, Z+27	; 0x1b
    40be:	28 17       	cp	r18, r24
    40c0:	19 f4       	brne	.+6      	; 0x40c8 <prvIsQueueFull+0x2e>
		{
			xReturn = pdTRUE;
    40c2:	81 e0       	ldi	r24, 0x01	; 1
    40c4:	89 83       	std	Y+1, r24	; 0x01
    40c6:	01 c0       	rjmp	.+2      	; 0x40ca <prvIsQueueFull+0x30>
		}
		else
		{
			xReturn = pdFALSE;
    40c8:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    40ca:	0f 90       	pop	r0
    40cc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    40ce:	89 81       	ldd	r24, Y+1	; 0x01
}
    40d0:	0f 90       	pop	r0
    40d2:	0f 90       	pop	r0
    40d4:	0f 90       	pop	r0
    40d6:	df 91       	pop	r29
    40d8:	cf 91       	pop	r28
    40da:	08 95       	ret

000040dc <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    40dc:	cf 93       	push	r28
    40de:	df 93       	push	r29
    40e0:	00 d0       	rcall	.+0      	; 0x40e2 <xQueueIsQueueFullFromISR+0x6>
    40e2:	cd b7       	in	r28, 0x3d	; 61
    40e4:	de b7       	in	r29, 0x3e	; 62
    40e6:	9b 83       	std	Y+3, r25	; 0x03
    40e8:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    40ea:	8a 81       	ldd	r24, Y+2	; 0x02
    40ec:	9b 81       	ldd	r25, Y+3	; 0x03
    40ee:	fc 01       	movw	r30, r24
    40f0:	22 8d       	ldd	r18, Z+26	; 0x1a
    40f2:	8a 81       	ldd	r24, Y+2	; 0x02
    40f4:	9b 81       	ldd	r25, Y+3	; 0x03
    40f6:	fc 01       	movw	r30, r24
    40f8:	83 8d       	ldd	r24, Z+27	; 0x1b
    40fa:	28 17       	cp	r18, r24
    40fc:	19 f4       	brne	.+6      	; 0x4104 <xQueueIsQueueFullFromISR+0x28>
	{
		xReturn = pdTRUE;
    40fe:	81 e0       	ldi	r24, 0x01	; 1
    4100:	89 83       	std	Y+1, r24	; 0x01
    4102:	01 c0       	rjmp	.+2      	; 0x4106 <xQueueIsQueueFullFromISR+0x2a>
	}
	else
	{
		xReturn = pdFALSE;
    4104:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4106:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4108:	0f 90       	pop	r0
    410a:	0f 90       	pop	r0
    410c:	0f 90       	pop	r0
    410e:	df 91       	pop	r29
    4110:	cf 91       	pop	r28
    4112:	08 95       	ret

00004114 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4114:	af 92       	push	r10
    4116:	bf 92       	push	r11
    4118:	cf 92       	push	r12
    411a:	df 92       	push	r13
    411c:	ef 92       	push	r14
    411e:	ff 92       	push	r15
    4120:	0f 93       	push	r16
    4122:	1f 93       	push	r17
    4124:	cf 93       	push	r28
    4126:	df 93       	push	r29
    4128:	cd b7       	in	r28, 0x3d	; 61
    412a:	de b7       	in	r29, 0x3e	; 62
    412c:	64 97       	sbiw	r28, 0x14	; 20
    412e:	0f b6       	in	r0, 0x3f	; 63
    4130:	f8 94       	cli
    4132:	de bf       	out	0x3e, r29	; 62
    4134:	0f be       	out	0x3f, r0	; 63
    4136:	cd bf       	out	0x3d, r28	; 61
    4138:	9f 83       	std	Y+7, r25	; 0x07
    413a:	8e 83       	std	Y+6, r24	; 0x06
    413c:	79 87       	std	Y+9, r23	; 0x09
    413e:	68 87       	std	Y+8, r22	; 0x08
    4140:	5b 87       	std	Y+11, r21	; 0x0b
    4142:	4a 87       	std	Y+10, r20	; 0x0a
    4144:	3d 87       	std	Y+13, r19	; 0x0d
    4146:	2c 87       	std	Y+12, r18	; 0x0c
    4148:	0e 87       	std	Y+14, r16	; 0x0e
    414a:	f8 8a       	std	Y+16, r15	; 0x10
    414c:	ef 86       	std	Y+15, r14	; 0x0f
    414e:	da 8a       	std	Y+18, r13	; 0x12
    4150:	c9 8a       	std	Y+17, r12	; 0x11
    4152:	bc 8a       	std	Y+20, r11	; 0x14
    4154:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    4156:	29 89       	ldd	r18, Y+17	; 0x11
    4158:	3a 89       	ldd	r19, Y+18	; 0x12
    415a:	8a 85       	ldd	r24, Y+10	; 0x0a
    415c:	9b 85       	ldd	r25, Y+11	; 0x0b
    415e:	b9 01       	movw	r22, r18
    4160:	0e 94 e7 2a 	call	0x55ce	; 0x55ce <prvAllocateTCBAndStack>
    4164:	9b 83       	std	Y+3, r25	; 0x03
    4166:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
    4168:	8a 81       	ldd	r24, Y+2	; 0x02
    416a:	9b 81       	ldd	r25, Y+3	; 0x03
    416c:	89 2b       	or	r24, r25
    416e:	09 f4       	brne	.+2      	; 0x4172 <xTaskGenericCreate+0x5e>
    4170:	91 c0       	rjmp	.+290    	; 0x4294 <xTaskGenericCreate+0x180>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    4172:	8a 81       	ldd	r24, Y+2	; 0x02
    4174:	9b 81       	ldd	r25, Y+3	; 0x03
    4176:	fc 01       	movw	r30, r24
    4178:	27 89       	ldd	r18, Z+23	; 0x17
    417a:	30 8d       	ldd	r19, Z+24	; 0x18
    417c:	8a 85       	ldd	r24, Y+10	; 0x0a
    417e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4180:	01 97       	sbiw	r24, 0x01	; 1
    4182:	82 0f       	add	r24, r18
    4184:	93 1f       	adc	r25, r19
    4186:	9d 83       	std	Y+5, r25	; 0x05
    4188:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    418a:	4a 85       	ldd	r20, Y+10	; 0x0a
    418c:	5b 85       	ldd	r21, Y+11	; 0x0b
    418e:	2b 89       	ldd	r18, Y+19	; 0x13
    4190:	3c 89       	ldd	r19, Y+20	; 0x14
    4192:	68 85       	ldd	r22, Y+8	; 0x08
    4194:	79 85       	ldd	r23, Y+9	; 0x09
    4196:	8a 81       	ldd	r24, Y+2	; 0x02
    4198:	9b 81       	ldd	r25, Y+3	; 0x03
    419a:	8a 01       	movw	r16, r20
    419c:	4e 85       	ldd	r20, Y+14	; 0x0e
    419e:	0e 94 8f 29 	call	0x531e	; 0x531e <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    41a2:	4c 85       	ldd	r20, Y+12	; 0x0c
    41a4:	5d 85       	ldd	r21, Y+13	; 0x0d
    41a6:	2e 81       	ldd	r18, Y+6	; 0x06
    41a8:	3f 81       	ldd	r19, Y+7	; 0x07
    41aa:	8c 81       	ldd	r24, Y+4	; 0x04
    41ac:	9d 81       	ldd	r25, Y+5	; 0x05
    41ae:	b9 01       	movw	r22, r18
    41b0:	0e 94 32 16 	call	0x2c64	; 0x2c64 <pxPortInitialiseStack>
    41b4:	9c 01       	movw	r18, r24
    41b6:	8a 81       	ldd	r24, Y+2	; 0x02
    41b8:	9b 81       	ldd	r25, Y+3	; 0x03
    41ba:	fc 01       	movw	r30, r24
    41bc:	31 83       	std	Z+1, r19	; 0x01
    41be:	20 83       	st	Z, r18
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    41c0:	8f 85       	ldd	r24, Y+15	; 0x0f
    41c2:	98 89       	ldd	r25, Y+16	; 0x10
    41c4:	89 2b       	or	r24, r25
    41c6:	39 f0       	breq	.+14     	; 0x41d6 <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    41c8:	8f 85       	ldd	r24, Y+15	; 0x0f
    41ca:	98 89       	ldd	r25, Y+16	; 0x10
    41cc:	2a 81       	ldd	r18, Y+2	; 0x02
    41ce:	3b 81       	ldd	r19, Y+3	; 0x03
    41d0:	fc 01       	movw	r30, r24
    41d2:	31 83       	std	Z+1, r19	; 0x01
    41d4:	20 83       	st	Z, r18
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    41d6:	0f b6       	in	r0, 0x3f	; 63
    41d8:	f8 94       	cli
    41da:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    41dc:	80 91 98 02 	lds	r24, 0x0298
    41e0:	8f 5f       	subi	r24, 0xFF	; 255
    41e2:	80 93 98 02 	sts	0x0298, r24
			if( pxCurrentTCB == NULL )
    41e6:	80 91 40 02 	lds	r24, 0x0240
    41ea:	90 91 41 02 	lds	r25, 0x0241
    41ee:	89 2b       	or	r24, r25
    41f0:	69 f4       	brne	.+26     	; 0x420c <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    41f2:	8a 81       	ldd	r24, Y+2	; 0x02
    41f4:	9b 81       	ldd	r25, Y+3	; 0x03
    41f6:	90 93 41 02 	sts	0x0241, r25
    41fa:	80 93 40 02 	sts	0x0240, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    41fe:	80 91 98 02 	lds	r24, 0x0298
    4202:	81 30       	cpi	r24, 0x01	; 1
    4204:	b1 f4       	brne	.+44     	; 0x4232 <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    4206:	0e 94 1c 2a 	call	0x5438	; 0x5438 <prvInitialiseTaskLists>
    420a:	13 c0       	rjmp	.+38     	; 0x4232 <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    420c:	80 91 9c 02 	lds	r24, 0x029C
    4210:	88 23       	and	r24, r24
    4212:	79 f4       	brne	.+30     	; 0x4232 <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4214:	80 91 40 02 	lds	r24, 0x0240
    4218:	90 91 41 02 	lds	r25, 0x0241
    421c:	fc 01       	movw	r30, r24
    421e:	96 89       	ldd	r25, Z+22	; 0x16
    4220:	8e 85       	ldd	r24, Y+14	; 0x0e
    4222:	89 17       	cp	r24, r25
    4224:	30 f0       	brcs	.+12     	; 0x4232 <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
    4226:	8a 81       	ldd	r24, Y+2	; 0x02
    4228:	9b 81       	ldd	r25, Y+3	; 0x03
    422a:	90 93 41 02 	sts	0x0241, r25
    422e:	80 93 40 02 	sts	0x0240, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    4232:	80 91 a0 02 	lds	r24, 0x02A0
    4236:	8f 5f       	subi	r24, 0xFF	; 255
    4238:	80 93 a0 02 	sts	0x02A0, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    423c:	8a 81       	ldd	r24, Y+2	; 0x02
    423e:	9b 81       	ldd	r25, Y+3	; 0x03
    4240:	fc 01       	movw	r30, r24
    4242:	96 89       	ldd	r25, Z+22	; 0x16
    4244:	80 91 9b 02 	lds	r24, 0x029B
    4248:	89 17       	cp	r24, r25
    424a:	30 f4       	brcc	.+12     	; 0x4258 <xTaskGenericCreate+0x144>
    424c:	8a 81       	ldd	r24, Y+2	; 0x02
    424e:	9b 81       	ldd	r25, Y+3	; 0x03
    4250:	fc 01       	movw	r30, r24
    4252:	86 89       	ldd	r24, Z+22	; 0x16
    4254:	80 93 9b 02 	sts	0x029B, r24
    4258:	8a 81       	ldd	r24, Y+2	; 0x02
    425a:	9b 81       	ldd	r25, Y+3	; 0x03
    425c:	ac 01       	movw	r20, r24
    425e:	4e 5f       	subi	r20, 0xFE	; 254
    4260:	5f 4f       	sbci	r21, 0xFF	; 255
    4262:	8a 81       	ldd	r24, Y+2	; 0x02
    4264:	9b 81       	ldd	r25, Y+3	; 0x03
    4266:	fc 01       	movw	r30, r24
    4268:	86 89       	ldd	r24, Z+22	; 0x16
    426a:	28 2f       	mov	r18, r24
    426c:	30 e0       	ldi	r19, 0x00	; 0
    426e:	c9 01       	movw	r24, r18
    4270:	88 0f       	add	r24, r24
    4272:	99 1f       	adc	r25, r25
    4274:	88 0f       	add	r24, r24
    4276:	99 1f       	adc	r25, r25
    4278:	88 0f       	add	r24, r24
    427a:	99 1f       	adc	r25, r25
    427c:	82 0f       	add	r24, r18
    427e:	93 1f       	adc	r25, r19
    4280:	8e 5b       	subi	r24, 0xBE	; 190
    4282:	9d 4f       	sbci	r25, 0xFD	; 253
    4284:	ba 01       	movw	r22, r20
    4286:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>

			xReturn = pdPASS;
    428a:	81 e0       	ldi	r24, 0x01	; 1
    428c:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    428e:	0f 90       	pop	r0
    4290:	0f be       	out	0x3f, r0	; 63
    4292:	02 c0       	rjmp	.+4      	; 0x4298 <xTaskGenericCreate+0x184>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4294:	8f ef       	ldi	r24, 0xFF	; 255
    4296:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    4298:	89 81       	ldd	r24, Y+1	; 0x01
    429a:	81 30       	cpi	r24, 0x01	; 1
    429c:	79 f4       	brne	.+30     	; 0x42bc <xTaskGenericCreate+0x1a8>
	{
		if( xSchedulerRunning != pdFALSE )
    429e:	80 91 9c 02 	lds	r24, 0x029C
    42a2:	88 23       	and	r24, r24
    42a4:	59 f0       	breq	.+22     	; 0x42bc <xTaskGenericCreate+0x1a8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    42a6:	80 91 40 02 	lds	r24, 0x0240
    42aa:	90 91 41 02 	lds	r25, 0x0241
    42ae:	fc 01       	movw	r30, r24
    42b0:	96 89       	ldd	r25, Z+22	; 0x16
    42b2:	8e 85       	ldd	r24, Y+14	; 0x0e
    42b4:	98 17       	cp	r25, r24
    42b6:	10 f4       	brcc	.+4      	; 0x42bc <xTaskGenericCreate+0x1a8>
			{
				taskYIELD_IF_USING_PREEMPTION();
    42b8:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    42bc:	89 81       	ldd	r24, Y+1	; 0x01
}
    42be:	64 96       	adiw	r28, 0x14	; 20
    42c0:	0f b6       	in	r0, 0x3f	; 63
    42c2:	f8 94       	cli
    42c4:	de bf       	out	0x3e, r29	; 62
    42c6:	0f be       	out	0x3f, r0	; 63
    42c8:	cd bf       	out	0x3d, r28	; 61
    42ca:	df 91       	pop	r29
    42cc:	cf 91       	pop	r28
    42ce:	1f 91       	pop	r17
    42d0:	0f 91       	pop	r16
    42d2:	ff 90       	pop	r15
    42d4:	ef 90       	pop	r14
    42d6:	df 90       	pop	r13
    42d8:	cf 90       	pop	r12
    42da:	bf 90       	pop	r11
    42dc:	af 90       	pop	r10
    42de:	08 95       	ret

000042e0 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    42e0:	cf 93       	push	r28
    42e2:	df 93       	push	r29
    42e4:	00 d0       	rcall	.+0      	; 0x42e6 <vTaskDelete+0x6>
    42e6:	1f 92       	push	r1
    42e8:	cd b7       	in	r28, 0x3d	; 61
    42ea:	de b7       	in	r29, 0x3e	; 62
    42ec:	9c 83       	std	Y+4, r25	; 0x04
    42ee:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    42f0:	0f b6       	in	r0, 0x3f	; 63
    42f2:	f8 94       	cli
    42f4:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    42f6:	8b 81       	ldd	r24, Y+3	; 0x03
    42f8:	9c 81       	ldd	r25, Y+4	; 0x04
    42fa:	89 2b       	or	r24, r25
    42fc:	29 f4       	brne	.+10     	; 0x4308 <vTaskDelete+0x28>
    42fe:	80 91 40 02 	lds	r24, 0x0240
    4302:	90 91 41 02 	lds	r25, 0x0241
    4306:	02 c0       	rjmp	.+4      	; 0x430c <vTaskDelete+0x2c>
    4308:	8b 81       	ldd	r24, Y+3	; 0x03
    430a:	9c 81       	ldd	r25, Y+4	; 0x04
    430c:	9a 83       	std	Y+2, r25	; 0x02
    430e:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4310:	89 81       	ldd	r24, Y+1	; 0x01
    4312:	9a 81       	ldd	r25, Y+2	; 0x02
    4314:	02 96       	adiw	r24, 0x02	; 2
    4316:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    431a:	89 81       	ldd	r24, Y+1	; 0x01
    431c:	9a 81       	ldd	r25, Y+2	; 0x02
    431e:	fc 01       	movw	r30, r24
    4320:	84 89       	ldd	r24, Z+20	; 0x14
    4322:	95 89       	ldd	r25, Z+21	; 0x15
    4324:	89 2b       	or	r24, r25
    4326:	29 f0       	breq	.+10     	; 0x4332 <vTaskDelete+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4328:	89 81       	ldd	r24, Y+1	; 0x01
    432a:	9a 81       	ldd	r25, Y+2	; 0x02
    432c:	0c 96       	adiw	r24, 0x0c	; 12
    432e:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    4332:	89 81       	ldd	r24, Y+1	; 0x01
    4334:	9a 81       	ldd	r25, Y+2	; 0x02
    4336:	02 96       	adiw	r24, 0x02	; 2
    4338:	bc 01       	movw	r22, r24
    433a:	85 e8       	ldi	r24, 0x85	; 133
    433c:	92 e0       	ldi	r25, 0x02	; 2
    433e:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    4342:	80 91 8e 02 	lds	r24, 0x028E
    4346:	8f 5f       	subi	r24, 0xFF	; 255
    4348:	80 93 8e 02 	sts	0x028E, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    434c:	80 91 a0 02 	lds	r24, 0x02A0
    4350:	8f 5f       	subi	r24, 0xFF	; 255
    4352:	80 93 a0 02 	sts	0x02A0, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4356:	0f 90       	pop	r0
    4358:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    435a:	80 91 9c 02 	lds	r24, 0x029C
    435e:	88 23       	and	r24, r24
    4360:	99 f0       	breq	.+38     	; 0x4388 <vTaskDelete+0xa8>
		{
			if( pxTCB == pxCurrentTCB )
    4362:	80 91 40 02 	lds	r24, 0x0240
    4366:	90 91 41 02 	lds	r25, 0x0241
    436a:	29 81       	ldd	r18, Y+1	; 0x01
    436c:	3a 81       	ldd	r19, Y+2	; 0x02
    436e:	28 17       	cp	r18, r24
    4370:	39 07       	cpc	r19, r25
    4372:	19 f4       	brne	.+6      	; 0x437a <vTaskDelete+0x9a>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    4374:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
    4378:	07 c0       	rjmp	.+14     	; 0x4388 <vTaskDelete+0xa8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    437a:	0f b6       	in	r0, 0x3f	; 63
    437c:	f8 94       	cli
    437e:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    4380:	0e 94 af 2b 	call	0x575e	; 0x575e <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    4384:	0f 90       	pop	r0
    4386:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    4388:	0f 90       	pop	r0
    438a:	0f 90       	pop	r0
    438c:	0f 90       	pop	r0
    438e:	0f 90       	pop	r0
    4390:	df 91       	pop	r29
    4392:	cf 91       	pop	r28
    4394:	08 95       	ret

00004396 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    4396:	cf 93       	push	r28
    4398:	df 93       	push	r29
    439a:	cd b7       	in	r28, 0x3d	; 61
    439c:	de b7       	in	r29, 0x3e	; 62
    439e:	2a 97       	sbiw	r28, 0x0a	; 10
    43a0:	0f b6       	in	r0, 0x3f	; 63
    43a2:	f8 94       	cli
    43a4:	de bf       	out	0x3e, r29	; 62
    43a6:	0f be       	out	0x3f, r0	; 63
    43a8:	cd bf       	out	0x3d, r28	; 61
    43aa:	98 87       	std	Y+8, r25	; 0x08
    43ac:	8f 83       	std	Y+7, r24	; 0x07
    43ae:	7a 87       	std	Y+10, r23	; 0x0a
    43b0:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    43b2:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    43b4:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    43b8:	80 91 99 02 	lds	r24, 0x0299
    43bc:	90 91 9a 02 	lds	r25, 0x029A
    43c0:	9b 83       	std	Y+3, r25	; 0x03
    43c2:	8a 83       	std	Y+2, r24	; 0x02

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    43c4:	8f 81       	ldd	r24, Y+7	; 0x07
    43c6:	98 85       	ldd	r25, Y+8	; 0x08
    43c8:	fc 01       	movw	r30, r24
    43ca:	20 81       	ld	r18, Z
    43cc:	31 81       	ldd	r19, Z+1	; 0x01
    43ce:	89 85       	ldd	r24, Y+9	; 0x09
    43d0:	9a 85       	ldd	r25, Y+10	; 0x0a
    43d2:	82 0f       	add	r24, r18
    43d4:	93 1f       	adc	r25, r19
    43d6:	9d 83       	std	Y+5, r25	; 0x05
    43d8:	8c 83       	std	Y+4, r24	; 0x04

			if( xConstTickCount < *pxPreviousWakeTime )
    43da:	8f 81       	ldd	r24, Y+7	; 0x07
    43dc:	98 85       	ldd	r25, Y+8	; 0x08
    43de:	fc 01       	movw	r30, r24
    43e0:	20 81       	ld	r18, Z
    43e2:	31 81       	ldd	r19, Z+1	; 0x01
    43e4:	8a 81       	ldd	r24, Y+2	; 0x02
    43e6:	9b 81       	ldd	r25, Y+3	; 0x03
    43e8:	82 17       	cp	r24, r18
    43ea:	93 07       	cpc	r25, r19
    43ec:	a0 f4       	brcc	.+40     	; 0x4416 <vTaskDelayUntil+0x80>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    43ee:	8f 81       	ldd	r24, Y+7	; 0x07
    43f0:	98 85       	ldd	r25, Y+8	; 0x08
    43f2:	fc 01       	movw	r30, r24
    43f4:	20 81       	ld	r18, Z
    43f6:	31 81       	ldd	r19, Z+1	; 0x01
    43f8:	8c 81       	ldd	r24, Y+4	; 0x04
    43fa:	9d 81       	ldd	r25, Y+5	; 0x05
    43fc:	82 17       	cp	r24, r18
    43fe:	93 07       	cpc	r25, r19
    4400:	e8 f4       	brcc	.+58     	; 0x443c <vTaskDelayUntil+0xa6>
    4402:	2c 81       	ldd	r18, Y+4	; 0x04
    4404:	3d 81       	ldd	r19, Y+5	; 0x05
    4406:	8a 81       	ldd	r24, Y+2	; 0x02
    4408:	9b 81       	ldd	r25, Y+3	; 0x03
    440a:	82 17       	cp	r24, r18
    440c:	93 07       	cpc	r25, r19
    440e:	b0 f4       	brcc	.+44     	; 0x443c <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    4410:	81 e0       	ldi	r24, 0x01	; 1
    4412:	89 83       	std	Y+1, r24	; 0x01
    4414:	13 c0       	rjmp	.+38     	; 0x443c <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    4416:	8f 81       	ldd	r24, Y+7	; 0x07
    4418:	98 85       	ldd	r25, Y+8	; 0x08
    441a:	fc 01       	movw	r30, r24
    441c:	20 81       	ld	r18, Z
    441e:	31 81       	ldd	r19, Z+1	; 0x01
    4420:	8c 81       	ldd	r24, Y+4	; 0x04
    4422:	9d 81       	ldd	r25, Y+5	; 0x05
    4424:	82 17       	cp	r24, r18
    4426:	93 07       	cpc	r25, r19
    4428:	38 f0       	brcs	.+14     	; 0x4438 <vTaskDelayUntil+0xa2>
    442a:	2c 81       	ldd	r18, Y+4	; 0x04
    442c:	3d 81       	ldd	r19, Y+5	; 0x05
    442e:	8a 81       	ldd	r24, Y+2	; 0x02
    4430:	9b 81       	ldd	r25, Y+3	; 0x03
    4432:	82 17       	cp	r24, r18
    4434:	93 07       	cpc	r25, r19
    4436:	10 f4       	brcc	.+4      	; 0x443c <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    4438:	81 e0       	ldi	r24, 0x01	; 1
    443a:	89 83       	std	Y+1, r24	; 0x01
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    443c:	8f 81       	ldd	r24, Y+7	; 0x07
    443e:	98 85       	ldd	r25, Y+8	; 0x08
    4440:	2c 81       	ldd	r18, Y+4	; 0x04
    4442:	3d 81       	ldd	r19, Y+5	; 0x05
    4444:	fc 01       	movw	r30, r24
    4446:	31 83       	std	Z+1, r19	; 0x01
    4448:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
    444a:	89 81       	ldd	r24, Y+1	; 0x01
    444c:	88 23       	and	r24, r24
    444e:	59 f0       	breq	.+22     	; 0x4466 <vTaskDelayUntil+0xd0>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4450:	80 91 40 02 	lds	r24, 0x0240
    4454:	90 91 41 02 	lds	r25, 0x0241
    4458:	02 96       	adiw	r24, 0x02	; 2
    445a:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    445e:	8c 81       	ldd	r24, Y+4	; 0x04
    4460:	9d 81       	ldd	r25, Y+5	; 0x05
    4462:	0e 94 9c 2a 	call	0x5538	; 0x5538 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    4466:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>
    446a:	8e 83       	std	Y+6, r24	; 0x06

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    446c:	8e 81       	ldd	r24, Y+6	; 0x06
    446e:	88 23       	and	r24, r24
    4470:	11 f4       	brne	.+4      	; 0x4476 <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
    4472:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4476:	2a 96       	adiw	r28, 0x0a	; 10
    4478:	0f b6       	in	r0, 0x3f	; 63
    447a:	f8 94       	cli
    447c:	de bf       	out	0x3e, r29	; 62
    447e:	0f be       	out	0x3f, r0	; 63
    4480:	cd bf       	out	0x3d, r28	; 61
    4482:	df 91       	pop	r29
    4484:	cf 91       	pop	r28
    4486:	08 95       	ret

00004488 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    4488:	cf 93       	push	r28
    448a:	df 93       	push	r29
    448c:	00 d0       	rcall	.+0      	; 0x448e <vTaskDelay+0x6>
    448e:	1f 92       	push	r1
    4490:	1f 92       	push	r1
    4492:	cd b7       	in	r28, 0x3d	; 61
    4494:	de b7       	in	r29, 0x3e	; 62
    4496:	9d 83       	std	Y+5, r25	; 0x05
    4498:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    449a:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    449c:	8c 81       	ldd	r24, Y+4	; 0x04
    449e:	9d 81       	ldd	r25, Y+5	; 0x05
    44a0:	89 2b       	or	r24, r25
    44a2:	d1 f0       	breq	.+52     	; 0x44d8 <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    44a4:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    44a8:	20 91 99 02 	lds	r18, 0x0299
    44ac:	30 91 9a 02 	lds	r19, 0x029A
    44b0:	8c 81       	ldd	r24, Y+4	; 0x04
    44b2:	9d 81       	ldd	r25, Y+5	; 0x05
    44b4:	82 0f       	add	r24, r18
    44b6:	93 1f       	adc	r25, r19
    44b8:	9b 83       	std	Y+3, r25	; 0x03
    44ba:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    44bc:	80 91 40 02 	lds	r24, 0x0240
    44c0:	90 91 41 02 	lds	r25, 0x0241
    44c4:	02 96       	adiw	r24, 0x02	; 2
    44c6:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    44ca:	8a 81       	ldd	r24, Y+2	; 0x02
    44cc:	9b 81       	ldd	r25, Y+3	; 0x03
    44ce:	0e 94 9c 2a 	call	0x5538	; 0x5538 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    44d2:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>
    44d6:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    44d8:	89 81       	ldd	r24, Y+1	; 0x01
    44da:	88 23       	and	r24, r24
    44dc:	11 f4       	brne	.+4      	; 0x44e2 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    44de:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    44e2:	0f 90       	pop	r0
    44e4:	0f 90       	pop	r0
    44e6:	0f 90       	pop	r0
    44e8:	0f 90       	pop	r0
    44ea:	0f 90       	pop	r0
    44ec:	df 91       	pop	r29
    44ee:	cf 91       	pop	r28
    44f0:	08 95       	ret

000044f2 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
    44f2:	cf 93       	push	r28
    44f4:	df 93       	push	r29
    44f6:	00 d0       	rcall	.+0      	; 0x44f8 <uxTaskPriorityGet+0x6>
    44f8:	1f 92       	push	r1
    44fa:	1f 92       	push	r1
    44fc:	cd b7       	in	r28, 0x3d	; 61
    44fe:	de b7       	in	r29, 0x3e	; 62
    4500:	9d 83       	std	Y+5, r25	; 0x05
    4502:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    4504:	0f b6       	in	r0, 0x3f	; 63
    4506:	f8 94       	cli
    4508:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    450a:	8c 81       	ldd	r24, Y+4	; 0x04
    450c:	9d 81       	ldd	r25, Y+5	; 0x05
    450e:	89 2b       	or	r24, r25
    4510:	29 f4       	brne	.+10     	; 0x451c <uxTaskPriorityGet+0x2a>
    4512:	80 91 40 02 	lds	r24, 0x0240
    4516:	90 91 41 02 	lds	r25, 0x0241
    451a:	02 c0       	rjmp	.+4      	; 0x4520 <uxTaskPriorityGet+0x2e>
    451c:	8c 81       	ldd	r24, Y+4	; 0x04
    451e:	9d 81       	ldd	r25, Y+5	; 0x05
    4520:	9a 83       	std	Y+2, r25	; 0x02
    4522:	89 83       	std	Y+1, r24	; 0x01
			uxReturn = pxTCB->uxPriority;
    4524:	89 81       	ldd	r24, Y+1	; 0x01
    4526:	9a 81       	ldd	r25, Y+2	; 0x02
    4528:	fc 01       	movw	r30, r24
    452a:	86 89       	ldd	r24, Z+22	; 0x16
    452c:	8b 83       	std	Y+3, r24	; 0x03
		}
		taskEXIT_CRITICAL();
    452e:	0f 90       	pop	r0
    4530:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    4532:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4534:	0f 90       	pop	r0
    4536:	0f 90       	pop	r0
    4538:	0f 90       	pop	r0
    453a:	0f 90       	pop	r0
    453c:	0f 90       	pop	r0
    453e:	df 91       	pop	r29
    4540:	cf 91       	pop	r28
    4542:	08 95       	ret

00004544 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
	{
    4544:	cf 93       	push	r28
    4546:	df 93       	push	r29
    4548:	00 d0       	rcall	.+0      	; 0x454a <uxTaskPriorityGetFromISR+0x6>
    454a:	00 d0       	rcall	.+0      	; 0x454c <uxTaskPriorityGetFromISR+0x8>
    454c:	cd b7       	in	r28, 0x3d	; 61
    454e:	de b7       	in	r29, 0x3e	; 62
    4550:	9e 83       	std	Y+6, r25	; 0x06
    4552:	8d 83       	std	Y+5, r24	; 0x05
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
    4554:	19 82       	std	Y+1, r1	; 0x01
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    4556:	8d 81       	ldd	r24, Y+5	; 0x05
    4558:	9e 81       	ldd	r25, Y+6	; 0x06
    455a:	89 2b       	or	r24, r25
    455c:	29 f4       	brne	.+10     	; 0x4568 <uxTaskPriorityGetFromISR+0x24>
    455e:	80 91 40 02 	lds	r24, 0x0240
    4562:	90 91 41 02 	lds	r25, 0x0241
    4566:	02 c0       	rjmp	.+4      	; 0x456c <uxTaskPriorityGetFromISR+0x28>
    4568:	8d 81       	ldd	r24, Y+5	; 0x05
    456a:	9e 81       	ldd	r25, Y+6	; 0x06
    456c:	9b 83       	std	Y+3, r25	; 0x03
    456e:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    4570:	8a 81       	ldd	r24, Y+2	; 0x02
    4572:	9b 81       	ldd	r25, Y+3	; 0x03
    4574:	fc 01       	movw	r30, r24
    4576:	86 89       	ldd	r24, Z+22	; 0x16
    4578:	8c 83       	std	Y+4, r24	; 0x04
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
    457a:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    457c:	26 96       	adiw	r28, 0x06	; 6
    457e:	0f b6       	in	r0, 0x3f	; 63
    4580:	f8 94       	cli
    4582:	de bf       	out	0x3e, r29	; 62
    4584:	0f be       	out	0x3f, r0	; 63
    4586:	cd bf       	out	0x3d, r28	; 61
    4588:	df 91       	pop	r29
    458a:	cf 91       	pop	r28
    458c:	08 95       	ret

0000458e <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    458e:	cf 93       	push	r28
    4590:	df 93       	push	r29
    4592:	cd b7       	in	r28, 0x3d	; 61
    4594:	de b7       	in	r29, 0x3e	; 62
    4596:	28 97       	sbiw	r28, 0x08	; 8
    4598:	0f b6       	in	r0, 0x3f	; 63
    459a:	f8 94       	cli
    459c:	de bf       	out	0x3e, r29	; 62
    459e:	0f be       	out	0x3f, r0	; 63
    45a0:	cd bf       	out	0x3d, r28	; 61
    45a2:	9f 83       	std	Y+7, r25	; 0x07
    45a4:	8e 83       	std	Y+6, r24	; 0x06
    45a6:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    45a8:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    45aa:	88 85       	ldd	r24, Y+8	; 0x08
    45ac:	84 30       	cpi	r24, 0x04	; 4
    45ae:	10 f0       	brcs	.+4      	; 0x45b4 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    45b0:	83 e0       	ldi	r24, 0x03	; 3
    45b2:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    45b4:	0f b6       	in	r0, 0x3f	; 63
    45b6:	f8 94       	cli
    45b8:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    45ba:	8e 81       	ldd	r24, Y+6	; 0x06
    45bc:	9f 81       	ldd	r25, Y+7	; 0x07
    45be:	89 2b       	or	r24, r25
    45c0:	29 f4       	brne	.+10     	; 0x45cc <vTaskPrioritySet+0x3e>
    45c2:	80 91 40 02 	lds	r24, 0x0240
    45c6:	90 91 41 02 	lds	r25, 0x0241
    45ca:	02 c0       	rjmp	.+4      	; 0x45d0 <vTaskPrioritySet+0x42>
    45cc:	8e 81       	ldd	r24, Y+6	; 0x06
    45ce:	9f 81       	ldd	r25, Y+7	; 0x07
    45d0:	9b 83       	std	Y+3, r25	; 0x03
    45d2:	8a 83       	std	Y+2, r24	; 0x02

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    45d4:	8a 81       	ldd	r24, Y+2	; 0x02
    45d6:	9b 81       	ldd	r25, Y+3	; 0x03
    45d8:	fc 01       	movw	r30, r24
    45da:	81 a1       	ldd	r24, Z+33	; 0x21
    45dc:	8c 83       	std	Y+4, r24	; 0x04
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    45de:	9c 81       	ldd	r25, Y+4	; 0x04
    45e0:	88 85       	ldd	r24, Y+8	; 0x08
    45e2:	98 17       	cp	r25, r24
    45e4:	09 f4       	brne	.+2      	; 0x45e8 <vTaskPrioritySet+0x5a>
    45e6:	97 c0       	rjmp	.+302    	; 0x4716 <vTaskPrioritySet+0x188>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    45e8:	98 85       	ldd	r25, Y+8	; 0x08
    45ea:	8c 81       	ldd	r24, Y+4	; 0x04
    45ec:	89 17       	cp	r24, r25
    45ee:	a8 f4       	brcc	.+42     	; 0x461a <vTaskPrioritySet+0x8c>
				{
					if( pxTCB != pxCurrentTCB )
    45f0:	80 91 40 02 	lds	r24, 0x0240
    45f4:	90 91 41 02 	lds	r25, 0x0241
    45f8:	2a 81       	ldd	r18, Y+2	; 0x02
    45fa:	3b 81       	ldd	r19, Y+3	; 0x03
    45fc:	28 17       	cp	r18, r24
    45fe:	39 07       	cpc	r19, r25
    4600:	b9 f0       	breq	.+46     	; 0x4630 <vTaskPrioritySet+0xa2>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    4602:	80 91 40 02 	lds	r24, 0x0240
    4606:	90 91 41 02 	lds	r25, 0x0241
    460a:	fc 01       	movw	r30, r24
    460c:	96 89       	ldd	r25, Z+22	; 0x16
    460e:	88 85       	ldd	r24, Y+8	; 0x08
    4610:	89 17       	cp	r24, r25
    4612:	70 f0       	brcs	.+28     	; 0x4630 <vTaskPrioritySet+0xa2>
						{
							xYieldRequired = pdTRUE;
    4614:	81 e0       	ldi	r24, 0x01	; 1
    4616:	89 83       	std	Y+1, r24	; 0x01
    4618:	0b c0       	rjmp	.+22     	; 0x4630 <vTaskPrioritySet+0xa2>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    461a:	80 91 40 02 	lds	r24, 0x0240
    461e:	90 91 41 02 	lds	r25, 0x0241
    4622:	2a 81       	ldd	r18, Y+2	; 0x02
    4624:	3b 81       	ldd	r19, Y+3	; 0x03
    4626:	28 17       	cp	r18, r24
    4628:	39 07       	cpc	r19, r25
    462a:	11 f4       	brne	.+4      	; 0x4630 <vTaskPrioritySet+0xa2>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    462c:	81 e0       	ldi	r24, 0x01	; 1
    462e:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    4630:	8a 81       	ldd	r24, Y+2	; 0x02
    4632:	9b 81       	ldd	r25, Y+3	; 0x03
    4634:	fc 01       	movw	r30, r24
    4636:	86 89       	ldd	r24, Z+22	; 0x16
    4638:	8d 83       	std	Y+5, r24	; 0x05

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    463a:	8a 81       	ldd	r24, Y+2	; 0x02
    463c:	9b 81       	ldd	r25, Y+3	; 0x03
    463e:	fc 01       	movw	r30, r24
    4640:	21 a1       	ldd	r18, Z+33	; 0x21
    4642:	8a 81       	ldd	r24, Y+2	; 0x02
    4644:	9b 81       	ldd	r25, Y+3	; 0x03
    4646:	fc 01       	movw	r30, r24
    4648:	86 89       	ldd	r24, Z+22	; 0x16
    464a:	28 17       	cp	r18, r24
    464c:	29 f4       	brne	.+10     	; 0x4658 <vTaskPrioritySet+0xca>
					{
						pxTCB->uxPriority = uxNewPriority;
    464e:	8a 81       	ldd	r24, Y+2	; 0x02
    4650:	9b 81       	ldd	r25, Y+3	; 0x03
    4652:	28 85       	ldd	r18, Y+8	; 0x08
    4654:	fc 01       	movw	r30, r24
    4656:	26 8b       	std	Z+22, r18	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    4658:	8a 81       	ldd	r24, Y+2	; 0x02
    465a:	9b 81       	ldd	r25, Y+3	; 0x03
    465c:	28 85       	ldd	r18, Y+8	; 0x08
    465e:	fc 01       	movw	r30, r24
    4660:	21 a3       	std	Z+33, r18	; 0x21
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    4662:	8a 81       	ldd	r24, Y+2	; 0x02
    4664:	9b 81       	ldd	r25, Y+3	; 0x03
    4666:	fc 01       	movw	r30, r24
    4668:	84 85       	ldd	r24, Z+12	; 0x0c
    466a:	95 85       	ldd	r25, Z+13	; 0x0d
    466c:	99 23       	and	r25, r25
    466e:	64 f0       	brlt	.+24     	; 0x4688 <vTaskPrioritySet+0xfa>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4670:	88 85       	ldd	r24, Y+8	; 0x08
    4672:	88 2f       	mov	r24, r24
    4674:	90 e0       	ldi	r25, 0x00	; 0
    4676:	24 e0       	ldi	r18, 0x04	; 4
    4678:	30 e0       	ldi	r19, 0x00	; 0
    467a:	28 1b       	sub	r18, r24
    467c:	39 0b       	sbc	r19, r25
    467e:	8a 81       	ldd	r24, Y+2	; 0x02
    4680:	9b 81       	ldd	r25, Y+3	; 0x03
    4682:	fc 01       	movw	r30, r24
    4684:	35 87       	std	Z+13, r19	; 0x0d
    4686:	24 87       	std	Z+12, r18	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    4688:	8a 81       	ldd	r24, Y+2	; 0x02
    468a:	9b 81       	ldd	r25, Y+3	; 0x03
    468c:	fc 01       	movw	r30, r24
    468e:	42 85       	ldd	r20, Z+10	; 0x0a
    4690:	53 85       	ldd	r21, Z+11	; 0x0b
    4692:	8d 81       	ldd	r24, Y+5	; 0x05
    4694:	28 2f       	mov	r18, r24
    4696:	30 e0       	ldi	r19, 0x00	; 0
    4698:	c9 01       	movw	r24, r18
    469a:	88 0f       	add	r24, r24
    469c:	99 1f       	adc	r25, r25
    469e:	88 0f       	add	r24, r24
    46a0:	99 1f       	adc	r25, r25
    46a2:	88 0f       	add	r24, r24
    46a4:	99 1f       	adc	r25, r25
    46a6:	82 0f       	add	r24, r18
    46a8:	93 1f       	adc	r25, r19
    46aa:	8e 5b       	subi	r24, 0xBE	; 190
    46ac:	9d 4f       	sbci	r25, 0xFD	; 253
    46ae:	48 17       	cp	r20, r24
    46b0:	59 07       	cpc	r21, r25
    46b2:	61 f5       	brne	.+88     	; 0x470c <vTaskPrioritySet+0x17e>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    46b4:	8a 81       	ldd	r24, Y+2	; 0x02
    46b6:	9b 81       	ldd	r25, Y+3	; 0x03
    46b8:	02 96       	adiw	r24, 0x02	; 2
    46ba:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    46be:	8a 81       	ldd	r24, Y+2	; 0x02
    46c0:	9b 81       	ldd	r25, Y+3	; 0x03
    46c2:	fc 01       	movw	r30, r24
    46c4:	96 89       	ldd	r25, Z+22	; 0x16
    46c6:	80 91 9b 02 	lds	r24, 0x029B
    46ca:	89 17       	cp	r24, r25
    46cc:	30 f4       	brcc	.+12     	; 0x46da <vTaskPrioritySet+0x14c>
    46ce:	8a 81       	ldd	r24, Y+2	; 0x02
    46d0:	9b 81       	ldd	r25, Y+3	; 0x03
    46d2:	fc 01       	movw	r30, r24
    46d4:	86 89       	ldd	r24, Z+22	; 0x16
    46d6:	80 93 9b 02 	sts	0x029B, r24
    46da:	8a 81       	ldd	r24, Y+2	; 0x02
    46dc:	9b 81       	ldd	r25, Y+3	; 0x03
    46de:	ac 01       	movw	r20, r24
    46e0:	4e 5f       	subi	r20, 0xFE	; 254
    46e2:	5f 4f       	sbci	r21, 0xFF	; 255
    46e4:	8a 81       	ldd	r24, Y+2	; 0x02
    46e6:	9b 81       	ldd	r25, Y+3	; 0x03
    46e8:	fc 01       	movw	r30, r24
    46ea:	86 89       	ldd	r24, Z+22	; 0x16
    46ec:	28 2f       	mov	r18, r24
    46ee:	30 e0       	ldi	r19, 0x00	; 0
    46f0:	c9 01       	movw	r24, r18
    46f2:	88 0f       	add	r24, r24
    46f4:	99 1f       	adc	r25, r25
    46f6:	88 0f       	add	r24, r24
    46f8:	99 1f       	adc	r25, r25
    46fa:	88 0f       	add	r24, r24
    46fc:	99 1f       	adc	r25, r25
    46fe:	82 0f       	add	r24, r18
    4700:	93 1f       	adc	r25, r19
    4702:	8e 5b       	subi	r24, 0xBE	; 190
    4704:	9d 4f       	sbci	r25, 0xFD	; 253
    4706:	ba 01       	movw	r22, r20
    4708:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired == pdTRUE )
    470c:	89 81       	ldd	r24, Y+1	; 0x01
    470e:	81 30       	cpi	r24, 0x01	; 1
    4710:	11 f4       	brne	.+4      	; 0x4716 <vTaskPrioritySet+0x188>
				{
					taskYIELD_IF_USING_PREEMPTION();
    4712:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    4716:	0f 90       	pop	r0
    4718:	0f be       	out	0x3f, r0	; 63
	}
    471a:	28 96       	adiw	r28, 0x08	; 8
    471c:	0f b6       	in	r0, 0x3f	; 63
    471e:	f8 94       	cli
    4720:	de bf       	out	0x3e, r29	; 62
    4722:	0f be       	out	0x3f, r0	; 63
    4724:	cd bf       	out	0x3d, r28	; 61
    4726:	df 91       	pop	r29
    4728:	cf 91       	pop	r28
    472a:	08 95       	ret

0000472c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    472c:	cf 93       	push	r28
    472e:	df 93       	push	r29
    4730:	00 d0       	rcall	.+0      	; 0x4732 <vTaskSuspend+0x6>
    4732:	1f 92       	push	r1
    4734:	cd b7       	in	r28, 0x3d	; 61
    4736:	de b7       	in	r29, 0x3e	; 62
    4738:	9c 83       	std	Y+4, r25	; 0x04
    473a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    473c:	0f b6       	in	r0, 0x3f	; 63
    473e:	f8 94       	cli
    4740:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    4742:	8b 81       	ldd	r24, Y+3	; 0x03
    4744:	9c 81       	ldd	r25, Y+4	; 0x04
    4746:	89 2b       	or	r24, r25
    4748:	29 f4       	brne	.+10     	; 0x4754 <vTaskSuspend+0x28>
    474a:	80 91 40 02 	lds	r24, 0x0240
    474e:	90 91 41 02 	lds	r25, 0x0241
    4752:	02 c0       	rjmp	.+4      	; 0x4758 <vTaskSuspend+0x2c>
    4754:	8b 81       	ldd	r24, Y+3	; 0x03
    4756:	9c 81       	ldd	r25, Y+4	; 0x04
    4758:	9a 83       	std	Y+2, r25	; 0x02
    475a:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    475c:	89 81       	ldd	r24, Y+1	; 0x01
    475e:	9a 81       	ldd	r25, Y+2	; 0x02
    4760:	02 96       	adiw	r24, 0x02	; 2
    4762:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4766:	89 81       	ldd	r24, Y+1	; 0x01
    4768:	9a 81       	ldd	r25, Y+2	; 0x02
    476a:	fc 01       	movw	r30, r24
    476c:	84 89       	ldd	r24, Z+20	; 0x14
    476e:	95 89       	ldd	r25, Z+21	; 0x15
    4770:	89 2b       	or	r24, r25
    4772:	29 f0       	breq	.+10     	; 0x477e <vTaskSuspend+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4774:	89 81       	ldd	r24, Y+1	; 0x01
    4776:	9a 81       	ldd	r25, Y+2	; 0x02
    4778:	0c 96       	adiw	r24, 0x0c	; 12
    477a:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    477e:	89 81       	ldd	r24, Y+1	; 0x01
    4780:	9a 81       	ldd	r25, Y+2	; 0x02
    4782:	02 96       	adiw	r24, 0x02	; 2
    4784:	bc 01       	movw	r22, r24
    4786:	8f e8       	ldi	r24, 0x8F	; 143
    4788:	92 e0       	ldi	r25, 0x02	; 2
    478a:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    478e:	0f 90       	pop	r0
    4790:	0f be       	out	0x3f, r0	; 63

		if( pxTCB == pxCurrentTCB )
    4792:	80 91 40 02 	lds	r24, 0x0240
    4796:	90 91 41 02 	lds	r25, 0x0241
    479a:	29 81       	ldd	r18, Y+1	; 0x01
    479c:	3a 81       	ldd	r19, Y+2	; 0x02
    479e:	28 17       	cp	r18, r24
    47a0:	39 07       	cpc	r19, r25
    47a2:	a9 f4       	brne	.+42     	; 0x47ce <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
    47a4:	80 91 9c 02 	lds	r24, 0x029C
    47a8:	88 23       	and	r24, r24
    47aa:	19 f0       	breq	.+6      	; 0x47b2 <vTaskSuspend+0x86>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    47ac:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
    47b0:	19 c0       	rjmp	.+50     	; 0x47e4 <vTaskSuspend+0xb8>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    47b2:	90 91 8f 02 	lds	r25, 0x028F
    47b6:	80 91 98 02 	lds	r24, 0x0298
    47ba:	98 17       	cp	r25, r24
    47bc:	29 f4       	brne	.+10     	; 0x47c8 <vTaskSuspend+0x9c>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    47be:	10 92 41 02 	sts	0x0241, r1
    47c2:	10 92 40 02 	sts	0x0240, r1
    47c6:	0e c0       	rjmp	.+28     	; 0x47e4 <vTaskSuspend+0xb8>
				}
				else
				{
					vTaskSwitchContext();
    47c8:	0e 94 fb 26 	call	0x4df6	; 0x4df6 <vTaskSwitchContext>
    47cc:	0b c0       	rjmp	.+22     	; 0x47e4 <vTaskSuspend+0xb8>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
    47ce:	80 91 9c 02 	lds	r24, 0x029C
    47d2:	88 23       	and	r24, r24
    47d4:	39 f0       	breq	.+14     	; 0x47e4 <vTaskSuspend+0xb8>
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
    47d6:	0f b6       	in	r0, 0x3f	; 63
    47d8:	f8 94       	cli
    47da:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    47dc:	0e 94 af 2b 	call	0x575e	; 0x575e <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    47e0:	0f 90       	pop	r0
    47e2:	0f be       	out	0x3f, r0	; 63
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    47e4:	0f 90       	pop	r0
    47e6:	0f 90       	pop	r0
    47e8:	0f 90       	pop	r0
    47ea:	0f 90       	pop	r0
    47ec:	df 91       	pop	r29
    47ee:	cf 91       	pop	r28
    47f0:	08 95       	ret

000047f2 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    47f2:	cf 93       	push	r28
    47f4:	df 93       	push	r29
    47f6:	00 d0       	rcall	.+0      	; 0x47f8 <prvTaskIsTaskSuspended+0x6>
    47f8:	1f 92       	push	r1
    47fa:	1f 92       	push	r1
    47fc:	cd b7       	in	r28, 0x3d	; 61
    47fe:	de b7       	in	r29, 0x3e	; 62
    4800:	9d 83       	std	Y+5, r25	; 0x05
    4802:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    4804:	19 82       	std	Y+1, r1	; 0x01
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    4806:	8c 81       	ldd	r24, Y+4	; 0x04
    4808:	9d 81       	ldd	r25, Y+5	; 0x05
    480a:	9b 83       	std	Y+3, r25	; 0x03
    480c:	8a 83       	std	Y+2, r24	; 0x02

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    480e:	8a 81       	ldd	r24, Y+2	; 0x02
    4810:	9b 81       	ldd	r25, Y+3	; 0x03
    4812:	fc 01       	movw	r30, r24
    4814:	82 85       	ldd	r24, Z+10	; 0x0a
    4816:	93 85       	ldd	r25, Z+11	; 0x0b
    4818:	8f 58       	subi	r24, 0x8F	; 143
    481a:	92 40       	sbci	r25, 0x02	; 2
    481c:	89 f4       	brne	.+34     	; 0x4840 <prvTaskIsTaskSuspended+0x4e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    481e:	8a 81       	ldd	r24, Y+2	; 0x02
    4820:	9b 81       	ldd	r25, Y+3	; 0x03
    4822:	fc 01       	movw	r30, r24
    4824:	84 89       	ldd	r24, Z+20	; 0x14
    4826:	95 89       	ldd	r25, Z+21	; 0x15
    4828:	8c 57       	subi	r24, 0x7C	; 124
    482a:	92 40       	sbci	r25, 0x02	; 2
    482c:	49 f0       	breq	.+18     	; 0x4840 <prvTaskIsTaskSuspended+0x4e>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    482e:	8a 81       	ldd	r24, Y+2	; 0x02
    4830:	9b 81       	ldd	r25, Y+3	; 0x03
    4832:	fc 01       	movw	r30, r24
    4834:	84 89       	ldd	r24, Z+20	; 0x14
    4836:	95 89       	ldd	r25, Z+21	; 0x15
    4838:	89 2b       	or	r24, r25
    483a:	11 f4       	brne	.+4      	; 0x4840 <prvTaskIsTaskSuspended+0x4e>
				{
					xReturn = pdTRUE;
    483c:	81 e0       	ldi	r24, 0x01	; 1
    483e:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4840:	89 81       	ldd	r24, Y+1	; 0x01
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    4842:	0f 90       	pop	r0
    4844:	0f 90       	pop	r0
    4846:	0f 90       	pop	r0
    4848:	0f 90       	pop	r0
    484a:	0f 90       	pop	r0
    484c:	df 91       	pop	r29
    484e:	cf 91       	pop	r28
    4850:	08 95       	ret

00004852 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    4852:	cf 93       	push	r28
    4854:	df 93       	push	r29
    4856:	00 d0       	rcall	.+0      	; 0x4858 <vTaskResume+0x6>
    4858:	1f 92       	push	r1
    485a:	cd b7       	in	r28, 0x3d	; 61
    485c:	de b7       	in	r29, 0x3e	; 62
    485e:	9c 83       	std	Y+4, r25	; 0x04
    4860:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    4862:	8b 81       	ldd	r24, Y+3	; 0x03
    4864:	9c 81       	ldd	r25, Y+4	; 0x04
    4866:	9a 83       	std	Y+2, r25	; 0x02
    4868:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    486a:	89 81       	ldd	r24, Y+1	; 0x01
    486c:	9a 81       	ldd	r25, Y+2	; 0x02
    486e:	89 2b       	or	r24, r25
    4870:	09 f4       	brne	.+2      	; 0x4874 <vTaskResume+0x22>
    4872:	4f c0       	rjmp	.+158    	; 0x4912 <vTaskResume+0xc0>
    4874:	80 91 40 02 	lds	r24, 0x0240
    4878:	90 91 41 02 	lds	r25, 0x0241
    487c:	29 81       	ldd	r18, Y+1	; 0x01
    487e:	3a 81       	ldd	r19, Y+2	; 0x02
    4880:	28 17       	cp	r18, r24
    4882:	39 07       	cpc	r19, r25
    4884:	09 f4       	brne	.+2      	; 0x4888 <vTaskResume+0x36>
    4886:	45 c0       	rjmp	.+138    	; 0x4912 <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
    4888:	0f b6       	in	r0, 0x3f	; 63
    488a:	f8 94       	cli
    488c:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    488e:	89 81       	ldd	r24, Y+1	; 0x01
    4890:	9a 81       	ldd	r25, Y+2	; 0x02
    4892:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <prvTaskIsTaskSuspended>
    4896:	81 30       	cpi	r24, 0x01	; 1
    4898:	d1 f5       	brne	.+116    	; 0x490e <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    489a:	89 81       	ldd	r24, Y+1	; 0x01
    489c:	9a 81       	ldd	r25, Y+2	; 0x02
    489e:	02 96       	adiw	r24, 0x02	; 2
    48a0:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    48a4:	89 81       	ldd	r24, Y+1	; 0x01
    48a6:	9a 81       	ldd	r25, Y+2	; 0x02
    48a8:	fc 01       	movw	r30, r24
    48aa:	96 89       	ldd	r25, Z+22	; 0x16
    48ac:	80 91 9b 02 	lds	r24, 0x029B
    48b0:	89 17       	cp	r24, r25
    48b2:	30 f4       	brcc	.+12     	; 0x48c0 <vTaskResume+0x6e>
    48b4:	89 81       	ldd	r24, Y+1	; 0x01
    48b6:	9a 81       	ldd	r25, Y+2	; 0x02
    48b8:	fc 01       	movw	r30, r24
    48ba:	86 89       	ldd	r24, Z+22	; 0x16
    48bc:	80 93 9b 02 	sts	0x029B, r24
    48c0:	89 81       	ldd	r24, Y+1	; 0x01
    48c2:	9a 81       	ldd	r25, Y+2	; 0x02
    48c4:	ac 01       	movw	r20, r24
    48c6:	4e 5f       	subi	r20, 0xFE	; 254
    48c8:	5f 4f       	sbci	r21, 0xFF	; 255
    48ca:	89 81       	ldd	r24, Y+1	; 0x01
    48cc:	9a 81       	ldd	r25, Y+2	; 0x02
    48ce:	fc 01       	movw	r30, r24
    48d0:	86 89       	ldd	r24, Z+22	; 0x16
    48d2:	28 2f       	mov	r18, r24
    48d4:	30 e0       	ldi	r19, 0x00	; 0
    48d6:	c9 01       	movw	r24, r18
    48d8:	88 0f       	add	r24, r24
    48da:	99 1f       	adc	r25, r25
    48dc:	88 0f       	add	r24, r24
    48de:	99 1f       	adc	r25, r25
    48e0:	88 0f       	add	r24, r24
    48e2:	99 1f       	adc	r25, r25
    48e4:	82 0f       	add	r24, r18
    48e6:	93 1f       	adc	r25, r19
    48e8:	8e 5b       	subi	r24, 0xBE	; 190
    48ea:	9d 4f       	sbci	r25, 0xFD	; 253
    48ec:	ba 01       	movw	r22, r20
    48ee:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    48f2:	89 81       	ldd	r24, Y+1	; 0x01
    48f4:	9a 81       	ldd	r25, Y+2	; 0x02
    48f6:	fc 01       	movw	r30, r24
    48f8:	26 89       	ldd	r18, Z+22	; 0x16
    48fa:	80 91 40 02 	lds	r24, 0x0240
    48fe:	90 91 41 02 	lds	r25, 0x0241
    4902:	fc 01       	movw	r30, r24
    4904:	86 89       	ldd	r24, Z+22	; 0x16
    4906:	28 17       	cp	r18, r24
    4908:	10 f0       	brcs	.+4      	; 0x490e <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    490a:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    490e:	0f 90       	pop	r0
    4910:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4912:	0f 90       	pop	r0
    4914:	0f 90       	pop	r0
    4916:	0f 90       	pop	r0
    4918:	0f 90       	pop	r0
    491a:	df 91       	pop	r29
    491c:	cf 91       	pop	r28
    491e:	08 95       	ret

00004920 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    4920:	cf 93       	push	r28
    4922:	df 93       	push	r29
    4924:	00 d0       	rcall	.+0      	; 0x4926 <xTaskResumeFromISR+0x6>
    4926:	00 d0       	rcall	.+0      	; 0x4928 <xTaskResumeFromISR+0x8>
    4928:	cd b7       	in	r28, 0x3d	; 61
    492a:	de b7       	in	r29, 0x3e	; 62
    492c:	9e 83       	std	Y+6, r25	; 0x06
    492e:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    4930:	19 82       	std	Y+1, r1	; 0x01
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    4932:	8d 81       	ldd	r24, Y+5	; 0x05
    4934:	9e 81       	ldd	r25, Y+6	; 0x06
    4936:	9b 83       	std	Y+3, r25	; 0x03
    4938:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    493a:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    493c:	8a 81       	ldd	r24, Y+2	; 0x02
    493e:	9b 81       	ldd	r25, Y+3	; 0x03
    4940:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <prvTaskIsTaskSuspended>
    4944:	81 30       	cpi	r24, 0x01	; 1
    4946:	09 f0       	breq	.+2      	; 0x494a <xTaskResumeFromISR+0x2a>
    4948:	47 c0       	rjmp	.+142    	; 0x49d8 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    494a:	80 91 a3 02 	lds	r24, 0x02A3
    494e:	88 23       	and	r24, r24
    4950:	d9 f5       	brne	.+118    	; 0x49c8 <xTaskResumeFromISR+0xa8>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4952:	8a 81       	ldd	r24, Y+2	; 0x02
    4954:	9b 81       	ldd	r25, Y+3	; 0x03
    4956:	fc 01       	movw	r30, r24
    4958:	26 89       	ldd	r18, Z+22	; 0x16
    495a:	80 91 40 02 	lds	r24, 0x0240
    495e:	90 91 41 02 	lds	r25, 0x0241
    4962:	fc 01       	movw	r30, r24
    4964:	86 89       	ldd	r24, Z+22	; 0x16
    4966:	28 17       	cp	r18, r24
    4968:	10 f0       	brcs	.+4      	; 0x496e <xTaskResumeFromISR+0x4e>
					{
						xYieldRequired = pdTRUE;
    496a:	81 e0       	ldi	r24, 0x01	; 1
    496c:	89 83       	std	Y+1, r24	; 0x01
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    496e:	8a 81       	ldd	r24, Y+2	; 0x02
    4970:	9b 81       	ldd	r25, Y+3	; 0x03
    4972:	02 96       	adiw	r24, 0x02	; 2
    4974:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4978:	8a 81       	ldd	r24, Y+2	; 0x02
    497a:	9b 81       	ldd	r25, Y+3	; 0x03
    497c:	fc 01       	movw	r30, r24
    497e:	96 89       	ldd	r25, Z+22	; 0x16
    4980:	80 91 9b 02 	lds	r24, 0x029B
    4984:	89 17       	cp	r24, r25
    4986:	30 f4       	brcc	.+12     	; 0x4994 <xTaskResumeFromISR+0x74>
    4988:	8a 81       	ldd	r24, Y+2	; 0x02
    498a:	9b 81       	ldd	r25, Y+3	; 0x03
    498c:	fc 01       	movw	r30, r24
    498e:	86 89       	ldd	r24, Z+22	; 0x16
    4990:	80 93 9b 02 	sts	0x029B, r24
    4994:	8a 81       	ldd	r24, Y+2	; 0x02
    4996:	9b 81       	ldd	r25, Y+3	; 0x03
    4998:	ac 01       	movw	r20, r24
    499a:	4e 5f       	subi	r20, 0xFE	; 254
    499c:	5f 4f       	sbci	r21, 0xFF	; 255
    499e:	8a 81       	ldd	r24, Y+2	; 0x02
    49a0:	9b 81       	ldd	r25, Y+3	; 0x03
    49a2:	fc 01       	movw	r30, r24
    49a4:	86 89       	ldd	r24, Z+22	; 0x16
    49a6:	28 2f       	mov	r18, r24
    49a8:	30 e0       	ldi	r19, 0x00	; 0
    49aa:	c9 01       	movw	r24, r18
    49ac:	88 0f       	add	r24, r24
    49ae:	99 1f       	adc	r25, r25
    49b0:	88 0f       	add	r24, r24
    49b2:	99 1f       	adc	r25, r25
    49b4:	88 0f       	add	r24, r24
    49b6:	99 1f       	adc	r25, r25
    49b8:	82 0f       	add	r24, r18
    49ba:	93 1f       	adc	r25, r19
    49bc:	8e 5b       	subi	r24, 0xBE	; 190
    49be:	9d 4f       	sbci	r25, 0xFD	; 253
    49c0:	ba 01       	movw	r22, r20
    49c2:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
    49c6:	08 c0       	rjmp	.+16     	; 0x49d8 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    49c8:	8a 81       	ldd	r24, Y+2	; 0x02
    49ca:	9b 81       	ldd	r25, Y+3	; 0x03
    49cc:	0c 96       	adiw	r24, 0x0c	; 12
    49ce:	bc 01       	movw	r22, r24
    49d0:	8c e7       	ldi	r24, 0x7C	; 124
    49d2:	92 e0       	ldi	r25, 0x02	; 2
    49d4:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    49d8:	89 81       	ldd	r24, Y+1	; 0x01
	}
    49da:	26 96       	adiw	r28, 0x06	; 6
    49dc:	0f b6       	in	r0, 0x3f	; 63
    49de:	f8 94       	cli
    49e0:	de bf       	out	0x3e, r29	; 62
    49e2:	0f be       	out	0x3f, r0	; 63
    49e4:	cd bf       	out	0x3d, r28	; 61
    49e6:	df 91       	pop	r29
    49e8:	cf 91       	pop	r28
    49ea:	08 95       	ret

000049ec <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    49ec:	af 92       	push	r10
    49ee:	bf 92       	push	r11
    49f0:	cf 92       	push	r12
    49f2:	df 92       	push	r13
    49f4:	ef 92       	push	r14
    49f6:	ff 92       	push	r15
    49f8:	0f 93       	push	r16
    49fa:	cf 93       	push	r28
    49fc:	df 93       	push	r29
    49fe:	1f 92       	push	r1
    4a00:	cd b7       	in	r28, 0x3d	; 61
    4a02:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    4a04:	a1 2c       	mov	r10, r1
    4a06:	b1 2c       	mov	r11, r1
    4a08:	c1 2c       	mov	r12, r1
    4a0a:	d1 2c       	mov	r13, r1
    4a0c:	e1 2c       	mov	r14, r1
    4a0e:	f1 2c       	mov	r15, r1
    4a10:	00 e0       	ldi	r16, 0x00	; 0
    4a12:	20 e0       	ldi	r18, 0x00	; 0
    4a14:	30 e0       	ldi	r19, 0x00	; 0
    4a16:	45 e5       	ldi	r20, 0x55	; 85
    4a18:	50 e0       	ldi	r21, 0x00	; 0
    4a1a:	62 e1       	ldi	r22, 0x12	; 18
    4a1c:	72 e0       	ldi	r23, 0x02	; 2
    4a1e:	89 e6       	ldi	r24, 0x69	; 105
    4a20:	91 e0       	ldi	r25, 0x01	; 1
    4a22:	0e 94 8a 20 	call	0x4114	; 0x4114 <xTaskGenericCreate>
    4a26:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    4a28:	89 81       	ldd	r24, Y+1	; 0x01
    4a2a:	81 30       	cpi	r24, 0x01	; 1
    4a2c:	81 f4       	brne	.+32     	; 0x4a4e <vTaskStartScheduler+0x62>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    4a2e:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    4a30:	8f ef       	ldi	r24, 0xFF	; 255
    4a32:	9f ef       	ldi	r25, 0xFF	; 255
    4a34:	90 93 a2 02 	sts	0x02A2, r25
    4a38:	80 93 a1 02 	sts	0x02A1, r24
		xSchedulerRunning = pdTRUE;
    4a3c:	81 e0       	ldi	r24, 0x01	; 1
    4a3e:	80 93 9c 02 	sts	0x029C, r24
		xTickCount = ( TickType_t ) 0U;
    4a42:	10 92 9a 02 	sts	0x029A, r1
    4a46:	10 92 99 02 	sts	0x0299, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4a4a:	0e 94 f6 17 	call	0x2fec	; 0x2fec <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    4a4e:	0f 90       	pop	r0
    4a50:	df 91       	pop	r29
    4a52:	cf 91       	pop	r28
    4a54:	0f 91       	pop	r16
    4a56:	ff 90       	pop	r15
    4a58:	ef 90       	pop	r14
    4a5a:	df 90       	pop	r13
    4a5c:	cf 90       	pop	r12
    4a5e:	bf 90       	pop	r11
    4a60:	af 90       	pop	r10
    4a62:	08 95       	ret

00004a64 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4a64:	cf 93       	push	r28
    4a66:	df 93       	push	r29
    4a68:	cd b7       	in	r28, 0x3d	; 61
    4a6a:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4a6c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4a6e:	10 92 9c 02 	sts	0x029C, r1
	vPortEndScheduler();
    4a72:	0e 94 2f 18 	call	0x305e	; 0x305e <vPortEndScheduler>
	portENABLE_INTERRUPTS(); /* As per comment, enable interrupts. */
    4a76:	78 94       	sei
}
    4a78:	df 91       	pop	r29
    4a7a:	cf 91       	pop	r28
    4a7c:	08 95       	ret

00004a7e <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4a7e:	cf 93       	push	r28
    4a80:	df 93       	push	r29
    4a82:	cd b7       	in	r28, 0x3d	; 61
    4a84:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    4a86:	80 91 a3 02 	lds	r24, 0x02A3
    4a8a:	8f 5f       	subi	r24, 0xFF	; 255
    4a8c:	80 93 a3 02 	sts	0x02A3, r24
}
    4a90:	df 91       	pop	r29
    4a92:	cf 91       	pop	r28
    4a94:	08 95       	ret

00004a96 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    4a96:	cf 93       	push	r28
    4a98:	df 93       	push	r29
    4a9a:	00 d0       	rcall	.+0      	; 0x4a9c <xTaskResumeAll+0x6>
    4a9c:	cd b7       	in	r28, 0x3d	; 61
    4a9e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    4aa0:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4aa2:	0f b6       	in	r0, 0x3f	; 63
    4aa4:	f8 94       	cli
    4aa6:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4aa8:	80 91 a3 02 	lds	r24, 0x02A3
    4aac:	81 50       	subi	r24, 0x01	; 1
    4aae:	80 93 a3 02 	sts	0x02A3, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4ab2:	80 91 a3 02 	lds	r24, 0x02A3
    4ab6:	88 23       	and	r24, r24
    4ab8:	09 f0       	breq	.+2      	; 0x4abc <xTaskResumeAll+0x26>
    4aba:	71 c0       	rjmp	.+226    	; 0x4b9e <xTaskResumeAll+0x108>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4abc:	80 91 98 02 	lds	r24, 0x0298
    4ac0:	88 23       	and	r24, r24
    4ac2:	09 f4       	brne	.+2      	; 0x4ac6 <xTaskResumeAll+0x30>
    4ac4:	6c c0       	rjmp	.+216    	; 0x4b9e <xTaskResumeAll+0x108>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4ac6:	49 c0       	rjmp	.+146    	; 0x4b5a <xTaskResumeAll+0xc4>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    4ac8:	80 91 81 02 	lds	r24, 0x0281
    4acc:	90 91 82 02 	lds	r25, 0x0282
    4ad0:	fc 01       	movw	r30, r24
    4ad2:	86 81       	ldd	r24, Z+6	; 0x06
    4ad4:	97 81       	ldd	r25, Z+7	; 0x07
    4ad6:	9b 83       	std	Y+3, r25	; 0x03
    4ad8:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4ada:	8a 81       	ldd	r24, Y+2	; 0x02
    4adc:	9b 81       	ldd	r25, Y+3	; 0x03
    4ade:	0c 96       	adiw	r24, 0x0c	; 12
    4ae0:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4ae4:	8a 81       	ldd	r24, Y+2	; 0x02
    4ae6:	9b 81       	ldd	r25, Y+3	; 0x03
    4ae8:	02 96       	adiw	r24, 0x02	; 2
    4aea:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4aee:	8a 81       	ldd	r24, Y+2	; 0x02
    4af0:	9b 81       	ldd	r25, Y+3	; 0x03
    4af2:	fc 01       	movw	r30, r24
    4af4:	96 89       	ldd	r25, Z+22	; 0x16
    4af6:	80 91 9b 02 	lds	r24, 0x029B
    4afa:	89 17       	cp	r24, r25
    4afc:	30 f4       	brcc	.+12     	; 0x4b0a <xTaskResumeAll+0x74>
    4afe:	8a 81       	ldd	r24, Y+2	; 0x02
    4b00:	9b 81       	ldd	r25, Y+3	; 0x03
    4b02:	fc 01       	movw	r30, r24
    4b04:	86 89       	ldd	r24, Z+22	; 0x16
    4b06:	80 93 9b 02 	sts	0x029B, r24
    4b0a:	8a 81       	ldd	r24, Y+2	; 0x02
    4b0c:	9b 81       	ldd	r25, Y+3	; 0x03
    4b0e:	ac 01       	movw	r20, r24
    4b10:	4e 5f       	subi	r20, 0xFE	; 254
    4b12:	5f 4f       	sbci	r21, 0xFF	; 255
    4b14:	8a 81       	ldd	r24, Y+2	; 0x02
    4b16:	9b 81       	ldd	r25, Y+3	; 0x03
    4b18:	fc 01       	movw	r30, r24
    4b1a:	86 89       	ldd	r24, Z+22	; 0x16
    4b1c:	28 2f       	mov	r18, r24
    4b1e:	30 e0       	ldi	r19, 0x00	; 0
    4b20:	c9 01       	movw	r24, r18
    4b22:	88 0f       	add	r24, r24
    4b24:	99 1f       	adc	r25, r25
    4b26:	88 0f       	add	r24, r24
    4b28:	99 1f       	adc	r25, r25
    4b2a:	88 0f       	add	r24, r24
    4b2c:	99 1f       	adc	r25, r25
    4b2e:	82 0f       	add	r24, r18
    4b30:	93 1f       	adc	r25, r19
    4b32:	8e 5b       	subi	r24, 0xBE	; 190
    4b34:	9d 4f       	sbci	r25, 0xFD	; 253
    4b36:	ba 01       	movw	r22, r20
    4b38:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4b3c:	8a 81       	ldd	r24, Y+2	; 0x02
    4b3e:	9b 81       	ldd	r25, Y+3	; 0x03
    4b40:	fc 01       	movw	r30, r24
    4b42:	26 89       	ldd	r18, Z+22	; 0x16
    4b44:	80 91 40 02 	lds	r24, 0x0240
    4b48:	90 91 41 02 	lds	r25, 0x0241
    4b4c:	fc 01       	movw	r30, r24
    4b4e:	86 89       	ldd	r24, Z+22	; 0x16
    4b50:	28 17       	cp	r18, r24
    4b52:	18 f0       	brcs	.+6      	; 0x4b5a <xTaskResumeAll+0xc4>
					{
						xYieldPending = pdTRUE;
    4b54:	81 e0       	ldi	r24, 0x01	; 1
    4b56:	80 93 9e 02 	sts	0x029E, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4b5a:	80 91 7c 02 	lds	r24, 0x027C
    4b5e:	88 23       	and	r24, r24
    4b60:	09 f0       	breq	.+2      	; 0x4b64 <xTaskResumeAll+0xce>
    4b62:	b2 cf       	rjmp	.-156    	; 0x4ac8 <xTaskResumeAll+0x32>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    4b64:	80 91 9d 02 	lds	r24, 0x029D
    4b68:	88 23       	and	r24, r24
    4b6a:	89 f0       	breq	.+34     	; 0x4b8e <xTaskResumeAll+0xf8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    4b6c:	0c c0       	rjmp	.+24     	; 0x4b86 <xTaskResumeAll+0xf0>
					{
						if( xTaskIncrementTick() != pdFALSE )
    4b6e:	0e 94 0d 26 	call	0x4c1a	; 0x4c1a <xTaskIncrementTick>
    4b72:	88 23       	and	r24, r24
    4b74:	19 f0       	breq	.+6      	; 0x4b7c <xTaskResumeAll+0xe6>
						{
							xYieldPending = pdTRUE;
    4b76:	81 e0       	ldi	r24, 0x01	; 1
    4b78:	80 93 9e 02 	sts	0x029E, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    4b7c:	80 91 9d 02 	lds	r24, 0x029D
    4b80:	81 50       	subi	r24, 0x01	; 1
    4b82:	80 93 9d 02 	sts	0x029D, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    4b86:	80 91 9d 02 	lds	r24, 0x029D
    4b8a:	88 23       	and	r24, r24
    4b8c:	81 f7       	brne	.-32     	; 0x4b6e <xTaskResumeAll+0xd8>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    4b8e:	80 91 9e 02 	lds	r24, 0x029E
    4b92:	81 30       	cpi	r24, 0x01	; 1
    4b94:	21 f4       	brne	.+8      	; 0x4b9e <xTaskResumeAll+0x108>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    4b96:	81 e0       	ldi	r24, 0x01	; 1
    4b98:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4b9a:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4b9e:	0f 90       	pop	r0
    4ba0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4ba2:	89 81       	ldd	r24, Y+1	; 0x01
}
    4ba4:	0f 90       	pop	r0
    4ba6:	0f 90       	pop	r0
    4ba8:	0f 90       	pop	r0
    4baa:	df 91       	pop	r29
    4bac:	cf 91       	pop	r28
    4bae:	08 95       	ret

00004bb0 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4bb0:	cf 93       	push	r28
    4bb2:	df 93       	push	r29
    4bb4:	1f 92       	push	r1
    4bb6:	1f 92       	push	r1
    4bb8:	cd b7       	in	r28, 0x3d	; 61
    4bba:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4bbc:	0f b6       	in	r0, 0x3f	; 63
    4bbe:	f8 94       	cli
    4bc0:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4bc2:	80 91 99 02 	lds	r24, 0x0299
    4bc6:	90 91 9a 02 	lds	r25, 0x029A
    4bca:	9a 83       	std	Y+2, r25	; 0x02
    4bcc:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    4bce:	0f 90       	pop	r0
    4bd0:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4bd2:	89 81       	ldd	r24, Y+1	; 0x01
    4bd4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4bd6:	0f 90       	pop	r0
    4bd8:	0f 90       	pop	r0
    4bda:	df 91       	pop	r29
    4bdc:	cf 91       	pop	r28
    4bde:	08 95       	ret

00004be0 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4be0:	cf 93       	push	r28
    4be2:	df 93       	push	r29
    4be4:	00 d0       	rcall	.+0      	; 0x4be6 <xTaskGetTickCountFromISR+0x6>
    4be6:	cd b7       	in	r28, 0x3d	; 61
    4be8:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4bea:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    4bec:	80 91 99 02 	lds	r24, 0x0299
    4bf0:	90 91 9a 02 	lds	r25, 0x029A
    4bf4:	9b 83       	std	Y+3, r25	; 0x03
    4bf6:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4bf8:	8a 81       	ldd	r24, Y+2	; 0x02
    4bfa:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4bfc:	0f 90       	pop	r0
    4bfe:	0f 90       	pop	r0
    4c00:	0f 90       	pop	r0
    4c02:	df 91       	pop	r29
    4c04:	cf 91       	pop	r28
    4c06:	08 95       	ret

00004c08 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4c08:	cf 93       	push	r28
    4c0a:	df 93       	push	r29
    4c0c:	cd b7       	in	r28, 0x3d	; 61
    4c0e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    4c10:	80 91 98 02 	lds	r24, 0x0298
}
    4c14:	df 91       	pop	r29
    4c16:	cf 91       	pop	r28
    4c18:	08 95       	ret

00004c1a <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4c1a:	cf 93       	push	r28
    4c1c:	df 93       	push	r29
    4c1e:	cd b7       	in	r28, 0x3d	; 61
    4c20:	de b7       	in	r29, 0x3e	; 62
    4c22:	29 97       	sbiw	r28, 0x09	; 9
    4c24:	0f b6       	in	r0, 0x3f	; 63
    4c26:	f8 94       	cli
    4c28:	de bf       	out	0x3e, r29	; 62
    4c2a:	0f be       	out	0x3f, r0	; 63
    4c2c:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    4c2e:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4c30:	80 91 a3 02 	lds	r24, 0x02A3
    4c34:	88 23       	and	r24, r24
    4c36:	09 f0       	breq	.+2      	; 0x4c3a <xTaskIncrementTick+0x20>
    4c38:	c9 c0       	rjmp	.+402    	; 0x4dcc <xTaskIncrementTick+0x1b2>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    4c3a:	80 91 99 02 	lds	r24, 0x0299
    4c3e:	90 91 9a 02 	lds	r25, 0x029A
    4c42:	01 96       	adiw	r24, 0x01	; 1
    4c44:	90 93 9a 02 	sts	0x029A, r25
    4c48:	80 93 99 02 	sts	0x0299, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    4c4c:	80 91 99 02 	lds	r24, 0x0299
    4c50:	90 91 9a 02 	lds	r25, 0x029A
    4c54:	9b 83       	std	Y+3, r25	; 0x03
    4c56:	8a 83       	std	Y+2, r24	; 0x02

			if( xConstTickCount == ( TickType_t ) 0U )
    4c58:	8a 81       	ldd	r24, Y+2	; 0x02
    4c5a:	9b 81       	ldd	r25, Y+3	; 0x03
    4c5c:	89 2b       	or	r24, r25
    4c5e:	d9 f4       	brne	.+54     	; 0x4c96 <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    4c60:	80 91 78 02 	lds	r24, 0x0278
    4c64:	90 91 79 02 	lds	r25, 0x0279
    4c68:	9d 83       	std	Y+5, r25	; 0x05
    4c6a:	8c 83       	std	Y+4, r24	; 0x04
    4c6c:	80 91 7a 02 	lds	r24, 0x027A
    4c70:	90 91 7b 02 	lds	r25, 0x027B
    4c74:	90 93 79 02 	sts	0x0279, r25
    4c78:	80 93 78 02 	sts	0x0278, r24
    4c7c:	8c 81       	ldd	r24, Y+4	; 0x04
    4c7e:	9d 81       	ldd	r25, Y+5	; 0x05
    4c80:	90 93 7b 02 	sts	0x027B, r25
    4c84:	80 93 7a 02 	sts	0x027A, r24
    4c88:	80 91 9f 02 	lds	r24, 0x029F
    4c8c:	8f 5f       	subi	r24, 0xFF	; 255
    4c8e:	80 93 9f 02 	sts	0x029F, r24
    4c92:	0e 94 af 2b 	call	0x575e	; 0x575e <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    4c96:	80 91 a1 02 	lds	r24, 0x02A1
    4c9a:	90 91 a2 02 	lds	r25, 0x02A2
    4c9e:	2a 81       	ldd	r18, Y+2	; 0x02
    4ca0:	3b 81       	ldd	r19, Y+3	; 0x03
    4ca2:	28 17       	cp	r18, r24
    4ca4:	39 07       	cpc	r19, r25
    4ca6:	08 f4       	brcc	.+2      	; 0x4caa <xTaskIncrementTick+0x90>
    4ca8:	77 c0       	rjmp	.+238    	; 0x4d98 <xTaskIncrementTick+0x17e>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4caa:	80 91 78 02 	lds	r24, 0x0278
    4cae:	90 91 79 02 	lds	r25, 0x0279
    4cb2:	fc 01       	movw	r30, r24
    4cb4:	80 81       	ld	r24, Z
    4cb6:	88 23       	and	r24, r24
    4cb8:	39 f4       	brne	.+14     	; 0x4cc8 <xTaskIncrementTick+0xae>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    4cba:	8f ef       	ldi	r24, 0xFF	; 255
    4cbc:	9f ef       	ldi	r25, 0xFF	; 255
    4cbe:	90 93 a2 02 	sts	0x02A2, r25
    4cc2:	80 93 a1 02 	sts	0x02A1, r24
						break;
    4cc6:	68 c0       	rjmp	.+208    	; 0x4d98 <xTaskIncrementTick+0x17e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4cc8:	80 91 78 02 	lds	r24, 0x0278
    4ccc:	90 91 79 02 	lds	r25, 0x0279
    4cd0:	fc 01       	movw	r30, r24
    4cd2:	85 81       	ldd	r24, Z+5	; 0x05
    4cd4:	96 81       	ldd	r25, Z+6	; 0x06
    4cd6:	fc 01       	movw	r30, r24
    4cd8:	86 81       	ldd	r24, Z+6	; 0x06
    4cda:	97 81       	ldd	r25, Z+7	; 0x07
    4cdc:	9f 83       	std	Y+7, r25	; 0x07
    4cde:	8e 83       	std	Y+6, r24	; 0x06
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    4ce0:	8e 81       	ldd	r24, Y+6	; 0x06
    4ce2:	9f 81       	ldd	r25, Y+7	; 0x07
    4ce4:	fc 01       	movw	r30, r24
    4ce6:	82 81       	ldd	r24, Z+2	; 0x02
    4ce8:	93 81       	ldd	r25, Z+3	; 0x03
    4cea:	99 87       	std	Y+9, r25	; 0x09
    4cec:	88 87       	std	Y+8, r24	; 0x08

						if( xConstTickCount < xItemValue )
    4cee:	2a 81       	ldd	r18, Y+2	; 0x02
    4cf0:	3b 81       	ldd	r19, Y+3	; 0x03
    4cf2:	88 85       	ldd	r24, Y+8	; 0x08
    4cf4:	99 85       	ldd	r25, Y+9	; 0x09
    4cf6:	28 17       	cp	r18, r24
    4cf8:	39 07       	cpc	r19, r25
    4cfa:	38 f4       	brcc	.+14     	; 0x4d0a <xTaskIncrementTick+0xf0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    4cfc:	88 85       	ldd	r24, Y+8	; 0x08
    4cfe:	99 85       	ldd	r25, Y+9	; 0x09
    4d00:	90 93 a2 02 	sts	0x02A2, r25
    4d04:	80 93 a1 02 	sts	0x02A1, r24
							break;
    4d08:	47 c0       	rjmp	.+142    	; 0x4d98 <xTaskIncrementTick+0x17e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4d0a:	8e 81       	ldd	r24, Y+6	; 0x06
    4d0c:	9f 81       	ldd	r25, Y+7	; 0x07
    4d0e:	02 96       	adiw	r24, 0x02	; 2
    4d10:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4d14:	8e 81       	ldd	r24, Y+6	; 0x06
    4d16:	9f 81       	ldd	r25, Y+7	; 0x07
    4d18:	fc 01       	movw	r30, r24
    4d1a:	84 89       	ldd	r24, Z+20	; 0x14
    4d1c:	95 89       	ldd	r25, Z+21	; 0x15
    4d1e:	89 2b       	or	r24, r25
    4d20:	29 f0       	breq	.+10     	; 0x4d2c <xTaskIncrementTick+0x112>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4d22:	8e 81       	ldd	r24, Y+6	; 0x06
    4d24:	9f 81       	ldd	r25, Y+7	; 0x07
    4d26:	0c 96       	adiw	r24, 0x0c	; 12
    4d28:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    4d2c:	8e 81       	ldd	r24, Y+6	; 0x06
    4d2e:	9f 81       	ldd	r25, Y+7	; 0x07
    4d30:	fc 01       	movw	r30, r24
    4d32:	96 89       	ldd	r25, Z+22	; 0x16
    4d34:	80 91 9b 02 	lds	r24, 0x029B
    4d38:	89 17       	cp	r24, r25
    4d3a:	30 f4       	brcc	.+12     	; 0x4d48 <xTaskIncrementTick+0x12e>
    4d3c:	8e 81       	ldd	r24, Y+6	; 0x06
    4d3e:	9f 81       	ldd	r25, Y+7	; 0x07
    4d40:	fc 01       	movw	r30, r24
    4d42:	86 89       	ldd	r24, Z+22	; 0x16
    4d44:	80 93 9b 02 	sts	0x029B, r24
    4d48:	8e 81       	ldd	r24, Y+6	; 0x06
    4d4a:	9f 81       	ldd	r25, Y+7	; 0x07
    4d4c:	ac 01       	movw	r20, r24
    4d4e:	4e 5f       	subi	r20, 0xFE	; 254
    4d50:	5f 4f       	sbci	r21, 0xFF	; 255
    4d52:	8e 81       	ldd	r24, Y+6	; 0x06
    4d54:	9f 81       	ldd	r25, Y+7	; 0x07
    4d56:	fc 01       	movw	r30, r24
    4d58:	86 89       	ldd	r24, Z+22	; 0x16
    4d5a:	28 2f       	mov	r18, r24
    4d5c:	30 e0       	ldi	r19, 0x00	; 0
    4d5e:	c9 01       	movw	r24, r18
    4d60:	88 0f       	add	r24, r24
    4d62:	99 1f       	adc	r25, r25
    4d64:	88 0f       	add	r24, r24
    4d66:	99 1f       	adc	r25, r25
    4d68:	88 0f       	add	r24, r24
    4d6a:	99 1f       	adc	r25, r25
    4d6c:	82 0f       	add	r24, r18
    4d6e:	93 1f       	adc	r25, r19
    4d70:	8e 5b       	subi	r24, 0xBE	; 190
    4d72:	9d 4f       	sbci	r25, 0xFD	; 253
    4d74:	ba 01       	movw	r22, r20
    4d76:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4d7a:	8e 81       	ldd	r24, Y+6	; 0x06
    4d7c:	9f 81       	ldd	r25, Y+7	; 0x07
    4d7e:	fc 01       	movw	r30, r24
    4d80:	26 89       	ldd	r18, Z+22	; 0x16
    4d82:	80 91 40 02 	lds	r24, 0x0240
    4d86:	90 91 41 02 	lds	r25, 0x0241
    4d8a:	fc 01       	movw	r30, r24
    4d8c:	86 89       	ldd	r24, Z+22	; 0x16
    4d8e:	28 17       	cp	r18, r24
    4d90:	10 f0       	brcs	.+4      	; 0x4d96 <xTaskIncrementTick+0x17c>
							{
								xSwitchRequired = pdTRUE;
    4d92:	81 e0       	ldi	r24, 0x01	; 1
    4d94:	89 83       	std	Y+1, r24	; 0x01
								mtCOVERAGE_TEST_MARKER();
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
    4d96:	89 cf       	rjmp	.-238    	; 0x4caa <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4d98:	80 91 40 02 	lds	r24, 0x0240
    4d9c:	90 91 41 02 	lds	r25, 0x0241
    4da0:	fc 01       	movw	r30, r24
    4da2:	86 89       	ldd	r24, Z+22	; 0x16
    4da4:	28 2f       	mov	r18, r24
    4da6:	30 e0       	ldi	r19, 0x00	; 0
    4da8:	c9 01       	movw	r24, r18
    4daa:	88 0f       	add	r24, r24
    4dac:	99 1f       	adc	r25, r25
    4dae:	88 0f       	add	r24, r24
    4db0:	99 1f       	adc	r25, r25
    4db2:	88 0f       	add	r24, r24
    4db4:	99 1f       	adc	r25, r25
    4db6:	82 0f       	add	r24, r18
    4db8:	93 1f       	adc	r25, r19
    4dba:	8e 5b       	subi	r24, 0xBE	; 190
    4dbc:	9d 4f       	sbci	r25, 0xFD	; 253
    4dbe:	fc 01       	movw	r30, r24
    4dc0:	80 81       	ld	r24, Z
    4dc2:	82 30       	cpi	r24, 0x02	; 2
    4dc4:	40 f0       	brcs	.+16     	; 0x4dd6 <xTaskIncrementTick+0x1bc>
			{
				xSwitchRequired = pdTRUE;
    4dc6:	81 e0       	ldi	r24, 0x01	; 1
    4dc8:	89 83       	std	Y+1, r24	; 0x01
    4dca:	05 c0       	rjmp	.+10     	; 0x4dd6 <xTaskIncrementTick+0x1bc>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    4dcc:	80 91 9d 02 	lds	r24, 0x029D
    4dd0:	8f 5f       	subi	r24, 0xFF	; 255
    4dd2:	80 93 9d 02 	sts	0x029D, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    4dd6:	80 91 9e 02 	lds	r24, 0x029E
    4dda:	88 23       	and	r24, r24
    4ddc:	11 f0       	breq	.+4      	; 0x4de2 <xTaskIncrementTick+0x1c8>
		{
			xSwitchRequired = pdTRUE;
    4dde:	81 e0       	ldi	r24, 0x01	; 1
    4de0:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    4de2:	89 81       	ldd	r24, Y+1	; 0x01
}
    4de4:	29 96       	adiw	r28, 0x09	; 9
    4de6:	0f b6       	in	r0, 0x3f	; 63
    4de8:	f8 94       	cli
    4dea:	de bf       	out	0x3e, r29	; 62
    4dec:	0f be       	out	0x3f, r0	; 63
    4dee:	cd bf       	out	0x3d, r28	; 61
    4df0:	df 91       	pop	r29
    4df2:	cf 91       	pop	r28
    4df4:	08 95       	ret

00004df6 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4df6:	cf 93       	push	r28
    4df8:	df 93       	push	r29
    4dfa:	1f 92       	push	r1
    4dfc:	1f 92       	push	r1
    4dfe:	cd b7       	in	r28, 0x3d	; 61
    4e00:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4e02:	80 91 a3 02 	lds	r24, 0x02A3
    4e06:	88 23       	and	r24, r24
    4e08:	21 f0       	breq	.+8      	; 0x4e12 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    4e0a:	81 e0       	ldi	r24, 0x01	; 1
    4e0c:	80 93 9e 02 	sts	0x029E, r24
    4e10:	7c c0       	rjmp	.+248    	; 0x4f0a <vTaskSwitchContext+0x114>
	}
	else
	{
		xYieldPending = pdFALSE;
    4e12:	10 92 9e 02 	sts	0x029E, r1
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
    4e16:	80 91 40 02 	lds	r24, 0x0240
    4e1a:	90 91 41 02 	lds	r25, 0x0241
    4e1e:	fc 01       	movw	r30, r24
    4e20:	20 81       	ld	r18, Z
    4e22:	31 81       	ldd	r19, Z+1	; 0x01
    4e24:	80 91 40 02 	lds	r24, 0x0240
    4e28:	90 91 41 02 	lds	r25, 0x0241
    4e2c:	fc 01       	movw	r30, r24
    4e2e:	87 89       	ldd	r24, Z+23	; 0x17
    4e30:	90 8d       	ldd	r25, Z+24	; 0x18
    4e32:	82 17       	cp	r24, r18
    4e34:	93 07       	cpc	r25, r19
    4e36:	70 f0       	brcs	.+28     	; 0x4e54 <vTaskSwitchContext+0x5e>
    4e38:	80 91 40 02 	lds	r24, 0x0240
    4e3c:	90 91 41 02 	lds	r25, 0x0241
    4e40:	9c 01       	movw	r18, r24
    4e42:	27 5e       	subi	r18, 0xE7	; 231
    4e44:	3f 4f       	sbci	r19, 0xFF	; 255
    4e46:	80 91 40 02 	lds	r24, 0x0240
    4e4a:	90 91 41 02 	lds	r25, 0x0241
    4e4e:	b9 01       	movw	r22, r18
    4e50:	0e 94 7e 13 	call	0x26fc	; 0x26fc <vApplicationStackOverflowHook>

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    4e54:	05 c0       	rjmp	.+10     	; 0x4e60 <vTaskSwitchContext+0x6a>
    4e56:	80 91 9b 02 	lds	r24, 0x029B
    4e5a:	81 50       	subi	r24, 0x01	; 1
    4e5c:	80 93 9b 02 	sts	0x029B, r24
    4e60:	80 91 9b 02 	lds	r24, 0x029B
    4e64:	28 2f       	mov	r18, r24
    4e66:	30 e0       	ldi	r19, 0x00	; 0
    4e68:	c9 01       	movw	r24, r18
    4e6a:	88 0f       	add	r24, r24
    4e6c:	99 1f       	adc	r25, r25
    4e6e:	88 0f       	add	r24, r24
    4e70:	99 1f       	adc	r25, r25
    4e72:	88 0f       	add	r24, r24
    4e74:	99 1f       	adc	r25, r25
    4e76:	82 0f       	add	r24, r18
    4e78:	93 1f       	adc	r25, r19
    4e7a:	8e 5b       	subi	r24, 0xBE	; 190
    4e7c:	9d 4f       	sbci	r25, 0xFD	; 253
    4e7e:	fc 01       	movw	r30, r24
    4e80:	80 81       	ld	r24, Z
    4e82:	88 23       	and	r24, r24
    4e84:	41 f3       	breq	.-48     	; 0x4e56 <vTaskSwitchContext+0x60>
    4e86:	80 91 9b 02 	lds	r24, 0x029B
    4e8a:	28 2f       	mov	r18, r24
    4e8c:	30 e0       	ldi	r19, 0x00	; 0
    4e8e:	c9 01       	movw	r24, r18
    4e90:	88 0f       	add	r24, r24
    4e92:	99 1f       	adc	r25, r25
    4e94:	88 0f       	add	r24, r24
    4e96:	99 1f       	adc	r25, r25
    4e98:	88 0f       	add	r24, r24
    4e9a:	99 1f       	adc	r25, r25
    4e9c:	82 0f       	add	r24, r18
    4e9e:	93 1f       	adc	r25, r19
    4ea0:	8e 5b       	subi	r24, 0xBE	; 190
    4ea2:	9d 4f       	sbci	r25, 0xFD	; 253
    4ea4:	9a 83       	std	Y+2, r25	; 0x02
    4ea6:	89 83       	std	Y+1, r24	; 0x01
    4ea8:	89 81       	ldd	r24, Y+1	; 0x01
    4eaa:	9a 81       	ldd	r25, Y+2	; 0x02
    4eac:	fc 01       	movw	r30, r24
    4eae:	81 81       	ldd	r24, Z+1	; 0x01
    4eb0:	92 81       	ldd	r25, Z+2	; 0x02
    4eb2:	fc 01       	movw	r30, r24
    4eb4:	22 81       	ldd	r18, Z+2	; 0x02
    4eb6:	33 81       	ldd	r19, Z+3	; 0x03
    4eb8:	89 81       	ldd	r24, Y+1	; 0x01
    4eba:	9a 81       	ldd	r25, Y+2	; 0x02
    4ebc:	fc 01       	movw	r30, r24
    4ebe:	32 83       	std	Z+2, r19	; 0x02
    4ec0:	21 83       	std	Z+1, r18	; 0x01
    4ec2:	89 81       	ldd	r24, Y+1	; 0x01
    4ec4:	9a 81       	ldd	r25, Y+2	; 0x02
    4ec6:	fc 01       	movw	r30, r24
    4ec8:	21 81       	ldd	r18, Z+1	; 0x01
    4eca:	32 81       	ldd	r19, Z+2	; 0x02
    4ecc:	89 81       	ldd	r24, Y+1	; 0x01
    4ece:	9a 81       	ldd	r25, Y+2	; 0x02
    4ed0:	03 96       	adiw	r24, 0x03	; 3
    4ed2:	28 17       	cp	r18, r24
    4ed4:	39 07       	cpc	r19, r25
    4ed6:	69 f4       	brne	.+26     	; 0x4ef2 <vTaskSwitchContext+0xfc>
    4ed8:	89 81       	ldd	r24, Y+1	; 0x01
    4eda:	9a 81       	ldd	r25, Y+2	; 0x02
    4edc:	fc 01       	movw	r30, r24
    4ede:	81 81       	ldd	r24, Z+1	; 0x01
    4ee0:	92 81       	ldd	r25, Z+2	; 0x02
    4ee2:	fc 01       	movw	r30, r24
    4ee4:	22 81       	ldd	r18, Z+2	; 0x02
    4ee6:	33 81       	ldd	r19, Z+3	; 0x03
    4ee8:	89 81       	ldd	r24, Y+1	; 0x01
    4eea:	9a 81       	ldd	r25, Y+2	; 0x02
    4eec:	fc 01       	movw	r30, r24
    4eee:	32 83       	std	Z+2, r19	; 0x02
    4ef0:	21 83       	std	Z+1, r18	; 0x01
    4ef2:	89 81       	ldd	r24, Y+1	; 0x01
    4ef4:	9a 81       	ldd	r25, Y+2	; 0x02
    4ef6:	fc 01       	movw	r30, r24
    4ef8:	81 81       	ldd	r24, Z+1	; 0x01
    4efa:	92 81       	ldd	r25, Z+2	; 0x02
    4efc:	fc 01       	movw	r30, r24
    4efe:	86 81       	ldd	r24, Z+6	; 0x06
    4f00:	97 81       	ldd	r25, Z+7	; 0x07
    4f02:	90 93 41 02 	sts	0x0241, r25
    4f06:	80 93 40 02 	sts	0x0240, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4f0a:	0f 90       	pop	r0
    4f0c:	0f 90       	pop	r0
    4f0e:	df 91       	pop	r29
    4f10:	cf 91       	pop	r28
    4f12:	08 95       	ret

00004f14 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    4f14:	cf 93       	push	r28
    4f16:	df 93       	push	r29
    4f18:	00 d0       	rcall	.+0      	; 0x4f1a <vTaskPlaceOnEventList+0x6>
    4f1a:	00 d0       	rcall	.+0      	; 0x4f1c <vTaskPlaceOnEventList+0x8>
    4f1c:	cd b7       	in	r28, 0x3d	; 61
    4f1e:	de b7       	in	r29, 0x3e	; 62
    4f20:	9c 83       	std	Y+4, r25	; 0x04
    4f22:	8b 83       	std	Y+3, r24	; 0x03
    4f24:	7e 83       	std	Y+6, r23	; 0x06
    4f26:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4f28:	80 91 40 02 	lds	r24, 0x0240
    4f2c:	90 91 41 02 	lds	r25, 0x0241
    4f30:	9c 01       	movw	r18, r24
    4f32:	24 5f       	subi	r18, 0xF4	; 244
    4f34:	3f 4f       	sbci	r19, 0xFF	; 255
    4f36:	8b 81       	ldd	r24, Y+3	; 0x03
    4f38:	9c 81       	ldd	r25, Y+4	; 0x04
    4f3a:	b9 01       	movw	r22, r18
    4f3c:	0e 94 af 14 	call	0x295e	; 0x295e <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4f40:	80 91 40 02 	lds	r24, 0x0240
    4f44:	90 91 41 02 	lds	r25, 0x0241
    4f48:	02 96       	adiw	r24, 0x02	; 2
    4f4a:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    4f4e:	8d 81       	ldd	r24, Y+5	; 0x05
    4f50:	9e 81       	ldd	r25, Y+6	; 0x06
    4f52:	01 96       	adiw	r24, 0x01	; 1
    4f54:	59 f4       	brne	.+22     	; 0x4f6c <vTaskPlaceOnEventList+0x58>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    4f56:	80 91 40 02 	lds	r24, 0x0240
    4f5a:	90 91 41 02 	lds	r25, 0x0241
    4f5e:	02 96       	adiw	r24, 0x02	; 2
    4f60:	bc 01       	movw	r22, r24
    4f62:	8f e8       	ldi	r24, 0x8F	; 143
    4f64:	92 e0       	ldi	r25, 0x02	; 2
    4f66:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
    4f6a:	0e c0       	rjmp	.+28     	; 0x4f88 <vTaskPlaceOnEventList+0x74>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    4f6c:	20 91 99 02 	lds	r18, 0x0299
    4f70:	30 91 9a 02 	lds	r19, 0x029A
    4f74:	8d 81       	ldd	r24, Y+5	; 0x05
    4f76:	9e 81       	ldd	r25, Y+6	; 0x06
    4f78:	82 0f       	add	r24, r18
    4f7a:	93 1f       	adc	r25, r19
    4f7c:	9a 83       	std	Y+2, r25	; 0x02
    4f7e:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4f80:	89 81       	ldd	r24, Y+1	; 0x01
    4f82:	9a 81       	ldd	r25, Y+2	; 0x02
    4f84:	0e 94 9c 2a 	call	0x5538	; 0x5538 <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    4f88:	26 96       	adiw	r28, 0x06	; 6
    4f8a:	0f b6       	in	r0, 0x3f	; 63
    4f8c:	f8 94       	cli
    4f8e:	de bf       	out	0x3e, r29	; 62
    4f90:	0f be       	out	0x3f, r0	; 63
    4f92:	cd bf       	out	0x3d, r28	; 61
    4f94:	df 91       	pop	r29
    4f96:	cf 91       	pop	r28
    4f98:	08 95       	ret

00004f9a <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    4f9a:	cf 93       	push	r28
    4f9c:	df 93       	push	r29
    4f9e:	cd b7       	in	r28, 0x3d	; 61
    4fa0:	de b7       	in	r29, 0x3e	; 62
    4fa2:	28 97       	sbiw	r28, 0x08	; 8
    4fa4:	0f b6       	in	r0, 0x3f	; 63
    4fa6:	f8 94       	cli
    4fa8:	de bf       	out	0x3e, r29	; 62
    4faa:	0f be       	out	0x3f, r0	; 63
    4fac:	cd bf       	out	0x3d, r28	; 61
    4fae:	9c 83       	std	Y+4, r25	; 0x04
    4fb0:	8b 83       	std	Y+3, r24	; 0x03
    4fb2:	7e 83       	std	Y+6, r23	; 0x06
    4fb4:	6d 83       	std	Y+5, r22	; 0x05
    4fb6:	58 87       	std	Y+8, r21	; 0x08
    4fb8:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4fba:	80 91 40 02 	lds	r24, 0x0240
    4fbe:	90 91 41 02 	lds	r25, 0x0241
    4fc2:	2d 81       	ldd	r18, Y+5	; 0x05
    4fc4:	3e 81       	ldd	r19, Y+6	; 0x06
    4fc6:	30 68       	ori	r19, 0x80	; 128
    4fc8:	fc 01       	movw	r30, r24
    4fca:	35 87       	std	Z+13, r19	; 0x0d
    4fcc:	24 87       	std	Z+12, r18	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4fce:	80 91 40 02 	lds	r24, 0x0240
    4fd2:	90 91 41 02 	lds	r25, 0x0241
    4fd6:	9c 01       	movw	r18, r24
    4fd8:	24 5f       	subi	r18, 0xF4	; 244
    4fda:	3f 4f       	sbci	r19, 0xFF	; 255
    4fdc:	8b 81       	ldd	r24, Y+3	; 0x03
    4fde:	9c 81       	ldd	r25, Y+4	; 0x04
    4fe0:	b9 01       	movw	r22, r18
    4fe2:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4fe6:	80 91 40 02 	lds	r24, 0x0240
    4fea:	90 91 41 02 	lds	r25, 0x0241
    4fee:	02 96       	adiw	r24, 0x02	; 2
    4ff0:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    4ff4:	8f 81       	ldd	r24, Y+7	; 0x07
    4ff6:	98 85       	ldd	r25, Y+8	; 0x08
    4ff8:	01 96       	adiw	r24, 0x01	; 1
    4ffa:	59 f4       	brne	.+22     	; 0x5012 <vTaskPlaceOnUnorderedEventList+0x78>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    4ffc:	80 91 40 02 	lds	r24, 0x0240
    5000:	90 91 41 02 	lds	r25, 0x0241
    5004:	02 96       	adiw	r24, 0x02	; 2
    5006:	bc 01       	movw	r22, r24
    5008:	8f e8       	ldi	r24, 0x8F	; 143
    500a:	92 e0       	ldi	r25, 0x02	; 2
    500c:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
    5010:	0e c0       	rjmp	.+28     	; 0x502e <vTaskPlaceOnUnorderedEventList+0x94>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    5012:	20 91 99 02 	lds	r18, 0x0299
    5016:	30 91 9a 02 	lds	r19, 0x029A
    501a:	8f 81       	ldd	r24, Y+7	; 0x07
    501c:	98 85       	ldd	r25, Y+8	; 0x08
    501e:	82 0f       	add	r24, r18
    5020:	93 1f       	adc	r25, r19
    5022:	9a 83       	std	Y+2, r25	; 0x02
    5024:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    5026:	89 81       	ldd	r24, Y+1	; 0x01
    5028:	9a 81       	ldd	r25, Y+2	; 0x02
    502a:	0e 94 9c 2a 	call	0x5538	; 0x5538 <prvAddCurrentTaskToDelayedList>
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    502e:	28 96       	adiw	r28, 0x08	; 8
    5030:	0f b6       	in	r0, 0x3f	; 63
    5032:	f8 94       	cli
    5034:	de bf       	out	0x3e, r29	; 62
    5036:	0f be       	out	0x3f, r0	; 63
    5038:	cd bf       	out	0x3d, r28	; 61
    503a:	df 91       	pop	r29
    503c:	cf 91       	pop	r28
    503e:	08 95       	ret

00005040 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    5040:	cf 93       	push	r28
    5042:	df 93       	push	r29
    5044:	00 d0       	rcall	.+0      	; 0x5046 <xTaskRemoveFromEventList+0x6>
    5046:	1f 92       	push	r1
    5048:	1f 92       	push	r1
    504a:	cd b7       	in	r28, 0x3d	; 61
    504c:	de b7       	in	r29, 0x3e	; 62
    504e:	9d 83       	std	Y+5, r25	; 0x05
    5050:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    5052:	8c 81       	ldd	r24, Y+4	; 0x04
    5054:	9d 81       	ldd	r25, Y+5	; 0x05
    5056:	fc 01       	movw	r30, r24
    5058:	85 81       	ldd	r24, Z+5	; 0x05
    505a:	96 81       	ldd	r25, Z+6	; 0x06
    505c:	fc 01       	movw	r30, r24
    505e:	86 81       	ldd	r24, Z+6	; 0x06
    5060:	97 81       	ldd	r25, Z+7	; 0x07
    5062:	9b 83       	std	Y+3, r25	; 0x03
    5064:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5066:	8a 81       	ldd	r24, Y+2	; 0x02
    5068:	9b 81       	ldd	r25, Y+3	; 0x03
    506a:	0c 96       	adiw	r24, 0x0c	; 12
    506c:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5070:	80 91 a3 02 	lds	r24, 0x02A3
    5074:	88 23       	and	r24, r24
    5076:	69 f5       	brne	.+90     	; 0x50d2 <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    5078:	8a 81       	ldd	r24, Y+2	; 0x02
    507a:	9b 81       	ldd	r25, Y+3	; 0x03
    507c:	02 96       	adiw	r24, 0x02	; 2
    507e:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    5082:	8a 81       	ldd	r24, Y+2	; 0x02
    5084:	9b 81       	ldd	r25, Y+3	; 0x03
    5086:	fc 01       	movw	r30, r24
    5088:	96 89       	ldd	r25, Z+22	; 0x16
    508a:	80 91 9b 02 	lds	r24, 0x029B
    508e:	89 17       	cp	r24, r25
    5090:	30 f4       	brcc	.+12     	; 0x509e <xTaskRemoveFromEventList+0x5e>
    5092:	8a 81       	ldd	r24, Y+2	; 0x02
    5094:	9b 81       	ldd	r25, Y+3	; 0x03
    5096:	fc 01       	movw	r30, r24
    5098:	86 89       	ldd	r24, Z+22	; 0x16
    509a:	80 93 9b 02 	sts	0x029B, r24
    509e:	8a 81       	ldd	r24, Y+2	; 0x02
    50a0:	9b 81       	ldd	r25, Y+3	; 0x03
    50a2:	ac 01       	movw	r20, r24
    50a4:	4e 5f       	subi	r20, 0xFE	; 254
    50a6:	5f 4f       	sbci	r21, 0xFF	; 255
    50a8:	8a 81       	ldd	r24, Y+2	; 0x02
    50aa:	9b 81       	ldd	r25, Y+3	; 0x03
    50ac:	fc 01       	movw	r30, r24
    50ae:	86 89       	ldd	r24, Z+22	; 0x16
    50b0:	28 2f       	mov	r18, r24
    50b2:	30 e0       	ldi	r19, 0x00	; 0
    50b4:	c9 01       	movw	r24, r18
    50b6:	88 0f       	add	r24, r24
    50b8:	99 1f       	adc	r25, r25
    50ba:	88 0f       	add	r24, r24
    50bc:	99 1f       	adc	r25, r25
    50be:	88 0f       	add	r24, r24
    50c0:	99 1f       	adc	r25, r25
    50c2:	82 0f       	add	r24, r18
    50c4:	93 1f       	adc	r25, r19
    50c6:	8e 5b       	subi	r24, 0xBE	; 190
    50c8:	9d 4f       	sbci	r25, 0xFD	; 253
    50ca:	ba 01       	movw	r22, r20
    50cc:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
    50d0:	08 c0       	rjmp	.+16     	; 0x50e2 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    50d2:	8a 81       	ldd	r24, Y+2	; 0x02
    50d4:	9b 81       	ldd	r25, Y+3	; 0x03
    50d6:	0c 96       	adiw	r24, 0x0c	; 12
    50d8:	bc 01       	movw	r22, r24
    50da:	8c e7       	ldi	r24, 0x7C	; 124
    50dc:	92 e0       	ldi	r25, 0x02	; 2
    50de:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    50e2:	8a 81       	ldd	r24, Y+2	; 0x02
    50e4:	9b 81       	ldd	r25, Y+3	; 0x03
    50e6:	fc 01       	movw	r30, r24
    50e8:	26 89       	ldd	r18, Z+22	; 0x16
    50ea:	80 91 40 02 	lds	r24, 0x0240
    50ee:	90 91 41 02 	lds	r25, 0x0241
    50f2:	fc 01       	movw	r30, r24
    50f4:	86 89       	ldd	r24, Z+22	; 0x16
    50f6:	82 17       	cp	r24, r18
    50f8:	30 f4       	brcc	.+12     	; 0x5106 <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    50fa:	81 e0       	ldi	r24, 0x01	; 1
    50fc:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    50fe:	81 e0       	ldi	r24, 0x01	; 1
    5100:	80 93 9e 02 	sts	0x029E, r24
    5104:	01 c0       	rjmp	.+2      	; 0x5108 <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    5106:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    5108:	89 81       	ldd	r24, Y+1	; 0x01
}
    510a:	0f 90       	pop	r0
    510c:	0f 90       	pop	r0
    510e:	0f 90       	pop	r0
    5110:	0f 90       	pop	r0
    5112:	0f 90       	pop	r0
    5114:	df 91       	pop	r29
    5116:	cf 91       	pop	r28
    5118:	08 95       	ret

0000511a <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    511a:	cf 93       	push	r28
    511c:	df 93       	push	r29
    511e:	cd b7       	in	r28, 0x3d	; 61
    5120:	de b7       	in	r29, 0x3e	; 62
    5122:	27 97       	sbiw	r28, 0x07	; 7
    5124:	0f b6       	in	r0, 0x3f	; 63
    5126:	f8 94       	cli
    5128:	de bf       	out	0x3e, r29	; 62
    512a:	0f be       	out	0x3f, r0	; 63
    512c:	cd bf       	out	0x3d, r28	; 61
    512e:	9d 83       	std	Y+5, r25	; 0x05
    5130:	8c 83       	std	Y+4, r24	; 0x04
    5132:	7f 83       	std	Y+7, r23	; 0x07
    5134:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5136:	8e 81       	ldd	r24, Y+6	; 0x06
    5138:	9f 81       	ldd	r25, Y+7	; 0x07
    513a:	9c 01       	movw	r18, r24
    513c:	30 68       	ori	r19, 0x80	; 128
    513e:	8c 81       	ldd	r24, Y+4	; 0x04
    5140:	9d 81       	ldd	r25, Y+5	; 0x05
    5142:	fc 01       	movw	r30, r24
    5144:	31 83       	std	Z+1, r19	; 0x01
    5146:	20 83       	st	Z, r18

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    5148:	8c 81       	ldd	r24, Y+4	; 0x04
    514a:	9d 81       	ldd	r25, Y+5	; 0x05
    514c:	fc 01       	movw	r30, r24
    514e:	86 81       	ldd	r24, Z+6	; 0x06
    5150:	97 81       	ldd	r25, Z+7	; 0x07
    5152:	9b 83       	std	Y+3, r25	; 0x03
    5154:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    5156:	8c 81       	ldd	r24, Y+4	; 0x04
    5158:	9d 81       	ldd	r25, Y+5	; 0x05
    515a:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    515e:	8a 81       	ldd	r24, Y+2	; 0x02
    5160:	9b 81       	ldd	r25, Y+3	; 0x03
    5162:	02 96       	adiw	r24, 0x02	; 2
    5164:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    5168:	8a 81       	ldd	r24, Y+2	; 0x02
    516a:	9b 81       	ldd	r25, Y+3	; 0x03
    516c:	fc 01       	movw	r30, r24
    516e:	96 89       	ldd	r25, Z+22	; 0x16
    5170:	80 91 9b 02 	lds	r24, 0x029B
    5174:	89 17       	cp	r24, r25
    5176:	30 f4       	brcc	.+12     	; 0x5184 <xTaskRemoveFromUnorderedEventList+0x6a>
    5178:	8a 81       	ldd	r24, Y+2	; 0x02
    517a:	9b 81       	ldd	r25, Y+3	; 0x03
    517c:	fc 01       	movw	r30, r24
    517e:	86 89       	ldd	r24, Z+22	; 0x16
    5180:	80 93 9b 02 	sts	0x029B, r24
    5184:	8a 81       	ldd	r24, Y+2	; 0x02
    5186:	9b 81       	ldd	r25, Y+3	; 0x03
    5188:	ac 01       	movw	r20, r24
    518a:	4e 5f       	subi	r20, 0xFE	; 254
    518c:	5f 4f       	sbci	r21, 0xFF	; 255
    518e:	8a 81       	ldd	r24, Y+2	; 0x02
    5190:	9b 81       	ldd	r25, Y+3	; 0x03
    5192:	fc 01       	movw	r30, r24
    5194:	86 89       	ldd	r24, Z+22	; 0x16
    5196:	28 2f       	mov	r18, r24
    5198:	30 e0       	ldi	r19, 0x00	; 0
    519a:	c9 01       	movw	r24, r18
    519c:	88 0f       	add	r24, r24
    519e:	99 1f       	adc	r25, r25
    51a0:	88 0f       	add	r24, r24
    51a2:	99 1f       	adc	r25, r25
    51a4:	88 0f       	add	r24, r24
    51a6:	99 1f       	adc	r25, r25
    51a8:	82 0f       	add	r24, r18
    51aa:	93 1f       	adc	r25, r19
    51ac:	8e 5b       	subi	r24, 0xBE	; 190
    51ae:	9d 4f       	sbci	r25, 0xFD	; 253
    51b0:	ba 01       	movw	r22, r20
    51b2:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    51b6:	8a 81       	ldd	r24, Y+2	; 0x02
    51b8:	9b 81       	ldd	r25, Y+3	; 0x03
    51ba:	fc 01       	movw	r30, r24
    51bc:	26 89       	ldd	r18, Z+22	; 0x16
    51be:	80 91 40 02 	lds	r24, 0x0240
    51c2:	90 91 41 02 	lds	r25, 0x0241
    51c6:	fc 01       	movw	r30, r24
    51c8:	86 89       	ldd	r24, Z+22	; 0x16
    51ca:	82 17       	cp	r24, r18
    51cc:	30 f4       	brcc	.+12     	; 0x51da <xTaskRemoveFromUnorderedEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    51ce:	81 e0       	ldi	r24, 0x01	; 1
    51d0:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    51d2:	81 e0       	ldi	r24, 0x01	; 1
    51d4:	80 93 9e 02 	sts	0x029E, r24
    51d8:	01 c0       	rjmp	.+2      	; 0x51dc <xTaskRemoveFromUnorderedEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
    51da:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    51dc:	89 81       	ldd	r24, Y+1	; 0x01
}
    51de:	27 96       	adiw	r28, 0x07	; 7
    51e0:	0f b6       	in	r0, 0x3f	; 63
    51e2:	f8 94       	cli
    51e4:	de bf       	out	0x3e, r29	; 62
    51e6:	0f be       	out	0x3f, r0	; 63
    51e8:	cd bf       	out	0x3d, r28	; 61
    51ea:	df 91       	pop	r29
    51ec:	cf 91       	pop	r28
    51ee:	08 95       	ret

000051f0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    51f0:	cf 93       	push	r28
    51f2:	df 93       	push	r29
    51f4:	1f 92       	push	r1
    51f6:	1f 92       	push	r1
    51f8:	cd b7       	in	r28, 0x3d	; 61
    51fa:	de b7       	in	r29, 0x3e	; 62
    51fc:	9a 83       	std	Y+2, r25	; 0x02
    51fe:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5200:	20 91 9f 02 	lds	r18, 0x029F
    5204:	89 81       	ldd	r24, Y+1	; 0x01
    5206:	9a 81       	ldd	r25, Y+2	; 0x02
    5208:	fc 01       	movw	r30, r24
    520a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    520c:	20 91 99 02 	lds	r18, 0x0299
    5210:	30 91 9a 02 	lds	r19, 0x029A
    5214:	89 81       	ldd	r24, Y+1	; 0x01
    5216:	9a 81       	ldd	r25, Y+2	; 0x02
    5218:	fc 01       	movw	r30, r24
    521a:	32 83       	std	Z+2, r19	; 0x02
    521c:	21 83       	std	Z+1, r18	; 0x01
}
    521e:	0f 90       	pop	r0
    5220:	0f 90       	pop	r0
    5222:	df 91       	pop	r29
    5224:	cf 91       	pop	r28
    5226:	08 95       	ret

00005228 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5228:	cf 93       	push	r28
    522a:	df 93       	push	r29
    522c:	cd b7       	in	r28, 0x3d	; 61
    522e:	de b7       	in	r29, 0x3e	; 62
    5230:	27 97       	sbiw	r28, 0x07	; 7
    5232:	0f b6       	in	r0, 0x3f	; 63
    5234:	f8 94       	cli
    5236:	de bf       	out	0x3e, r29	; 62
    5238:	0f be       	out	0x3f, r0	; 63
    523a:	cd bf       	out	0x3d, r28	; 61
    523c:	9d 83       	std	Y+5, r25	; 0x05
    523e:	8c 83       	std	Y+4, r24	; 0x04
    5240:	7f 83       	std	Y+7, r23	; 0x07
    5242:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5244:	0f b6       	in	r0, 0x3f	; 63
    5246:	f8 94       	cli
    5248:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    524a:	80 91 99 02 	lds	r24, 0x0299
    524e:	90 91 9a 02 	lds	r25, 0x029A
    5252:	9b 83       	std	Y+3, r25	; 0x03
    5254:	8a 83       	std	Y+2, r24	; 0x02

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    5256:	8e 81       	ldd	r24, Y+6	; 0x06
    5258:	9f 81       	ldd	r25, Y+7	; 0x07
    525a:	fc 01       	movw	r30, r24
    525c:	80 81       	ld	r24, Z
    525e:	91 81       	ldd	r25, Z+1	; 0x01
    5260:	01 96       	adiw	r24, 0x01	; 1
    5262:	11 f4       	brne	.+4      	; 0x5268 <xTaskCheckForTimeOut+0x40>
			{
				xReturn = pdFALSE;
    5264:	19 82       	std	Y+1, r1	; 0x01
    5266:	45 c0       	rjmp	.+138    	; 0x52f2 <xTaskCheckForTimeOut+0xca>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    5268:	8c 81       	ldd	r24, Y+4	; 0x04
    526a:	9d 81       	ldd	r25, Y+5	; 0x05
    526c:	fc 01       	movw	r30, r24
    526e:	90 81       	ld	r25, Z
    5270:	80 91 9f 02 	lds	r24, 0x029F
    5274:	98 17       	cp	r25, r24
    5276:	69 f0       	breq	.+26     	; 0x5292 <xTaskCheckForTimeOut+0x6a>
    5278:	8c 81       	ldd	r24, Y+4	; 0x04
    527a:	9d 81       	ldd	r25, Y+5	; 0x05
    527c:	fc 01       	movw	r30, r24
    527e:	21 81       	ldd	r18, Z+1	; 0x01
    5280:	32 81       	ldd	r19, Z+2	; 0x02
    5282:	8a 81       	ldd	r24, Y+2	; 0x02
    5284:	9b 81       	ldd	r25, Y+3	; 0x03
    5286:	82 17       	cp	r24, r18
    5288:	93 07       	cpc	r25, r19
    528a:	18 f0       	brcs	.+6      	; 0x5292 <xTaskCheckForTimeOut+0x6a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    528c:	81 e0       	ldi	r24, 0x01	; 1
    528e:	89 83       	std	Y+1, r24	; 0x01
    5290:	30 c0       	rjmp	.+96     	; 0x52f2 <xTaskCheckForTimeOut+0xca>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    5292:	8c 81       	ldd	r24, Y+4	; 0x04
    5294:	9d 81       	ldd	r25, Y+5	; 0x05
    5296:	fc 01       	movw	r30, r24
    5298:	81 81       	ldd	r24, Z+1	; 0x01
    529a:	92 81       	ldd	r25, Z+2	; 0x02
    529c:	2a 81       	ldd	r18, Y+2	; 0x02
    529e:	3b 81       	ldd	r19, Y+3	; 0x03
    52a0:	28 1b       	sub	r18, r24
    52a2:	39 0b       	sbc	r19, r25
    52a4:	8e 81       	ldd	r24, Y+6	; 0x06
    52a6:	9f 81       	ldd	r25, Y+7	; 0x07
    52a8:	fc 01       	movw	r30, r24
    52aa:	80 81       	ld	r24, Z
    52ac:	91 81       	ldd	r25, Z+1	; 0x01
    52ae:	28 17       	cp	r18, r24
    52b0:	39 07       	cpc	r19, r25
    52b2:	e8 f4       	brcc	.+58     	; 0x52ee <xTaskCheckForTimeOut+0xc6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    52b4:	8e 81       	ldd	r24, Y+6	; 0x06
    52b6:	9f 81       	ldd	r25, Y+7	; 0x07
    52b8:	fc 01       	movw	r30, r24
    52ba:	20 81       	ld	r18, Z
    52bc:	31 81       	ldd	r19, Z+1	; 0x01
    52be:	8c 81       	ldd	r24, Y+4	; 0x04
    52c0:	9d 81       	ldd	r25, Y+5	; 0x05
    52c2:	fc 01       	movw	r30, r24
    52c4:	41 81       	ldd	r20, Z+1	; 0x01
    52c6:	52 81       	ldd	r21, Z+2	; 0x02
    52c8:	8a 81       	ldd	r24, Y+2	; 0x02
    52ca:	9b 81       	ldd	r25, Y+3	; 0x03
    52cc:	ba 01       	movw	r22, r20
    52ce:	68 1b       	sub	r22, r24
    52d0:	79 0b       	sbc	r23, r25
    52d2:	cb 01       	movw	r24, r22
    52d4:	28 0f       	add	r18, r24
    52d6:	39 1f       	adc	r19, r25
    52d8:	8e 81       	ldd	r24, Y+6	; 0x06
    52da:	9f 81       	ldd	r25, Y+7	; 0x07
    52dc:	fc 01       	movw	r30, r24
    52de:	31 83       	std	Z+1, r19	; 0x01
    52e0:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    52e2:	8c 81       	ldd	r24, Y+4	; 0x04
    52e4:	9d 81       	ldd	r25, Y+5	; 0x05
    52e6:	0e 94 f8 28 	call	0x51f0	; 0x51f0 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    52ea:	19 82       	std	Y+1, r1	; 0x01
    52ec:	02 c0       	rjmp	.+4      	; 0x52f2 <xTaskCheckForTimeOut+0xca>
		}
		else
		{
			xReturn = pdTRUE;
    52ee:	81 e0       	ldi	r24, 0x01	; 1
    52f0:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    52f2:	0f 90       	pop	r0
    52f4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    52f6:	89 81       	ldd	r24, Y+1	; 0x01
}
    52f8:	27 96       	adiw	r28, 0x07	; 7
    52fa:	0f b6       	in	r0, 0x3f	; 63
    52fc:	f8 94       	cli
    52fe:	de bf       	out	0x3e, r29	; 62
    5300:	0f be       	out	0x3f, r0	; 63
    5302:	cd bf       	out	0x3d, r28	; 61
    5304:	df 91       	pop	r29
    5306:	cf 91       	pop	r28
    5308:	08 95       	ret

0000530a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    530a:	cf 93       	push	r28
    530c:	df 93       	push	r29
    530e:	cd b7       	in	r28, 0x3d	; 61
    5310:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    5312:	81 e0       	ldi	r24, 0x01	; 1
    5314:	80 93 9e 02 	sts	0x029E, r24
}
    5318:	df 91       	pop	r29
    531a:	cf 91       	pop	r28
    531c:	08 95       	ret

0000531e <prvInitialiseTCBVariables>:

#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    531e:	0f 93       	push	r16
    5320:	1f 93       	push	r17
    5322:	cf 93       	push	r28
    5324:	df 93       	push	r29
    5326:	cd b7       	in	r28, 0x3d	; 61
    5328:	de b7       	in	r29, 0x3e	; 62
    532a:	2a 97       	sbiw	r28, 0x0a	; 10
    532c:	0f b6       	in	r0, 0x3f	; 63
    532e:	f8 94       	cli
    5330:	de bf       	out	0x3e, r29	; 62
    5332:	0f be       	out	0x3f, r0	; 63
    5334:	cd bf       	out	0x3d, r28	; 61
    5336:	9b 83       	std	Y+3, r25	; 0x03
    5338:	8a 83       	std	Y+2, r24	; 0x02
    533a:	7d 83       	std	Y+5, r23	; 0x05
    533c:	6c 83       	std	Y+4, r22	; 0x04
    533e:	4e 83       	std	Y+6, r20	; 0x06
    5340:	38 87       	std	Y+8, r19	; 0x08
    5342:	2f 83       	std	Y+7, r18	; 0x07
    5344:	1a 87       	std	Y+10, r17	; 0x0a
    5346:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5348:	19 82       	std	Y+1, r1	; 0x01
    534a:	22 c0       	rjmp	.+68     	; 0x5390 <prvInitialiseTCBVariables+0x72>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    534c:	89 81       	ldd	r24, Y+1	; 0x01
    534e:	88 2f       	mov	r24, r24
    5350:	90 e0       	ldi	r25, 0x00	; 0
    5352:	29 81       	ldd	r18, Y+1	; 0x01
    5354:	22 2f       	mov	r18, r18
    5356:	30 e0       	ldi	r19, 0x00	; 0
    5358:	4c 81       	ldd	r20, Y+4	; 0x04
    535a:	5d 81       	ldd	r21, Y+5	; 0x05
    535c:	24 0f       	add	r18, r20
    535e:	35 1f       	adc	r19, r21
    5360:	f9 01       	movw	r30, r18
    5362:	40 81       	ld	r20, Z
    5364:	2a 81       	ldd	r18, Y+2	; 0x02
    5366:	3b 81       	ldd	r19, Y+3	; 0x03
    5368:	82 0f       	add	r24, r18
    536a:	93 1f       	adc	r25, r19
    536c:	49 96       	adiw	r24, 0x19	; 25
    536e:	fc 01       	movw	r30, r24
    5370:	40 83       	st	Z, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    5372:	89 81       	ldd	r24, Y+1	; 0x01
    5374:	88 2f       	mov	r24, r24
    5376:	90 e0       	ldi	r25, 0x00	; 0
    5378:	2c 81       	ldd	r18, Y+4	; 0x04
    537a:	3d 81       	ldd	r19, Y+5	; 0x05
    537c:	82 0f       	add	r24, r18
    537e:	93 1f       	adc	r25, r19
    5380:	fc 01       	movw	r30, r24
    5382:	80 81       	ld	r24, Z
    5384:	88 23       	and	r24, r24
    5386:	09 f4       	brne	.+2      	; 0x538a <prvInitialiseTCBVariables+0x6c>
		{
			break;
    5388:	06 c0       	rjmp	.+12     	; 0x5396 <prvInitialiseTCBVariables+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    538a:	89 81       	ldd	r24, Y+1	; 0x01
    538c:	8f 5f       	subi	r24, 0xFF	; 255
    538e:	89 83       	std	Y+1, r24	; 0x01
    5390:	89 81       	ldd	r24, Y+1	; 0x01
    5392:	88 30       	cpi	r24, 0x08	; 8
    5394:	d8 f2       	brcs	.-74     	; 0x534c <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    5396:	8a 81       	ldd	r24, Y+2	; 0x02
    5398:	9b 81       	ldd	r25, Y+3	; 0x03
    539a:	fc 01       	movw	r30, r24
    539c:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    539e:	8e 81       	ldd	r24, Y+6	; 0x06
    53a0:	84 30       	cpi	r24, 0x04	; 4
    53a2:	10 f0       	brcs	.+4      	; 0x53a8 <prvInitialiseTCBVariables+0x8a>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    53a4:	83 e0       	ldi	r24, 0x03	; 3
    53a6:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    53a8:	8a 81       	ldd	r24, Y+2	; 0x02
    53aa:	9b 81       	ldd	r25, Y+3	; 0x03
    53ac:	2e 81       	ldd	r18, Y+6	; 0x06
    53ae:	fc 01       	movw	r30, r24
    53b0:	26 8b       	std	Z+22, r18	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    53b2:	8a 81       	ldd	r24, Y+2	; 0x02
    53b4:	9b 81       	ldd	r25, Y+3	; 0x03
    53b6:	2e 81       	ldd	r18, Y+6	; 0x06
    53b8:	fc 01       	movw	r30, r24
    53ba:	21 a3       	std	Z+33, r18	; 0x21
		pxTCB->uxMutexesHeld = 0;
    53bc:	8a 81       	ldd	r24, Y+2	; 0x02
    53be:	9b 81       	ldd	r25, Y+3	; 0x03
    53c0:	fc 01       	movw	r30, r24
    53c2:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    53c4:	8a 81       	ldd	r24, Y+2	; 0x02
    53c6:	9b 81       	ldd	r25, Y+3	; 0x03
    53c8:	02 96       	adiw	r24, 0x02	; 2
    53ca:	0e 94 50 14 	call	0x28a0	; 0x28a0 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    53ce:	8a 81       	ldd	r24, Y+2	; 0x02
    53d0:	9b 81       	ldd	r25, Y+3	; 0x03
    53d2:	0c 96       	adiw	r24, 0x0c	; 12
    53d4:	0e 94 50 14 	call	0x28a0	; 0x28a0 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    53d8:	8a 81       	ldd	r24, Y+2	; 0x02
    53da:	9b 81       	ldd	r25, Y+3	; 0x03
    53dc:	2a 81       	ldd	r18, Y+2	; 0x02
    53de:	3b 81       	ldd	r19, Y+3	; 0x03
    53e0:	fc 01       	movw	r30, r24
    53e2:	31 87       	std	Z+9, r19	; 0x09
    53e4:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    53e6:	8e 81       	ldd	r24, Y+6	; 0x06
    53e8:	88 2f       	mov	r24, r24
    53ea:	90 e0       	ldi	r25, 0x00	; 0
    53ec:	24 e0       	ldi	r18, 0x04	; 4
    53ee:	30 e0       	ldi	r19, 0x00	; 0
    53f0:	28 1b       	sub	r18, r24
    53f2:	39 0b       	sbc	r19, r25
    53f4:	8a 81       	ldd	r24, Y+2	; 0x02
    53f6:	9b 81       	ldd	r25, Y+3	; 0x03
    53f8:	fc 01       	movw	r30, r24
    53fa:	35 87       	std	Z+13, r19	; 0x0d
    53fc:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    53fe:	8a 81       	ldd	r24, Y+2	; 0x02
    5400:	9b 81       	ldd	r25, Y+3	; 0x03
    5402:	2a 81       	ldd	r18, Y+2	; 0x02
    5404:	3b 81       	ldd	r19, Y+3	; 0x03
    5406:	fc 01       	movw	r30, r24
    5408:	33 8b       	std	Z+19, r19	; 0x13
    540a:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    540c:	8a 81       	ldd	r24, Y+2	; 0x02
    540e:	9b 81       	ldd	r25, Y+3	; 0x03
    5410:	fc 01       	movw	r30, r24
    5412:	13 a2       	std	Z+35, r1	; 0x23
    5414:	14 a2       	std	Z+36, r1	; 0x24
    5416:	15 a2       	std	Z+37, r1	; 0x25
    5418:	16 a2       	std	Z+38, r1	; 0x26
		pxTCB->eNotifyState = eNotWaitingNotification;
    541a:	8a 81       	ldd	r24, Y+2	; 0x02
    541c:	9b 81       	ldd	r25, Y+3	; 0x03
    541e:	fc 01       	movw	r30, r24
    5420:	17 a2       	std	Z+39, r1	; 0x27
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    5422:	2a 96       	adiw	r28, 0x0a	; 10
    5424:	0f b6       	in	r0, 0x3f	; 63
    5426:	f8 94       	cli
    5428:	de bf       	out	0x3e, r29	; 62
    542a:	0f be       	out	0x3f, r0	; 63
    542c:	cd bf       	out	0x3d, r28	; 61
    542e:	df 91       	pop	r29
    5430:	cf 91       	pop	r28
    5432:	1f 91       	pop	r17
    5434:	0f 91       	pop	r16
    5436:	08 95       	ret

00005438 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    5438:	cf 93       	push	r28
    543a:	df 93       	push	r29
    543c:	1f 92       	push	r1
    543e:	cd b7       	in	r28, 0x3d	; 61
    5440:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5442:	19 82       	std	Y+1, r1	; 0x01
    5444:	13 c0       	rjmp	.+38     	; 0x546c <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5446:	89 81       	ldd	r24, Y+1	; 0x01
    5448:	28 2f       	mov	r18, r24
    544a:	30 e0       	ldi	r19, 0x00	; 0
    544c:	c9 01       	movw	r24, r18
    544e:	88 0f       	add	r24, r24
    5450:	99 1f       	adc	r25, r25
    5452:	88 0f       	add	r24, r24
    5454:	99 1f       	adc	r25, r25
    5456:	88 0f       	add	r24, r24
    5458:	99 1f       	adc	r25, r25
    545a:	82 0f       	add	r24, r18
    545c:	93 1f       	adc	r25, r19
    545e:	8e 5b       	subi	r24, 0xBE	; 190
    5460:	9d 4f       	sbci	r25, 0xFD	; 253
    5462:	0e 94 1a 14 	call	0x2834	; 0x2834 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5466:	89 81       	ldd	r24, Y+1	; 0x01
    5468:	8f 5f       	subi	r24, 0xFF	; 255
    546a:	89 83       	std	Y+1, r24	; 0x01
    546c:	89 81       	ldd	r24, Y+1	; 0x01
    546e:	84 30       	cpi	r24, 0x04	; 4
    5470:	50 f3       	brcs	.-44     	; 0x5446 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    5472:	86 e6       	ldi	r24, 0x66	; 102
    5474:	92 e0       	ldi	r25, 0x02	; 2
    5476:	0e 94 1a 14 	call	0x2834	; 0x2834 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    547a:	8f e6       	ldi	r24, 0x6F	; 111
    547c:	92 e0       	ldi	r25, 0x02	; 2
    547e:	0e 94 1a 14 	call	0x2834	; 0x2834 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    5482:	8c e7       	ldi	r24, 0x7C	; 124
    5484:	92 e0       	ldi	r25, 0x02	; 2
    5486:	0e 94 1a 14 	call	0x2834	; 0x2834 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    548a:	85 e8       	ldi	r24, 0x85	; 133
    548c:	92 e0       	ldi	r25, 0x02	; 2
    548e:	0e 94 1a 14 	call	0x2834	; 0x2834 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    5492:	8f e8       	ldi	r24, 0x8F	; 143
    5494:	92 e0       	ldi	r25, 0x02	; 2
    5496:	0e 94 1a 14 	call	0x2834	; 0x2834 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    549a:	86 e6       	ldi	r24, 0x66	; 102
    549c:	92 e0       	ldi	r25, 0x02	; 2
    549e:	90 93 79 02 	sts	0x0279, r25
    54a2:	80 93 78 02 	sts	0x0278, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    54a6:	8f e6       	ldi	r24, 0x6F	; 111
    54a8:	92 e0       	ldi	r25, 0x02	; 2
    54aa:	90 93 7b 02 	sts	0x027B, r25
    54ae:	80 93 7a 02 	sts	0x027A, r24
}
    54b2:	0f 90       	pop	r0
    54b4:	df 91       	pop	r29
    54b6:	cf 91       	pop	r28
    54b8:	08 95       	ret

000054ba <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    54ba:	cf 93       	push	r28
    54bc:	df 93       	push	r29
    54be:	00 d0       	rcall	.+0      	; 0x54c0 <prvCheckTasksWaitingTermination+0x6>
    54c0:	cd b7       	in	r28, 0x3d	; 61
    54c2:	de b7       	in	r29, 0x3e	; 62
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    54c4:	2f c0       	rjmp	.+94     	; 0x5524 <prvCheckTasksWaitingTermination+0x6a>
		{
			vTaskSuspendAll();
    54c6:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    54ca:	90 91 85 02 	lds	r25, 0x0285
    54ce:	81 e0       	ldi	r24, 0x01	; 1
    54d0:	99 23       	and	r25, r25
    54d2:	09 f0       	breq	.+2      	; 0x54d6 <prvCheckTasksWaitingTermination+0x1c>
    54d4:	80 e0       	ldi	r24, 0x00	; 0
    54d6:	89 83       	std	Y+1, r24	; 0x01
			}
			( void ) xTaskResumeAll();
    54d8:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    54dc:	89 81       	ldd	r24, Y+1	; 0x01
    54de:	88 23       	and	r24, r24
    54e0:	09 f5       	brne	.+66     	; 0x5524 <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    54e2:	0f b6       	in	r0, 0x3f	; 63
    54e4:	f8 94       	cli
    54e6:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    54e8:	80 91 8a 02 	lds	r24, 0x028A
    54ec:	90 91 8b 02 	lds	r25, 0x028B
    54f0:	fc 01       	movw	r30, r24
    54f2:	86 81       	ldd	r24, Z+6	; 0x06
    54f4:	97 81       	ldd	r25, Z+7	; 0x07
    54f6:	9b 83       	std	Y+3, r25	; 0x03
    54f8:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    54fa:	8a 81       	ldd	r24, Y+2	; 0x02
    54fc:	9b 81       	ldd	r25, Y+3	; 0x03
    54fe:	02 96       	adiw	r24, 0x02	; 2
    5500:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
					--uxCurrentNumberOfTasks;
    5504:	80 91 98 02 	lds	r24, 0x0298
    5508:	81 50       	subi	r24, 0x01	; 1
    550a:	80 93 98 02 	sts	0x0298, r24
					--uxTasksDeleted;
    550e:	80 91 8e 02 	lds	r24, 0x028E
    5512:	81 50       	subi	r24, 0x01	; 1
    5514:	80 93 8e 02 	sts	0x028E, r24
				}
				taskEXIT_CRITICAL();
    5518:	0f 90       	pop	r0
    551a:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    551c:	8a 81       	ldd	r24, Y+2	; 0x02
    551e:	9b 81       	ldd	r25, Y+3	; 0x03
    5520:	0e 94 97 2b 	call	0x572e	; 0x572e <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    5524:	80 91 8e 02 	lds	r24, 0x028E
    5528:	88 23       	and	r24, r24
    552a:	69 f6       	brne	.-102    	; 0x54c6 <prvCheckTasksWaitingTermination+0xc>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    552c:	0f 90       	pop	r0
    552e:	0f 90       	pop	r0
    5530:	0f 90       	pop	r0
    5532:	df 91       	pop	r29
    5534:	cf 91       	pop	r28
    5536:	08 95       	ret

00005538 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    5538:	cf 93       	push	r28
    553a:	df 93       	push	r29
    553c:	1f 92       	push	r1
    553e:	1f 92       	push	r1
    5540:	cd b7       	in	r28, 0x3d	; 61
    5542:	de b7       	in	r29, 0x3e	; 62
    5544:	9a 83       	std	Y+2, r25	; 0x02
    5546:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    5548:	80 91 40 02 	lds	r24, 0x0240
    554c:	90 91 41 02 	lds	r25, 0x0241
    5550:	29 81       	ldd	r18, Y+1	; 0x01
    5552:	3a 81       	ldd	r19, Y+2	; 0x02
    5554:	fc 01       	movw	r30, r24
    5556:	33 83       	std	Z+3, r19	; 0x03
    5558:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    555a:	80 91 99 02 	lds	r24, 0x0299
    555e:	90 91 9a 02 	lds	r25, 0x029A
    5562:	29 81       	ldd	r18, Y+1	; 0x01
    5564:	3a 81       	ldd	r19, Y+2	; 0x02
    5566:	28 17       	cp	r18, r24
    5568:	39 07       	cpc	r19, r25
    556a:	78 f4       	brcc	.+30     	; 0x558a <prvAddCurrentTaskToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    556c:	80 91 40 02 	lds	r24, 0x0240
    5570:	90 91 41 02 	lds	r25, 0x0241
    5574:	9c 01       	movw	r18, r24
    5576:	2e 5f       	subi	r18, 0xFE	; 254
    5578:	3f 4f       	sbci	r19, 0xFF	; 255
    557a:	80 91 7a 02 	lds	r24, 0x027A
    557e:	90 91 7b 02 	lds	r25, 0x027B
    5582:	b9 01       	movw	r22, r18
    5584:	0e 94 af 14 	call	0x295e	; 0x295e <vListInsert>
    5588:	1d c0       	rjmp	.+58     	; 0x55c4 <prvAddCurrentTaskToDelayedList+0x8c>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    558a:	80 91 40 02 	lds	r24, 0x0240
    558e:	90 91 41 02 	lds	r25, 0x0241
    5592:	9c 01       	movw	r18, r24
    5594:	2e 5f       	subi	r18, 0xFE	; 254
    5596:	3f 4f       	sbci	r19, 0xFF	; 255
    5598:	80 91 78 02 	lds	r24, 0x0278
    559c:	90 91 79 02 	lds	r25, 0x0279
    55a0:	b9 01       	movw	r22, r18
    55a2:	0e 94 af 14 	call	0x295e	; 0x295e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    55a6:	80 91 a1 02 	lds	r24, 0x02A1
    55aa:	90 91 a2 02 	lds	r25, 0x02A2
    55ae:	29 81       	ldd	r18, Y+1	; 0x01
    55b0:	3a 81       	ldd	r19, Y+2	; 0x02
    55b2:	28 17       	cp	r18, r24
    55b4:	39 07       	cpc	r19, r25
    55b6:	30 f4       	brcc	.+12     	; 0x55c4 <prvAddCurrentTaskToDelayedList+0x8c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    55b8:	89 81       	ldd	r24, Y+1	; 0x01
    55ba:	9a 81       	ldd	r25, Y+2	; 0x02
    55bc:	90 93 a2 02 	sts	0x02A2, r25
    55c0:	80 93 a1 02 	sts	0x02A1, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    55c4:	0f 90       	pop	r0
    55c6:	0f 90       	pop	r0
    55c8:	df 91       	pop	r29
    55ca:	cf 91       	pop	r28
    55cc:	08 95       	ret

000055ce <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    55ce:	cf 93       	push	r28
    55d0:	df 93       	push	r29
    55d2:	cd b7       	in	r28, 0x3d	; 61
    55d4:	de b7       	in	r29, 0x3e	; 62
    55d6:	28 97       	sbiw	r28, 0x08	; 8
    55d8:	0f b6       	in	r0, 0x3f	; 63
    55da:	f8 94       	cli
    55dc:	de bf       	out	0x3e, r29	; 62
    55de:	0f be       	out	0x3f, r0	; 63
    55e0:	cd bf       	out	0x3d, r28	; 61
    55e2:	9e 83       	std	Y+6, r25	; 0x06
    55e4:	8d 83       	std	Y+5, r24	; 0x05
    55e6:	78 87       	std	Y+8, r23	; 0x08
    55e8:	6f 83       	std	Y+7, r22	; 0x07
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    55ea:	8f 81       	ldd	r24, Y+7	; 0x07
    55ec:	98 85       	ldd	r25, Y+8	; 0x08
    55ee:	89 2b       	or	r24, r25
    55f0:	29 f4       	brne	.+10     	; 0x55fc <prvAllocateTCBAndStack+0x2e>
    55f2:	8d 81       	ldd	r24, Y+5	; 0x05
    55f4:	9e 81       	ldd	r25, Y+6	; 0x06
    55f6:	0e 94 63 12 	call	0x24c6	; 0x24c6 <pvPortMalloc>
    55fa:	02 c0       	rjmp	.+4      	; 0x5600 <prvAllocateTCBAndStack+0x32>
    55fc:	8f 81       	ldd	r24, Y+7	; 0x07
    55fe:	98 85       	ldd	r25, Y+8	; 0x08
    5600:	9c 83       	std	Y+4, r25	; 0x04
    5602:	8b 83       	std	Y+3, r24	; 0x03

		if( pxStack != NULL )
    5604:	8b 81       	ldd	r24, Y+3	; 0x03
    5606:	9c 81       	ldd	r25, Y+4	; 0x04
    5608:	89 2b       	or	r24, r25
    560a:	b9 f0       	breq	.+46     	; 0x563a <prvAllocateTCBAndStack+0x6c>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    560c:	88 e2       	ldi	r24, 0x28	; 40
    560e:	90 e0       	ldi	r25, 0x00	; 0
    5610:	0e 94 63 12 	call	0x24c6	; 0x24c6 <pvPortMalloc>
    5614:	9a 83       	std	Y+2, r25	; 0x02
    5616:	89 83       	std	Y+1, r24	; 0x01

			if( pxNewTCB != NULL )
    5618:	89 81       	ldd	r24, Y+1	; 0x01
    561a:	9a 81       	ldd	r25, Y+2	; 0x02
    561c:	89 2b       	or	r24, r25
    561e:	41 f0       	breq	.+16     	; 0x5630 <prvAllocateTCBAndStack+0x62>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    5620:	89 81       	ldd	r24, Y+1	; 0x01
    5622:	9a 81       	ldd	r25, Y+2	; 0x02
    5624:	2b 81       	ldd	r18, Y+3	; 0x03
    5626:	3c 81       	ldd	r19, Y+4	; 0x04
    5628:	fc 01       	movw	r30, r24
    562a:	30 8f       	std	Z+24, r19	; 0x18
    562c:	27 8b       	std	Z+23, r18	; 0x17
    562e:	07 c0       	rjmp	.+14     	; 0x563e <prvAllocateTCBAndStack+0x70>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    5630:	8b 81       	ldd	r24, Y+3	; 0x03
    5632:	9c 81       	ldd	r25, Y+4	; 0x04
    5634:	0e 94 84 12 	call	0x2508	; 0x2508 <vPortFree>
    5638:	02 c0       	rjmp	.+4      	; 0x563e <prvAllocateTCBAndStack+0x70>
			}
		}
		else
		{
			pxNewTCB = NULL;
    563a:	1a 82       	std	Y+2, r1	; 0x02
    563c:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	#endif /* portSTACK_GROWTH */

	if( pxNewTCB != NULL )
    563e:	89 81       	ldd	r24, Y+1	; 0x01
    5640:	9a 81       	ldd	r25, Y+2	; 0x02
    5642:	89 2b       	or	r24, r25
    5644:	61 f0       	breq	.+24     	; 0x565e <prvAllocateTCBAndStack+0x90>
	{
		/* Avoid dependency on memset() if it is not required. */
		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
    5646:	89 81       	ldd	r24, Y+1	; 0x01
    5648:	9a 81       	ldd	r25, Y+2	; 0x02
    564a:	fc 01       	movw	r30, r24
    564c:	87 89       	ldd	r24, Z+23	; 0x17
    564e:	90 8d       	ldd	r25, Z+24	; 0x18
    5650:	2d 81       	ldd	r18, Y+5	; 0x05
    5652:	3e 81       	ldd	r19, Y+6	; 0x06
    5654:	a9 01       	movw	r20, r18
    5656:	65 ea       	ldi	r22, 0xA5	; 165
    5658:	70 e0       	ldi	r23, 0x00	; 0
    565a:	0e 94 f9 36 	call	0x6df2	; 0x6df2 <memset>
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
    565e:	89 81       	ldd	r24, Y+1	; 0x01
    5660:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5662:	28 96       	adiw	r28, 0x08	; 8
    5664:	0f b6       	in	r0, 0x3f	; 63
    5666:	f8 94       	cli
    5668:	de bf       	out	0x3e, r29	; 62
    566a:	0f be       	out	0x3f, r0	; 63
    566c:	cd bf       	out	0x3d, r28	; 61
    566e:	df 91       	pop	r29
    5670:	cf 91       	pop	r28
    5672:	08 95       	ret

00005674 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
    5674:	cf 93       	push	r28
    5676:	df 93       	push	r29
    5678:	00 d0       	rcall	.+0      	; 0x567a <prvTaskCheckFreeStackSpace+0x6>
    567a:	00 d0       	rcall	.+0      	; 0x567c <prvTaskCheckFreeStackSpace+0x8>
    567c:	cd b7       	in	r28, 0x3d	; 61
    567e:	de b7       	in	r29, 0x3e	; 62
    5680:	9e 83       	std	Y+6, r25	; 0x06
    5682:	8d 83       	std	Y+5, r24	; 0x05
	uint32_t ulCount = 0U;
    5684:	19 82       	std	Y+1, r1	; 0x01
    5686:	1a 82       	std	Y+2, r1	; 0x02
    5688:	1b 82       	std	Y+3, r1	; 0x03
    568a:	1c 82       	std	Y+4, r1	; 0x04

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    568c:	10 c0       	rjmp	.+32     	; 0x56ae <prvTaskCheckFreeStackSpace+0x3a>
		{
			pucStackByte -= portSTACK_GROWTH;
    568e:	8d 81       	ldd	r24, Y+5	; 0x05
    5690:	9e 81       	ldd	r25, Y+6	; 0x06
    5692:	01 96       	adiw	r24, 0x01	; 1
    5694:	9e 83       	std	Y+6, r25	; 0x06
    5696:	8d 83       	std	Y+5, r24	; 0x05
			ulCount++;
    5698:	89 81       	ldd	r24, Y+1	; 0x01
    569a:	9a 81       	ldd	r25, Y+2	; 0x02
    569c:	ab 81       	ldd	r26, Y+3	; 0x03
    569e:	bc 81       	ldd	r27, Y+4	; 0x04
    56a0:	01 96       	adiw	r24, 0x01	; 1
    56a2:	a1 1d       	adc	r26, r1
    56a4:	b1 1d       	adc	r27, r1
    56a6:	89 83       	std	Y+1, r24	; 0x01
    56a8:	9a 83       	std	Y+2, r25	; 0x02
    56aa:	ab 83       	std	Y+3, r26	; 0x03
    56ac:	bc 83       	std	Y+4, r27	; 0x04

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    56ae:	8d 81       	ldd	r24, Y+5	; 0x05
    56b0:	9e 81       	ldd	r25, Y+6	; 0x06
    56b2:	fc 01       	movw	r30, r24
    56b4:	80 81       	ld	r24, Z
    56b6:	85 3a       	cpi	r24, 0xA5	; 165
    56b8:	51 f3       	breq	.-44     	; 0x568e <prvTaskCheckFreeStackSpace+0x1a>
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t );

		return ( uint16_t ) ulCount;
    56ba:	89 81       	ldd	r24, Y+1	; 0x01
    56bc:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    56be:	26 96       	adiw	r28, 0x06	; 6
    56c0:	0f b6       	in	r0, 0x3f	; 63
    56c2:	f8 94       	cli
    56c4:	de bf       	out	0x3e, r29	; 62
    56c6:	0f be       	out	0x3f, r0	; 63
    56c8:	cd bf       	out	0x3d, r28	; 61
    56ca:	df 91       	pop	r29
    56cc:	cf 91       	pop	r28
    56ce:	08 95       	ret

000056d0 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
	{
    56d0:	cf 93       	push	r28
    56d2:	df 93       	push	r29
    56d4:	cd b7       	in	r28, 0x3d	; 61
    56d6:	de b7       	in	r29, 0x3e	; 62
    56d8:	27 97       	sbiw	r28, 0x07	; 7
    56da:	0f b6       	in	r0, 0x3f	; 63
    56dc:	f8 94       	cli
    56de:	de bf       	out	0x3e, r29	; 62
    56e0:	0f be       	out	0x3f, r0	; 63
    56e2:	cd bf       	out	0x3d, r28	; 61
    56e4:	9f 83       	std	Y+7, r25	; 0x07
    56e6:	8e 83       	std	Y+6, r24	; 0x06
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    56e8:	8e 81       	ldd	r24, Y+6	; 0x06
    56ea:	9f 81       	ldd	r25, Y+7	; 0x07
    56ec:	89 2b       	or	r24, r25
    56ee:	29 f4       	brne	.+10     	; 0x56fa <uxTaskGetStackHighWaterMark+0x2a>
    56f0:	80 91 40 02 	lds	r24, 0x0240
    56f4:	90 91 41 02 	lds	r25, 0x0241
    56f8:	02 c0       	rjmp	.+4      	; 0x56fe <uxTaskGetStackHighWaterMark+0x2e>
    56fa:	8e 81       	ldd	r24, Y+6	; 0x06
    56fc:	9f 81       	ldd	r25, Y+7	; 0x07
    56fe:	9a 83       	std	Y+2, r25	; 0x02
    5700:	89 83       	std	Y+1, r24	; 0x01

		#if portSTACK_GROWTH < 0
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
    5702:	89 81       	ldd	r24, Y+1	; 0x01
    5704:	9a 81       	ldd	r25, Y+2	; 0x02
    5706:	fc 01       	movw	r30, r24
    5708:	87 89       	ldd	r24, Z+23	; 0x17
    570a:	90 8d       	ldd	r25, Z+24	; 0x18
    570c:	9c 83       	std	Y+4, r25	; 0x04
    570e:	8b 83       	std	Y+3, r24	; 0x03
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
    5710:	8b 81       	ldd	r24, Y+3	; 0x03
    5712:	9c 81       	ldd	r25, Y+4	; 0x04
    5714:	0e 94 3a 2b 	call	0x5674	; 0x5674 <prvTaskCheckFreeStackSpace>
    5718:	8d 83       	std	Y+5, r24	; 0x05

		return uxReturn;
    571a:	8d 81       	ldd	r24, Y+5	; 0x05
	}
    571c:	27 96       	adiw	r28, 0x07	; 7
    571e:	0f b6       	in	r0, 0x3f	; 63
    5720:	f8 94       	cli
    5722:	de bf       	out	0x3e, r29	; 62
    5724:	0f be       	out	0x3f, r0	; 63
    5726:	cd bf       	out	0x3d, r28	; 61
    5728:	df 91       	pop	r29
    572a:	cf 91       	pop	r28
    572c:	08 95       	ret

0000572e <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    572e:	cf 93       	push	r28
    5730:	df 93       	push	r29
    5732:	1f 92       	push	r1
    5734:	1f 92       	push	r1
    5736:	cd b7       	in	r28, 0x3d	; 61
    5738:	de b7       	in	r29, 0x3e	; 62
    573a:	9a 83       	std	Y+2, r25	; 0x02
    573c:	89 83       	std	Y+1, r24	; 0x01
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    573e:	89 81       	ldd	r24, Y+1	; 0x01
    5740:	9a 81       	ldd	r25, Y+2	; 0x02
    5742:	fc 01       	movw	r30, r24
    5744:	87 89       	ldd	r24, Z+23	; 0x17
    5746:	90 8d       	ldd	r25, Z+24	; 0x18
    5748:	0e 94 84 12 	call	0x2508	; 0x2508 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    574c:	89 81       	ldd	r24, Y+1	; 0x01
    574e:	9a 81       	ldd	r25, Y+2	; 0x02
    5750:	0e 94 84 12 	call	0x2508	; 0x2508 <vPortFree>
	}
    5754:	0f 90       	pop	r0
    5756:	0f 90       	pop	r0
    5758:	df 91       	pop	r29
    575a:	cf 91       	pop	r28
    575c:	08 95       	ret

0000575e <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    575e:	cf 93       	push	r28
    5760:	df 93       	push	r29
    5762:	1f 92       	push	r1
    5764:	1f 92       	push	r1
    5766:	cd b7       	in	r28, 0x3d	; 61
    5768:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    576a:	80 91 78 02 	lds	r24, 0x0278
    576e:	90 91 79 02 	lds	r25, 0x0279
    5772:	fc 01       	movw	r30, r24
    5774:	80 81       	ld	r24, Z
    5776:	88 23       	and	r24, r24
    5778:	39 f4       	brne	.+14     	; 0x5788 <prvResetNextTaskUnblockTime+0x2a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    577a:	8f ef       	ldi	r24, 0xFF	; 255
    577c:	9f ef       	ldi	r25, 0xFF	; 255
    577e:	90 93 a2 02 	sts	0x02A2, r25
    5782:	80 93 a1 02 	sts	0x02A1, r24
    5786:	15 c0       	rjmp	.+42     	; 0x57b2 <prvResetNextTaskUnblockTime+0x54>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    5788:	80 91 78 02 	lds	r24, 0x0278
    578c:	90 91 79 02 	lds	r25, 0x0279
    5790:	fc 01       	movw	r30, r24
    5792:	85 81       	ldd	r24, Z+5	; 0x05
    5794:	96 81       	ldd	r25, Z+6	; 0x06
    5796:	fc 01       	movw	r30, r24
    5798:	86 81       	ldd	r24, Z+6	; 0x06
    579a:	97 81       	ldd	r25, Z+7	; 0x07
    579c:	9a 83       	std	Y+2, r25	; 0x02
    579e:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    57a0:	89 81       	ldd	r24, Y+1	; 0x01
    57a2:	9a 81       	ldd	r25, Y+2	; 0x02
    57a4:	fc 01       	movw	r30, r24
    57a6:	82 81       	ldd	r24, Z+2	; 0x02
    57a8:	93 81       	ldd	r25, Z+3	; 0x03
    57aa:	90 93 a2 02 	sts	0x02A2, r25
    57ae:	80 93 a1 02 	sts	0x02A1, r24
	}
}
    57b2:	0f 90       	pop	r0
    57b4:	0f 90       	pop	r0
    57b6:	df 91       	pop	r29
    57b8:	cf 91       	pop	r28
    57ba:	08 95       	ret

000057bc <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    57bc:	cf 93       	push	r28
    57be:	df 93       	push	r29
    57c0:	1f 92       	push	r1
    57c2:	1f 92       	push	r1
    57c4:	cd b7       	in	r28, 0x3d	; 61
    57c6:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    57c8:	80 91 40 02 	lds	r24, 0x0240
    57cc:	90 91 41 02 	lds	r25, 0x0241
    57d0:	9a 83       	std	Y+2, r25	; 0x02
    57d2:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    57d4:	89 81       	ldd	r24, Y+1	; 0x01
    57d6:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    57d8:	0f 90       	pop	r0
    57da:	0f 90       	pop	r0
    57dc:	df 91       	pop	r29
    57de:	cf 91       	pop	r28
    57e0:	08 95       	ret

000057e2 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    57e2:	cf 93       	push	r28
    57e4:	df 93       	push	r29
    57e6:	00 d0       	rcall	.+0      	; 0x57e8 <vTaskPriorityInherit+0x6>
    57e8:	1f 92       	push	r1
    57ea:	cd b7       	in	r28, 0x3d	; 61
    57ec:	de b7       	in	r29, 0x3e	; 62
    57ee:	9c 83       	std	Y+4, r25	; 0x04
    57f0:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    57f2:	8b 81       	ldd	r24, Y+3	; 0x03
    57f4:	9c 81       	ldd	r25, Y+4	; 0x04
    57f6:	9a 83       	std	Y+2, r25	; 0x02
    57f8:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    57fa:	8b 81       	ldd	r24, Y+3	; 0x03
    57fc:	9c 81       	ldd	r25, Y+4	; 0x04
    57fe:	89 2b       	or	r24, r25
    5800:	09 f4       	brne	.+2      	; 0x5804 <vTaskPriorityInherit+0x22>
    5802:	7f c0       	rjmp	.+254    	; 0x5902 <vTaskPriorityInherit+0x120>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    5804:	89 81       	ldd	r24, Y+1	; 0x01
    5806:	9a 81       	ldd	r25, Y+2	; 0x02
    5808:	fc 01       	movw	r30, r24
    580a:	26 89       	ldd	r18, Z+22	; 0x16
    580c:	80 91 40 02 	lds	r24, 0x0240
    5810:	90 91 41 02 	lds	r25, 0x0241
    5814:	fc 01       	movw	r30, r24
    5816:	86 89       	ldd	r24, Z+22	; 0x16
    5818:	28 17       	cp	r18, r24
    581a:	08 f0       	brcs	.+2      	; 0x581e <vTaskPriorityInherit+0x3c>
    581c:	72 c0       	rjmp	.+228    	; 0x5902 <vTaskPriorityInherit+0x120>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    581e:	89 81       	ldd	r24, Y+1	; 0x01
    5820:	9a 81       	ldd	r25, Y+2	; 0x02
    5822:	fc 01       	movw	r30, r24
    5824:	84 85       	ldd	r24, Z+12	; 0x0c
    5826:	95 85       	ldd	r25, Z+13	; 0x0d
    5828:	99 23       	and	r25, r25
    582a:	8c f0       	brlt	.+34     	; 0x584e <vTaskPriorityInherit+0x6c>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    582c:	80 91 40 02 	lds	r24, 0x0240
    5830:	90 91 41 02 	lds	r25, 0x0241
    5834:	fc 01       	movw	r30, r24
    5836:	86 89       	ldd	r24, Z+22	; 0x16
    5838:	88 2f       	mov	r24, r24
    583a:	90 e0       	ldi	r25, 0x00	; 0
    583c:	24 e0       	ldi	r18, 0x04	; 4
    583e:	30 e0       	ldi	r19, 0x00	; 0
    5840:	28 1b       	sub	r18, r24
    5842:	39 0b       	sbc	r19, r25
    5844:	89 81       	ldd	r24, Y+1	; 0x01
    5846:	9a 81       	ldd	r25, Y+2	; 0x02
    5848:	fc 01       	movw	r30, r24
    584a:	35 87       	std	Z+13, r19	; 0x0d
    584c:	24 87       	std	Z+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    584e:	89 81       	ldd	r24, Y+1	; 0x01
    5850:	9a 81       	ldd	r25, Y+2	; 0x02
    5852:	fc 01       	movw	r30, r24
    5854:	42 85       	ldd	r20, Z+10	; 0x0a
    5856:	53 85       	ldd	r21, Z+11	; 0x0b
    5858:	89 81       	ldd	r24, Y+1	; 0x01
    585a:	9a 81       	ldd	r25, Y+2	; 0x02
    585c:	fc 01       	movw	r30, r24
    585e:	86 89       	ldd	r24, Z+22	; 0x16
    5860:	28 2f       	mov	r18, r24
    5862:	30 e0       	ldi	r19, 0x00	; 0
    5864:	c9 01       	movw	r24, r18
    5866:	88 0f       	add	r24, r24
    5868:	99 1f       	adc	r25, r25
    586a:	88 0f       	add	r24, r24
    586c:	99 1f       	adc	r25, r25
    586e:	88 0f       	add	r24, r24
    5870:	99 1f       	adc	r25, r25
    5872:	82 0f       	add	r24, r18
    5874:	93 1f       	adc	r25, r19
    5876:	8e 5b       	subi	r24, 0xBE	; 190
    5878:	9d 4f       	sbci	r25, 0xFD	; 253
    587a:	48 17       	cp	r20, r24
    587c:	59 07       	cpc	r21, r25
    587e:	b9 f5       	brne	.+110    	; 0x58ee <vTaskPriorityInherit+0x10c>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    5880:	89 81       	ldd	r24, Y+1	; 0x01
    5882:	9a 81       	ldd	r25, Y+2	; 0x02
    5884:	02 96       	adiw	r24, 0x02	; 2
    5886:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    588a:	80 91 40 02 	lds	r24, 0x0240
    588e:	90 91 41 02 	lds	r25, 0x0241
    5892:	fc 01       	movw	r30, r24
    5894:	26 89       	ldd	r18, Z+22	; 0x16
    5896:	89 81       	ldd	r24, Y+1	; 0x01
    5898:	9a 81       	ldd	r25, Y+2	; 0x02
    589a:	fc 01       	movw	r30, r24
    589c:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyList( pxTCB );
    589e:	89 81       	ldd	r24, Y+1	; 0x01
    58a0:	9a 81       	ldd	r25, Y+2	; 0x02
    58a2:	fc 01       	movw	r30, r24
    58a4:	96 89       	ldd	r25, Z+22	; 0x16
    58a6:	80 91 9b 02 	lds	r24, 0x029B
    58aa:	89 17       	cp	r24, r25
    58ac:	30 f4       	brcc	.+12     	; 0x58ba <vTaskPriorityInherit+0xd8>
    58ae:	89 81       	ldd	r24, Y+1	; 0x01
    58b0:	9a 81       	ldd	r25, Y+2	; 0x02
    58b2:	fc 01       	movw	r30, r24
    58b4:	86 89       	ldd	r24, Z+22	; 0x16
    58b6:	80 93 9b 02 	sts	0x029B, r24
    58ba:	89 81       	ldd	r24, Y+1	; 0x01
    58bc:	9a 81       	ldd	r25, Y+2	; 0x02
    58be:	ac 01       	movw	r20, r24
    58c0:	4e 5f       	subi	r20, 0xFE	; 254
    58c2:	5f 4f       	sbci	r21, 0xFF	; 255
    58c4:	89 81       	ldd	r24, Y+1	; 0x01
    58c6:	9a 81       	ldd	r25, Y+2	; 0x02
    58c8:	fc 01       	movw	r30, r24
    58ca:	86 89       	ldd	r24, Z+22	; 0x16
    58cc:	28 2f       	mov	r18, r24
    58ce:	30 e0       	ldi	r19, 0x00	; 0
    58d0:	c9 01       	movw	r24, r18
    58d2:	88 0f       	add	r24, r24
    58d4:	99 1f       	adc	r25, r25
    58d6:	88 0f       	add	r24, r24
    58d8:	99 1f       	adc	r25, r25
    58da:	88 0f       	add	r24, r24
    58dc:	99 1f       	adc	r25, r25
    58de:	82 0f       	add	r24, r18
    58e0:	93 1f       	adc	r25, r19
    58e2:	8e 5b       	subi	r24, 0xBE	; 190
    58e4:	9d 4f       	sbci	r25, 0xFD	; 253
    58e6:	ba 01       	movw	r22, r20
    58e8:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
    58ec:	0a c0       	rjmp	.+20     	; 0x5902 <vTaskPriorityInherit+0x120>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    58ee:	80 91 40 02 	lds	r24, 0x0240
    58f2:	90 91 41 02 	lds	r25, 0x0241
    58f6:	fc 01       	movw	r30, r24
    58f8:	26 89       	ldd	r18, Z+22	; 0x16
    58fa:	89 81       	ldd	r24, Y+1	; 0x01
    58fc:	9a 81       	ldd	r25, Y+2	; 0x02
    58fe:	fc 01       	movw	r30, r24
    5900:	26 8b       	std	Z+22, r18	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    5902:	0f 90       	pop	r0
    5904:	0f 90       	pop	r0
    5906:	0f 90       	pop	r0
    5908:	0f 90       	pop	r0
    590a:	df 91       	pop	r29
    590c:	cf 91       	pop	r28
    590e:	08 95       	ret

00005910 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    5910:	cf 93       	push	r28
    5912:	df 93       	push	r29
    5914:	00 d0       	rcall	.+0      	; 0x5916 <xTaskPriorityDisinherit+0x6>
    5916:	1f 92       	push	r1
    5918:	1f 92       	push	r1
    591a:	cd b7       	in	r28, 0x3d	; 61
    591c:	de b7       	in	r29, 0x3e	; 62
    591e:	9d 83       	std	Y+5, r25	; 0x05
    5920:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    5922:	8c 81       	ldd	r24, Y+4	; 0x04
    5924:	9d 81       	ldd	r25, Y+5	; 0x05
    5926:	9b 83       	std	Y+3, r25	; 0x03
    5928:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    592a:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    592c:	8c 81       	ldd	r24, Y+4	; 0x04
    592e:	9d 81       	ldd	r25, Y+5	; 0x05
    5930:	89 2b       	or	r24, r25
    5932:	09 f4       	brne	.+2      	; 0x5936 <xTaskPriorityDisinherit+0x26>
    5934:	61 c0       	rjmp	.+194    	; 0x59f8 <xTaskPriorityDisinherit+0xe8>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    5936:	8a 81       	ldd	r24, Y+2	; 0x02
    5938:	9b 81       	ldd	r25, Y+3	; 0x03
    593a:	fc 01       	movw	r30, r24
    593c:	82 a1       	ldd	r24, Z+34	; 0x22
    593e:	2f ef       	ldi	r18, 0xFF	; 255
    5940:	28 0f       	add	r18, r24
    5942:	8a 81       	ldd	r24, Y+2	; 0x02
    5944:	9b 81       	ldd	r25, Y+3	; 0x03
    5946:	fc 01       	movw	r30, r24
    5948:	22 a3       	std	Z+34, r18	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    594a:	8a 81       	ldd	r24, Y+2	; 0x02
    594c:	9b 81       	ldd	r25, Y+3	; 0x03
    594e:	fc 01       	movw	r30, r24
    5950:	26 89       	ldd	r18, Z+22	; 0x16
    5952:	8a 81       	ldd	r24, Y+2	; 0x02
    5954:	9b 81       	ldd	r25, Y+3	; 0x03
    5956:	fc 01       	movw	r30, r24
    5958:	81 a1       	ldd	r24, Z+33	; 0x21
    595a:	28 17       	cp	r18, r24
    595c:	09 f4       	brne	.+2      	; 0x5960 <xTaskPriorityDisinherit+0x50>
    595e:	4c c0       	rjmp	.+152    	; 0x59f8 <xTaskPriorityDisinherit+0xe8>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    5960:	8a 81       	ldd	r24, Y+2	; 0x02
    5962:	9b 81       	ldd	r25, Y+3	; 0x03
    5964:	fc 01       	movw	r30, r24
    5966:	82 a1       	ldd	r24, Z+34	; 0x22
    5968:	88 23       	and	r24, r24
    596a:	09 f0       	breq	.+2      	; 0x596e <xTaskPriorityDisinherit+0x5e>
    596c:	45 c0       	rjmp	.+138    	; 0x59f8 <xTaskPriorityDisinherit+0xe8>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    596e:	8a 81       	ldd	r24, Y+2	; 0x02
    5970:	9b 81       	ldd	r25, Y+3	; 0x03
    5972:	02 96       	adiw	r24, 0x02	; 2
    5974:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    5978:	8a 81       	ldd	r24, Y+2	; 0x02
    597a:	9b 81       	ldd	r25, Y+3	; 0x03
    597c:	fc 01       	movw	r30, r24
    597e:	21 a1       	ldd	r18, Z+33	; 0x21
    5980:	8a 81       	ldd	r24, Y+2	; 0x02
    5982:	9b 81       	ldd	r25, Y+3	; 0x03
    5984:	fc 01       	movw	r30, r24
    5986:	26 8b       	std	Z+22, r18	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority );
    5988:	8a 81       	ldd	r24, Y+2	; 0x02
    598a:	9b 81       	ldd	r25, Y+3	; 0x03
    598c:	fc 01       	movw	r30, r24
    598e:	86 89       	ldd	r24, Z+22	; 0x16
    5990:	88 2f       	mov	r24, r24
    5992:	90 e0       	ldi	r25, 0x00	; 0
    5994:	24 e0       	ldi	r18, 0x04	; 4
    5996:	30 e0       	ldi	r19, 0x00	; 0
    5998:	28 1b       	sub	r18, r24
    599a:	39 0b       	sbc	r19, r25
    599c:	8a 81       	ldd	r24, Y+2	; 0x02
    599e:	9b 81       	ldd	r25, Y+3	; 0x03
    59a0:	fc 01       	movw	r30, r24
    59a2:	35 87       	std	Z+13, r19	; 0x0d
    59a4:	24 87       	std	Z+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    59a6:	8a 81       	ldd	r24, Y+2	; 0x02
    59a8:	9b 81       	ldd	r25, Y+3	; 0x03
    59aa:	fc 01       	movw	r30, r24
    59ac:	96 89       	ldd	r25, Z+22	; 0x16
    59ae:	80 91 9b 02 	lds	r24, 0x029B
    59b2:	89 17       	cp	r24, r25
    59b4:	30 f4       	brcc	.+12     	; 0x59c2 <xTaskPriorityDisinherit+0xb2>
    59b6:	8a 81       	ldd	r24, Y+2	; 0x02
    59b8:	9b 81       	ldd	r25, Y+3	; 0x03
    59ba:	fc 01       	movw	r30, r24
    59bc:	86 89       	ldd	r24, Z+22	; 0x16
    59be:	80 93 9b 02 	sts	0x029B, r24
    59c2:	8a 81       	ldd	r24, Y+2	; 0x02
    59c4:	9b 81       	ldd	r25, Y+3	; 0x03
    59c6:	ac 01       	movw	r20, r24
    59c8:	4e 5f       	subi	r20, 0xFE	; 254
    59ca:	5f 4f       	sbci	r21, 0xFF	; 255
    59cc:	8a 81       	ldd	r24, Y+2	; 0x02
    59ce:	9b 81       	ldd	r25, Y+3	; 0x03
    59d0:	fc 01       	movw	r30, r24
    59d2:	86 89       	ldd	r24, Z+22	; 0x16
    59d4:	28 2f       	mov	r18, r24
    59d6:	30 e0       	ldi	r19, 0x00	; 0
    59d8:	c9 01       	movw	r24, r18
    59da:	88 0f       	add	r24, r24
    59dc:	99 1f       	adc	r25, r25
    59de:	88 0f       	add	r24, r24
    59e0:	99 1f       	adc	r25, r25
    59e2:	88 0f       	add	r24, r24
    59e4:	99 1f       	adc	r25, r25
    59e6:	82 0f       	add	r24, r18
    59e8:	93 1f       	adc	r25, r19
    59ea:	8e 5b       	subi	r24, 0xBE	; 190
    59ec:	9d 4f       	sbci	r25, 0xFD	; 253
    59ee:	ba 01       	movw	r22, r20
    59f0:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    59f4:	81 e0       	ldi	r24, 0x01	; 1
    59f6:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    59f8:	89 81       	ldd	r24, Y+1	; 0x01
	}
    59fa:	0f 90       	pop	r0
    59fc:	0f 90       	pop	r0
    59fe:	0f 90       	pop	r0
    5a00:	0f 90       	pop	r0
    5a02:	0f 90       	pop	r0
    5a04:	df 91       	pop	r29
    5a06:	cf 91       	pop	r28
    5a08:	08 95       	ret

00005a0a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    5a0a:	cf 93       	push	r28
    5a0c:	df 93       	push	r29
    5a0e:	1f 92       	push	r1
    5a10:	1f 92       	push	r1
    5a12:	cd b7       	in	r28, 0x3d	; 61
    5a14:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5a16:	80 91 40 02 	lds	r24, 0x0240
    5a1a:	90 91 41 02 	lds	r25, 0x0241
    5a1e:	fc 01       	movw	r30, r24
    5a20:	84 85       	ldd	r24, Z+12	; 0x0c
    5a22:	95 85       	ldd	r25, Z+13	; 0x0d
    5a24:	9a 83       	std	Y+2, r25	; 0x02
    5a26:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5a28:	80 91 40 02 	lds	r24, 0x0240
    5a2c:	90 91 41 02 	lds	r25, 0x0241
    5a30:	20 91 40 02 	lds	r18, 0x0240
    5a34:	30 91 41 02 	lds	r19, 0x0241
    5a38:	f9 01       	movw	r30, r18
    5a3a:	26 89       	ldd	r18, Z+22	; 0x16
    5a3c:	22 2f       	mov	r18, r18
    5a3e:	30 e0       	ldi	r19, 0x00	; 0
    5a40:	44 e0       	ldi	r20, 0x04	; 4
    5a42:	50 e0       	ldi	r21, 0x00	; 0
    5a44:	ba 01       	movw	r22, r20
    5a46:	62 1b       	sub	r22, r18
    5a48:	73 0b       	sbc	r23, r19
    5a4a:	9b 01       	movw	r18, r22
    5a4c:	fc 01       	movw	r30, r24
    5a4e:	35 87       	std	Z+13, r19	; 0x0d
    5a50:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
    5a52:	89 81       	ldd	r24, Y+1	; 0x01
    5a54:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5a56:	0f 90       	pop	r0
    5a58:	0f 90       	pop	r0
    5a5a:	df 91       	pop	r29
    5a5c:	cf 91       	pop	r28
    5a5e:	08 95       	ret

00005a60 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    5a60:	cf 93       	push	r28
    5a62:	df 93       	push	r29
    5a64:	cd b7       	in	r28, 0x3d	; 61
    5a66:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    5a68:	80 91 40 02 	lds	r24, 0x0240
    5a6c:	90 91 41 02 	lds	r25, 0x0241
    5a70:	89 2b       	or	r24, r25
    5a72:	49 f0       	breq	.+18     	; 0x5a86 <pvTaskIncrementMutexHeldCount+0x26>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    5a74:	80 91 40 02 	lds	r24, 0x0240
    5a78:	90 91 41 02 	lds	r25, 0x0241
    5a7c:	fc 01       	movw	r30, r24
    5a7e:	22 a1       	ldd	r18, Z+34	; 0x22
    5a80:	2f 5f       	subi	r18, 0xFF	; 255
    5a82:	fc 01       	movw	r30, r24
    5a84:	22 a3       	std	Z+34, r18	; 0x22
		}

		return pxCurrentTCB;
    5a86:	80 91 40 02 	lds	r24, 0x0240
    5a8a:	90 91 41 02 	lds	r25, 0x0241
	}
    5a8e:	df 91       	pop	r29
    5a90:	cf 91       	pop	r28
    5a92:	08 95       	ret

00005a94 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    5a94:	cf 93       	push	r28
    5a96:	df 93       	push	r29
    5a98:	cd b7       	in	r28, 0x3d	; 61
    5a9a:	de b7       	in	r29, 0x3e	; 62
    5a9c:	29 97       	sbiw	r28, 0x09	; 9
    5a9e:	0f b6       	in	r0, 0x3f	; 63
    5aa0:	f8 94       	cli
    5aa2:	de bf       	out	0x3e, r29	; 62
    5aa4:	0f be       	out	0x3f, r0	; 63
    5aa6:	cd bf       	out	0x3d, r28	; 61
    5aa8:	8f 83       	std	Y+7, r24	; 0x07
    5aaa:	79 87       	std	Y+9, r23	; 0x09
    5aac:	68 87       	std	Y+8, r22	; 0x08
	TickType_t xTimeToWake;
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    5aae:	0f b6       	in	r0, 0x3f	; 63
    5ab0:	f8 94       	cli
    5ab2:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    5ab4:	80 91 40 02 	lds	r24, 0x0240
    5ab8:	90 91 41 02 	lds	r25, 0x0241
    5abc:	fc 01       	movw	r30, r24
    5abe:	83 a1       	ldd	r24, Z+35	; 0x23
    5ac0:	94 a1       	ldd	r25, Z+36	; 0x24
    5ac2:	a5 a1       	ldd	r26, Z+37	; 0x25
    5ac4:	b6 a1       	ldd	r27, Z+38	; 0x26
    5ac6:	89 2b       	or	r24, r25
    5ac8:	8a 2b       	or	r24, r26
    5aca:	8b 2b       	or	r24, r27
    5acc:	89 f5       	brne	.+98     	; 0x5b30 <ulTaskNotifyTake+0x9c>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    5ace:	80 91 40 02 	lds	r24, 0x0240
    5ad2:	90 91 41 02 	lds	r25, 0x0241
    5ad6:	21 e0       	ldi	r18, 0x01	; 1
    5ad8:	fc 01       	movw	r30, r24
    5ada:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    5adc:	88 85       	ldd	r24, Y+8	; 0x08
    5ade:	99 85       	ldd	r25, Y+9	; 0x09
    5ae0:	89 2b       	or	r24, r25
    5ae2:	31 f1       	breq	.+76     	; 0x5b30 <ulTaskNotifyTake+0x9c>
				{
					/* The task is going to block.  First it must be removed
					from the ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    5ae4:	80 91 40 02 	lds	r24, 0x0240
    5ae8:	90 91 41 02 	lds	r25, 0x0241
    5aec:	02 96       	adiw	r24, 0x02	; 2
    5aee:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
    5af2:	88 85       	ldd	r24, Y+8	; 0x08
    5af4:	99 85       	ldd	r25, Y+9	; 0x09
    5af6:	01 96       	adiw	r24, 0x01	; 1
    5af8:	59 f4       	brne	.+22     	; 0x5b10 <ulTaskNotifyTake+0x7c>
						{
							/* Add the task to the suspended task list instead
							of a delayed task list to ensure the task is not
							woken by a timing event.  It will block
							indefinitely. */
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    5afa:	80 91 40 02 	lds	r24, 0x0240
    5afe:	90 91 41 02 	lds	r25, 0x0241
    5b02:	02 96       	adiw	r24, 0x02	; 2
    5b04:	bc 01       	movw	r22, r24
    5b06:	8f e8       	ldi	r24, 0x8F	; 143
    5b08:	92 e0       	ldi	r25, 0x02	; 2
    5b0a:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
    5b0e:	0e c0       	rjmp	.+28     	; 0x5b2c <ulTaskNotifyTake+0x98>
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    5b10:	20 91 99 02 	lds	r18, 0x0299
    5b14:	30 91 9a 02 	lds	r19, 0x029A
    5b18:	88 85       	ldd	r24, Y+8	; 0x08
    5b1a:	99 85       	ldd	r25, Y+9	; 0x09
    5b1c:	82 0f       	add	r24, r18
    5b1e:	93 1f       	adc	r25, r19
    5b20:	9a 83       	std	Y+2, r25	; 0x02
    5b22:	89 83       	std	Y+1, r24	; 0x01
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    5b24:	89 81       	ldd	r24, Y+1	; 0x01
    5b26:	9a 81       	ldd	r25, Y+2	; 0x02
    5b28:	0e 94 9c 2a 	call	0x5538	; 0x5538 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5b2c:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5b30:	0f 90       	pop	r0
    5b32:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5b34:	0f b6       	in	r0, 0x3f	; 63
    5b36:	f8 94       	cli
    5b38:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    5b3a:	80 91 40 02 	lds	r24, 0x0240
    5b3e:	90 91 41 02 	lds	r25, 0x0241
    5b42:	fc 01       	movw	r30, r24
    5b44:	83 a1       	ldd	r24, Z+35	; 0x23
    5b46:	94 a1       	ldd	r25, Z+36	; 0x24
    5b48:	a5 a1       	ldd	r26, Z+37	; 0x25
    5b4a:	b6 a1       	ldd	r27, Z+38	; 0x26
    5b4c:	8b 83       	std	Y+3, r24	; 0x03
    5b4e:	9c 83       	std	Y+4, r25	; 0x04
    5b50:	ad 83       	std	Y+5, r26	; 0x05
    5b52:	be 83       	std	Y+6, r27	; 0x06

			if( ulReturn != 0UL )
    5b54:	8b 81       	ldd	r24, Y+3	; 0x03
    5b56:	9c 81       	ldd	r25, Y+4	; 0x04
    5b58:	ad 81       	ldd	r26, Y+5	; 0x05
    5b5a:	be 81       	ldd	r27, Y+6	; 0x06
    5b5c:	89 2b       	or	r24, r25
    5b5e:	8a 2b       	or	r24, r26
    5b60:	8b 2b       	or	r24, r27
    5b62:	f1 f0       	breq	.+60     	; 0x5ba0 <ulTaskNotifyTake+0x10c>
			{
				if( xClearCountOnExit != pdFALSE )
    5b64:	8f 81       	ldd	r24, Y+7	; 0x07
    5b66:	88 23       	and	r24, r24
    5b68:	51 f0       	breq	.+20     	; 0x5b7e <ulTaskNotifyTake+0xea>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    5b6a:	80 91 40 02 	lds	r24, 0x0240
    5b6e:	90 91 41 02 	lds	r25, 0x0241
    5b72:	fc 01       	movw	r30, r24
    5b74:	13 a2       	std	Z+35, r1	; 0x23
    5b76:	14 a2       	std	Z+36, r1	; 0x24
    5b78:	15 a2       	std	Z+37, r1	; 0x25
    5b7a:	16 a2       	std	Z+38, r1	; 0x26
    5b7c:	11 c0       	rjmp	.+34     	; 0x5ba0 <ulTaskNotifyTake+0x10c>
				}
				else
				{
					( pxCurrentTCB->ulNotifiedValue )--;
    5b7e:	20 91 40 02 	lds	r18, 0x0240
    5b82:	30 91 41 02 	lds	r19, 0x0241
    5b86:	f9 01       	movw	r30, r18
    5b88:	83 a1       	ldd	r24, Z+35	; 0x23
    5b8a:	94 a1       	ldd	r25, Z+36	; 0x24
    5b8c:	a5 a1       	ldd	r26, Z+37	; 0x25
    5b8e:	b6 a1       	ldd	r27, Z+38	; 0x26
    5b90:	01 97       	sbiw	r24, 0x01	; 1
    5b92:	a1 09       	sbc	r26, r1
    5b94:	b1 09       	sbc	r27, r1
    5b96:	f9 01       	movw	r30, r18
    5b98:	83 a3       	std	Z+35, r24	; 0x23
    5b9a:	94 a3       	std	Z+36, r25	; 0x24
    5b9c:	a5 a3       	std	Z+37, r26	; 0x25
    5b9e:	b6 a3       	std	Z+38, r27	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    5ba0:	80 91 40 02 	lds	r24, 0x0240
    5ba4:	90 91 41 02 	lds	r25, 0x0241
    5ba8:	fc 01       	movw	r30, r24
    5baa:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    5bac:	0f 90       	pop	r0
    5bae:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    5bb0:	8b 81       	ldd	r24, Y+3	; 0x03
    5bb2:	9c 81       	ldd	r25, Y+4	; 0x04
    5bb4:	ad 81       	ldd	r26, Y+5	; 0x05
    5bb6:	be 81       	ldd	r27, Y+6	; 0x06
	}
    5bb8:	bc 01       	movw	r22, r24
    5bba:	cd 01       	movw	r24, r26
    5bbc:	29 96       	adiw	r28, 0x09	; 9
    5bbe:	0f b6       	in	r0, 0x3f	; 63
    5bc0:	f8 94       	cli
    5bc2:	de bf       	out	0x3e, r29	; 62
    5bc4:	0f be       	out	0x3f, r0	; 63
    5bc6:	cd bf       	out	0x3d, r28	; 61
    5bc8:	df 91       	pop	r29
    5bca:	cf 91       	pop	r28
    5bcc:	08 95       	ret

00005bce <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    5bce:	ef 92       	push	r14
    5bd0:	ff 92       	push	r15
    5bd2:	0f 93       	push	r16
    5bd4:	1f 93       	push	r17
    5bd6:	cf 93       	push	r28
    5bd8:	df 93       	push	r29
    5bda:	cd b7       	in	r28, 0x3d	; 61
    5bdc:	de b7       	in	r29, 0x3e	; 62
    5bde:	2f 97       	sbiw	r28, 0x0f	; 15
    5be0:	0f b6       	in	r0, 0x3f	; 63
    5be2:	f8 94       	cli
    5be4:	de bf       	out	0x3e, r29	; 62
    5be6:	0f be       	out	0x3f, r0	; 63
    5be8:	cd bf       	out	0x3d, r28	; 61
    5bea:	6c 83       	std	Y+4, r22	; 0x04
    5bec:	7d 83       	std	Y+5, r23	; 0x05
    5bee:	8e 83       	std	Y+6, r24	; 0x06
    5bf0:	9f 83       	std	Y+7, r25	; 0x07
    5bf2:	28 87       	std	Y+8, r18	; 0x08
    5bf4:	39 87       	std	Y+9, r19	; 0x09
    5bf6:	4a 87       	std	Y+10, r20	; 0x0a
    5bf8:	5b 87       	std	Y+11, r21	; 0x0b
    5bfa:	1d 87       	std	Y+13, r17	; 0x0d
    5bfc:	0c 87       	std	Y+12, r16	; 0x0c
    5bfe:	ff 86       	std	Y+15, r15	; 0x0f
    5c00:	ee 86       	std	Y+14, r14	; 0x0e
	TickType_t xTimeToWake;
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    5c02:	0f b6       	in	r0, 0x3f	; 63
    5c04:	f8 94       	cli
    5c06:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
    5c08:	80 91 40 02 	lds	r24, 0x0240
    5c0c:	90 91 41 02 	lds	r25, 0x0241
    5c10:	fc 01       	movw	r30, r24
    5c12:	87 a1       	ldd	r24, Z+39	; 0x27
    5c14:	82 30       	cpi	r24, 0x02	; 2
    5c16:	09 f4       	brne	.+2      	; 0x5c1a <xTaskNotifyWait+0x4c>
    5c18:	4b c0       	rjmp	.+150    	; 0x5cb0 <xTaskNotifyWait+0xe2>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    5c1a:	60 91 40 02 	lds	r22, 0x0240
    5c1e:	70 91 41 02 	lds	r23, 0x0241
    5c22:	fb 01       	movw	r30, r22
    5c24:	23 a1       	ldd	r18, Z+35	; 0x23
    5c26:	34 a1       	ldd	r19, Z+36	; 0x24
    5c28:	45 a1       	ldd	r20, Z+37	; 0x25
    5c2a:	56 a1       	ldd	r21, Z+38	; 0x26
    5c2c:	8c 81       	ldd	r24, Y+4	; 0x04
    5c2e:	9d 81       	ldd	r25, Y+5	; 0x05
    5c30:	ae 81       	ldd	r26, Y+6	; 0x06
    5c32:	bf 81       	ldd	r27, Y+7	; 0x07
    5c34:	80 95       	com	r24
    5c36:	90 95       	com	r25
    5c38:	a0 95       	com	r26
    5c3a:	b0 95       	com	r27
    5c3c:	82 23       	and	r24, r18
    5c3e:	93 23       	and	r25, r19
    5c40:	a4 23       	and	r26, r20
    5c42:	b5 23       	and	r27, r21
    5c44:	fb 01       	movw	r30, r22
    5c46:	83 a3       	std	Z+35, r24	; 0x23
    5c48:	94 a3       	std	Z+36, r25	; 0x24
    5c4a:	a5 a3       	std	Z+37, r26	; 0x25
    5c4c:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    5c4e:	80 91 40 02 	lds	r24, 0x0240
    5c52:	90 91 41 02 	lds	r25, 0x0241
    5c56:	21 e0       	ldi	r18, 0x01	; 1
    5c58:	fc 01       	movw	r30, r24
    5c5a:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    5c5c:	8e 85       	ldd	r24, Y+14	; 0x0e
    5c5e:	9f 85       	ldd	r25, Y+15	; 0x0f
    5c60:	89 2b       	or	r24, r25
    5c62:	31 f1       	breq	.+76     	; 0x5cb0 <xTaskNotifyWait+0xe2>
				{
					/* The task is going to block.  First it must be removed
					from the	ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    5c64:	80 91 40 02 	lds	r24, 0x0240
    5c68:	90 91 41 02 	lds	r25, 0x0241
    5c6c:	02 96       	adiw	r24, 0x02	; 2
    5c6e:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
    5c72:	8e 85       	ldd	r24, Y+14	; 0x0e
    5c74:	9f 85       	ldd	r25, Y+15	; 0x0f
    5c76:	01 96       	adiw	r24, 0x01	; 1
    5c78:	59 f4       	brne	.+22     	; 0x5c90 <xTaskNotifyWait+0xc2>
						{
							/* Add the task to the suspended task list instead
							of a delayed task list to ensure the task is not
							woken by a timing event.  It will block
							indefinitely. */
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    5c7a:	80 91 40 02 	lds	r24, 0x0240
    5c7e:	90 91 41 02 	lds	r25, 0x0241
    5c82:	02 96       	adiw	r24, 0x02	; 2
    5c84:	bc 01       	movw	r22, r24
    5c86:	8f e8       	ldi	r24, 0x8F	; 143
    5c88:	92 e0       	ldi	r25, 0x02	; 2
    5c8a:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
    5c8e:	0e c0       	rjmp	.+28     	; 0x5cac <xTaskNotifyWait+0xde>
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    5c90:	20 91 99 02 	lds	r18, 0x0299
    5c94:	30 91 9a 02 	lds	r19, 0x029A
    5c98:	8e 85       	ldd	r24, Y+14	; 0x0e
    5c9a:	9f 85       	ldd	r25, Y+15	; 0x0f
    5c9c:	82 0f       	add	r24, r18
    5c9e:	93 1f       	adc	r25, r19
    5ca0:	9b 83       	std	Y+3, r25	; 0x03
    5ca2:	8a 83       	std	Y+2, r24	; 0x02
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    5ca4:	8a 81       	ldd	r24, Y+2	; 0x02
    5ca6:	9b 81       	ldd	r25, Y+3	; 0x03
    5ca8:	0e 94 9c 2a 	call	0x5538	; 0x5538 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5cac:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5cb0:	0f 90       	pop	r0
    5cb2:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5cb4:	0f b6       	in	r0, 0x3f	; 63
    5cb6:	f8 94       	cli
    5cb8:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    5cba:	8c 85       	ldd	r24, Y+12	; 0x0c
    5cbc:	9d 85       	ldd	r25, Y+13	; 0x0d
    5cbe:	89 2b       	or	r24, r25
    5cc0:	81 f0       	breq	.+32     	; 0x5ce2 <xTaskNotifyWait+0x114>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    5cc2:	80 91 40 02 	lds	r24, 0x0240
    5cc6:	90 91 41 02 	lds	r25, 0x0241
    5cca:	fc 01       	movw	r30, r24
    5ccc:	83 a1       	ldd	r24, Z+35	; 0x23
    5cce:	94 a1       	ldd	r25, Z+36	; 0x24
    5cd0:	a5 a1       	ldd	r26, Z+37	; 0x25
    5cd2:	b6 a1       	ldd	r27, Z+38	; 0x26
    5cd4:	2c 85       	ldd	r18, Y+12	; 0x0c
    5cd6:	3d 85       	ldd	r19, Y+13	; 0x0d
    5cd8:	f9 01       	movw	r30, r18
    5cda:	80 83       	st	Z, r24
    5cdc:	91 83       	std	Z+1, r25	; 0x01
    5cde:	a2 83       	std	Z+2, r26	; 0x02
    5ce0:	b3 83       	std	Z+3, r27	; 0x03

			/* If eNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
    5ce2:	80 91 40 02 	lds	r24, 0x0240
    5ce6:	90 91 41 02 	lds	r25, 0x0241
    5cea:	fc 01       	movw	r30, r24
    5cec:	87 a1       	ldd	r24, Z+39	; 0x27
    5cee:	81 30       	cpi	r24, 0x01	; 1
    5cf0:	11 f4       	brne	.+4      	; 0x5cf6 <xTaskNotifyWait+0x128>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    5cf2:	19 82       	std	Y+1, r1	; 0x01
    5cf4:	1c c0       	rjmp	.+56     	; 0x5d2e <xTaskNotifyWait+0x160>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    5cf6:	60 91 40 02 	lds	r22, 0x0240
    5cfa:	70 91 41 02 	lds	r23, 0x0241
    5cfe:	fb 01       	movw	r30, r22
    5d00:	23 a1       	ldd	r18, Z+35	; 0x23
    5d02:	34 a1       	ldd	r19, Z+36	; 0x24
    5d04:	45 a1       	ldd	r20, Z+37	; 0x25
    5d06:	56 a1       	ldd	r21, Z+38	; 0x26
    5d08:	88 85       	ldd	r24, Y+8	; 0x08
    5d0a:	99 85       	ldd	r25, Y+9	; 0x09
    5d0c:	aa 85       	ldd	r26, Y+10	; 0x0a
    5d0e:	bb 85       	ldd	r27, Y+11	; 0x0b
    5d10:	80 95       	com	r24
    5d12:	90 95       	com	r25
    5d14:	a0 95       	com	r26
    5d16:	b0 95       	com	r27
    5d18:	82 23       	and	r24, r18
    5d1a:	93 23       	and	r25, r19
    5d1c:	a4 23       	and	r26, r20
    5d1e:	b5 23       	and	r27, r21
    5d20:	fb 01       	movw	r30, r22
    5d22:	83 a3       	std	Z+35, r24	; 0x23
    5d24:	94 a3       	std	Z+36, r25	; 0x24
    5d26:	a5 a3       	std	Z+37, r26	; 0x25
    5d28:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    5d2a:	81 e0       	ldi	r24, 0x01	; 1
    5d2c:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    5d2e:	80 91 40 02 	lds	r24, 0x0240
    5d32:	90 91 41 02 	lds	r25, 0x0241
    5d36:	fc 01       	movw	r30, r24
    5d38:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    5d3a:	0f 90       	pop	r0
    5d3c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5d3e:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5d40:	2f 96       	adiw	r28, 0x0f	; 15
    5d42:	0f b6       	in	r0, 0x3f	; 63
    5d44:	f8 94       	cli
    5d46:	de bf       	out	0x3e, r29	; 62
    5d48:	0f be       	out	0x3f, r0	; 63
    5d4a:	cd bf       	out	0x3d, r28	; 61
    5d4c:	df 91       	pop	r29
    5d4e:	cf 91       	pop	r28
    5d50:	1f 91       	pop	r17
    5d52:	0f 91       	pop	r16
    5d54:	ff 90       	pop	r15
    5d56:	ef 90       	pop	r14
    5d58:	08 95       	ret

00005d5a <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    5d5a:	0f 93       	push	r16
    5d5c:	1f 93       	push	r17
    5d5e:	cf 93       	push	r28
    5d60:	df 93       	push	r29
    5d62:	cd b7       	in	r28, 0x3d	; 61
    5d64:	de b7       	in	r29, 0x3e	; 62
    5d66:	2d 97       	sbiw	r28, 0x0d	; 13
    5d68:	0f b6       	in	r0, 0x3f	; 63
    5d6a:	f8 94       	cli
    5d6c:	de bf       	out	0x3e, r29	; 62
    5d6e:	0f be       	out	0x3f, r0	; 63
    5d70:	cd bf       	out	0x3d, r28	; 61
    5d72:	9e 83       	std	Y+6, r25	; 0x06
    5d74:	8d 83       	std	Y+5, r24	; 0x05
    5d76:	4f 83       	std	Y+7, r20	; 0x07
    5d78:	58 87       	std	Y+8, r21	; 0x08
    5d7a:	69 87       	std	Y+9, r22	; 0x09
    5d7c:	7a 87       	std	Y+10, r23	; 0x0a
    5d7e:	2b 87       	std	Y+11, r18	; 0x0b
    5d80:	1d 87       	std	Y+13, r17	; 0x0d
    5d82:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5d84:	81 e0       	ldi	r24, 0x01	; 1
    5d86:	89 83       	std	Y+1, r24	; 0x01

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    5d88:	8d 81       	ldd	r24, Y+5	; 0x05
    5d8a:	9e 81       	ldd	r25, Y+6	; 0x06
    5d8c:	9b 83       	std	Y+3, r25	; 0x03
    5d8e:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5d90:	0f b6       	in	r0, 0x3f	; 63
    5d92:	f8 94       	cli
    5d94:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    5d96:	8c 85       	ldd	r24, Y+12	; 0x0c
    5d98:	9d 85       	ldd	r25, Y+13	; 0x0d
    5d9a:	89 2b       	or	r24, r25
    5d9c:	71 f0       	breq	.+28     	; 0x5dba <xTaskGenericNotify+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    5da0:	9b 81       	ldd	r25, Y+3	; 0x03
    5da2:	fc 01       	movw	r30, r24
    5da4:	83 a1       	ldd	r24, Z+35	; 0x23
    5da6:	94 a1       	ldd	r25, Z+36	; 0x24
    5da8:	a5 a1       	ldd	r26, Z+37	; 0x25
    5daa:	b6 a1       	ldd	r27, Z+38	; 0x26
    5dac:	2c 85       	ldd	r18, Y+12	; 0x0c
    5dae:	3d 85       	ldd	r19, Y+13	; 0x0d
    5db0:	f9 01       	movw	r30, r18
    5db2:	80 83       	st	Z, r24
    5db4:	91 83       	std	Z+1, r25	; 0x01
    5db6:	a2 83       	std	Z+2, r26	; 0x02
    5db8:	b3 83       	std	Z+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    5dba:	8a 81       	ldd	r24, Y+2	; 0x02
    5dbc:	9b 81       	ldd	r25, Y+3	; 0x03
    5dbe:	fc 01       	movw	r30, r24
    5dc0:	87 a1       	ldd	r24, Z+39	; 0x27
    5dc2:	8c 83       	std	Y+4, r24	; 0x04

			pxTCB->eNotifyState = eNotified;
    5dc4:	8a 81       	ldd	r24, Y+2	; 0x02
    5dc6:	9b 81       	ldd	r25, Y+3	; 0x03
    5dc8:	22 e0       	ldi	r18, 0x02	; 2
    5dca:	fc 01       	movw	r30, r24
    5dcc:	27 a3       	std	Z+39, r18	; 0x27

			switch( eAction )
    5dce:	8b 85       	ldd	r24, Y+11	; 0x0b
    5dd0:	88 2f       	mov	r24, r24
    5dd2:	90 e0       	ldi	r25, 0x00	; 0
    5dd4:	82 30       	cpi	r24, 0x02	; 2
    5dd6:	91 05       	cpc	r25, r1
    5dd8:	31 f1       	breq	.+76     	; 0x5e26 <xTaskGenericNotify+0xcc>
    5dda:	83 30       	cpi	r24, 0x03	; 3
    5ddc:	91 05       	cpc	r25, r1
    5dde:	34 f4       	brge	.+12     	; 0x5dec <xTaskGenericNotify+0x92>
    5de0:	00 97       	sbiw	r24, 0x00	; 0
    5de2:	09 f4       	brne	.+2      	; 0x5de6 <xTaskGenericNotify+0x8c>
    5de4:	4f c0       	rjmp	.+158    	; 0x5e84 <xTaskGenericNotify+0x12a>
    5de6:	01 97       	sbiw	r24, 0x01	; 1
    5de8:	39 f0       	breq	.+14     	; 0x5df8 <xTaskGenericNotify+0x9e>
    5dea:	4d c0       	rjmp	.+154    	; 0x5e86 <xTaskGenericNotify+0x12c>
    5dec:	83 30       	cpi	r24, 0x03	; 3
    5dee:	91 05       	cpc	r25, r1
    5df0:	61 f1       	breq	.+88     	; 0x5e4a <xTaskGenericNotify+0xf0>
    5df2:	04 97       	sbiw	r24, 0x04	; 4
    5df4:	b1 f1       	breq	.+108    	; 0x5e62 <xTaskGenericNotify+0x108>
    5df6:	47 c0       	rjmp	.+142    	; 0x5e86 <xTaskGenericNotify+0x12c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5df8:	8a 81       	ldd	r24, Y+2	; 0x02
    5dfa:	9b 81       	ldd	r25, Y+3	; 0x03
    5dfc:	fc 01       	movw	r30, r24
    5dfe:	23 a1       	ldd	r18, Z+35	; 0x23
    5e00:	34 a1       	ldd	r19, Z+36	; 0x24
    5e02:	45 a1       	ldd	r20, Z+37	; 0x25
    5e04:	56 a1       	ldd	r21, Z+38	; 0x26
    5e06:	8f 81       	ldd	r24, Y+7	; 0x07
    5e08:	98 85       	ldd	r25, Y+8	; 0x08
    5e0a:	a9 85       	ldd	r26, Y+9	; 0x09
    5e0c:	ba 85       	ldd	r27, Y+10	; 0x0a
    5e0e:	82 2b       	or	r24, r18
    5e10:	93 2b       	or	r25, r19
    5e12:	a4 2b       	or	r26, r20
    5e14:	b5 2b       	or	r27, r21
    5e16:	2a 81       	ldd	r18, Y+2	; 0x02
    5e18:	3b 81       	ldd	r19, Y+3	; 0x03
    5e1a:	f9 01       	movw	r30, r18
    5e1c:	83 a3       	std	Z+35, r24	; 0x23
    5e1e:	94 a3       	std	Z+36, r25	; 0x24
    5e20:	a5 a3       	std	Z+37, r26	; 0x25
    5e22:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5e24:	30 c0       	rjmp	.+96     	; 0x5e86 <xTaskGenericNotify+0x12c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5e26:	8a 81       	ldd	r24, Y+2	; 0x02
    5e28:	9b 81       	ldd	r25, Y+3	; 0x03
    5e2a:	fc 01       	movw	r30, r24
    5e2c:	83 a1       	ldd	r24, Z+35	; 0x23
    5e2e:	94 a1       	ldd	r25, Z+36	; 0x24
    5e30:	a5 a1       	ldd	r26, Z+37	; 0x25
    5e32:	b6 a1       	ldd	r27, Z+38	; 0x26
    5e34:	01 96       	adiw	r24, 0x01	; 1
    5e36:	a1 1d       	adc	r26, r1
    5e38:	b1 1d       	adc	r27, r1
    5e3a:	2a 81       	ldd	r18, Y+2	; 0x02
    5e3c:	3b 81       	ldd	r19, Y+3	; 0x03
    5e3e:	f9 01       	movw	r30, r18
    5e40:	83 a3       	std	Z+35, r24	; 0x23
    5e42:	94 a3       	std	Z+36, r25	; 0x24
    5e44:	a5 a3       	std	Z+37, r26	; 0x25
    5e46:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5e48:	1e c0       	rjmp	.+60     	; 0x5e86 <xTaskGenericNotify+0x12c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5e4a:	2a 81       	ldd	r18, Y+2	; 0x02
    5e4c:	3b 81       	ldd	r19, Y+3	; 0x03
    5e4e:	8f 81       	ldd	r24, Y+7	; 0x07
    5e50:	98 85       	ldd	r25, Y+8	; 0x08
    5e52:	a9 85       	ldd	r26, Y+9	; 0x09
    5e54:	ba 85       	ldd	r27, Y+10	; 0x0a
    5e56:	f9 01       	movw	r30, r18
    5e58:	83 a3       	std	Z+35, r24	; 0x23
    5e5a:	94 a3       	std	Z+36, r25	; 0x24
    5e5c:	a5 a3       	std	Z+37, r26	; 0x25
    5e5e:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5e60:	12 c0       	rjmp	.+36     	; 0x5e86 <xTaskGenericNotify+0x12c>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    5e62:	8c 81       	ldd	r24, Y+4	; 0x04
    5e64:	82 30       	cpi	r24, 0x02	; 2
    5e66:	61 f0       	breq	.+24     	; 0x5e80 <xTaskGenericNotify+0x126>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5e68:	2a 81       	ldd	r18, Y+2	; 0x02
    5e6a:	3b 81       	ldd	r19, Y+3	; 0x03
    5e6c:	8f 81       	ldd	r24, Y+7	; 0x07
    5e6e:	98 85       	ldd	r25, Y+8	; 0x08
    5e70:	a9 85       	ldd	r26, Y+9	; 0x09
    5e72:	ba 85       	ldd	r27, Y+10	; 0x0a
    5e74:	f9 01       	movw	r30, r18
    5e76:	83 a3       	std	Z+35, r24	; 0x23
    5e78:	94 a3       	std	Z+36, r25	; 0x24
    5e7a:	a5 a3       	std	Z+37, r26	; 0x25
    5e7c:	b6 a3       	std	Z+38, r27	; 0x26
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    5e7e:	03 c0       	rjmp	.+6      	; 0x5e86 <xTaskGenericNotify+0x12c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5e80:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    5e82:	01 c0       	rjmp	.+2      	; 0x5e86 <xTaskGenericNotify+0x12c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
    5e84:	00 00       	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    5e86:	8c 81       	ldd	r24, Y+4	; 0x04
    5e88:	81 30       	cpi	r24, 0x01	; 1
    5e8a:	d1 f5       	brne	.+116    	; 0x5f00 <xTaskGenericNotify+0x1a6>
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    5e8c:	8a 81       	ldd	r24, Y+2	; 0x02
    5e8e:	9b 81       	ldd	r25, Y+3	; 0x03
    5e90:	02 96       	adiw	r24, 0x02	; 2
    5e92:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    5e96:	8a 81       	ldd	r24, Y+2	; 0x02
    5e98:	9b 81       	ldd	r25, Y+3	; 0x03
    5e9a:	fc 01       	movw	r30, r24
    5e9c:	96 89       	ldd	r25, Z+22	; 0x16
    5e9e:	80 91 9b 02 	lds	r24, 0x029B
    5ea2:	89 17       	cp	r24, r25
    5ea4:	30 f4       	brcc	.+12     	; 0x5eb2 <xTaskGenericNotify+0x158>
    5ea6:	8a 81       	ldd	r24, Y+2	; 0x02
    5ea8:	9b 81       	ldd	r25, Y+3	; 0x03
    5eaa:	fc 01       	movw	r30, r24
    5eac:	86 89       	ldd	r24, Z+22	; 0x16
    5eae:	80 93 9b 02 	sts	0x029B, r24
    5eb2:	8a 81       	ldd	r24, Y+2	; 0x02
    5eb4:	9b 81       	ldd	r25, Y+3	; 0x03
    5eb6:	ac 01       	movw	r20, r24
    5eb8:	4e 5f       	subi	r20, 0xFE	; 254
    5eba:	5f 4f       	sbci	r21, 0xFF	; 255
    5ebc:	8a 81       	ldd	r24, Y+2	; 0x02
    5ebe:	9b 81       	ldd	r25, Y+3	; 0x03
    5ec0:	fc 01       	movw	r30, r24
    5ec2:	86 89       	ldd	r24, Z+22	; 0x16
    5ec4:	28 2f       	mov	r18, r24
    5ec6:	30 e0       	ldi	r19, 0x00	; 0
    5ec8:	c9 01       	movw	r24, r18
    5eca:	88 0f       	add	r24, r24
    5ecc:	99 1f       	adc	r25, r25
    5ece:	88 0f       	add	r24, r24
    5ed0:	99 1f       	adc	r25, r25
    5ed2:	88 0f       	add	r24, r24
    5ed4:	99 1f       	adc	r25, r25
    5ed6:	82 0f       	add	r24, r18
    5ed8:	93 1f       	adc	r25, r19
    5eda:	8e 5b       	subi	r24, 0xBE	; 190
    5edc:	9d 4f       	sbci	r25, 0xFD	; 253
    5ede:	ba 01       	movw	r22, r20
    5ee0:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5ee4:	8a 81       	ldd	r24, Y+2	; 0x02
    5ee6:	9b 81       	ldd	r25, Y+3	; 0x03
    5ee8:	fc 01       	movw	r30, r24
    5eea:	26 89       	ldd	r18, Z+22	; 0x16
    5eec:	80 91 40 02 	lds	r24, 0x0240
    5ef0:	90 91 41 02 	lds	r25, 0x0241
    5ef4:	fc 01       	movw	r30, r24
    5ef6:	86 89       	ldd	r24, Z+22	; 0x16
    5ef8:	82 17       	cp	r24, r18
    5efa:	10 f4       	brcc	.+4      	; 0x5f00 <xTaskGenericNotify+0x1a6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    5efc:	0e 94 41 18 	call	0x3082	; 0x3082 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5f00:	0f 90       	pop	r0
    5f02:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5f04:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5f06:	2d 96       	adiw	r28, 0x0d	; 13
    5f08:	0f b6       	in	r0, 0x3f	; 63
    5f0a:	f8 94       	cli
    5f0c:	de bf       	out	0x3e, r29	; 62
    5f0e:	0f be       	out	0x3f, r0	; 63
    5f10:	cd bf       	out	0x3d, r28	; 61
    5f12:	df 91       	pop	r29
    5f14:	cf 91       	pop	r28
    5f16:	1f 91       	pop	r17
    5f18:	0f 91       	pop	r16
    5f1a:	08 95       	ret

00005f1c <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5f1c:	ef 92       	push	r14
    5f1e:	ff 92       	push	r15
    5f20:	0f 93       	push	r16
    5f22:	1f 93       	push	r17
    5f24:	cf 93       	push	r28
    5f26:	df 93       	push	r29
    5f28:	cd b7       	in	r28, 0x3d	; 61
    5f2a:	de b7       	in	r29, 0x3e	; 62
    5f2c:	60 97       	sbiw	r28, 0x10	; 16
    5f2e:	0f b6       	in	r0, 0x3f	; 63
    5f30:	f8 94       	cli
    5f32:	de bf       	out	0x3e, r29	; 62
    5f34:	0f be       	out	0x3f, r0	; 63
    5f36:	cd bf       	out	0x3d, r28	; 61
    5f38:	9f 83       	std	Y+7, r25	; 0x07
    5f3a:	8e 83       	std	Y+6, r24	; 0x06
    5f3c:	48 87       	std	Y+8, r20	; 0x08
    5f3e:	59 87       	std	Y+9, r21	; 0x09
    5f40:	6a 87       	std	Y+10, r22	; 0x0a
    5f42:	7b 87       	std	Y+11, r23	; 0x0b
    5f44:	2c 87       	std	Y+12, r18	; 0x0c
    5f46:	1e 87       	std	Y+14, r17	; 0x0e
    5f48:	0d 87       	std	Y+13, r16	; 0x0d
    5f4a:	f8 8a       	std	Y+16, r15	; 0x10
    5f4c:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5f4e:	81 e0       	ldi	r24, 0x01	; 1
    5f50:	89 83       	std	Y+1, r24	; 0x01
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    5f52:	8e 81       	ldd	r24, Y+6	; 0x06
    5f54:	9f 81       	ldd	r25, Y+7	; 0x07
    5f56:	9b 83       	std	Y+3, r25	; 0x03
    5f58:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5f5a:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( pulPreviousNotificationValue != NULL )
    5f5c:	8d 85       	ldd	r24, Y+13	; 0x0d
    5f5e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5f60:	89 2b       	or	r24, r25
    5f62:	71 f0       	breq	.+28     	; 0x5f80 <xTaskGenericNotifyFromISR+0x64>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5f64:	8a 81       	ldd	r24, Y+2	; 0x02
    5f66:	9b 81       	ldd	r25, Y+3	; 0x03
    5f68:	fc 01       	movw	r30, r24
    5f6a:	83 a1       	ldd	r24, Z+35	; 0x23
    5f6c:	94 a1       	ldd	r25, Z+36	; 0x24
    5f6e:	a5 a1       	ldd	r26, Z+37	; 0x25
    5f70:	b6 a1       	ldd	r27, Z+38	; 0x26
    5f72:	2d 85       	ldd	r18, Y+13	; 0x0d
    5f74:	3e 85       	ldd	r19, Y+14	; 0x0e
    5f76:	f9 01       	movw	r30, r18
    5f78:	80 83       	st	Z, r24
    5f7a:	91 83       	std	Z+1, r25	; 0x01
    5f7c:	a2 83       	std	Z+2, r26	; 0x02
    5f7e:	b3 83       	std	Z+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    5f80:	8a 81       	ldd	r24, Y+2	; 0x02
    5f82:	9b 81       	ldd	r25, Y+3	; 0x03
    5f84:	fc 01       	movw	r30, r24
    5f86:	87 a1       	ldd	r24, Z+39	; 0x27
    5f88:	8d 83       	std	Y+5, r24	; 0x05
			pxTCB->eNotifyState = eNotified;
    5f8a:	8a 81       	ldd	r24, Y+2	; 0x02
    5f8c:	9b 81       	ldd	r25, Y+3	; 0x03
    5f8e:	22 e0       	ldi	r18, 0x02	; 2
    5f90:	fc 01       	movw	r30, r24
    5f92:	27 a3       	std	Z+39, r18	; 0x27

			switch( eAction )
    5f94:	8c 85       	ldd	r24, Y+12	; 0x0c
    5f96:	88 2f       	mov	r24, r24
    5f98:	90 e0       	ldi	r25, 0x00	; 0
    5f9a:	82 30       	cpi	r24, 0x02	; 2
    5f9c:	91 05       	cpc	r25, r1
    5f9e:	31 f1       	breq	.+76     	; 0x5fec <xTaskGenericNotifyFromISR+0xd0>
    5fa0:	83 30       	cpi	r24, 0x03	; 3
    5fa2:	91 05       	cpc	r25, r1
    5fa4:	34 f4       	brge	.+12     	; 0x5fb2 <xTaskGenericNotifyFromISR+0x96>
    5fa6:	00 97       	sbiw	r24, 0x00	; 0
    5fa8:	09 f4       	brne	.+2      	; 0x5fac <xTaskGenericNotifyFromISR+0x90>
    5faa:	4f c0       	rjmp	.+158    	; 0x604a <xTaskGenericNotifyFromISR+0x12e>
    5fac:	01 97       	sbiw	r24, 0x01	; 1
    5fae:	39 f0       	breq	.+14     	; 0x5fbe <xTaskGenericNotifyFromISR+0xa2>
    5fb0:	4d c0       	rjmp	.+154    	; 0x604c <xTaskGenericNotifyFromISR+0x130>
    5fb2:	83 30       	cpi	r24, 0x03	; 3
    5fb4:	91 05       	cpc	r25, r1
    5fb6:	61 f1       	breq	.+88     	; 0x6010 <xTaskGenericNotifyFromISR+0xf4>
    5fb8:	04 97       	sbiw	r24, 0x04	; 4
    5fba:	b1 f1       	breq	.+108    	; 0x6028 <xTaskGenericNotifyFromISR+0x10c>
    5fbc:	47 c0       	rjmp	.+142    	; 0x604c <xTaskGenericNotifyFromISR+0x130>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5fbe:	8a 81       	ldd	r24, Y+2	; 0x02
    5fc0:	9b 81       	ldd	r25, Y+3	; 0x03
    5fc2:	fc 01       	movw	r30, r24
    5fc4:	23 a1       	ldd	r18, Z+35	; 0x23
    5fc6:	34 a1       	ldd	r19, Z+36	; 0x24
    5fc8:	45 a1       	ldd	r20, Z+37	; 0x25
    5fca:	56 a1       	ldd	r21, Z+38	; 0x26
    5fcc:	88 85       	ldd	r24, Y+8	; 0x08
    5fce:	99 85       	ldd	r25, Y+9	; 0x09
    5fd0:	aa 85       	ldd	r26, Y+10	; 0x0a
    5fd2:	bb 85       	ldd	r27, Y+11	; 0x0b
    5fd4:	82 2b       	or	r24, r18
    5fd6:	93 2b       	or	r25, r19
    5fd8:	a4 2b       	or	r26, r20
    5fda:	b5 2b       	or	r27, r21
    5fdc:	2a 81       	ldd	r18, Y+2	; 0x02
    5fde:	3b 81       	ldd	r19, Y+3	; 0x03
    5fe0:	f9 01       	movw	r30, r18
    5fe2:	83 a3       	std	Z+35, r24	; 0x23
    5fe4:	94 a3       	std	Z+36, r25	; 0x24
    5fe6:	a5 a3       	std	Z+37, r26	; 0x25
    5fe8:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    5fea:	30 c0       	rjmp	.+96     	; 0x604c <xTaskGenericNotifyFromISR+0x130>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5fec:	8a 81       	ldd	r24, Y+2	; 0x02
    5fee:	9b 81       	ldd	r25, Y+3	; 0x03
    5ff0:	fc 01       	movw	r30, r24
    5ff2:	83 a1       	ldd	r24, Z+35	; 0x23
    5ff4:	94 a1       	ldd	r25, Z+36	; 0x24
    5ff6:	a5 a1       	ldd	r26, Z+37	; 0x25
    5ff8:	b6 a1       	ldd	r27, Z+38	; 0x26
    5ffa:	01 96       	adiw	r24, 0x01	; 1
    5ffc:	a1 1d       	adc	r26, r1
    5ffe:	b1 1d       	adc	r27, r1
    6000:	2a 81       	ldd	r18, Y+2	; 0x02
    6002:	3b 81       	ldd	r19, Y+3	; 0x03
    6004:	f9 01       	movw	r30, r18
    6006:	83 a3       	std	Z+35, r24	; 0x23
    6008:	94 a3       	std	Z+36, r25	; 0x24
    600a:	a5 a3       	std	Z+37, r26	; 0x25
    600c:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    600e:	1e c0       	rjmp	.+60     	; 0x604c <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    6010:	2a 81       	ldd	r18, Y+2	; 0x02
    6012:	3b 81       	ldd	r19, Y+3	; 0x03
    6014:	88 85       	ldd	r24, Y+8	; 0x08
    6016:	99 85       	ldd	r25, Y+9	; 0x09
    6018:	aa 85       	ldd	r26, Y+10	; 0x0a
    601a:	bb 85       	ldd	r27, Y+11	; 0x0b
    601c:	f9 01       	movw	r30, r18
    601e:	83 a3       	std	Z+35, r24	; 0x23
    6020:	94 a3       	std	Z+36, r25	; 0x24
    6022:	a5 a3       	std	Z+37, r26	; 0x25
    6024:	b6 a3       	std	Z+38, r27	; 0x26
					break;
    6026:	12 c0       	rjmp	.+36     	; 0x604c <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    6028:	8d 81       	ldd	r24, Y+5	; 0x05
    602a:	82 30       	cpi	r24, 0x02	; 2
    602c:	61 f0       	breq	.+24     	; 0x6046 <xTaskGenericNotifyFromISR+0x12a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    602e:	2a 81       	ldd	r18, Y+2	; 0x02
    6030:	3b 81       	ldd	r19, Y+3	; 0x03
    6032:	88 85       	ldd	r24, Y+8	; 0x08
    6034:	99 85       	ldd	r25, Y+9	; 0x09
    6036:	aa 85       	ldd	r26, Y+10	; 0x0a
    6038:	bb 85       	ldd	r27, Y+11	; 0x0b
    603a:	f9 01       	movw	r30, r18
    603c:	83 a3       	std	Z+35, r24	; 0x23
    603e:	94 a3       	std	Z+36, r25	; 0x24
    6040:	a5 a3       	std	Z+37, r26	; 0x25
    6042:	b6 a3       	std	Z+38, r27	; 0x26
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    6044:	03 c0       	rjmp	.+6      	; 0x604c <xTaskGenericNotifyFromISR+0x130>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    6046:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    6048:	01 c0       	rjmp	.+2      	; 0x604c <xTaskGenericNotifyFromISR+0x130>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
    604a:	00 00       	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    604c:	8d 81       	ldd	r24, Y+5	; 0x05
    604e:	81 30       	cpi	r24, 0x01	; 1
    6050:	09 f0       	breq	.+2      	; 0x6054 <xTaskGenericNotifyFromISR+0x138>
    6052:	4e c0       	rjmp	.+156    	; 0x60f0 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6054:	80 91 a3 02 	lds	r24, 0x02A3
    6058:	88 23       	and	r24, r24
    605a:	69 f5       	brne	.+90     	; 0x60b6 <xTaskGenericNotifyFromISR+0x19a>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    605c:	8a 81       	ldd	r24, Y+2	; 0x02
    605e:	9b 81       	ldd	r25, Y+3	; 0x03
    6060:	02 96       	adiw	r24, 0x02	; 2
    6062:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    6066:	8a 81       	ldd	r24, Y+2	; 0x02
    6068:	9b 81       	ldd	r25, Y+3	; 0x03
    606a:	fc 01       	movw	r30, r24
    606c:	96 89       	ldd	r25, Z+22	; 0x16
    606e:	80 91 9b 02 	lds	r24, 0x029B
    6072:	89 17       	cp	r24, r25
    6074:	30 f4       	brcc	.+12     	; 0x6082 <xTaskGenericNotifyFromISR+0x166>
    6076:	8a 81       	ldd	r24, Y+2	; 0x02
    6078:	9b 81       	ldd	r25, Y+3	; 0x03
    607a:	fc 01       	movw	r30, r24
    607c:	86 89       	ldd	r24, Z+22	; 0x16
    607e:	80 93 9b 02 	sts	0x029B, r24
    6082:	8a 81       	ldd	r24, Y+2	; 0x02
    6084:	9b 81       	ldd	r25, Y+3	; 0x03
    6086:	ac 01       	movw	r20, r24
    6088:	4e 5f       	subi	r20, 0xFE	; 254
    608a:	5f 4f       	sbci	r21, 0xFF	; 255
    608c:	8a 81       	ldd	r24, Y+2	; 0x02
    608e:	9b 81       	ldd	r25, Y+3	; 0x03
    6090:	fc 01       	movw	r30, r24
    6092:	86 89       	ldd	r24, Z+22	; 0x16
    6094:	28 2f       	mov	r18, r24
    6096:	30 e0       	ldi	r19, 0x00	; 0
    6098:	c9 01       	movw	r24, r18
    609a:	88 0f       	add	r24, r24
    609c:	99 1f       	adc	r25, r25
    609e:	88 0f       	add	r24, r24
    60a0:	99 1f       	adc	r25, r25
    60a2:	88 0f       	add	r24, r24
    60a4:	99 1f       	adc	r25, r25
    60a6:	82 0f       	add	r24, r18
    60a8:	93 1f       	adc	r25, r19
    60aa:	8e 5b       	subi	r24, 0xBE	; 190
    60ac:	9d 4f       	sbci	r25, 0xFD	; 253
    60ae:	ba 01       	movw	r22, r20
    60b0:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
    60b4:	08 c0       	rjmp	.+16     	; 0x60c6 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    60b6:	8a 81       	ldd	r24, Y+2	; 0x02
    60b8:	9b 81       	ldd	r25, Y+3	; 0x03
    60ba:	0c 96       	adiw	r24, 0x0c	; 12
    60bc:	bc 01       	movw	r22, r24
    60be:	8c e7       	ldi	r24, 0x7C	; 124
    60c0:	92 e0       	ldi	r25, 0x02	; 2
    60c2:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    60c6:	8a 81       	ldd	r24, Y+2	; 0x02
    60c8:	9b 81       	ldd	r25, Y+3	; 0x03
    60ca:	fc 01       	movw	r30, r24
    60cc:	26 89       	ldd	r18, Z+22	; 0x16
    60ce:	80 91 40 02 	lds	r24, 0x0240
    60d2:	90 91 41 02 	lds	r25, 0x0241
    60d6:	fc 01       	movw	r30, r24
    60d8:	86 89       	ldd	r24, Z+22	; 0x16
    60da:	82 17       	cp	r24, r18
    60dc:	48 f4       	brcc	.+18     	; 0x60f0 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    60de:	8f 85       	ldd	r24, Y+15	; 0x0f
    60e0:	98 89       	ldd	r25, Y+16	; 0x10
    60e2:	89 2b       	or	r24, r25
    60e4:	29 f0       	breq	.+10     	; 0x60f0 <xTaskGenericNotifyFromISR+0x1d4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    60e6:	8f 85       	ldd	r24, Y+15	; 0x0f
    60e8:	98 89       	ldd	r25, Y+16	; 0x10
    60ea:	21 e0       	ldi	r18, 0x01	; 1
    60ec:	fc 01       	movw	r30, r24
    60ee:	20 83       	st	Z, r18
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    60f0:	89 81       	ldd	r24, Y+1	; 0x01
	}
    60f2:	60 96       	adiw	r28, 0x10	; 16
    60f4:	0f b6       	in	r0, 0x3f	; 63
    60f6:	f8 94       	cli
    60f8:	de bf       	out	0x3e, r29	; 62
    60fa:	0f be       	out	0x3f, r0	; 63
    60fc:	cd bf       	out	0x3d, r28	; 61
    60fe:	df 91       	pop	r29
    6100:	cf 91       	pop	r28
    6102:	1f 91       	pop	r17
    6104:	0f 91       	pop	r16
    6106:	ff 90       	pop	r15
    6108:	ef 90       	pop	r14
    610a:	08 95       	ret

0000610c <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    610c:	cf 93       	push	r28
    610e:	df 93       	push	r29
    6110:	cd b7       	in	r28, 0x3d	; 61
    6112:	de b7       	in	r29, 0x3e	; 62
    6114:	28 97       	sbiw	r28, 0x08	; 8
    6116:	0f b6       	in	r0, 0x3f	; 63
    6118:	f8 94       	cli
    611a:	de bf       	out	0x3e, r29	; 62
    611c:	0f be       	out	0x3f, r0	; 63
    611e:	cd bf       	out	0x3d, r28	; 61
    6120:	9e 83       	std	Y+6, r25	; 0x06
    6122:	8d 83       	std	Y+5, r24	; 0x05
    6124:	78 87       	std	Y+8, r23	; 0x08
    6126:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    6128:	8d 81       	ldd	r24, Y+5	; 0x05
    612a:	9e 81       	ldd	r25, Y+6	; 0x06
    612c:	9a 83       	std	Y+2, r25	; 0x02
    612e:	89 83       	std	Y+1, r24	; 0x01

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    6130:	1b 82       	std	Y+3, r1	; 0x03
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
    6132:	89 81       	ldd	r24, Y+1	; 0x01
    6134:	9a 81       	ldd	r25, Y+2	; 0x02
    6136:	fc 01       	movw	r30, r24
    6138:	87 a1       	ldd	r24, Z+39	; 0x27
    613a:	8c 83       	std	Y+4, r24	; 0x04
			pxTCB->eNotifyState = eNotified;
    613c:	89 81       	ldd	r24, Y+1	; 0x01
    613e:	9a 81       	ldd	r25, Y+2	; 0x02
    6140:	22 e0       	ldi	r18, 0x02	; 2
    6142:	fc 01       	movw	r30, r24
    6144:	27 a3       	std	Z+39, r18	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    6146:	89 81       	ldd	r24, Y+1	; 0x01
    6148:	9a 81       	ldd	r25, Y+2	; 0x02
    614a:	fc 01       	movw	r30, r24
    614c:	83 a1       	ldd	r24, Z+35	; 0x23
    614e:	94 a1       	ldd	r25, Z+36	; 0x24
    6150:	a5 a1       	ldd	r26, Z+37	; 0x25
    6152:	b6 a1       	ldd	r27, Z+38	; 0x26
    6154:	01 96       	adiw	r24, 0x01	; 1
    6156:	a1 1d       	adc	r26, r1
    6158:	b1 1d       	adc	r27, r1
    615a:	29 81       	ldd	r18, Y+1	; 0x01
    615c:	3a 81       	ldd	r19, Y+2	; 0x02
    615e:	f9 01       	movw	r30, r18
    6160:	83 a3       	std	Z+35, r24	; 0x23
    6162:	94 a3       	std	Z+36, r25	; 0x24
    6164:	a5 a3       	std	Z+37, r26	; 0x25
    6166:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    6168:	8c 81       	ldd	r24, Y+4	; 0x04
    616a:	81 30       	cpi	r24, 0x01	; 1
    616c:	09 f0       	breq	.+2      	; 0x6170 <vTaskNotifyGiveFromISR+0x64>
    616e:	4e c0       	rjmp	.+156    	; 0x620c <vTaskNotifyGiveFromISR+0x100>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6170:	80 91 a3 02 	lds	r24, 0x02A3
    6174:	88 23       	and	r24, r24
    6176:	69 f5       	brne	.+90     	; 0x61d2 <vTaskNotifyGiveFromISR+0xc6>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    6178:	89 81       	ldd	r24, Y+1	; 0x01
    617a:	9a 81       	ldd	r25, Y+2	; 0x02
    617c:	02 96       	adiw	r24, 0x02	; 2
    617e:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    6182:	89 81       	ldd	r24, Y+1	; 0x01
    6184:	9a 81       	ldd	r25, Y+2	; 0x02
    6186:	fc 01       	movw	r30, r24
    6188:	96 89       	ldd	r25, Z+22	; 0x16
    618a:	80 91 9b 02 	lds	r24, 0x029B
    618e:	89 17       	cp	r24, r25
    6190:	30 f4       	brcc	.+12     	; 0x619e <vTaskNotifyGiveFromISR+0x92>
    6192:	89 81       	ldd	r24, Y+1	; 0x01
    6194:	9a 81       	ldd	r25, Y+2	; 0x02
    6196:	fc 01       	movw	r30, r24
    6198:	86 89       	ldd	r24, Z+22	; 0x16
    619a:	80 93 9b 02 	sts	0x029B, r24
    619e:	89 81       	ldd	r24, Y+1	; 0x01
    61a0:	9a 81       	ldd	r25, Y+2	; 0x02
    61a2:	ac 01       	movw	r20, r24
    61a4:	4e 5f       	subi	r20, 0xFE	; 254
    61a6:	5f 4f       	sbci	r21, 0xFF	; 255
    61a8:	89 81       	ldd	r24, Y+1	; 0x01
    61aa:	9a 81       	ldd	r25, Y+2	; 0x02
    61ac:	fc 01       	movw	r30, r24
    61ae:	86 89       	ldd	r24, Z+22	; 0x16
    61b0:	28 2f       	mov	r18, r24
    61b2:	30 e0       	ldi	r19, 0x00	; 0
    61b4:	c9 01       	movw	r24, r18
    61b6:	88 0f       	add	r24, r24
    61b8:	99 1f       	adc	r25, r25
    61ba:	88 0f       	add	r24, r24
    61bc:	99 1f       	adc	r25, r25
    61be:	88 0f       	add	r24, r24
    61c0:	99 1f       	adc	r25, r25
    61c2:	82 0f       	add	r24, r18
    61c4:	93 1f       	adc	r25, r19
    61c6:	8e 5b       	subi	r24, 0xBE	; 190
    61c8:	9d 4f       	sbci	r25, 0xFD	; 253
    61ca:	ba 01       	movw	r22, r20
    61cc:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
    61d0:	08 c0       	rjmp	.+16     	; 0x61e2 <vTaskNotifyGiveFromISR+0xd6>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    61d2:	89 81       	ldd	r24, Y+1	; 0x01
    61d4:	9a 81       	ldd	r25, Y+2	; 0x02
    61d6:	0c 96       	adiw	r24, 0x0c	; 12
    61d8:	bc 01       	movw	r22, r24
    61da:	8c e7       	ldi	r24, 0x7C	; 124
    61dc:	92 e0       	ldi	r25, 0x02	; 2
    61de:	0e 94 62 14 	call	0x28c4	; 0x28c4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    61e2:	89 81       	ldd	r24, Y+1	; 0x01
    61e4:	9a 81       	ldd	r25, Y+2	; 0x02
    61e6:	fc 01       	movw	r30, r24
    61e8:	26 89       	ldd	r18, Z+22	; 0x16
    61ea:	80 91 40 02 	lds	r24, 0x0240
    61ee:	90 91 41 02 	lds	r25, 0x0241
    61f2:	fc 01       	movw	r30, r24
    61f4:	86 89       	ldd	r24, Z+22	; 0x16
    61f6:	82 17       	cp	r24, r18
    61f8:	48 f4       	brcc	.+18     	; 0x620c <vTaskNotifyGiveFromISR+0x100>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    61fa:	8f 81       	ldd	r24, Y+7	; 0x07
    61fc:	98 85       	ldd	r25, Y+8	; 0x08
    61fe:	89 2b       	or	r24, r25
    6200:	29 f0       	breq	.+10     	; 0x620c <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    6202:	8f 81       	ldd	r24, Y+7	; 0x07
    6204:	98 85       	ldd	r25, Y+8	; 0x08
    6206:	21 e0       	ldi	r18, 0x01	; 1
    6208:	fc 01       	movw	r30, r24
    620a:	20 83       	st	Z, r18
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    620c:	28 96       	adiw	r28, 0x08	; 8
    620e:	0f b6       	in	r0, 0x3f	; 63
    6210:	f8 94       	cli
    6212:	de bf       	out	0x3e, r29	; 62
    6214:	0f be       	out	0x3f, r0	; 63
    6216:	cd bf       	out	0x3d, r28	; 61
    6218:	df 91       	pop	r29
    621a:	cf 91       	pop	r28
    621c:	08 95       	ret

0000621e <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    621e:	cf 93       	push	r28
    6220:	df 93       	push	r29
    6222:	00 d0       	rcall	.+0      	; 0x6224 <xTaskNotifyStateClear+0x6>
    6224:	1f 92       	push	r1
    6226:	1f 92       	push	r1
    6228:	cd b7       	in	r28, 0x3d	; 61
    622a:	de b7       	in	r29, 0x3e	; 62
    622c:	9d 83       	std	Y+5, r25	; 0x05
    622e:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		pxTCB = ( TCB_t * ) xTask;
    6230:	8c 81       	ldd	r24, Y+4	; 0x04
    6232:	9d 81       	ldd	r25, Y+5	; 0x05
    6234:	9b 83       	std	Y+3, r25	; 0x03
    6236:	8a 83       	std	Y+2, r24	; 0x02

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    6238:	8a 81       	ldd	r24, Y+2	; 0x02
    623a:	9b 81       	ldd	r25, Y+3	; 0x03
    623c:	89 2b       	or	r24, r25
    623e:	29 f4       	brne	.+10     	; 0x624a <xTaskNotifyStateClear+0x2c>
    6240:	80 91 40 02 	lds	r24, 0x0240
    6244:	90 91 41 02 	lds	r25, 0x0241
    6248:	02 c0       	rjmp	.+4      	; 0x624e <xTaskNotifyStateClear+0x30>
    624a:	8a 81       	ldd	r24, Y+2	; 0x02
    624c:	9b 81       	ldd	r25, Y+3	; 0x03
    624e:	9b 83       	std	Y+3, r25	; 0x03
    6250:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    6252:	0f b6       	in	r0, 0x3f	; 63
    6254:	f8 94       	cli
    6256:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    6258:	8a 81       	ldd	r24, Y+2	; 0x02
    625a:	9b 81       	ldd	r25, Y+3	; 0x03
    625c:	fc 01       	movw	r30, r24
    625e:	87 a1       	ldd	r24, Z+39	; 0x27
    6260:	82 30       	cpi	r24, 0x02	; 2
    6262:	39 f4       	brne	.+14     	; 0x6272 <xTaskNotifyStateClear+0x54>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    6264:	8a 81       	ldd	r24, Y+2	; 0x02
    6266:	9b 81       	ldd	r25, Y+3	; 0x03
    6268:	fc 01       	movw	r30, r24
    626a:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    626c:	81 e0       	ldi	r24, 0x01	; 1
    626e:	89 83       	std	Y+1, r24	; 0x01
    6270:	01 c0       	rjmp	.+2      	; 0x6274 <xTaskNotifyStateClear+0x56>
			}
			else
			{
				xReturn = pdFAIL;
    6272:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    6274:	0f 90       	pop	r0
    6276:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    6278:	89 81       	ldd	r24, Y+1	; 0x01
	}
    627a:	0f 90       	pop	r0
    627c:	0f 90       	pop	r0
    627e:	0f 90       	pop	r0
    6280:	0f 90       	pop	r0
    6282:	0f 90       	pop	r0
    6284:	df 91       	pop	r29
    6286:	cf 91       	pop	r28
    6288:	08 95       	ret

0000628a <__subsf3>:
    628a:	50 58       	subi	r21, 0x80	; 128

0000628c <__addsf3>:
    628c:	bb 27       	eor	r27, r27
    628e:	aa 27       	eor	r26, r26
    6290:	0e 94 5d 31 	call	0x62ba	; 0x62ba <__addsf3x>
    6294:	0c 94 26 33 	jmp	0x664c	; 0x664c <__fp_round>
    6298:	0e 94 18 33 	call	0x6630	; 0x6630 <__fp_pscA>
    629c:	38 f0       	brcs	.+14     	; 0x62ac <__addsf3+0x20>
    629e:	0e 94 1f 33 	call	0x663e	; 0x663e <__fp_pscB>
    62a2:	20 f0       	brcs	.+8      	; 0x62ac <__addsf3+0x20>
    62a4:	39 f4       	brne	.+14     	; 0x62b4 <__addsf3+0x28>
    62a6:	9f 3f       	cpi	r25, 0xFF	; 255
    62a8:	19 f4       	brne	.+6      	; 0x62b0 <__addsf3+0x24>
    62aa:	26 f4       	brtc	.+8      	; 0x62b4 <__addsf3+0x28>
    62ac:	0c 94 ee 32 	jmp	0x65dc	; 0x65dc <__fp_nan>
    62b0:	0e f4       	brtc	.+2      	; 0x62b4 <__addsf3+0x28>
    62b2:	e0 95       	com	r30
    62b4:	e7 fb       	bst	r30, 7
    62b6:	0c 94 e8 32 	jmp	0x65d0	; 0x65d0 <__fp_inf>

000062ba <__addsf3x>:
    62ba:	e9 2f       	mov	r30, r25
    62bc:	0e 94 37 33 	call	0x666e	; 0x666e <__fp_split3>
    62c0:	58 f3       	brcs	.-42     	; 0x6298 <__addsf3+0xc>
    62c2:	ba 17       	cp	r27, r26
    62c4:	62 07       	cpc	r22, r18
    62c6:	73 07       	cpc	r23, r19
    62c8:	84 07       	cpc	r24, r20
    62ca:	95 07       	cpc	r25, r21
    62cc:	20 f0       	brcs	.+8      	; 0x62d6 <__addsf3x+0x1c>
    62ce:	79 f4       	brne	.+30     	; 0x62ee <__addsf3x+0x34>
    62d0:	a6 f5       	brtc	.+104    	; 0x633a <__addsf3x+0x80>
    62d2:	0c 94 59 33 	jmp	0x66b2	; 0x66b2 <__fp_zero>
    62d6:	0e f4       	brtc	.+2      	; 0x62da <__addsf3x+0x20>
    62d8:	e0 95       	com	r30
    62da:	0b 2e       	mov	r0, r27
    62dc:	ba 2f       	mov	r27, r26
    62de:	a0 2d       	mov	r26, r0
    62e0:	0b 01       	movw	r0, r22
    62e2:	b9 01       	movw	r22, r18
    62e4:	90 01       	movw	r18, r0
    62e6:	0c 01       	movw	r0, r24
    62e8:	ca 01       	movw	r24, r20
    62ea:	a0 01       	movw	r20, r0
    62ec:	11 24       	eor	r1, r1
    62ee:	ff 27       	eor	r31, r31
    62f0:	59 1b       	sub	r21, r25
    62f2:	99 f0       	breq	.+38     	; 0x631a <__addsf3x+0x60>
    62f4:	59 3f       	cpi	r21, 0xF9	; 249
    62f6:	50 f4       	brcc	.+20     	; 0x630c <__addsf3x+0x52>
    62f8:	50 3e       	cpi	r21, 0xE0	; 224
    62fa:	68 f1       	brcs	.+90     	; 0x6356 <__addsf3x+0x9c>
    62fc:	1a 16       	cp	r1, r26
    62fe:	f0 40       	sbci	r31, 0x00	; 0
    6300:	a2 2f       	mov	r26, r18
    6302:	23 2f       	mov	r18, r19
    6304:	34 2f       	mov	r19, r20
    6306:	44 27       	eor	r20, r20
    6308:	58 5f       	subi	r21, 0xF8	; 248
    630a:	f3 cf       	rjmp	.-26     	; 0x62f2 <__addsf3x+0x38>
    630c:	46 95       	lsr	r20
    630e:	37 95       	ror	r19
    6310:	27 95       	ror	r18
    6312:	a7 95       	ror	r26
    6314:	f0 40       	sbci	r31, 0x00	; 0
    6316:	53 95       	inc	r21
    6318:	c9 f7       	brne	.-14     	; 0x630c <__addsf3x+0x52>
    631a:	7e f4       	brtc	.+30     	; 0x633a <__addsf3x+0x80>
    631c:	1f 16       	cp	r1, r31
    631e:	ba 0b       	sbc	r27, r26
    6320:	62 0b       	sbc	r22, r18
    6322:	73 0b       	sbc	r23, r19
    6324:	84 0b       	sbc	r24, r20
    6326:	ba f0       	brmi	.+46     	; 0x6356 <__addsf3x+0x9c>
    6328:	91 50       	subi	r25, 0x01	; 1
    632a:	a1 f0       	breq	.+40     	; 0x6354 <__addsf3x+0x9a>
    632c:	ff 0f       	add	r31, r31
    632e:	bb 1f       	adc	r27, r27
    6330:	66 1f       	adc	r22, r22
    6332:	77 1f       	adc	r23, r23
    6334:	88 1f       	adc	r24, r24
    6336:	c2 f7       	brpl	.-16     	; 0x6328 <__addsf3x+0x6e>
    6338:	0e c0       	rjmp	.+28     	; 0x6356 <__addsf3x+0x9c>
    633a:	ba 0f       	add	r27, r26
    633c:	62 1f       	adc	r22, r18
    633e:	73 1f       	adc	r23, r19
    6340:	84 1f       	adc	r24, r20
    6342:	48 f4       	brcc	.+18     	; 0x6356 <__addsf3x+0x9c>
    6344:	87 95       	ror	r24
    6346:	77 95       	ror	r23
    6348:	67 95       	ror	r22
    634a:	b7 95       	ror	r27
    634c:	f7 95       	ror	r31
    634e:	9e 3f       	cpi	r25, 0xFE	; 254
    6350:	08 f0       	brcs	.+2      	; 0x6354 <__addsf3x+0x9a>
    6352:	b0 cf       	rjmp	.-160    	; 0x62b4 <__addsf3+0x28>
    6354:	93 95       	inc	r25
    6356:	88 0f       	add	r24, r24
    6358:	08 f0       	brcs	.+2      	; 0x635c <__addsf3x+0xa2>
    635a:	99 27       	eor	r25, r25
    635c:	ee 0f       	add	r30, r30
    635e:	97 95       	ror	r25
    6360:	87 95       	ror	r24
    6362:	08 95       	ret

00006364 <atan>:
    6364:	df 93       	push	r29
    6366:	dd 27       	eor	r29, r29
    6368:	b9 2f       	mov	r27, r25
    636a:	bf 77       	andi	r27, 0x7F	; 127
    636c:	40 e8       	ldi	r20, 0x80	; 128
    636e:	5f e3       	ldi	r21, 0x3F	; 63
    6370:	16 16       	cp	r1, r22
    6372:	17 06       	cpc	r1, r23
    6374:	48 07       	cpc	r20, r24
    6376:	5b 07       	cpc	r21, r27
    6378:	18 f4       	brcc	.+6      	; 0x6380 <atan+0x1c>
    637a:	d9 2f       	mov	r29, r25
    637c:	0e 94 65 33 	call	0x66ca	; 0x66ca <inverse>
    6380:	9f 93       	push	r25
    6382:	8f 93       	push	r24
    6384:	7f 93       	push	r23
    6386:	6f 93       	push	r22
    6388:	0e 94 70 34 	call	0x68e0	; 0x68e0 <square>
    638c:	e4 ee       	ldi	r30, 0xE4	; 228
    638e:	f0 e0       	ldi	r31, 0x00	; 0
    6390:	0e 94 f1 32 	call	0x65e2	; 0x65e2 <__fp_powser>
    6394:	0e 94 26 33 	call	0x664c	; 0x664c <__fp_round>
    6398:	2f 91       	pop	r18
    639a:	3f 91       	pop	r19
    639c:	4f 91       	pop	r20
    639e:	5f 91       	pop	r21
    63a0:	0e 94 80 33 	call	0x6700	; 0x6700 <__mulsf3x>
    63a4:	dd 23       	and	r29, r29
    63a6:	51 f0       	breq	.+20     	; 0x63bc <atan+0x58>
    63a8:	90 58       	subi	r25, 0x80	; 128
    63aa:	a2 ea       	ldi	r26, 0xA2	; 162
    63ac:	2a ed       	ldi	r18, 0xDA	; 218
    63ae:	3f e0       	ldi	r19, 0x0F	; 15
    63b0:	49 ec       	ldi	r20, 0xC9	; 201
    63b2:	5f e3       	ldi	r21, 0x3F	; 63
    63b4:	d0 78       	andi	r29, 0x80	; 128
    63b6:	5d 27       	eor	r21, r29
    63b8:	0e 94 5d 31 	call	0x62ba	; 0x62ba <__addsf3x>
    63bc:	df 91       	pop	r29
    63be:	0c 94 26 33 	jmp	0x664c	; 0x664c <__fp_round>

000063c2 <__cmpsf2>:
    63c2:	0e 94 c4 32 	call	0x6588	; 0x6588 <__fp_cmp>
    63c6:	08 f4       	brcc	.+2      	; 0x63ca <__cmpsf2+0x8>
    63c8:	81 e0       	ldi	r24, 0x01	; 1
    63ca:	08 95       	ret

000063cc <__divsf3>:
    63cc:	0e 94 fa 31 	call	0x63f4	; 0x63f4 <__divsf3x>
    63d0:	0c 94 26 33 	jmp	0x664c	; 0x664c <__fp_round>
    63d4:	0e 94 1f 33 	call	0x663e	; 0x663e <__fp_pscB>
    63d8:	58 f0       	brcs	.+22     	; 0x63f0 <__divsf3+0x24>
    63da:	0e 94 18 33 	call	0x6630	; 0x6630 <__fp_pscA>
    63de:	40 f0       	brcs	.+16     	; 0x63f0 <__divsf3+0x24>
    63e0:	29 f4       	brne	.+10     	; 0x63ec <__divsf3+0x20>
    63e2:	5f 3f       	cpi	r21, 0xFF	; 255
    63e4:	29 f0       	breq	.+10     	; 0x63f0 <__divsf3+0x24>
    63e6:	0c 94 e8 32 	jmp	0x65d0	; 0x65d0 <__fp_inf>
    63ea:	51 11       	cpse	r21, r1
    63ec:	0c 94 5a 33 	jmp	0x66b4	; 0x66b4 <__fp_szero>
    63f0:	0c 94 ee 32 	jmp	0x65dc	; 0x65dc <__fp_nan>

000063f4 <__divsf3x>:
    63f4:	0e 94 37 33 	call	0x666e	; 0x666e <__fp_split3>
    63f8:	68 f3       	brcs	.-38     	; 0x63d4 <__divsf3+0x8>

000063fa <__divsf3_pse>:
    63fa:	99 23       	and	r25, r25
    63fc:	b1 f3       	breq	.-20     	; 0x63ea <__divsf3+0x1e>
    63fe:	55 23       	and	r21, r21
    6400:	91 f3       	breq	.-28     	; 0x63e6 <__divsf3+0x1a>
    6402:	95 1b       	sub	r25, r21
    6404:	55 0b       	sbc	r21, r21
    6406:	bb 27       	eor	r27, r27
    6408:	aa 27       	eor	r26, r26
    640a:	62 17       	cp	r22, r18
    640c:	73 07       	cpc	r23, r19
    640e:	84 07       	cpc	r24, r20
    6410:	38 f0       	brcs	.+14     	; 0x6420 <__divsf3_pse+0x26>
    6412:	9f 5f       	subi	r25, 0xFF	; 255
    6414:	5f 4f       	sbci	r21, 0xFF	; 255
    6416:	22 0f       	add	r18, r18
    6418:	33 1f       	adc	r19, r19
    641a:	44 1f       	adc	r20, r20
    641c:	aa 1f       	adc	r26, r26
    641e:	a9 f3       	breq	.-22     	; 0x640a <__divsf3_pse+0x10>
    6420:	35 d0       	rcall	.+106    	; 0x648c <__divsf3_pse+0x92>
    6422:	0e 2e       	mov	r0, r30
    6424:	3a f0       	brmi	.+14     	; 0x6434 <__divsf3_pse+0x3a>
    6426:	e0 e8       	ldi	r30, 0x80	; 128
    6428:	32 d0       	rcall	.+100    	; 0x648e <__divsf3_pse+0x94>
    642a:	91 50       	subi	r25, 0x01	; 1
    642c:	50 40       	sbci	r21, 0x00	; 0
    642e:	e6 95       	lsr	r30
    6430:	00 1c       	adc	r0, r0
    6432:	ca f7       	brpl	.-14     	; 0x6426 <__divsf3_pse+0x2c>
    6434:	2b d0       	rcall	.+86     	; 0x648c <__divsf3_pse+0x92>
    6436:	fe 2f       	mov	r31, r30
    6438:	29 d0       	rcall	.+82     	; 0x648c <__divsf3_pse+0x92>
    643a:	66 0f       	add	r22, r22
    643c:	77 1f       	adc	r23, r23
    643e:	88 1f       	adc	r24, r24
    6440:	bb 1f       	adc	r27, r27
    6442:	26 17       	cp	r18, r22
    6444:	37 07       	cpc	r19, r23
    6446:	48 07       	cpc	r20, r24
    6448:	ab 07       	cpc	r26, r27
    644a:	b0 e8       	ldi	r27, 0x80	; 128
    644c:	09 f0       	breq	.+2      	; 0x6450 <__divsf3_pse+0x56>
    644e:	bb 0b       	sbc	r27, r27
    6450:	80 2d       	mov	r24, r0
    6452:	bf 01       	movw	r22, r30
    6454:	ff 27       	eor	r31, r31
    6456:	93 58       	subi	r25, 0x83	; 131
    6458:	5f 4f       	sbci	r21, 0xFF	; 255
    645a:	3a f0       	brmi	.+14     	; 0x646a <__divsf3_pse+0x70>
    645c:	9e 3f       	cpi	r25, 0xFE	; 254
    645e:	51 05       	cpc	r21, r1
    6460:	78 f0       	brcs	.+30     	; 0x6480 <__divsf3_pse+0x86>
    6462:	0c 94 e8 32 	jmp	0x65d0	; 0x65d0 <__fp_inf>
    6466:	0c 94 5a 33 	jmp	0x66b4	; 0x66b4 <__fp_szero>
    646a:	5f 3f       	cpi	r21, 0xFF	; 255
    646c:	e4 f3       	brlt	.-8      	; 0x6466 <__divsf3_pse+0x6c>
    646e:	98 3e       	cpi	r25, 0xE8	; 232
    6470:	d4 f3       	brlt	.-12     	; 0x6466 <__divsf3_pse+0x6c>
    6472:	86 95       	lsr	r24
    6474:	77 95       	ror	r23
    6476:	67 95       	ror	r22
    6478:	b7 95       	ror	r27
    647a:	f7 95       	ror	r31
    647c:	9f 5f       	subi	r25, 0xFF	; 255
    647e:	c9 f7       	brne	.-14     	; 0x6472 <__divsf3_pse+0x78>
    6480:	88 0f       	add	r24, r24
    6482:	91 1d       	adc	r25, r1
    6484:	96 95       	lsr	r25
    6486:	87 95       	ror	r24
    6488:	97 f9       	bld	r25, 7
    648a:	08 95       	ret
    648c:	e1 e0       	ldi	r30, 0x01	; 1
    648e:	66 0f       	add	r22, r22
    6490:	77 1f       	adc	r23, r23
    6492:	88 1f       	adc	r24, r24
    6494:	bb 1f       	adc	r27, r27
    6496:	62 17       	cp	r22, r18
    6498:	73 07       	cpc	r23, r19
    649a:	84 07       	cpc	r24, r20
    649c:	ba 07       	cpc	r27, r26
    649e:	20 f0       	brcs	.+8      	; 0x64a8 <__divsf3_pse+0xae>
    64a0:	62 1b       	sub	r22, r18
    64a2:	73 0b       	sbc	r23, r19
    64a4:	84 0b       	sbc	r24, r20
    64a6:	ba 0b       	sbc	r27, r26
    64a8:	ee 1f       	adc	r30, r30
    64aa:	88 f7       	brcc	.-30     	; 0x648e <__divsf3_pse+0x94>
    64ac:	e0 95       	com	r30
    64ae:	08 95       	ret

000064b0 <__fixunssfsi>:
    64b0:	0e 94 3f 33 	call	0x667e	; 0x667e <__fp_splitA>
    64b4:	88 f0       	brcs	.+34     	; 0x64d8 <__fixunssfsi+0x28>
    64b6:	9f 57       	subi	r25, 0x7F	; 127
    64b8:	98 f0       	brcs	.+38     	; 0x64e0 <__fixunssfsi+0x30>
    64ba:	b9 2f       	mov	r27, r25
    64bc:	99 27       	eor	r25, r25
    64be:	b7 51       	subi	r27, 0x17	; 23
    64c0:	b0 f0       	brcs	.+44     	; 0x64ee <__fixunssfsi+0x3e>
    64c2:	e1 f0       	breq	.+56     	; 0x64fc <__fixunssfsi+0x4c>
    64c4:	66 0f       	add	r22, r22
    64c6:	77 1f       	adc	r23, r23
    64c8:	88 1f       	adc	r24, r24
    64ca:	99 1f       	adc	r25, r25
    64cc:	1a f0       	brmi	.+6      	; 0x64d4 <__fixunssfsi+0x24>
    64ce:	ba 95       	dec	r27
    64d0:	c9 f7       	brne	.-14     	; 0x64c4 <__fixunssfsi+0x14>
    64d2:	14 c0       	rjmp	.+40     	; 0x64fc <__fixunssfsi+0x4c>
    64d4:	b1 30       	cpi	r27, 0x01	; 1
    64d6:	91 f0       	breq	.+36     	; 0x64fc <__fixunssfsi+0x4c>
    64d8:	0e 94 59 33 	call	0x66b2	; 0x66b2 <__fp_zero>
    64dc:	b1 e0       	ldi	r27, 0x01	; 1
    64de:	08 95       	ret
    64e0:	0c 94 59 33 	jmp	0x66b2	; 0x66b2 <__fp_zero>
    64e4:	67 2f       	mov	r22, r23
    64e6:	78 2f       	mov	r23, r24
    64e8:	88 27       	eor	r24, r24
    64ea:	b8 5f       	subi	r27, 0xF8	; 248
    64ec:	39 f0       	breq	.+14     	; 0x64fc <__fixunssfsi+0x4c>
    64ee:	b9 3f       	cpi	r27, 0xF9	; 249
    64f0:	cc f3       	brlt	.-14     	; 0x64e4 <__fixunssfsi+0x34>
    64f2:	86 95       	lsr	r24
    64f4:	77 95       	ror	r23
    64f6:	67 95       	ror	r22
    64f8:	b3 95       	inc	r27
    64fa:	d9 f7       	brne	.-10     	; 0x64f2 <__fixunssfsi+0x42>
    64fc:	3e f4       	brtc	.+14     	; 0x650c <__fixunssfsi+0x5c>
    64fe:	90 95       	com	r25
    6500:	80 95       	com	r24
    6502:	70 95       	com	r23
    6504:	61 95       	neg	r22
    6506:	7f 4f       	sbci	r23, 0xFF	; 255
    6508:	8f 4f       	sbci	r24, 0xFF	; 255
    650a:	9f 4f       	sbci	r25, 0xFF	; 255
    650c:	08 95       	ret

0000650e <__floatunsisf>:
    650e:	e8 94       	clt
    6510:	09 c0       	rjmp	.+18     	; 0x6524 <__floatsisf+0x12>

00006512 <__floatsisf>:
    6512:	97 fb       	bst	r25, 7
    6514:	3e f4       	brtc	.+14     	; 0x6524 <__floatsisf+0x12>
    6516:	90 95       	com	r25
    6518:	80 95       	com	r24
    651a:	70 95       	com	r23
    651c:	61 95       	neg	r22
    651e:	7f 4f       	sbci	r23, 0xFF	; 255
    6520:	8f 4f       	sbci	r24, 0xFF	; 255
    6522:	9f 4f       	sbci	r25, 0xFF	; 255
    6524:	99 23       	and	r25, r25
    6526:	a9 f0       	breq	.+42     	; 0x6552 <__floatsisf+0x40>
    6528:	f9 2f       	mov	r31, r25
    652a:	96 e9       	ldi	r25, 0x96	; 150
    652c:	bb 27       	eor	r27, r27
    652e:	93 95       	inc	r25
    6530:	f6 95       	lsr	r31
    6532:	87 95       	ror	r24
    6534:	77 95       	ror	r23
    6536:	67 95       	ror	r22
    6538:	b7 95       	ror	r27
    653a:	f1 11       	cpse	r31, r1
    653c:	f8 cf       	rjmp	.-16     	; 0x652e <__floatsisf+0x1c>
    653e:	fa f4       	brpl	.+62     	; 0x657e <__floatsisf+0x6c>
    6540:	bb 0f       	add	r27, r27
    6542:	11 f4       	brne	.+4      	; 0x6548 <__floatsisf+0x36>
    6544:	60 ff       	sbrs	r22, 0
    6546:	1b c0       	rjmp	.+54     	; 0x657e <__floatsisf+0x6c>
    6548:	6f 5f       	subi	r22, 0xFF	; 255
    654a:	7f 4f       	sbci	r23, 0xFF	; 255
    654c:	8f 4f       	sbci	r24, 0xFF	; 255
    654e:	9f 4f       	sbci	r25, 0xFF	; 255
    6550:	16 c0       	rjmp	.+44     	; 0x657e <__floatsisf+0x6c>
    6552:	88 23       	and	r24, r24
    6554:	11 f0       	breq	.+4      	; 0x655a <__floatsisf+0x48>
    6556:	96 e9       	ldi	r25, 0x96	; 150
    6558:	11 c0       	rjmp	.+34     	; 0x657c <__floatsisf+0x6a>
    655a:	77 23       	and	r23, r23
    655c:	21 f0       	breq	.+8      	; 0x6566 <__floatsisf+0x54>
    655e:	9e e8       	ldi	r25, 0x8E	; 142
    6560:	87 2f       	mov	r24, r23
    6562:	76 2f       	mov	r23, r22
    6564:	05 c0       	rjmp	.+10     	; 0x6570 <__floatsisf+0x5e>
    6566:	66 23       	and	r22, r22
    6568:	71 f0       	breq	.+28     	; 0x6586 <__floatsisf+0x74>
    656a:	96 e8       	ldi	r25, 0x86	; 134
    656c:	86 2f       	mov	r24, r22
    656e:	70 e0       	ldi	r23, 0x00	; 0
    6570:	60 e0       	ldi	r22, 0x00	; 0
    6572:	2a f0       	brmi	.+10     	; 0x657e <__floatsisf+0x6c>
    6574:	9a 95       	dec	r25
    6576:	66 0f       	add	r22, r22
    6578:	77 1f       	adc	r23, r23
    657a:	88 1f       	adc	r24, r24
    657c:	da f7       	brpl	.-10     	; 0x6574 <__floatsisf+0x62>
    657e:	88 0f       	add	r24, r24
    6580:	96 95       	lsr	r25
    6582:	87 95       	ror	r24
    6584:	97 f9       	bld	r25, 7
    6586:	08 95       	ret

00006588 <__fp_cmp>:
    6588:	99 0f       	add	r25, r25
    658a:	00 08       	sbc	r0, r0
    658c:	55 0f       	add	r21, r21
    658e:	aa 0b       	sbc	r26, r26
    6590:	e0 e8       	ldi	r30, 0x80	; 128
    6592:	fe ef       	ldi	r31, 0xFE	; 254
    6594:	16 16       	cp	r1, r22
    6596:	17 06       	cpc	r1, r23
    6598:	e8 07       	cpc	r30, r24
    659a:	f9 07       	cpc	r31, r25
    659c:	c0 f0       	brcs	.+48     	; 0x65ce <__fp_cmp+0x46>
    659e:	12 16       	cp	r1, r18
    65a0:	13 06       	cpc	r1, r19
    65a2:	e4 07       	cpc	r30, r20
    65a4:	f5 07       	cpc	r31, r21
    65a6:	98 f0       	brcs	.+38     	; 0x65ce <__fp_cmp+0x46>
    65a8:	62 1b       	sub	r22, r18
    65aa:	73 0b       	sbc	r23, r19
    65ac:	84 0b       	sbc	r24, r20
    65ae:	95 0b       	sbc	r25, r21
    65b0:	39 f4       	brne	.+14     	; 0x65c0 <__fp_cmp+0x38>
    65b2:	0a 26       	eor	r0, r26
    65b4:	61 f0       	breq	.+24     	; 0x65ce <__fp_cmp+0x46>
    65b6:	23 2b       	or	r18, r19
    65b8:	24 2b       	or	r18, r20
    65ba:	25 2b       	or	r18, r21
    65bc:	21 f4       	brne	.+8      	; 0x65c6 <__fp_cmp+0x3e>
    65be:	08 95       	ret
    65c0:	0a 26       	eor	r0, r26
    65c2:	09 f4       	brne	.+2      	; 0x65c6 <__fp_cmp+0x3e>
    65c4:	a1 40       	sbci	r26, 0x01	; 1
    65c6:	a6 95       	lsr	r26
    65c8:	8f ef       	ldi	r24, 0xFF	; 255
    65ca:	81 1d       	adc	r24, r1
    65cc:	81 1d       	adc	r24, r1
    65ce:	08 95       	ret

000065d0 <__fp_inf>:
    65d0:	97 f9       	bld	r25, 7
    65d2:	9f 67       	ori	r25, 0x7F	; 127
    65d4:	80 e8       	ldi	r24, 0x80	; 128
    65d6:	70 e0       	ldi	r23, 0x00	; 0
    65d8:	60 e0       	ldi	r22, 0x00	; 0
    65da:	08 95       	ret

000065dc <__fp_nan>:
    65dc:	9f ef       	ldi	r25, 0xFF	; 255
    65de:	80 ec       	ldi	r24, 0xC0	; 192
    65e0:	08 95       	ret

000065e2 <__fp_powser>:
    65e2:	df 93       	push	r29
    65e4:	cf 93       	push	r28
    65e6:	1f 93       	push	r17
    65e8:	0f 93       	push	r16
    65ea:	ff 92       	push	r15
    65ec:	ef 92       	push	r14
    65ee:	df 92       	push	r13
    65f0:	7b 01       	movw	r14, r22
    65f2:	8c 01       	movw	r16, r24
    65f4:	68 94       	set
    65f6:	06 c0       	rjmp	.+12     	; 0x6604 <__fp_powser+0x22>
    65f8:	da 2e       	mov	r13, r26
    65fa:	ef 01       	movw	r28, r30
    65fc:	0e 94 80 33 	call	0x6700	; 0x6700 <__mulsf3x>
    6600:	fe 01       	movw	r30, r28
    6602:	e8 94       	clt
    6604:	a5 91       	lpm	r26, Z+
    6606:	25 91       	lpm	r18, Z+
    6608:	35 91       	lpm	r19, Z+
    660a:	45 91       	lpm	r20, Z+
    660c:	55 91       	lpm	r21, Z+
    660e:	a6 f3       	brts	.-24     	; 0x65f8 <__fp_powser+0x16>
    6610:	ef 01       	movw	r28, r30
    6612:	0e 94 5d 31 	call	0x62ba	; 0x62ba <__addsf3x>
    6616:	fe 01       	movw	r30, r28
    6618:	97 01       	movw	r18, r14
    661a:	a8 01       	movw	r20, r16
    661c:	da 94       	dec	r13
    661e:	69 f7       	brne	.-38     	; 0x65fa <__fp_powser+0x18>
    6620:	df 90       	pop	r13
    6622:	ef 90       	pop	r14
    6624:	ff 90       	pop	r15
    6626:	0f 91       	pop	r16
    6628:	1f 91       	pop	r17
    662a:	cf 91       	pop	r28
    662c:	df 91       	pop	r29
    662e:	08 95       	ret

00006630 <__fp_pscA>:
    6630:	00 24       	eor	r0, r0
    6632:	0a 94       	dec	r0
    6634:	16 16       	cp	r1, r22
    6636:	17 06       	cpc	r1, r23
    6638:	18 06       	cpc	r1, r24
    663a:	09 06       	cpc	r0, r25
    663c:	08 95       	ret

0000663e <__fp_pscB>:
    663e:	00 24       	eor	r0, r0
    6640:	0a 94       	dec	r0
    6642:	12 16       	cp	r1, r18
    6644:	13 06       	cpc	r1, r19
    6646:	14 06       	cpc	r1, r20
    6648:	05 06       	cpc	r0, r21
    664a:	08 95       	ret

0000664c <__fp_round>:
    664c:	09 2e       	mov	r0, r25
    664e:	03 94       	inc	r0
    6650:	00 0c       	add	r0, r0
    6652:	11 f4       	brne	.+4      	; 0x6658 <__fp_round+0xc>
    6654:	88 23       	and	r24, r24
    6656:	52 f0       	brmi	.+20     	; 0x666c <__fp_round+0x20>
    6658:	bb 0f       	add	r27, r27
    665a:	40 f4       	brcc	.+16     	; 0x666c <__fp_round+0x20>
    665c:	bf 2b       	or	r27, r31
    665e:	11 f4       	brne	.+4      	; 0x6664 <__fp_round+0x18>
    6660:	60 ff       	sbrs	r22, 0
    6662:	04 c0       	rjmp	.+8      	; 0x666c <__fp_round+0x20>
    6664:	6f 5f       	subi	r22, 0xFF	; 255
    6666:	7f 4f       	sbci	r23, 0xFF	; 255
    6668:	8f 4f       	sbci	r24, 0xFF	; 255
    666a:	9f 4f       	sbci	r25, 0xFF	; 255
    666c:	08 95       	ret

0000666e <__fp_split3>:
    666e:	57 fd       	sbrc	r21, 7
    6670:	90 58       	subi	r25, 0x80	; 128
    6672:	44 0f       	add	r20, r20
    6674:	55 1f       	adc	r21, r21
    6676:	59 f0       	breq	.+22     	; 0x668e <__fp_splitA+0x10>
    6678:	5f 3f       	cpi	r21, 0xFF	; 255
    667a:	71 f0       	breq	.+28     	; 0x6698 <__fp_splitA+0x1a>
    667c:	47 95       	ror	r20

0000667e <__fp_splitA>:
    667e:	88 0f       	add	r24, r24
    6680:	97 fb       	bst	r25, 7
    6682:	99 1f       	adc	r25, r25
    6684:	61 f0       	breq	.+24     	; 0x669e <__fp_splitA+0x20>
    6686:	9f 3f       	cpi	r25, 0xFF	; 255
    6688:	79 f0       	breq	.+30     	; 0x66a8 <__fp_splitA+0x2a>
    668a:	87 95       	ror	r24
    668c:	08 95       	ret
    668e:	12 16       	cp	r1, r18
    6690:	13 06       	cpc	r1, r19
    6692:	14 06       	cpc	r1, r20
    6694:	55 1f       	adc	r21, r21
    6696:	f2 cf       	rjmp	.-28     	; 0x667c <__fp_split3+0xe>
    6698:	46 95       	lsr	r20
    669a:	f1 df       	rcall	.-30     	; 0x667e <__fp_splitA>
    669c:	08 c0       	rjmp	.+16     	; 0x66ae <__fp_splitA+0x30>
    669e:	16 16       	cp	r1, r22
    66a0:	17 06       	cpc	r1, r23
    66a2:	18 06       	cpc	r1, r24
    66a4:	99 1f       	adc	r25, r25
    66a6:	f1 cf       	rjmp	.-30     	; 0x668a <__fp_splitA+0xc>
    66a8:	86 95       	lsr	r24
    66aa:	71 05       	cpc	r23, r1
    66ac:	61 05       	cpc	r22, r1
    66ae:	08 94       	sec
    66b0:	08 95       	ret

000066b2 <__fp_zero>:
    66b2:	e8 94       	clt

000066b4 <__fp_szero>:
    66b4:	bb 27       	eor	r27, r27
    66b6:	66 27       	eor	r22, r22
    66b8:	77 27       	eor	r23, r23
    66ba:	cb 01       	movw	r24, r22
    66bc:	97 f9       	bld	r25, 7
    66be:	08 95       	ret

000066c0 <__gesf2>:
    66c0:	0e 94 c4 32 	call	0x6588	; 0x6588 <__fp_cmp>
    66c4:	08 f4       	brcc	.+2      	; 0x66c8 <__gesf2+0x8>
    66c6:	8f ef       	ldi	r24, 0xFF	; 255
    66c8:	08 95       	ret

000066ca <inverse>:
    66ca:	9b 01       	movw	r18, r22
    66cc:	ac 01       	movw	r20, r24
    66ce:	60 e0       	ldi	r22, 0x00	; 0
    66d0:	70 e0       	ldi	r23, 0x00	; 0
    66d2:	80 e8       	ldi	r24, 0x80	; 128
    66d4:	9f e3       	ldi	r25, 0x3F	; 63
    66d6:	0c 94 e6 31 	jmp	0x63cc	; 0x63cc <__divsf3>

000066da <__mulsf3>:
    66da:	0e 94 80 33 	call	0x6700	; 0x6700 <__mulsf3x>
    66de:	0c 94 26 33 	jmp	0x664c	; 0x664c <__fp_round>
    66e2:	0e 94 18 33 	call	0x6630	; 0x6630 <__fp_pscA>
    66e6:	38 f0       	brcs	.+14     	; 0x66f6 <__mulsf3+0x1c>
    66e8:	0e 94 1f 33 	call	0x663e	; 0x663e <__fp_pscB>
    66ec:	20 f0       	brcs	.+8      	; 0x66f6 <__mulsf3+0x1c>
    66ee:	95 23       	and	r25, r21
    66f0:	11 f0       	breq	.+4      	; 0x66f6 <__mulsf3+0x1c>
    66f2:	0c 94 e8 32 	jmp	0x65d0	; 0x65d0 <__fp_inf>
    66f6:	0c 94 ee 32 	jmp	0x65dc	; 0x65dc <__fp_nan>
    66fa:	11 24       	eor	r1, r1
    66fc:	0c 94 5a 33 	jmp	0x66b4	; 0x66b4 <__fp_szero>

00006700 <__mulsf3x>:
    6700:	0e 94 37 33 	call	0x666e	; 0x666e <__fp_split3>
    6704:	70 f3       	brcs	.-36     	; 0x66e2 <__mulsf3+0x8>

00006706 <__mulsf3_pse>:
    6706:	95 9f       	mul	r25, r21
    6708:	c1 f3       	breq	.-16     	; 0x66fa <__mulsf3+0x20>
    670a:	95 0f       	add	r25, r21
    670c:	50 e0       	ldi	r21, 0x00	; 0
    670e:	55 1f       	adc	r21, r21
    6710:	62 9f       	mul	r22, r18
    6712:	f0 01       	movw	r30, r0
    6714:	72 9f       	mul	r23, r18
    6716:	bb 27       	eor	r27, r27
    6718:	f0 0d       	add	r31, r0
    671a:	b1 1d       	adc	r27, r1
    671c:	63 9f       	mul	r22, r19
    671e:	aa 27       	eor	r26, r26
    6720:	f0 0d       	add	r31, r0
    6722:	b1 1d       	adc	r27, r1
    6724:	aa 1f       	adc	r26, r26
    6726:	64 9f       	mul	r22, r20
    6728:	66 27       	eor	r22, r22
    672a:	b0 0d       	add	r27, r0
    672c:	a1 1d       	adc	r26, r1
    672e:	66 1f       	adc	r22, r22
    6730:	82 9f       	mul	r24, r18
    6732:	22 27       	eor	r18, r18
    6734:	b0 0d       	add	r27, r0
    6736:	a1 1d       	adc	r26, r1
    6738:	62 1f       	adc	r22, r18
    673a:	73 9f       	mul	r23, r19
    673c:	b0 0d       	add	r27, r0
    673e:	a1 1d       	adc	r26, r1
    6740:	62 1f       	adc	r22, r18
    6742:	83 9f       	mul	r24, r19
    6744:	a0 0d       	add	r26, r0
    6746:	61 1d       	adc	r22, r1
    6748:	22 1f       	adc	r18, r18
    674a:	74 9f       	mul	r23, r20
    674c:	33 27       	eor	r19, r19
    674e:	a0 0d       	add	r26, r0
    6750:	61 1d       	adc	r22, r1
    6752:	23 1f       	adc	r18, r19
    6754:	84 9f       	mul	r24, r20
    6756:	60 0d       	add	r22, r0
    6758:	21 1d       	adc	r18, r1
    675a:	82 2f       	mov	r24, r18
    675c:	76 2f       	mov	r23, r22
    675e:	6a 2f       	mov	r22, r26
    6760:	11 24       	eor	r1, r1
    6762:	9f 57       	subi	r25, 0x7F	; 127
    6764:	50 40       	sbci	r21, 0x00	; 0
    6766:	9a f0       	brmi	.+38     	; 0x678e <__mulsf3_pse+0x88>
    6768:	f1 f0       	breq	.+60     	; 0x67a6 <__mulsf3_pse+0xa0>
    676a:	88 23       	and	r24, r24
    676c:	4a f0       	brmi	.+18     	; 0x6780 <__mulsf3_pse+0x7a>
    676e:	ee 0f       	add	r30, r30
    6770:	ff 1f       	adc	r31, r31
    6772:	bb 1f       	adc	r27, r27
    6774:	66 1f       	adc	r22, r22
    6776:	77 1f       	adc	r23, r23
    6778:	88 1f       	adc	r24, r24
    677a:	91 50       	subi	r25, 0x01	; 1
    677c:	50 40       	sbci	r21, 0x00	; 0
    677e:	a9 f7       	brne	.-22     	; 0x676a <__mulsf3_pse+0x64>
    6780:	9e 3f       	cpi	r25, 0xFE	; 254
    6782:	51 05       	cpc	r21, r1
    6784:	80 f0       	brcs	.+32     	; 0x67a6 <__mulsf3_pse+0xa0>
    6786:	0c 94 e8 32 	jmp	0x65d0	; 0x65d0 <__fp_inf>
    678a:	0c 94 5a 33 	jmp	0x66b4	; 0x66b4 <__fp_szero>
    678e:	5f 3f       	cpi	r21, 0xFF	; 255
    6790:	e4 f3       	brlt	.-8      	; 0x678a <__mulsf3_pse+0x84>
    6792:	98 3e       	cpi	r25, 0xE8	; 232
    6794:	d4 f3       	brlt	.-12     	; 0x678a <__mulsf3_pse+0x84>
    6796:	86 95       	lsr	r24
    6798:	77 95       	ror	r23
    679a:	67 95       	ror	r22
    679c:	b7 95       	ror	r27
    679e:	f7 95       	ror	r31
    67a0:	e7 95       	ror	r30
    67a2:	9f 5f       	subi	r25, 0xFF	; 255
    67a4:	c1 f7       	brne	.-16     	; 0x6796 <__mulsf3_pse+0x90>
    67a6:	fe 2b       	or	r31, r30
    67a8:	88 0f       	add	r24, r24
    67aa:	91 1d       	adc	r25, r1
    67ac:	96 95       	lsr	r25
    67ae:	87 95       	ror	r24
    67b0:	97 f9       	bld	r25, 7
    67b2:	08 95       	ret

000067b4 <pow>:
    67b4:	fa 01       	movw	r30, r20
    67b6:	ee 0f       	add	r30, r30
    67b8:	ff 1f       	adc	r31, r31
    67ba:	30 96       	adiw	r30, 0x00	; 0
    67bc:	21 05       	cpc	r18, r1
    67be:	31 05       	cpc	r19, r1
    67c0:	a1 f1       	breq	.+104    	; 0x682a <pow+0x76>
    67c2:	61 15       	cp	r22, r1
    67c4:	71 05       	cpc	r23, r1
    67c6:	61 f4       	brne	.+24     	; 0x67e0 <pow+0x2c>
    67c8:	80 38       	cpi	r24, 0x80	; 128
    67ca:	bf e3       	ldi	r27, 0x3F	; 63
    67cc:	9b 07       	cpc	r25, r27
    67ce:	49 f1       	breq	.+82     	; 0x6822 <pow+0x6e>
    67d0:	68 94       	set
    67d2:	90 38       	cpi	r25, 0x80	; 128
    67d4:	81 05       	cpc	r24, r1
    67d6:	61 f0       	breq	.+24     	; 0x67f0 <pow+0x3c>
    67d8:	80 38       	cpi	r24, 0x80	; 128
    67da:	bf ef       	ldi	r27, 0xFF	; 255
    67dc:	9b 07       	cpc	r25, r27
    67de:	41 f0       	breq	.+16     	; 0x67f0 <pow+0x3c>
    67e0:	99 23       	and	r25, r25
    67e2:	4a f5       	brpl	.+82     	; 0x6836 <pow+0x82>
    67e4:	ff 3f       	cpi	r31, 0xFF	; 255
    67e6:	e1 05       	cpc	r30, r1
    67e8:	31 05       	cpc	r19, r1
    67ea:	21 05       	cpc	r18, r1
    67ec:	19 f1       	breq	.+70     	; 0x6834 <pow+0x80>
    67ee:	e8 94       	clt
    67f0:	08 94       	sec
    67f2:	e7 95       	ror	r30
    67f4:	d9 01       	movw	r26, r18
    67f6:	aa 23       	and	r26, r26
    67f8:	29 f4       	brne	.+10     	; 0x6804 <pow+0x50>
    67fa:	ab 2f       	mov	r26, r27
    67fc:	be 2f       	mov	r27, r30
    67fe:	f8 5f       	subi	r31, 0xF8	; 248
    6800:	d0 f3       	brcs	.-12     	; 0x67f6 <pow+0x42>
    6802:	10 c0       	rjmp	.+32     	; 0x6824 <pow+0x70>
    6804:	ff 5f       	subi	r31, 0xFF	; 255
    6806:	70 f4       	brcc	.+28     	; 0x6824 <pow+0x70>
    6808:	a6 95       	lsr	r26
    680a:	e0 f7       	brcc	.-8      	; 0x6804 <pow+0x50>
    680c:	f7 39       	cpi	r31, 0x97	; 151
    680e:	50 f0       	brcs	.+20     	; 0x6824 <pow+0x70>
    6810:	19 f0       	breq	.+6      	; 0x6818 <pow+0x64>
    6812:	ff 3a       	cpi	r31, 0xAF	; 175
    6814:	38 f4       	brcc	.+14     	; 0x6824 <pow+0x70>
    6816:	9f 77       	andi	r25, 0x7F	; 127
    6818:	9f 93       	push	r25
    681a:	0d d0       	rcall	.+26     	; 0x6836 <pow+0x82>
    681c:	0f 90       	pop	r0
    681e:	07 fc       	sbrc	r0, 7
    6820:	90 58       	subi	r25, 0x80	; 128
    6822:	08 95       	ret
    6824:	46 f0       	brts	.+16     	; 0x6836 <pow+0x82>
    6826:	0c 94 ee 32 	jmp	0x65dc	; 0x65dc <__fp_nan>
    682a:	60 e0       	ldi	r22, 0x00	; 0
    682c:	70 e0       	ldi	r23, 0x00	; 0
    682e:	80 e8       	ldi	r24, 0x80	; 128
    6830:	9f e3       	ldi	r25, 0x3F	; 63
    6832:	08 95       	ret
    6834:	4f e7       	ldi	r20, 0x7F	; 127
    6836:	9f 77       	andi	r25, 0x7F	; 127
    6838:	5f 93       	push	r21
    683a:	4f 93       	push	r20
    683c:	3f 93       	push	r19
    683e:	2f 93       	push	r18
    6840:	0e 94 05 35 	call	0x6a0a	; 0x6a0a <log>
    6844:	2f 91       	pop	r18
    6846:	3f 91       	pop	r19
    6848:	4f 91       	pop	r20
    684a:	5f 91       	pop	r21
    684c:	0e 94 6d 33 	call	0x66da	; 0x66da <__mulsf3>
    6850:	0c 94 7c 34 	jmp	0x68f8	; 0x68f8 <exp>
    6854:	19 f4       	brne	.+6      	; 0x685c <pow+0xa8>
    6856:	16 f4       	brtc	.+4      	; 0x685c <pow+0xa8>
    6858:	0c 94 ee 32 	jmp	0x65dc	; 0x65dc <__fp_nan>
    685c:	0c 94 ae 34 	jmp	0x695c	; 0x695c <__fp_mpack>

00006860 <sqrt>:
    6860:	0e 94 3f 33 	call	0x667e	; 0x667e <__fp_splitA>
    6864:	b8 f3       	brcs	.-18     	; 0x6854 <pow+0xa0>
    6866:	99 23       	and	r25, r25
    6868:	c9 f3       	breq	.-14     	; 0x685c <pow+0xa8>
    686a:	b6 f3       	brts	.-20     	; 0x6858 <pow+0xa4>
    686c:	9f 57       	subi	r25, 0x7F	; 127
    686e:	55 0b       	sbc	r21, r21
    6870:	87 ff       	sbrs	r24, 7
    6872:	0e 94 bc 34 	call	0x6978	; 0x6978 <__fp_norm2>
    6876:	00 24       	eor	r0, r0
    6878:	a0 e6       	ldi	r26, 0x60	; 96
    687a:	40 ea       	ldi	r20, 0xA0	; 160
    687c:	90 01       	movw	r18, r0
    687e:	80 58       	subi	r24, 0x80	; 128
    6880:	56 95       	lsr	r21
    6882:	97 95       	ror	r25
    6884:	28 f4       	brcc	.+10     	; 0x6890 <sqrt+0x30>
    6886:	80 5c       	subi	r24, 0xC0	; 192
    6888:	66 0f       	add	r22, r22
    688a:	77 1f       	adc	r23, r23
    688c:	88 1f       	adc	r24, r24
    688e:	20 f0       	brcs	.+8      	; 0x6898 <sqrt+0x38>
    6890:	26 17       	cp	r18, r22
    6892:	37 07       	cpc	r19, r23
    6894:	48 07       	cpc	r20, r24
    6896:	30 f4       	brcc	.+12     	; 0x68a4 <sqrt+0x44>
    6898:	62 1b       	sub	r22, r18
    689a:	73 0b       	sbc	r23, r19
    689c:	84 0b       	sbc	r24, r20
    689e:	20 29       	or	r18, r0
    68a0:	31 29       	or	r19, r1
    68a2:	4a 2b       	or	r20, r26
    68a4:	a6 95       	lsr	r26
    68a6:	17 94       	ror	r1
    68a8:	07 94       	ror	r0
    68aa:	20 25       	eor	r18, r0
    68ac:	31 25       	eor	r19, r1
    68ae:	4a 27       	eor	r20, r26
    68b0:	58 f7       	brcc	.-42     	; 0x6888 <sqrt+0x28>
    68b2:	66 0f       	add	r22, r22
    68b4:	77 1f       	adc	r23, r23
    68b6:	88 1f       	adc	r24, r24
    68b8:	20 f0       	brcs	.+8      	; 0x68c2 <sqrt+0x62>
    68ba:	26 17       	cp	r18, r22
    68bc:	37 07       	cpc	r19, r23
    68be:	48 07       	cpc	r20, r24
    68c0:	30 f4       	brcc	.+12     	; 0x68ce <sqrt+0x6e>
    68c2:	62 0b       	sbc	r22, r18
    68c4:	73 0b       	sbc	r23, r19
    68c6:	84 0b       	sbc	r24, r20
    68c8:	20 0d       	add	r18, r0
    68ca:	31 1d       	adc	r19, r1
    68cc:	41 1d       	adc	r20, r1
    68ce:	a0 95       	com	r26
    68d0:	81 f7       	brne	.-32     	; 0x68b2 <sqrt+0x52>
    68d2:	b9 01       	movw	r22, r18
    68d4:	84 2f       	mov	r24, r20
    68d6:	91 58       	subi	r25, 0x81	; 129
    68d8:	88 0f       	add	r24, r24
    68da:	96 95       	lsr	r25
    68dc:	87 95       	ror	r24
    68de:	08 95       	ret

000068e0 <square>:
    68e0:	9b 01       	movw	r18, r22
    68e2:	ac 01       	movw	r20, r24
    68e4:	0c 94 6d 33 	jmp	0x66da	; 0x66da <__mulsf3>
    68e8:	29 f4       	brne	.+10     	; 0x68f4 <square+0x14>
    68ea:	16 f0       	brts	.+4      	; 0x68f0 <square+0x10>
    68ec:	0c 94 e8 32 	jmp	0x65d0	; 0x65d0 <__fp_inf>
    68f0:	0c 94 59 33 	jmp	0x66b2	; 0x66b2 <__fp_zero>
    68f4:	0c 94 ee 32 	jmp	0x65dc	; 0x65dc <__fp_nan>

000068f8 <exp>:
    68f8:	0e 94 3f 33 	call	0x667e	; 0x667e <__fp_splitA>
    68fc:	a8 f3       	brcs	.-22     	; 0x68e8 <square+0x8>
    68fe:	96 38       	cpi	r25, 0x86	; 134
    6900:	a0 f7       	brcc	.-24     	; 0x68ea <square+0xa>
    6902:	07 f8       	bld	r0, 7
    6904:	0f 92       	push	r0
    6906:	e8 94       	clt
    6908:	2b e3       	ldi	r18, 0x3B	; 59
    690a:	3a ea       	ldi	r19, 0xAA	; 170
    690c:	48 eb       	ldi	r20, 0xB8	; 184
    690e:	5f e7       	ldi	r21, 0x7F	; 127
    6910:	0e 94 83 33 	call	0x6706	; 0x6706 <__mulsf3_pse>
    6914:	0f 92       	push	r0
    6916:	0f 92       	push	r0
    6918:	0f 92       	push	r0
    691a:	4d b7       	in	r20, 0x3d	; 61
    691c:	5e b7       	in	r21, 0x3e	; 62
    691e:	0f 92       	push	r0
    6920:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <modf>
    6924:	e1 e1       	ldi	r30, 0x11	; 17
    6926:	f1 e0       	ldi	r31, 0x01	; 1
    6928:	0e 94 f1 32 	call	0x65e2	; 0x65e2 <__fp_powser>
    692c:	4f 91       	pop	r20
    692e:	5f 91       	pop	r21
    6930:	ef 91       	pop	r30
    6932:	ff 91       	pop	r31
    6934:	e5 95       	asr	r30
    6936:	ee 1f       	adc	r30, r30
    6938:	ff 1f       	adc	r31, r31
    693a:	49 f0       	breq	.+18     	; 0x694e <exp+0x56>
    693c:	fe 57       	subi	r31, 0x7E	; 126
    693e:	e0 68       	ori	r30, 0x80	; 128
    6940:	44 27       	eor	r20, r20
    6942:	ee 0f       	add	r30, r30
    6944:	44 1f       	adc	r20, r20
    6946:	fa 95       	dec	r31
    6948:	e1 f7       	brne	.-8      	; 0x6942 <exp+0x4a>
    694a:	41 95       	neg	r20
    694c:	55 0b       	sbc	r21, r21
    694e:	0e 94 c7 34 	call	0x698e	; 0x698e <ldexp>
    6952:	0f 90       	pop	r0
    6954:	07 fe       	sbrs	r0, 7
    6956:	0c 94 65 33 	jmp	0x66ca	; 0x66ca <inverse>
    695a:	08 95       	ret

0000695c <__fp_mpack>:
    695c:	9f 3f       	cpi	r25, 0xFF	; 255
    695e:	31 f0       	breq	.+12     	; 0x696c <__fp_mpack_finite+0xc>

00006960 <__fp_mpack_finite>:
    6960:	91 50       	subi	r25, 0x01	; 1
    6962:	20 f4       	brcc	.+8      	; 0x696c <__fp_mpack_finite+0xc>
    6964:	87 95       	ror	r24
    6966:	77 95       	ror	r23
    6968:	67 95       	ror	r22
    696a:	b7 95       	ror	r27
    696c:	88 0f       	add	r24, r24
    696e:	91 1d       	adc	r25, r1
    6970:	96 95       	lsr	r25
    6972:	87 95       	ror	r24
    6974:	97 f9       	bld	r25, 7
    6976:	08 95       	ret

00006978 <__fp_norm2>:
    6978:	91 50       	subi	r25, 0x01	; 1
    697a:	50 40       	sbci	r21, 0x00	; 0
    697c:	66 0f       	add	r22, r22
    697e:	77 1f       	adc	r23, r23
    6980:	88 1f       	adc	r24, r24
    6982:	d2 f7       	brpl	.-12     	; 0x6978 <__fp_norm2>
    6984:	08 95       	ret
    6986:	0c 94 e8 32 	jmp	0x65d0	; 0x65d0 <__fp_inf>
    698a:	0c 94 ae 34 	jmp	0x695c	; 0x695c <__fp_mpack>

0000698e <ldexp>:
    698e:	0e 94 3f 33 	call	0x667e	; 0x667e <__fp_splitA>
    6992:	d8 f3       	brcs	.-10     	; 0x698a <__fp_norm2+0x12>
    6994:	99 23       	and	r25, r25
    6996:	c9 f3       	breq	.-14     	; 0x698a <__fp_norm2+0x12>
    6998:	94 0f       	add	r25, r20
    699a:	51 1d       	adc	r21, r1
    699c:	a3 f3       	brvs	.-24     	; 0x6986 <__fp_norm2+0xe>
    699e:	91 50       	subi	r25, 0x01	; 1
    69a0:	50 40       	sbci	r21, 0x00	; 0
    69a2:	94 f0       	brlt	.+36     	; 0x69c8 <ldexp+0x3a>
    69a4:	59 f0       	breq	.+22     	; 0x69bc <ldexp+0x2e>
    69a6:	88 23       	and	r24, r24
    69a8:	32 f0       	brmi	.+12     	; 0x69b6 <ldexp+0x28>
    69aa:	66 0f       	add	r22, r22
    69ac:	77 1f       	adc	r23, r23
    69ae:	88 1f       	adc	r24, r24
    69b0:	91 50       	subi	r25, 0x01	; 1
    69b2:	50 40       	sbci	r21, 0x00	; 0
    69b4:	c1 f7       	brne	.-16     	; 0x69a6 <ldexp+0x18>
    69b6:	9e 3f       	cpi	r25, 0xFE	; 254
    69b8:	51 05       	cpc	r21, r1
    69ba:	2c f7       	brge	.-54     	; 0x6986 <__fp_norm2+0xe>
    69bc:	88 0f       	add	r24, r24
    69be:	91 1d       	adc	r25, r1
    69c0:	96 95       	lsr	r25
    69c2:	87 95       	ror	r24
    69c4:	97 f9       	bld	r25, 7
    69c6:	08 95       	ret
    69c8:	5f 3f       	cpi	r21, 0xFF	; 255
    69ca:	ac f0       	brlt	.+42     	; 0x69f6 <ldexp+0x68>
    69cc:	98 3e       	cpi	r25, 0xE8	; 232
    69ce:	9c f0       	brlt	.+38     	; 0x69f6 <ldexp+0x68>
    69d0:	bb 27       	eor	r27, r27
    69d2:	86 95       	lsr	r24
    69d4:	77 95       	ror	r23
    69d6:	67 95       	ror	r22
    69d8:	b7 95       	ror	r27
    69da:	08 f4       	brcc	.+2      	; 0x69de <ldexp+0x50>
    69dc:	b1 60       	ori	r27, 0x01	; 1
    69de:	93 95       	inc	r25
    69e0:	c1 f7       	brne	.-16     	; 0x69d2 <ldexp+0x44>
    69e2:	bb 0f       	add	r27, r27
    69e4:	58 f7       	brcc	.-42     	; 0x69bc <ldexp+0x2e>
    69e6:	11 f4       	brne	.+4      	; 0x69ec <ldexp+0x5e>
    69e8:	60 ff       	sbrs	r22, 0
    69ea:	e8 cf       	rjmp	.-48     	; 0x69bc <ldexp+0x2e>
    69ec:	6f 5f       	subi	r22, 0xFF	; 255
    69ee:	7f 4f       	sbci	r23, 0xFF	; 255
    69f0:	8f 4f       	sbci	r24, 0xFF	; 255
    69f2:	9f 4f       	sbci	r25, 0xFF	; 255
    69f4:	e3 cf       	rjmp	.-58     	; 0x69bc <ldexp+0x2e>
    69f6:	0c 94 5a 33 	jmp	0x66b4	; 0x66b4 <__fp_szero>
    69fa:	16 f0       	brts	.+4      	; 0x6a00 <ldexp+0x72>
    69fc:	0c 94 ae 34 	jmp	0x695c	; 0x695c <__fp_mpack>
    6a00:	0c 94 ee 32 	jmp	0x65dc	; 0x65dc <__fp_nan>
    6a04:	68 94       	set
    6a06:	0c 94 e8 32 	jmp	0x65d0	; 0x65d0 <__fp_inf>

00006a0a <log>:
    6a0a:	0e 94 3f 33 	call	0x667e	; 0x667e <__fp_splitA>
    6a0e:	a8 f3       	brcs	.-22     	; 0x69fa <ldexp+0x6c>
    6a10:	99 23       	and	r25, r25
    6a12:	c1 f3       	breq	.-16     	; 0x6a04 <ldexp+0x76>
    6a14:	ae f3       	brts	.-22     	; 0x6a00 <ldexp+0x72>
    6a16:	df 93       	push	r29
    6a18:	cf 93       	push	r28
    6a1a:	1f 93       	push	r17
    6a1c:	0f 93       	push	r16
    6a1e:	ff 92       	push	r15
    6a20:	c9 2f       	mov	r28, r25
    6a22:	dd 27       	eor	r29, r29
    6a24:	88 23       	and	r24, r24
    6a26:	2a f0       	brmi	.+10     	; 0x6a32 <log+0x28>
    6a28:	21 97       	sbiw	r28, 0x01	; 1
    6a2a:	66 0f       	add	r22, r22
    6a2c:	77 1f       	adc	r23, r23
    6a2e:	88 1f       	adc	r24, r24
    6a30:	da f7       	brpl	.-10     	; 0x6a28 <log+0x1e>
    6a32:	20 e0       	ldi	r18, 0x00	; 0
    6a34:	30 e0       	ldi	r19, 0x00	; 0
    6a36:	40 e8       	ldi	r20, 0x80	; 128
    6a38:	5f eb       	ldi	r21, 0xBF	; 191
    6a3a:	9f e3       	ldi	r25, 0x3F	; 63
    6a3c:	88 39       	cpi	r24, 0x98	; 152
    6a3e:	20 f0       	brcs	.+8      	; 0x6a48 <log+0x3e>
    6a40:	80 3e       	cpi	r24, 0xE0	; 224
    6a42:	38 f0       	brcs	.+14     	; 0x6a52 <log+0x48>
    6a44:	21 96       	adiw	r28, 0x01	; 1
    6a46:	8f 77       	andi	r24, 0x7F	; 127
    6a48:	0e 94 46 31 	call	0x628c	; 0x628c <__addsf3>
    6a4c:	e9 e3       	ldi	r30, 0x39	; 57
    6a4e:	f1 e0       	ldi	r31, 0x01	; 1
    6a50:	04 c0       	rjmp	.+8      	; 0x6a5a <log+0x50>
    6a52:	0e 94 46 31 	call	0x628c	; 0x628c <__addsf3>
    6a56:	e6 e6       	ldi	r30, 0x66	; 102
    6a58:	f1 e0       	ldi	r31, 0x01	; 1
    6a5a:	0e 94 f1 32 	call	0x65e2	; 0x65e2 <__fp_powser>
    6a5e:	8b 01       	movw	r16, r22
    6a60:	be 01       	movw	r22, r28
    6a62:	ec 01       	movw	r28, r24
    6a64:	fb 2e       	mov	r15, r27
    6a66:	6f 57       	subi	r22, 0x7F	; 127
    6a68:	71 09       	sbc	r23, r1
    6a6a:	75 95       	asr	r23
    6a6c:	77 1f       	adc	r23, r23
    6a6e:	88 0b       	sbc	r24, r24
    6a70:	99 0b       	sbc	r25, r25
    6a72:	0e 94 89 32 	call	0x6512	; 0x6512 <__floatsisf>
    6a76:	28 e1       	ldi	r18, 0x18	; 24
    6a78:	32 e7       	ldi	r19, 0x72	; 114
    6a7a:	41 e3       	ldi	r20, 0x31	; 49
    6a7c:	5f e3       	ldi	r21, 0x3F	; 63
    6a7e:	0e 94 80 33 	call	0x6700	; 0x6700 <__mulsf3x>
    6a82:	af 2d       	mov	r26, r15
    6a84:	98 01       	movw	r18, r16
    6a86:	ae 01       	movw	r20, r28
    6a88:	ff 90       	pop	r15
    6a8a:	0f 91       	pop	r16
    6a8c:	1f 91       	pop	r17
    6a8e:	cf 91       	pop	r28
    6a90:	df 91       	pop	r29
    6a92:	0e 94 5d 31 	call	0x62ba	; 0x62ba <__addsf3x>
    6a96:	0c 94 26 33 	jmp	0x664c	; 0x664c <__fp_round>

00006a9a <modf>:
    6a9a:	fa 01       	movw	r30, r20
    6a9c:	dc 01       	movw	r26, r24
    6a9e:	aa 0f       	add	r26, r26
    6aa0:	bb 1f       	adc	r27, r27
    6aa2:	9b 01       	movw	r18, r22
    6aa4:	ac 01       	movw	r20, r24
    6aa6:	bf 57       	subi	r27, 0x7F	; 127
    6aa8:	28 f4       	brcc	.+10     	; 0x6ab4 <modf+0x1a>
    6aaa:	22 27       	eor	r18, r18
    6aac:	33 27       	eor	r19, r19
    6aae:	44 27       	eor	r20, r20
    6ab0:	50 78       	andi	r21, 0x80	; 128
    6ab2:	20 c0       	rjmp	.+64     	; 0x6af4 <modf+0x5a>
    6ab4:	b7 51       	subi	r27, 0x17	; 23
    6ab6:	90 f4       	brcc	.+36     	; 0x6adc <modf+0x42>
    6ab8:	ab 2f       	mov	r26, r27
    6aba:	00 24       	eor	r0, r0
    6abc:	46 95       	lsr	r20
    6abe:	37 95       	ror	r19
    6ac0:	27 95       	ror	r18
    6ac2:	01 1c       	adc	r0, r1
    6ac4:	a3 95       	inc	r26
    6ac6:	d2 f3       	brmi	.-12     	; 0x6abc <modf+0x22>
    6ac8:	00 20       	and	r0, r0
    6aca:	71 f0       	breq	.+28     	; 0x6ae8 <modf+0x4e>
    6acc:	22 0f       	add	r18, r18
    6ace:	33 1f       	adc	r19, r19
    6ad0:	44 1f       	adc	r20, r20
    6ad2:	b3 95       	inc	r27
    6ad4:	da f3       	brmi	.-10     	; 0x6acc <modf+0x32>
    6ad6:	0e d0       	rcall	.+28     	; 0x6af4 <modf+0x5a>
    6ad8:	0c 94 45 31 	jmp	0x628a	; 0x628a <__subsf3>
    6adc:	61 30       	cpi	r22, 0x01	; 1
    6ade:	71 05       	cpc	r23, r1
    6ae0:	a0 e8       	ldi	r26, 0x80	; 128
    6ae2:	8a 07       	cpc	r24, r26
    6ae4:	b9 46       	sbci	r27, 0x69	; 105
    6ae6:	30 f4       	brcc	.+12     	; 0x6af4 <modf+0x5a>
    6ae8:	9b 01       	movw	r18, r22
    6aea:	ac 01       	movw	r20, r24
    6aec:	66 27       	eor	r22, r22
    6aee:	77 27       	eor	r23, r23
    6af0:	88 27       	eor	r24, r24
    6af2:	90 78       	andi	r25, 0x80	; 128
    6af4:	30 96       	adiw	r30, 0x00	; 0
    6af6:	21 f0       	breq	.+8      	; 0x6b00 <modf+0x66>
    6af8:	20 83       	st	Z, r18
    6afa:	31 83       	std	Z+1, r19	; 0x01
    6afc:	42 83       	std	Z+2, r20	; 0x02
    6afe:	53 83       	std	Z+3, r21	; 0x03
    6b00:	08 95       	ret

00006b02 <dtostrf>:
    6b02:	ef 92       	push	r14
    6b04:	0f 93       	push	r16
    6b06:	1f 93       	push	r17
    6b08:	cf 93       	push	r28
    6b0a:	df 93       	push	r29
    6b0c:	e8 01       	movw	r28, r16
    6b0e:	47 fd       	sbrc	r20, 7
    6b10:	02 c0       	rjmp	.+4      	; 0x6b16 <dtostrf+0x14>
    6b12:	34 e0       	ldi	r19, 0x04	; 4
    6b14:	01 c0       	rjmp	.+2      	; 0x6b18 <dtostrf+0x16>
    6b16:	34 e1       	ldi	r19, 0x14	; 20
    6b18:	e4 2f       	mov	r30, r20
    6b1a:	44 0f       	add	r20, r20
    6b1c:	ff 0b       	sbc	r31, r31
    6b1e:	f7 ff       	sbrs	r31, 7
    6b20:	03 c0       	rjmp	.+6      	; 0x6b28 <dtostrf+0x26>
    6b22:	f1 95       	neg	r31
    6b24:	e1 95       	neg	r30
    6b26:	f1 09       	sbc	r31, r1
    6b28:	e3 2e       	mov	r14, r19
    6b2a:	02 2f       	mov	r16, r18
    6b2c:	2e 2f       	mov	r18, r30
    6b2e:	ae 01       	movw	r20, r28
    6b30:	0e 94 74 37 	call	0x6ee8	; 0x6ee8 <dtoa_prf>
    6b34:	ce 01       	movw	r24, r28
    6b36:	df 91       	pop	r29
    6b38:	cf 91       	pop	r28
    6b3a:	1f 91       	pop	r17
    6b3c:	0f 91       	pop	r16
    6b3e:	ef 90       	pop	r14
    6b40:	08 95       	ret

00006b42 <malloc>:
    6b42:	cf 93       	push	r28
    6b44:	df 93       	push	r29
    6b46:	82 30       	cpi	r24, 0x02	; 2
    6b48:	91 05       	cpc	r25, r1
    6b4a:	10 f4       	brcc	.+4      	; 0x6b50 <malloc+0xe>
    6b4c:	82 e0       	ldi	r24, 0x02	; 2
    6b4e:	90 e0       	ldi	r25, 0x00	; 0
    6b50:	e0 91 b7 02 	lds	r30, 0x02B7
    6b54:	f0 91 b8 02 	lds	r31, 0x02B8
    6b58:	20 e0       	ldi	r18, 0x00	; 0
    6b5a:	30 e0       	ldi	r19, 0x00	; 0
    6b5c:	c0 e0       	ldi	r28, 0x00	; 0
    6b5e:	d0 e0       	ldi	r29, 0x00	; 0
    6b60:	30 97       	sbiw	r30, 0x00	; 0
    6b62:	11 f1       	breq	.+68     	; 0x6ba8 <malloc+0x66>
    6b64:	40 81       	ld	r20, Z
    6b66:	51 81       	ldd	r21, Z+1	; 0x01
    6b68:	48 17       	cp	r20, r24
    6b6a:	59 07       	cpc	r21, r25
    6b6c:	c0 f0       	brcs	.+48     	; 0x6b9e <malloc+0x5c>
    6b6e:	48 17       	cp	r20, r24
    6b70:	59 07       	cpc	r21, r25
    6b72:	61 f4       	brne	.+24     	; 0x6b8c <malloc+0x4a>
    6b74:	82 81       	ldd	r24, Z+2	; 0x02
    6b76:	93 81       	ldd	r25, Z+3	; 0x03
    6b78:	20 97       	sbiw	r28, 0x00	; 0
    6b7a:	19 f0       	breq	.+6      	; 0x6b82 <malloc+0x40>
    6b7c:	9b 83       	std	Y+3, r25	; 0x03
    6b7e:	8a 83       	std	Y+2, r24	; 0x02
    6b80:	2b c0       	rjmp	.+86     	; 0x6bd8 <malloc+0x96>
    6b82:	90 93 b8 02 	sts	0x02B8, r25
    6b86:	80 93 b7 02 	sts	0x02B7, r24
    6b8a:	26 c0       	rjmp	.+76     	; 0x6bd8 <malloc+0x96>
    6b8c:	21 15       	cp	r18, r1
    6b8e:	31 05       	cpc	r19, r1
    6b90:	19 f0       	breq	.+6      	; 0x6b98 <malloc+0x56>
    6b92:	42 17       	cp	r20, r18
    6b94:	53 07       	cpc	r21, r19
    6b96:	18 f4       	brcc	.+6      	; 0x6b9e <malloc+0x5c>
    6b98:	9a 01       	movw	r18, r20
    6b9a:	be 01       	movw	r22, r28
    6b9c:	df 01       	movw	r26, r30
    6b9e:	ef 01       	movw	r28, r30
    6ba0:	02 80       	ldd	r0, Z+2	; 0x02
    6ba2:	f3 81       	ldd	r31, Z+3	; 0x03
    6ba4:	e0 2d       	mov	r30, r0
    6ba6:	dc cf       	rjmp	.-72     	; 0x6b60 <malloc+0x1e>
    6ba8:	21 15       	cp	r18, r1
    6baa:	31 05       	cpc	r19, r1
    6bac:	09 f1       	breq	.+66     	; 0x6bf0 <malloc+0xae>
    6bae:	28 1b       	sub	r18, r24
    6bb0:	39 0b       	sbc	r19, r25
    6bb2:	24 30       	cpi	r18, 0x04	; 4
    6bb4:	31 05       	cpc	r19, r1
    6bb6:	90 f4       	brcc	.+36     	; 0x6bdc <malloc+0x9a>
    6bb8:	12 96       	adiw	r26, 0x02	; 2
    6bba:	8d 91       	ld	r24, X+
    6bbc:	9c 91       	ld	r25, X
    6bbe:	13 97       	sbiw	r26, 0x03	; 3
    6bc0:	61 15       	cp	r22, r1
    6bc2:	71 05       	cpc	r23, r1
    6bc4:	21 f0       	breq	.+8      	; 0x6bce <malloc+0x8c>
    6bc6:	fb 01       	movw	r30, r22
    6bc8:	93 83       	std	Z+3, r25	; 0x03
    6bca:	82 83       	std	Z+2, r24	; 0x02
    6bcc:	04 c0       	rjmp	.+8      	; 0x6bd6 <malloc+0x94>
    6bce:	90 93 b8 02 	sts	0x02B8, r25
    6bd2:	80 93 b7 02 	sts	0x02B7, r24
    6bd6:	fd 01       	movw	r30, r26
    6bd8:	32 96       	adiw	r30, 0x02	; 2
    6bda:	44 c0       	rjmp	.+136    	; 0x6c64 <malloc+0x122>
    6bdc:	fd 01       	movw	r30, r26
    6bde:	e2 0f       	add	r30, r18
    6be0:	f3 1f       	adc	r31, r19
    6be2:	81 93       	st	Z+, r24
    6be4:	91 93       	st	Z+, r25
    6be6:	22 50       	subi	r18, 0x02	; 2
    6be8:	31 09       	sbc	r19, r1
    6bea:	2d 93       	st	X+, r18
    6bec:	3c 93       	st	X, r19
    6bee:	3a c0       	rjmp	.+116    	; 0x6c64 <malloc+0x122>
    6bf0:	20 91 b5 02 	lds	r18, 0x02B5
    6bf4:	30 91 b6 02 	lds	r19, 0x02B6
    6bf8:	23 2b       	or	r18, r19
    6bfa:	41 f4       	brne	.+16     	; 0x6c0c <malloc+0xca>
    6bfc:	20 91 02 02 	lds	r18, 0x0202
    6c00:	30 91 03 02 	lds	r19, 0x0203
    6c04:	30 93 b6 02 	sts	0x02B6, r19
    6c08:	20 93 b5 02 	sts	0x02B5, r18
    6c0c:	20 91 00 02 	lds	r18, 0x0200
    6c10:	30 91 01 02 	lds	r19, 0x0201
    6c14:	21 15       	cp	r18, r1
    6c16:	31 05       	cpc	r19, r1
    6c18:	41 f4       	brne	.+16     	; 0x6c2a <malloc+0xe8>
    6c1a:	2d b7       	in	r18, 0x3d	; 61
    6c1c:	3e b7       	in	r19, 0x3e	; 62
    6c1e:	40 91 04 02 	lds	r20, 0x0204
    6c22:	50 91 05 02 	lds	r21, 0x0205
    6c26:	24 1b       	sub	r18, r20
    6c28:	35 0b       	sbc	r19, r21
    6c2a:	e0 91 b5 02 	lds	r30, 0x02B5
    6c2e:	f0 91 b6 02 	lds	r31, 0x02B6
    6c32:	e2 17       	cp	r30, r18
    6c34:	f3 07       	cpc	r31, r19
    6c36:	a0 f4       	brcc	.+40     	; 0x6c60 <malloc+0x11e>
    6c38:	2e 1b       	sub	r18, r30
    6c3a:	3f 0b       	sbc	r19, r31
    6c3c:	28 17       	cp	r18, r24
    6c3e:	39 07       	cpc	r19, r25
    6c40:	78 f0       	brcs	.+30     	; 0x6c60 <malloc+0x11e>
    6c42:	ac 01       	movw	r20, r24
    6c44:	4e 5f       	subi	r20, 0xFE	; 254
    6c46:	5f 4f       	sbci	r21, 0xFF	; 255
    6c48:	24 17       	cp	r18, r20
    6c4a:	35 07       	cpc	r19, r21
    6c4c:	48 f0       	brcs	.+18     	; 0x6c60 <malloc+0x11e>
    6c4e:	4e 0f       	add	r20, r30
    6c50:	5f 1f       	adc	r21, r31
    6c52:	50 93 b6 02 	sts	0x02B6, r21
    6c56:	40 93 b5 02 	sts	0x02B5, r20
    6c5a:	81 93       	st	Z+, r24
    6c5c:	91 93       	st	Z+, r25
    6c5e:	02 c0       	rjmp	.+4      	; 0x6c64 <malloc+0x122>
    6c60:	e0 e0       	ldi	r30, 0x00	; 0
    6c62:	f0 e0       	ldi	r31, 0x00	; 0
    6c64:	cf 01       	movw	r24, r30
    6c66:	df 91       	pop	r29
    6c68:	cf 91       	pop	r28
    6c6a:	08 95       	ret

00006c6c <free>:
    6c6c:	0f 93       	push	r16
    6c6e:	1f 93       	push	r17
    6c70:	cf 93       	push	r28
    6c72:	df 93       	push	r29
    6c74:	00 97       	sbiw	r24, 0x00	; 0
    6c76:	09 f4       	brne	.+2      	; 0x6c7a <free+0xe>
    6c78:	8c c0       	rjmp	.+280    	; 0x6d92 <free+0x126>
    6c7a:	fc 01       	movw	r30, r24
    6c7c:	32 97       	sbiw	r30, 0x02	; 2
    6c7e:	13 82       	std	Z+3, r1	; 0x03
    6c80:	12 82       	std	Z+2, r1	; 0x02
    6c82:	00 91 b7 02 	lds	r16, 0x02B7
    6c86:	10 91 b8 02 	lds	r17, 0x02B8
    6c8a:	01 15       	cp	r16, r1
    6c8c:	11 05       	cpc	r17, r1
    6c8e:	81 f4       	brne	.+32     	; 0x6cb0 <free+0x44>
    6c90:	20 81       	ld	r18, Z
    6c92:	31 81       	ldd	r19, Z+1	; 0x01
    6c94:	82 0f       	add	r24, r18
    6c96:	93 1f       	adc	r25, r19
    6c98:	20 91 b5 02 	lds	r18, 0x02B5
    6c9c:	30 91 b6 02 	lds	r19, 0x02B6
    6ca0:	28 17       	cp	r18, r24
    6ca2:	39 07       	cpc	r19, r25
    6ca4:	79 f5       	brne	.+94     	; 0x6d04 <free+0x98>
    6ca6:	f0 93 b6 02 	sts	0x02B6, r31
    6caa:	e0 93 b5 02 	sts	0x02B5, r30
    6cae:	71 c0       	rjmp	.+226    	; 0x6d92 <free+0x126>
    6cb0:	d8 01       	movw	r26, r16
    6cb2:	40 e0       	ldi	r20, 0x00	; 0
    6cb4:	50 e0       	ldi	r21, 0x00	; 0
    6cb6:	ae 17       	cp	r26, r30
    6cb8:	bf 07       	cpc	r27, r31
    6cba:	50 f4       	brcc	.+20     	; 0x6cd0 <free+0x64>
    6cbc:	12 96       	adiw	r26, 0x02	; 2
    6cbe:	2d 91       	ld	r18, X+
    6cc0:	3c 91       	ld	r19, X
    6cc2:	13 97       	sbiw	r26, 0x03	; 3
    6cc4:	ad 01       	movw	r20, r26
    6cc6:	21 15       	cp	r18, r1
    6cc8:	31 05       	cpc	r19, r1
    6cca:	09 f1       	breq	.+66     	; 0x6d0e <free+0xa2>
    6ccc:	d9 01       	movw	r26, r18
    6cce:	f3 cf       	rjmp	.-26     	; 0x6cb6 <free+0x4a>
    6cd0:	9d 01       	movw	r18, r26
    6cd2:	da 01       	movw	r26, r20
    6cd4:	33 83       	std	Z+3, r19	; 0x03
    6cd6:	22 83       	std	Z+2, r18	; 0x02
    6cd8:	60 81       	ld	r22, Z
    6cda:	71 81       	ldd	r23, Z+1	; 0x01
    6cdc:	86 0f       	add	r24, r22
    6cde:	97 1f       	adc	r25, r23
    6ce0:	82 17       	cp	r24, r18
    6ce2:	93 07       	cpc	r25, r19
    6ce4:	69 f4       	brne	.+26     	; 0x6d00 <free+0x94>
    6ce6:	ec 01       	movw	r28, r24
    6ce8:	28 81       	ld	r18, Y
    6cea:	39 81       	ldd	r19, Y+1	; 0x01
    6cec:	26 0f       	add	r18, r22
    6cee:	37 1f       	adc	r19, r23
    6cf0:	2e 5f       	subi	r18, 0xFE	; 254
    6cf2:	3f 4f       	sbci	r19, 0xFF	; 255
    6cf4:	31 83       	std	Z+1, r19	; 0x01
    6cf6:	20 83       	st	Z, r18
    6cf8:	8a 81       	ldd	r24, Y+2	; 0x02
    6cfa:	9b 81       	ldd	r25, Y+3	; 0x03
    6cfc:	93 83       	std	Z+3, r25	; 0x03
    6cfe:	82 83       	std	Z+2, r24	; 0x02
    6d00:	45 2b       	or	r20, r21
    6d02:	29 f4       	brne	.+10     	; 0x6d0e <free+0xa2>
    6d04:	f0 93 b8 02 	sts	0x02B8, r31
    6d08:	e0 93 b7 02 	sts	0x02B7, r30
    6d0c:	42 c0       	rjmp	.+132    	; 0x6d92 <free+0x126>
    6d0e:	13 96       	adiw	r26, 0x03	; 3
    6d10:	fc 93       	st	X, r31
    6d12:	ee 93       	st	-X, r30
    6d14:	12 97       	sbiw	r26, 0x02	; 2
    6d16:	ed 01       	movw	r28, r26
    6d18:	49 91       	ld	r20, Y+
    6d1a:	59 91       	ld	r21, Y+
    6d1c:	9e 01       	movw	r18, r28
    6d1e:	24 0f       	add	r18, r20
    6d20:	35 1f       	adc	r19, r21
    6d22:	e2 17       	cp	r30, r18
    6d24:	f3 07       	cpc	r31, r19
    6d26:	71 f4       	brne	.+28     	; 0x6d44 <free+0xd8>
    6d28:	80 81       	ld	r24, Z
    6d2a:	91 81       	ldd	r25, Z+1	; 0x01
    6d2c:	84 0f       	add	r24, r20
    6d2e:	95 1f       	adc	r25, r21
    6d30:	02 96       	adiw	r24, 0x02	; 2
    6d32:	11 96       	adiw	r26, 0x01	; 1
    6d34:	9c 93       	st	X, r25
    6d36:	8e 93       	st	-X, r24
    6d38:	82 81       	ldd	r24, Z+2	; 0x02
    6d3a:	93 81       	ldd	r25, Z+3	; 0x03
    6d3c:	13 96       	adiw	r26, 0x03	; 3
    6d3e:	9c 93       	st	X, r25
    6d40:	8e 93       	st	-X, r24
    6d42:	12 97       	sbiw	r26, 0x02	; 2
    6d44:	e0 e0       	ldi	r30, 0x00	; 0
    6d46:	f0 e0       	ldi	r31, 0x00	; 0
    6d48:	d8 01       	movw	r26, r16
    6d4a:	12 96       	adiw	r26, 0x02	; 2
    6d4c:	8d 91       	ld	r24, X+
    6d4e:	9c 91       	ld	r25, X
    6d50:	13 97       	sbiw	r26, 0x03	; 3
    6d52:	00 97       	sbiw	r24, 0x00	; 0
    6d54:	19 f0       	breq	.+6      	; 0x6d5c <free+0xf0>
    6d56:	f8 01       	movw	r30, r16
    6d58:	8c 01       	movw	r16, r24
    6d5a:	f6 cf       	rjmp	.-20     	; 0x6d48 <free+0xdc>
    6d5c:	8d 91       	ld	r24, X+
    6d5e:	9c 91       	ld	r25, X
    6d60:	98 01       	movw	r18, r16
    6d62:	2e 5f       	subi	r18, 0xFE	; 254
    6d64:	3f 4f       	sbci	r19, 0xFF	; 255
    6d66:	82 0f       	add	r24, r18
    6d68:	93 1f       	adc	r25, r19
    6d6a:	20 91 b5 02 	lds	r18, 0x02B5
    6d6e:	30 91 b6 02 	lds	r19, 0x02B6
    6d72:	28 17       	cp	r18, r24
    6d74:	39 07       	cpc	r19, r25
    6d76:	69 f4       	brne	.+26     	; 0x6d92 <free+0x126>
    6d78:	30 97       	sbiw	r30, 0x00	; 0
    6d7a:	29 f4       	brne	.+10     	; 0x6d86 <free+0x11a>
    6d7c:	10 92 b8 02 	sts	0x02B8, r1
    6d80:	10 92 b7 02 	sts	0x02B7, r1
    6d84:	02 c0       	rjmp	.+4      	; 0x6d8a <free+0x11e>
    6d86:	13 82       	std	Z+3, r1	; 0x03
    6d88:	12 82       	std	Z+2, r1	; 0x02
    6d8a:	10 93 b6 02 	sts	0x02B6, r17
    6d8e:	00 93 b5 02 	sts	0x02B5, r16
    6d92:	df 91       	pop	r29
    6d94:	cf 91       	pop	r28
    6d96:	1f 91       	pop	r17
    6d98:	0f 91       	pop	r16
    6d9a:	08 95       	ret

00006d9c <atof>:
    6d9c:	66 27       	eor	r22, r22
    6d9e:	77 27       	eor	r23, r23
    6da0:	0c 94 02 39 	jmp	0x7204	; 0x7204 <strtod>

00006da4 <atoi>:
    6da4:	fc 01       	movw	r30, r24
    6da6:	88 27       	eor	r24, r24
    6da8:	99 27       	eor	r25, r25
    6daa:	e8 94       	clt
    6dac:	21 91       	ld	r18, Z+
    6dae:	20 32       	cpi	r18, 0x20	; 32
    6db0:	e9 f3       	breq	.-6      	; 0x6dac <atoi+0x8>
    6db2:	29 30       	cpi	r18, 0x09	; 9
    6db4:	10 f0       	brcs	.+4      	; 0x6dba <atoi+0x16>
    6db6:	2e 30       	cpi	r18, 0x0E	; 14
    6db8:	c8 f3       	brcs	.-14     	; 0x6dac <atoi+0x8>
    6dba:	2b 32       	cpi	r18, 0x2B	; 43
    6dbc:	41 f0       	breq	.+16     	; 0x6dce <atoi+0x2a>
    6dbe:	2d 32       	cpi	r18, 0x2D	; 45
    6dc0:	39 f4       	brne	.+14     	; 0x6dd0 <atoi+0x2c>
    6dc2:	68 94       	set
    6dc4:	04 c0       	rjmp	.+8      	; 0x6dce <atoi+0x2a>
    6dc6:	0e 94 30 37 	call	0x6e60	; 0x6e60 <__mulhi_const_10>
    6dca:	82 0f       	add	r24, r18
    6dcc:	91 1d       	adc	r25, r1
    6dce:	21 91       	ld	r18, Z+
    6dd0:	20 53       	subi	r18, 0x30	; 48
    6dd2:	2a 30       	cpi	r18, 0x0A	; 10
    6dd4:	c0 f3       	brcs	.-16     	; 0x6dc6 <atoi+0x22>
    6dd6:	1e f4       	brtc	.+6      	; 0x6dde <atoi+0x3a>
    6dd8:	90 95       	com	r25
    6dda:	81 95       	neg	r24
    6ddc:	9f 4f       	sbci	r25, 0xFF	; 255
    6dde:	08 95       	ret

00006de0 <memcpy>:
    6de0:	fb 01       	movw	r30, r22
    6de2:	dc 01       	movw	r26, r24
    6de4:	02 c0       	rjmp	.+4      	; 0x6dea <memcpy+0xa>
    6de6:	01 90       	ld	r0, Z+
    6de8:	0d 92       	st	X+, r0
    6dea:	41 50       	subi	r20, 0x01	; 1
    6dec:	50 40       	sbci	r21, 0x00	; 0
    6dee:	d8 f7       	brcc	.-10     	; 0x6de6 <memcpy+0x6>
    6df0:	08 95       	ret

00006df2 <memset>:
    6df2:	dc 01       	movw	r26, r24
    6df4:	01 c0       	rjmp	.+2      	; 0x6df8 <memset+0x6>
    6df6:	6d 93       	st	X+, r22
    6df8:	41 50       	subi	r20, 0x01	; 1
    6dfa:	50 40       	sbci	r21, 0x00	; 0
    6dfc:	e0 f7       	brcc	.-8      	; 0x6df6 <memset+0x4>
    6dfe:	08 95       	ret

00006e00 <itoa>:
    6e00:	45 32       	cpi	r20, 0x25	; 37
    6e02:	51 05       	cpc	r21, r1
    6e04:	20 f4       	brcc	.+8      	; 0x6e0e <itoa+0xe>
    6e06:	42 30       	cpi	r20, 0x02	; 2
    6e08:	10 f0       	brcs	.+4      	; 0x6e0e <itoa+0xe>
    6e0a:	0c 94 0b 37 	jmp	0x6e16	; 0x6e16 <__itoa_ncheck>
    6e0e:	fb 01       	movw	r30, r22
    6e10:	10 82       	st	Z, r1
    6e12:	cb 01       	movw	r24, r22
    6e14:	08 95       	ret

00006e16 <__itoa_ncheck>:
    6e16:	bb 27       	eor	r27, r27
    6e18:	4a 30       	cpi	r20, 0x0A	; 10
    6e1a:	31 f4       	brne	.+12     	; 0x6e28 <__itoa_ncheck+0x12>
    6e1c:	99 23       	and	r25, r25
    6e1e:	22 f4       	brpl	.+8      	; 0x6e28 <__itoa_ncheck+0x12>
    6e20:	bd e2       	ldi	r27, 0x2D	; 45
    6e22:	90 95       	com	r25
    6e24:	81 95       	neg	r24
    6e26:	9f 4f       	sbci	r25, 0xFF	; 255
    6e28:	0c 94 5b 37 	jmp	0x6eb6	; 0x6eb6 <__utoa_common>

00006e2c <ltoa>:
    6e2c:	25 32       	cpi	r18, 0x25	; 37
    6e2e:	31 05       	cpc	r19, r1
    6e30:	20 f4       	brcc	.+8      	; 0x6e3a <ltoa+0xe>
    6e32:	22 30       	cpi	r18, 0x02	; 2
    6e34:	10 f0       	brcs	.+4      	; 0x6e3a <ltoa+0xe>
    6e36:	0c 94 21 37 	jmp	0x6e42	; 0x6e42 <__ltoa_ncheck>
    6e3a:	fa 01       	movw	r30, r20
    6e3c:	10 82       	st	Z, r1
    6e3e:	ca 01       	movw	r24, r20
    6e40:	08 95       	ret

00006e42 <__ltoa_ncheck>:
    6e42:	bb 27       	eor	r27, r27
    6e44:	2a 30       	cpi	r18, 0x0A	; 10
    6e46:	51 f4       	brne	.+20     	; 0x6e5c <__ltoa_ncheck+0x1a>
    6e48:	99 23       	and	r25, r25
    6e4a:	42 f4       	brpl	.+16     	; 0x6e5c <__ltoa_ncheck+0x1a>
    6e4c:	bd e2       	ldi	r27, 0x2D	; 45
    6e4e:	90 95       	com	r25
    6e50:	80 95       	com	r24
    6e52:	70 95       	com	r23
    6e54:	61 95       	neg	r22
    6e56:	7f 4f       	sbci	r23, 0xFF	; 255
    6e58:	8f 4f       	sbci	r24, 0xFF	; 255
    6e5a:	9f 4f       	sbci	r25, 0xFF	; 255
    6e5c:	0c 94 39 37 	jmp	0x6e72	; 0x6e72 <__ultoa_common>

00006e60 <__mulhi_const_10>:
    6e60:	7a e0       	ldi	r23, 0x0A	; 10
    6e62:	97 9f       	mul	r25, r23
    6e64:	90 2d       	mov	r25, r0
    6e66:	87 9f       	mul	r24, r23
    6e68:	80 2d       	mov	r24, r0
    6e6a:	91 0d       	add	r25, r1
    6e6c:	11 24       	eor	r1, r1
    6e6e:	08 95       	ret

00006e70 <__ultoa_ncheck>:
    6e70:	bb 27       	eor	r27, r27

00006e72 <__ultoa_common>:
    6e72:	fa 01       	movw	r30, r20
    6e74:	a6 2f       	mov	r26, r22
    6e76:	62 17       	cp	r22, r18
    6e78:	71 05       	cpc	r23, r1
    6e7a:	81 05       	cpc	r24, r1
    6e7c:	91 05       	cpc	r25, r1
    6e7e:	33 0b       	sbc	r19, r19
    6e80:	30 fb       	bst	r19, 0
    6e82:	66 f0       	brts	.+24     	; 0x6e9c <__ultoa_common+0x2a>
    6e84:	aa 27       	eor	r26, r26
    6e86:	66 0f       	add	r22, r22
    6e88:	77 1f       	adc	r23, r23
    6e8a:	88 1f       	adc	r24, r24
    6e8c:	99 1f       	adc	r25, r25
    6e8e:	aa 1f       	adc	r26, r26
    6e90:	a2 17       	cp	r26, r18
    6e92:	10 f0       	brcs	.+4      	; 0x6e98 <__ultoa_common+0x26>
    6e94:	a2 1b       	sub	r26, r18
    6e96:	63 95       	inc	r22
    6e98:	38 50       	subi	r19, 0x08	; 8
    6e9a:	a9 f7       	brne	.-22     	; 0x6e86 <__ultoa_common+0x14>
    6e9c:	a0 5d       	subi	r26, 0xD0	; 208
    6e9e:	aa 33       	cpi	r26, 0x3A	; 58
    6ea0:	08 f0       	brcs	.+2      	; 0x6ea4 <__ultoa_common+0x32>
    6ea2:	a9 5d       	subi	r26, 0xD9	; 217
    6ea4:	a1 93       	st	Z+, r26
    6ea6:	36 f7       	brtc	.-52     	; 0x6e74 <__ultoa_common+0x2>
    6ea8:	b1 11       	cpse	r27, r1
    6eaa:	b1 93       	st	Z+, r27
    6eac:	10 82       	st	Z, r1
    6eae:	ca 01       	movw	r24, r20
    6eb0:	0c 94 6a 3b 	jmp	0x76d4	; 0x76d4 <strrev>

00006eb4 <__utoa_ncheck>:
    6eb4:	bb 27       	eor	r27, r27

00006eb6 <__utoa_common>:
    6eb6:	fb 01       	movw	r30, r22
    6eb8:	55 27       	eor	r21, r21
    6eba:	aa 27       	eor	r26, r26
    6ebc:	88 0f       	add	r24, r24
    6ebe:	99 1f       	adc	r25, r25
    6ec0:	aa 1f       	adc	r26, r26
    6ec2:	a4 17       	cp	r26, r20
    6ec4:	10 f0       	brcs	.+4      	; 0x6eca <__utoa_common+0x14>
    6ec6:	a4 1b       	sub	r26, r20
    6ec8:	83 95       	inc	r24
    6eca:	50 51       	subi	r21, 0x10	; 16
    6ecc:	b9 f7       	brne	.-18     	; 0x6ebc <__utoa_common+0x6>
    6ece:	a0 5d       	subi	r26, 0xD0	; 208
    6ed0:	aa 33       	cpi	r26, 0x3A	; 58
    6ed2:	08 f0       	brcs	.+2      	; 0x6ed6 <__utoa_common+0x20>
    6ed4:	a9 5d       	subi	r26, 0xD9	; 217
    6ed6:	a1 93       	st	Z+, r26
    6ed8:	00 97       	sbiw	r24, 0x00	; 0
    6eda:	79 f7       	brne	.-34     	; 0x6eba <__utoa_common+0x4>
    6edc:	b1 11       	cpse	r27, r1
    6ede:	b1 93       	st	Z+, r27
    6ee0:	11 92       	st	Z+, r1
    6ee2:	cb 01       	movw	r24, r22
    6ee4:	0c 94 6a 3b 	jmp	0x76d4	; 0x76d4 <strrev>

00006ee8 <dtoa_prf>:
    6ee8:	4f 92       	push	r4
    6eea:	5f 92       	push	r5
    6eec:	6f 92       	push	r6
    6eee:	7f 92       	push	r7
    6ef0:	9f 92       	push	r9
    6ef2:	af 92       	push	r10
    6ef4:	bf 92       	push	r11
    6ef6:	cf 92       	push	r12
    6ef8:	df 92       	push	r13
    6efa:	ef 92       	push	r14
    6efc:	ff 92       	push	r15
    6efe:	0f 93       	push	r16
    6f00:	1f 93       	push	r17
    6f02:	cf 93       	push	r28
    6f04:	df 93       	push	r29
    6f06:	cd b7       	in	r28, 0x3d	; 61
    6f08:	de b7       	in	r29, 0x3e	; 62
    6f0a:	29 97       	sbiw	r28, 0x09	; 9
    6f0c:	0f b6       	in	r0, 0x3f	; 63
    6f0e:	f8 94       	cli
    6f10:	de bf       	out	0x3e, r29	; 62
    6f12:	0f be       	out	0x3f, r0	; 63
    6f14:	cd bf       	out	0x3d, r28	; 61
    6f16:	6a 01       	movw	r12, r20
    6f18:	12 2f       	mov	r17, r18
    6f1a:	b0 2e       	mov	r11, r16
    6f1c:	2b e3       	ldi	r18, 0x3B	; 59
    6f1e:	20 17       	cp	r18, r16
    6f20:	20 f0       	brcs	.+8      	; 0x6f2a <dtoa_prf+0x42>
    6f22:	ff 24       	eor	r15, r15
    6f24:	f3 94       	inc	r15
    6f26:	f0 0e       	add	r15, r16
    6f28:	02 c0       	rjmp	.+4      	; 0x6f2e <dtoa_prf+0x46>
    6f2a:	bc e3       	ldi	r27, 0x3C	; 60
    6f2c:	fb 2e       	mov	r15, r27
    6f2e:	0f 2d       	mov	r16, r15
    6f30:	27 e0       	ldi	r18, 0x07	; 7
    6f32:	ae 01       	movw	r20, r28
    6f34:	4f 5f       	subi	r20, 0xFF	; 255
    6f36:	5f 4f       	sbci	r21, 0xFF	; 255
    6f38:	0e 94 71 3a 	call	0x74e2	; 0x74e2 <__ftoa_engine>
    6f3c:	ac 01       	movw	r20, r24
    6f3e:	89 81       	ldd	r24, Y+1	; 0x01
    6f40:	98 2f       	mov	r25, r24
    6f42:	99 70       	andi	r25, 0x09	; 9
    6f44:	91 30       	cpi	r25, 0x01	; 1
    6f46:	31 f0       	breq	.+12     	; 0x6f54 <dtoa_prf+0x6c>
    6f48:	e1 fc       	sbrc	r14, 1
    6f4a:	06 c0       	rjmp	.+12     	; 0x6f58 <dtoa_prf+0x70>
    6f4c:	e0 fe       	sbrs	r14, 0
    6f4e:	06 c0       	rjmp	.+12     	; 0x6f5c <dtoa_prf+0x74>
    6f50:	90 e2       	ldi	r25, 0x20	; 32
    6f52:	05 c0       	rjmp	.+10     	; 0x6f5e <dtoa_prf+0x76>
    6f54:	9d e2       	ldi	r25, 0x2D	; 45
    6f56:	03 c0       	rjmp	.+6      	; 0x6f5e <dtoa_prf+0x76>
    6f58:	9b e2       	ldi	r25, 0x2B	; 43
    6f5a:	01 c0       	rjmp	.+2      	; 0x6f5e <dtoa_prf+0x76>
    6f5c:	90 e0       	ldi	r25, 0x00	; 0
    6f5e:	ee 2d       	mov	r30, r14
    6f60:	e0 71       	andi	r30, 0x10	; 16
    6f62:	83 ff       	sbrs	r24, 3
    6f64:	3c c0       	rjmp	.+120    	; 0x6fde <dtoa_prf+0xf6>
    6f66:	91 11       	cpse	r25, r1
    6f68:	02 c0       	rjmp	.+4      	; 0x6f6e <dtoa_prf+0x86>
    6f6a:	83 e0       	ldi	r24, 0x03	; 3
    6f6c:	01 c0       	rjmp	.+2      	; 0x6f70 <dtoa_prf+0x88>
    6f6e:	84 e0       	ldi	r24, 0x04	; 4
    6f70:	81 17       	cp	r24, r17
    6f72:	18 f4       	brcc	.+6      	; 0x6f7a <dtoa_prf+0x92>
    6f74:	21 2f       	mov	r18, r17
    6f76:	28 1b       	sub	r18, r24
    6f78:	01 c0       	rjmp	.+2      	; 0x6f7c <dtoa_prf+0x94>
    6f7a:	20 e0       	ldi	r18, 0x00	; 0
    6f7c:	e1 11       	cpse	r30, r1
    6f7e:	0b c0       	rjmp	.+22     	; 0x6f96 <dtoa_prf+0xae>
    6f80:	f6 01       	movw	r30, r12
    6f82:	82 2f       	mov	r24, r18
    6f84:	30 e2       	ldi	r19, 0x20	; 32
    6f86:	88 23       	and	r24, r24
    6f88:	19 f0       	breq	.+6      	; 0x6f90 <dtoa_prf+0xa8>
    6f8a:	31 93       	st	Z+, r19
    6f8c:	81 50       	subi	r24, 0x01	; 1
    6f8e:	fb cf       	rjmp	.-10     	; 0x6f86 <dtoa_prf+0x9e>
    6f90:	c2 0e       	add	r12, r18
    6f92:	d1 1c       	adc	r13, r1
    6f94:	20 e0       	ldi	r18, 0x00	; 0
    6f96:	99 23       	and	r25, r25
    6f98:	29 f0       	breq	.+10     	; 0x6fa4 <dtoa_prf+0xbc>
    6f9a:	d6 01       	movw	r26, r12
    6f9c:	9c 93       	st	X, r25
    6f9e:	f6 01       	movw	r30, r12
    6fa0:	31 96       	adiw	r30, 0x01	; 1
    6fa2:	6f 01       	movw	r12, r30
    6fa4:	c6 01       	movw	r24, r12
    6fa6:	03 96       	adiw	r24, 0x03	; 3
    6fa8:	e2 fe       	sbrs	r14, 2
    6faa:	0a c0       	rjmp	.+20     	; 0x6fc0 <dtoa_prf+0xd8>
    6fac:	3e e4       	ldi	r19, 0x4E	; 78
    6fae:	d6 01       	movw	r26, r12
    6fb0:	3c 93       	st	X, r19
    6fb2:	41 e4       	ldi	r20, 0x41	; 65
    6fb4:	11 96       	adiw	r26, 0x01	; 1
    6fb6:	4c 93       	st	X, r20
    6fb8:	11 97       	sbiw	r26, 0x01	; 1
    6fba:	12 96       	adiw	r26, 0x02	; 2
    6fbc:	3c 93       	st	X, r19
    6fbe:	06 c0       	rjmp	.+12     	; 0x6fcc <dtoa_prf+0xe4>
    6fc0:	3e e6       	ldi	r19, 0x6E	; 110
    6fc2:	f6 01       	movw	r30, r12
    6fc4:	30 83       	st	Z, r19
    6fc6:	41 e6       	ldi	r20, 0x61	; 97
    6fc8:	41 83       	std	Z+1, r20	; 0x01
    6fca:	32 83       	std	Z+2, r19	; 0x02
    6fcc:	fc 01       	movw	r30, r24
    6fce:	32 2f       	mov	r19, r18
    6fd0:	40 e2       	ldi	r20, 0x20	; 32
    6fd2:	33 23       	and	r19, r19
    6fd4:	09 f4       	brne	.+2      	; 0x6fd8 <dtoa_prf+0xf0>
    6fd6:	42 c0       	rjmp	.+132    	; 0x705c <dtoa_prf+0x174>
    6fd8:	41 93       	st	Z+, r20
    6fda:	31 50       	subi	r19, 0x01	; 1
    6fdc:	fa cf       	rjmp	.-12     	; 0x6fd2 <dtoa_prf+0xea>
    6fde:	82 ff       	sbrs	r24, 2
    6fe0:	44 c0       	rjmp	.+136    	; 0x706a <dtoa_prf+0x182>
    6fe2:	91 11       	cpse	r25, r1
    6fe4:	02 c0       	rjmp	.+4      	; 0x6fea <dtoa_prf+0x102>
    6fe6:	83 e0       	ldi	r24, 0x03	; 3
    6fe8:	01 c0       	rjmp	.+2      	; 0x6fec <dtoa_prf+0x104>
    6fea:	84 e0       	ldi	r24, 0x04	; 4
    6fec:	81 17       	cp	r24, r17
    6fee:	18 f4       	brcc	.+6      	; 0x6ff6 <dtoa_prf+0x10e>
    6ff0:	21 2f       	mov	r18, r17
    6ff2:	28 1b       	sub	r18, r24
    6ff4:	01 c0       	rjmp	.+2      	; 0x6ff8 <dtoa_prf+0x110>
    6ff6:	20 e0       	ldi	r18, 0x00	; 0
    6ff8:	e1 11       	cpse	r30, r1
    6ffa:	0b c0       	rjmp	.+22     	; 0x7012 <dtoa_prf+0x12a>
    6ffc:	f6 01       	movw	r30, r12
    6ffe:	82 2f       	mov	r24, r18
    7000:	30 e2       	ldi	r19, 0x20	; 32
    7002:	88 23       	and	r24, r24
    7004:	19 f0       	breq	.+6      	; 0x700c <dtoa_prf+0x124>
    7006:	31 93       	st	Z+, r19
    7008:	81 50       	subi	r24, 0x01	; 1
    700a:	fb cf       	rjmp	.-10     	; 0x7002 <dtoa_prf+0x11a>
    700c:	c2 0e       	add	r12, r18
    700e:	d1 1c       	adc	r13, r1
    7010:	20 e0       	ldi	r18, 0x00	; 0
    7012:	99 23       	and	r25, r25
    7014:	29 f0       	breq	.+10     	; 0x7020 <dtoa_prf+0x138>
    7016:	d6 01       	movw	r26, r12
    7018:	9c 93       	st	X, r25
    701a:	f6 01       	movw	r30, r12
    701c:	31 96       	adiw	r30, 0x01	; 1
    701e:	6f 01       	movw	r12, r30
    7020:	c6 01       	movw	r24, r12
    7022:	03 96       	adiw	r24, 0x03	; 3
    7024:	e2 fe       	sbrs	r14, 2
    7026:	0b c0       	rjmp	.+22     	; 0x703e <dtoa_prf+0x156>
    7028:	39 e4       	ldi	r19, 0x49	; 73
    702a:	d6 01       	movw	r26, r12
    702c:	3c 93       	st	X, r19
    702e:	3e e4       	ldi	r19, 0x4E	; 78
    7030:	11 96       	adiw	r26, 0x01	; 1
    7032:	3c 93       	st	X, r19
    7034:	11 97       	sbiw	r26, 0x01	; 1
    7036:	36 e4       	ldi	r19, 0x46	; 70
    7038:	12 96       	adiw	r26, 0x02	; 2
    703a:	3c 93       	st	X, r19
    703c:	07 c0       	rjmp	.+14     	; 0x704c <dtoa_prf+0x164>
    703e:	39 e6       	ldi	r19, 0x69	; 105
    7040:	f6 01       	movw	r30, r12
    7042:	30 83       	st	Z, r19
    7044:	3e e6       	ldi	r19, 0x6E	; 110
    7046:	31 83       	std	Z+1, r19	; 0x01
    7048:	36 e6       	ldi	r19, 0x66	; 102
    704a:	32 83       	std	Z+2, r19	; 0x02
    704c:	fc 01       	movw	r30, r24
    704e:	32 2f       	mov	r19, r18
    7050:	40 e2       	ldi	r20, 0x20	; 32
    7052:	33 23       	and	r19, r19
    7054:	19 f0       	breq	.+6      	; 0x705c <dtoa_prf+0x174>
    7056:	41 93       	st	Z+, r20
    7058:	31 50       	subi	r19, 0x01	; 1
    705a:	fb cf       	rjmp	.-10     	; 0x7052 <dtoa_prf+0x16a>
    705c:	fc 01       	movw	r30, r24
    705e:	e2 0f       	add	r30, r18
    7060:	f1 1d       	adc	r31, r1
    7062:	10 82       	st	Z, r1
    7064:	8e ef       	ldi	r24, 0xFE	; 254
    7066:	9f ef       	ldi	r25, 0xFF	; 255
    7068:	b7 c0       	rjmp	.+366    	; 0x71d8 <dtoa_prf+0x2f0>
    706a:	f1 e0       	ldi	r31, 0x01	; 1
    706c:	91 11       	cpse	r25, r1
    706e:	01 c0       	rjmp	.+2      	; 0x7072 <dtoa_prf+0x18a>
    7070:	f0 e0       	ldi	r31, 0x00	; 0
    7072:	6f 2f       	mov	r22, r31
    7074:	70 e0       	ldi	r23, 0x00	; 0
    7076:	14 16       	cp	r1, r20
    7078:	15 06       	cpc	r1, r21
    707a:	24 f4       	brge	.+8      	; 0x7084 <dtoa_prf+0x19c>
    707c:	9a 01       	movw	r18, r20
    707e:	2f 5f       	subi	r18, 0xFF	; 255
    7080:	3f 4f       	sbci	r19, 0xFF	; 255
    7082:	02 c0       	rjmp	.+4      	; 0x7088 <dtoa_prf+0x1a0>
    7084:	21 e0       	ldi	r18, 0x01	; 1
    7086:	30 e0       	ldi	r19, 0x00	; 0
    7088:	26 0f       	add	r18, r22
    708a:	37 1f       	adc	r19, r23
    708c:	bb 20       	and	r11, r11
    708e:	29 f0       	breq	.+10     	; 0x709a <dtoa_prf+0x1b2>
    7090:	6b 2d       	mov	r22, r11
    7092:	70 e0       	ldi	r23, 0x00	; 0
    7094:	6f 5f       	subi	r22, 0xFF	; 255
    7096:	7f 4f       	sbci	r23, 0xFF	; 255
    7098:	02 c0       	rjmp	.+4      	; 0x709e <dtoa_prf+0x1b6>
    709a:	60 e0       	ldi	r22, 0x00	; 0
    709c:	70 e0       	ldi	r23, 0x00	; 0
    709e:	26 0f       	add	r18, r22
    70a0:	37 1f       	adc	r19, r23
    70a2:	61 2f       	mov	r22, r17
    70a4:	70 e0       	ldi	r23, 0x00	; 0
    70a6:	26 17       	cp	r18, r22
    70a8:	37 07       	cpc	r19, r23
    70aa:	1c f4       	brge	.+6      	; 0x70b2 <dtoa_prf+0x1ca>
    70ac:	12 1b       	sub	r17, r18
    70ae:	21 2f       	mov	r18, r17
    70b0:	01 c0       	rjmp	.+2      	; 0x70b4 <dtoa_prf+0x1cc>
    70b2:	20 e0       	ldi	r18, 0x00	; 0
    70b4:	3e 2d       	mov	r19, r14
    70b6:	38 71       	andi	r19, 0x18	; 24
    70b8:	59 f4       	brne	.+22     	; 0x70d0 <dtoa_prf+0x1e8>
    70ba:	d6 01       	movw	r26, r12
    70bc:	32 2f       	mov	r19, r18
    70be:	60 e2       	ldi	r22, 0x20	; 32
    70c0:	33 23       	and	r19, r19
    70c2:	19 f0       	breq	.+6      	; 0x70ca <dtoa_prf+0x1e2>
    70c4:	6d 93       	st	X+, r22
    70c6:	31 50       	subi	r19, 0x01	; 1
    70c8:	fb cf       	rjmp	.-10     	; 0x70c0 <dtoa_prf+0x1d8>
    70ca:	c2 0e       	add	r12, r18
    70cc:	d1 1c       	adc	r13, r1
    70ce:	20 e0       	ldi	r18, 0x00	; 0
    70d0:	ff 23       	and	r31, r31
    70d2:	31 f0       	breq	.+12     	; 0x70e0 <dtoa_prf+0x1f8>
    70d4:	d6 01       	movw	r26, r12
    70d6:	9c 93       	st	X, r25
    70d8:	b6 01       	movw	r22, r12
    70da:	6f 5f       	subi	r22, 0xFF	; 255
    70dc:	7f 4f       	sbci	r23, 0xFF	; 255
    70de:	6b 01       	movw	r12, r22
    70e0:	e1 11       	cpse	r30, r1
    70e2:	0b c0       	rjmp	.+22     	; 0x70fa <dtoa_prf+0x212>
    70e4:	f6 01       	movw	r30, r12
    70e6:	92 2f       	mov	r25, r18
    70e8:	30 e3       	ldi	r19, 0x30	; 48
    70ea:	99 23       	and	r25, r25
    70ec:	19 f0       	breq	.+6      	; 0x70f4 <dtoa_prf+0x20c>
    70ee:	31 93       	st	Z+, r19
    70f0:	91 50       	subi	r25, 0x01	; 1
    70f2:	fb cf       	rjmp	.-10     	; 0x70ea <dtoa_prf+0x202>
    70f4:	c2 0e       	add	r12, r18
    70f6:	d1 1c       	adc	r13, r1
    70f8:	20 e0       	ldi	r18, 0x00	; 0
    70fa:	9f 2d       	mov	r25, r15
    70fc:	94 0f       	add	r25, r20
    70fe:	3a 81       	ldd	r19, Y+2	; 0x02
    7100:	78 2f       	mov	r23, r24
    7102:	70 71       	andi	r23, 0x10	; 16
    7104:	a7 2e       	mov	r10, r23
    7106:	84 ff       	sbrs	r24, 4
    7108:	03 c0       	rjmp	.+6      	; 0x7110 <dtoa_prf+0x228>
    710a:	31 33       	cpi	r19, 0x31	; 49
    710c:	09 f4       	brne	.+2      	; 0x7110 <dtoa_prf+0x228>
    710e:	91 50       	subi	r25, 0x01	; 1
    7110:	19 16       	cp	r1, r25
    7112:	24 f4       	brge	.+8      	; 0x711c <dtoa_prf+0x234>
    7114:	99 30       	cpi	r25, 0x09	; 9
    7116:	18 f0       	brcs	.+6      	; 0x711e <dtoa_prf+0x236>
    7118:	98 e0       	ldi	r25, 0x08	; 8
    711a:	01 c0       	rjmp	.+2      	; 0x711e <dtoa_prf+0x236>
    711c:	91 e0       	ldi	r25, 0x01	; 1
    711e:	e4 2f       	mov	r30, r20
    7120:	85 2f       	mov	r24, r21
    7122:	57 ff       	sbrs	r21, 7
    7124:	02 c0       	rjmp	.+4      	; 0x712a <dtoa_prf+0x242>
    7126:	e0 e0       	ldi	r30, 0x00	; 0
    7128:	80 e0       	ldi	r24, 0x00	; 0
    712a:	6e 2f       	mov	r22, r30
    712c:	78 2f       	mov	r23, r24
    712e:	e0 e0       	ldi	r30, 0x00	; 0
    7130:	f0 e0       	ldi	r31, 0x00	; 0
    7132:	ae e2       	ldi	r26, 0x2E	; 46
    7134:	9a 2e       	mov	r9, r26
    7136:	3a 01       	movw	r6, r20
    7138:	69 1a       	sub	r6, r25
    713a:	71 08       	sbc	r7, r1
    713c:	2a 01       	movw	r4, r20
    713e:	46 1a       	sub	r4, r22
    7140:	57 0a       	sbc	r5, r23
    7142:	0b 2d       	mov	r16, r11
    7144:	10 e0       	ldi	r17, 0x00	; 0
    7146:	11 95       	neg	r17
    7148:	01 95       	neg	r16
    714a:	11 09       	sbc	r17, r1
    714c:	6f 3f       	cpi	r22, 0xFF	; 255
    714e:	8f ef       	ldi	r24, 0xFF	; 255
    7150:	78 07       	cpc	r23, r24
    7152:	29 f4       	brne	.+10     	; 0x715e <dtoa_prf+0x276>
    7154:	d6 01       	movw	r26, r12
    7156:	9c 92       	st	X, r9
    7158:	c6 01       	movw	r24, r12
    715a:	01 96       	adiw	r24, 0x01	; 1
    715c:	6c 01       	movw	r12, r24
    715e:	46 17       	cp	r20, r22
    7160:	57 07       	cpc	r21, r23
    7162:	84 f0       	brlt	.+32     	; 0x7184 <dtoa_prf+0x29c>
    7164:	66 16       	cp	r6, r22
    7166:	77 06       	cpc	r7, r23
    7168:	6c f4       	brge	.+26     	; 0x7184 <dtoa_prf+0x29c>
    716a:	7f 01       	movw	r14, r30
    716c:	e4 0c       	add	r14, r4
    716e:	f5 1c       	adc	r15, r5
    7170:	a1 e0       	ldi	r26, 0x01	; 1
    7172:	b0 e0       	ldi	r27, 0x00	; 0
    7174:	ac 0f       	add	r26, r28
    7176:	bd 1f       	adc	r27, r29
    7178:	ea 0e       	add	r14, r26
    717a:	fb 1e       	adc	r15, r27
    717c:	d7 01       	movw	r26, r14
    717e:	11 96       	adiw	r26, 0x01	; 1
    7180:	bc 90       	ld	r11, X
    7182:	02 c0       	rjmp	.+4      	; 0x7188 <dtoa_prf+0x2a0>
    7184:	90 e3       	ldi	r25, 0x30	; 48
    7186:	b9 2e       	mov	r11, r25
    7188:	61 50       	subi	r22, 0x01	; 1
    718a:	71 09       	sbc	r23, r1
    718c:	31 96       	adiw	r30, 0x01	; 1
    718e:	c6 01       	movw	r24, r12
    7190:	01 96       	adiw	r24, 0x01	; 1
    7192:	7c 01       	movw	r14, r24
    7194:	60 17       	cp	r22, r16
    7196:	71 07       	cpc	r23, r17
    7198:	24 f0       	brlt	.+8      	; 0x71a2 <dtoa_prf+0x2ba>
    719a:	d6 01       	movw	r26, r12
    719c:	bc 92       	st	X, r11
    719e:	6c 01       	movw	r12, r24
    71a0:	d5 cf       	rjmp	.-86     	; 0x714c <dtoa_prf+0x264>
    71a2:	64 17       	cp	r22, r20
    71a4:	75 07       	cpc	r23, r21
    71a6:	41 f4       	brne	.+16     	; 0x71b8 <dtoa_prf+0x2d0>
    71a8:	36 33       	cpi	r19, 0x36	; 54
    71aa:	20 f4       	brcc	.+8      	; 0x71b4 <dtoa_prf+0x2cc>
    71ac:	35 33       	cpi	r19, 0x35	; 53
    71ae:	21 f4       	brne	.+8      	; 0x71b8 <dtoa_prf+0x2d0>
    71b0:	a1 10       	cpse	r10, r1
    71b2:	02 c0       	rjmp	.+4      	; 0x71b8 <dtoa_prf+0x2d0>
    71b4:	81 e3       	ldi	r24, 0x31	; 49
    71b6:	b8 2e       	mov	r11, r24
    71b8:	f6 01       	movw	r30, r12
    71ba:	b0 82       	st	Z, r11
    71bc:	f7 01       	movw	r30, r14
    71be:	82 2f       	mov	r24, r18
    71c0:	90 e2       	ldi	r25, 0x20	; 32
    71c2:	88 23       	and	r24, r24
    71c4:	19 f0       	breq	.+6      	; 0x71cc <dtoa_prf+0x2e4>
    71c6:	91 93       	st	Z+, r25
    71c8:	81 50       	subi	r24, 0x01	; 1
    71ca:	fb cf       	rjmp	.-10     	; 0x71c2 <dtoa_prf+0x2da>
    71cc:	f7 01       	movw	r30, r14
    71ce:	e2 0f       	add	r30, r18
    71d0:	f1 1d       	adc	r31, r1
    71d2:	10 82       	st	Z, r1
    71d4:	80 e0       	ldi	r24, 0x00	; 0
    71d6:	90 e0       	ldi	r25, 0x00	; 0
    71d8:	29 96       	adiw	r28, 0x09	; 9
    71da:	0f b6       	in	r0, 0x3f	; 63
    71dc:	f8 94       	cli
    71de:	de bf       	out	0x3e, r29	; 62
    71e0:	0f be       	out	0x3f, r0	; 63
    71e2:	cd bf       	out	0x3d, r28	; 61
    71e4:	df 91       	pop	r29
    71e6:	cf 91       	pop	r28
    71e8:	1f 91       	pop	r17
    71ea:	0f 91       	pop	r16
    71ec:	ff 90       	pop	r15
    71ee:	ef 90       	pop	r14
    71f0:	df 90       	pop	r13
    71f2:	cf 90       	pop	r12
    71f4:	bf 90       	pop	r11
    71f6:	af 90       	pop	r10
    71f8:	9f 90       	pop	r9
    71fa:	7f 90       	pop	r7
    71fc:	6f 90       	pop	r6
    71fe:	5f 90       	pop	r5
    7200:	4f 90       	pop	r4
    7202:	08 95       	ret

00007204 <strtod>:
    7204:	6f 92       	push	r6
    7206:	7f 92       	push	r7
    7208:	8f 92       	push	r8
    720a:	9f 92       	push	r9
    720c:	af 92       	push	r10
    720e:	bf 92       	push	r11
    7210:	cf 92       	push	r12
    7212:	df 92       	push	r13
    7214:	ef 92       	push	r14
    7216:	ff 92       	push	r15
    7218:	0f 93       	push	r16
    721a:	1f 93       	push	r17
    721c:	cf 93       	push	r28
    721e:	df 93       	push	r29
    7220:	ec 01       	movw	r28, r24
    7222:	7b 01       	movw	r14, r22
    7224:	61 15       	cp	r22, r1
    7226:	71 05       	cpc	r23, r1
    7228:	19 f0       	breq	.+6      	; 0x7230 <strtod+0x2c>
    722a:	db 01       	movw	r26, r22
    722c:	8d 93       	st	X+, r24
    722e:	9c 93       	st	X, r25
    7230:	8e 01       	movw	r16, r28
    7232:	0f 5f       	subi	r16, 0xFF	; 255
    7234:	1f 4f       	sbci	r17, 0xFF	; 255
    7236:	78 80       	ld	r7, Y
    7238:	87 2d       	mov	r24, r7
    723a:	90 e0       	ldi	r25, 0x00	; 0
    723c:	0e 94 49 3b 	call	0x7692	; 0x7692 <isspace>
    7240:	89 2b       	or	r24, r25
    7242:	11 f0       	breq	.+4      	; 0x7248 <strtod+0x44>
    7244:	e8 01       	movw	r28, r16
    7246:	f4 cf       	rjmp	.-24     	; 0x7230 <strtod+0x2c>
    7248:	bd e2       	ldi	r27, 0x2D	; 45
    724a:	7b 12       	cpse	r7, r27
    724c:	05 c0       	rjmp	.+10     	; 0x7258 <strtod+0x54>
    724e:	0f 5f       	subi	r16, 0xFF	; 255
    7250:	1f 4f       	sbci	r17, 0xFF	; 255
    7252:	79 80       	ldd	r7, Y+1	; 0x01
    7254:	c1 e0       	ldi	r28, 0x01	; 1
    7256:	08 c0       	rjmp	.+16     	; 0x7268 <strtod+0x64>
    7258:	eb e2       	ldi	r30, 0x2B	; 43
    725a:	7e 12       	cpse	r7, r30
    725c:	04 c0       	rjmp	.+8      	; 0x7266 <strtod+0x62>
    725e:	8e 01       	movw	r16, r28
    7260:	0e 5f       	subi	r16, 0xFE	; 254
    7262:	1f 4f       	sbci	r17, 0xFF	; 255
    7264:	79 80       	ldd	r7, Y+1	; 0x01
    7266:	c0 e0       	ldi	r28, 0x00	; 0
    7268:	68 01       	movw	r12, r16
    726a:	f1 e0       	ldi	r31, 0x01	; 1
    726c:	cf 1a       	sub	r12, r31
    726e:	d1 08       	sbc	r13, r1
    7270:	43 e0       	ldi	r20, 0x03	; 3
    7272:	50 e0       	ldi	r21, 0x00	; 0
    7274:	64 ea       	ldi	r22, 0xA4	; 164
    7276:	71 e0       	ldi	r23, 0x01	; 1
    7278:	c6 01       	movw	r24, r12
    727a:	0e 94 52 3b 	call	0x76a4	; 0x76a4 <strncasecmp_P>
    727e:	89 2b       	or	r24, r25
    7280:	f1 f4       	brne	.+60     	; 0x72be <strtod+0xba>
    7282:	68 01       	movw	r12, r16
    7284:	22 e0       	ldi	r18, 0x02	; 2
    7286:	c2 0e       	add	r12, r18
    7288:	d1 1c       	adc	r13, r1
    728a:	45 e0       	ldi	r20, 0x05	; 5
    728c:	50 e0       	ldi	r21, 0x00	; 0
    728e:	6f e9       	ldi	r22, 0x9F	; 159
    7290:	71 e0       	ldi	r23, 0x01	; 1
    7292:	c6 01       	movw	r24, r12
    7294:	0e 94 52 3b 	call	0x76a4	; 0x76a4 <strncasecmp_P>
    7298:	89 2b       	or	r24, r25
    729a:	21 f4       	brne	.+8      	; 0x72a4 <strtod+0xa0>
    729c:	68 01       	movw	r12, r16
    729e:	87 e0       	ldi	r24, 0x07	; 7
    72a0:	c8 0e       	add	r12, r24
    72a2:	d1 1c       	adc	r13, r1
    72a4:	e1 14       	cp	r14, r1
    72a6:	f1 04       	cpc	r15, r1
    72a8:	19 f0       	breq	.+6      	; 0x72b0 <strtod+0xac>
    72aa:	d7 01       	movw	r26, r14
    72ac:	cd 92       	st	X+, r12
    72ae:	dc 92       	st	X, r13
    72b0:	c1 11       	cpse	r28, r1
    72b2:	ff c0       	rjmp	.+510    	; 0x74b2 <strtod+0x2ae>
    72b4:	60 e0       	ldi	r22, 0x00	; 0
    72b6:	70 e0       	ldi	r23, 0x00	; 0
    72b8:	80 e8       	ldi	r24, 0x80	; 128
    72ba:	9f e7       	ldi	r25, 0x7F	; 127
    72bc:	03 c1       	rjmp	.+518    	; 0x74c4 <strtod+0x2c0>
    72be:	43 e0       	ldi	r20, 0x03	; 3
    72c0:	50 e0       	ldi	r21, 0x00	; 0
    72c2:	6c e9       	ldi	r22, 0x9C	; 156
    72c4:	71 e0       	ldi	r23, 0x01	; 1
    72c6:	c6 01       	movw	r24, r12
    72c8:	0e 94 52 3b 	call	0x76a4	; 0x76a4 <strncasecmp_P>
    72cc:	89 2b       	or	r24, r25
    72ce:	51 f4       	brne	.+20     	; 0x72e4 <strtod+0xe0>
    72d0:	e1 14       	cp	r14, r1
    72d2:	f1 04       	cpc	r15, r1
    72d4:	09 f4       	brne	.+2      	; 0x72d8 <strtod+0xd4>
    72d6:	f2 c0       	rjmp	.+484    	; 0x74bc <strtod+0x2b8>
    72d8:	0e 5f       	subi	r16, 0xFE	; 254
    72da:	1f 4f       	sbci	r17, 0xFF	; 255
    72dc:	f7 01       	movw	r30, r14
    72de:	11 83       	std	Z+1, r17	; 0x01
    72e0:	00 83       	st	Z, r16
    72e2:	ec c0       	rjmp	.+472    	; 0x74bc <strtod+0x2b8>
    72e4:	68 01       	movw	r12, r16
    72e6:	60 e0       	ldi	r22, 0x00	; 0
    72e8:	70 e0       	ldi	r23, 0x00	; 0
    72ea:	cb 01       	movw	r24, r22
    72ec:	00 e0       	ldi	r16, 0x00	; 0
    72ee:	10 e0       	ldi	r17, 0x00	; 0
    72f0:	f6 01       	movw	r30, r12
    72f2:	d0 ed       	ldi	r29, 0xD0	; 208
    72f4:	d7 0d       	add	r29, r7
    72f6:	da 30       	cpi	r29, 0x0A	; 10
    72f8:	58 f5       	brcc	.+86     	; 0x7350 <strtod+0x14c>
    72fa:	2c 2f       	mov	r18, r28
    72fc:	22 60       	ori	r18, 0x02	; 2
    72fe:	62 2e       	mov	r6, r18
    7300:	2c 2f       	mov	r18, r28
    7302:	28 70       	andi	r18, 0x08	; 8
    7304:	c2 ff       	sbrs	r28, 2
    7306:	05 c0       	rjmp	.+10     	; 0x7312 <strtod+0x10e>
    7308:	21 11       	cpse	r18, r1
    730a:	28 c0       	rjmp	.+80     	; 0x735c <strtod+0x158>
    730c:	0f 5f       	subi	r16, 0xFF	; 255
    730e:	1f 4f       	sbci	r17, 0xFF	; 255
    7310:	25 c0       	rjmp	.+74     	; 0x735c <strtod+0x158>
    7312:	22 23       	and	r18, r18
    7314:	11 f0       	breq	.+4      	; 0x731a <strtod+0x116>
    7316:	01 50       	subi	r16, 0x01	; 1
    7318:	11 09       	sbc	r17, r1
    731a:	a5 e0       	ldi	r26, 0x05	; 5
    731c:	b0 e0       	ldi	r27, 0x00	; 0
    731e:	9b 01       	movw	r18, r22
    7320:	ac 01       	movw	r20, r24
    7322:	0e 94 7d 3b 	call	0x76fa	; 0x76fa <__muluhisi3>
    7326:	4b 01       	movw	r8, r22
    7328:	5c 01       	movw	r10, r24
    732a:	88 0c       	add	r8, r8
    732c:	99 1c       	adc	r9, r9
    732e:	aa 1c       	adc	r10, r10
    7330:	bb 1c       	adc	r11, r11
    7332:	c5 01       	movw	r24, r10
    7334:	b4 01       	movw	r22, r8
    7336:	6d 0f       	add	r22, r29
    7338:	71 1d       	adc	r23, r1
    733a:	81 1d       	adc	r24, r1
    733c:	91 1d       	adc	r25, r1
    733e:	68 39       	cpi	r22, 0x98	; 152
    7340:	a9 e9       	ldi	r26, 0x99	; 153
    7342:	7a 07       	cpc	r23, r26
    7344:	8a 07       	cpc	r24, r26
    7346:	a9 e1       	ldi	r26, 0x19	; 25
    7348:	9a 07       	cpc	r25, r26
    734a:	40 f0       	brcs	.+16     	; 0x735c <strtod+0x158>
    734c:	c6 60       	ori	r28, 0x06	; 6
    734e:	05 c0       	rjmp	.+10     	; 0x735a <strtod+0x156>
    7350:	de 3f       	cpi	r29, 0xFE	; 254
    7352:	51 f4       	brne	.+20     	; 0x7368 <strtod+0x164>
    7354:	c3 fd       	sbrc	r28, 3
    7356:	44 c0       	rjmp	.+136    	; 0x73e0 <strtod+0x1dc>
    7358:	c8 60       	ori	r28, 0x08	; 8
    735a:	6c 2e       	mov	r6, r28
    735c:	bf ef       	ldi	r27, 0xFF	; 255
    735e:	cb 1a       	sub	r12, r27
    7360:	db 0a       	sbc	r13, r27
    7362:	70 80       	ld	r7, Z
    7364:	c6 2d       	mov	r28, r6
    7366:	c4 cf       	rjmp	.-120    	; 0x72f0 <strtod+0xec>
    7368:	2d 2f       	mov	r18, r29
    736a:	2f 7d       	andi	r18, 0xDF	; 223
    736c:	25 31       	cpi	r18, 0x15	; 21
    736e:	c1 f5       	brne	.+112    	; 0x73e0 <strtod+0x1dc>
    7370:	40 81       	ld	r20, Z
    7372:	4d 32       	cpi	r20, 0x2D	; 45
    7374:	11 f4       	brne	.+4      	; 0x737a <strtod+0x176>
    7376:	c0 61       	ori	r28, 0x10	; 16
    7378:	06 c0       	rjmp	.+12     	; 0x7386 <strtod+0x182>
    737a:	4b 32       	cpi	r20, 0x2B	; 43
    737c:	21 f0       	breq	.+8      	; 0x7386 <strtod+0x182>
    737e:	31 96       	adiw	r30, 0x01	; 1
    7380:	21 e0       	ldi	r18, 0x01	; 1
    7382:	30 e0       	ldi	r19, 0x00	; 0
    7384:	06 c0       	rjmp	.+12     	; 0x7392 <strtod+0x18e>
    7386:	32 96       	adiw	r30, 0x02	; 2
    7388:	d6 01       	movw	r26, r12
    738a:	11 96       	adiw	r26, 0x01	; 1
    738c:	4c 91       	ld	r20, X
    738e:	22 e0       	ldi	r18, 0x02	; 2
    7390:	30 e0       	ldi	r19, 0x00	; 0
    7392:	a0 ed       	ldi	r26, 0xD0	; 208
    7394:	a4 0f       	add	r26, r20
    7396:	aa 30       	cpi	r26, 0x0A	; 10
    7398:	18 f0       	brcs	.+6      	; 0x73a0 <strtod+0x19c>
    739a:	e2 1b       	sub	r30, r18
    739c:	f3 0b       	sbc	r31, r19
    739e:	20 c0       	rjmp	.+64     	; 0x73e0 <strtod+0x1dc>
    73a0:	40 e0       	ldi	r20, 0x00	; 0
    73a2:	50 e0       	ldi	r21, 0x00	; 0
    73a4:	40 38       	cpi	r20, 0x80	; 128
    73a6:	bc e0       	ldi	r27, 0x0C	; 12
    73a8:	5b 07       	cpc	r21, r27
    73aa:	5c f4       	brge	.+22     	; 0x73c2 <strtod+0x1be>
    73ac:	9a 01       	movw	r18, r20
    73ae:	22 0f       	add	r18, r18
    73b0:	33 1f       	adc	r19, r19
    73b2:	22 0f       	add	r18, r18
    73b4:	33 1f       	adc	r19, r19
    73b6:	42 0f       	add	r20, r18
    73b8:	53 1f       	adc	r21, r19
    73ba:	44 0f       	add	r20, r20
    73bc:	55 1f       	adc	r21, r21
    73be:	4a 0f       	add	r20, r26
    73c0:	51 1d       	adc	r21, r1
    73c2:	31 96       	adiw	r30, 0x01	; 1
    73c4:	df 01       	movw	r26, r30
    73c6:	11 97       	sbiw	r26, 0x01	; 1
    73c8:	2c 91       	ld	r18, X
    73ca:	a0 ed       	ldi	r26, 0xD0	; 208
    73cc:	a2 0f       	add	r26, r18
    73ce:	aa 30       	cpi	r26, 0x0A	; 10
    73d0:	48 f3       	brcs	.-46     	; 0x73a4 <strtod+0x1a0>
    73d2:	c4 ff       	sbrs	r28, 4
    73d4:	03 c0       	rjmp	.+6      	; 0x73dc <strtod+0x1d8>
    73d6:	51 95       	neg	r21
    73d8:	41 95       	neg	r20
    73da:	51 09       	sbc	r21, r1
    73dc:	04 0f       	add	r16, r20
    73de:	15 1f       	adc	r17, r21
    73e0:	c1 ff       	sbrs	r28, 1
    73e2:	07 c0       	rjmp	.+14     	; 0x73f2 <strtod+0x1ee>
    73e4:	e1 14       	cp	r14, r1
    73e6:	f1 04       	cpc	r15, r1
    73e8:	21 f0       	breq	.+8      	; 0x73f2 <strtod+0x1ee>
    73ea:	31 97       	sbiw	r30, 0x01	; 1
    73ec:	d7 01       	movw	r26, r14
    73ee:	ed 93       	st	X+, r30
    73f0:	fc 93       	st	X, r31
    73f2:	0e 94 87 32 	call	0x650e	; 0x650e <__floatunsisf>
    73f6:	c3 70       	andi	r28, 0x03	; 3
    73f8:	c3 30       	cpi	r28, 0x03	; 3
    73fa:	19 f0       	breq	.+6      	; 0x7402 <strtod+0x1fe>
    73fc:	6b 01       	movw	r12, r22
    73fe:	7c 01       	movw	r14, r24
    7400:	06 c0       	rjmp	.+12     	; 0x740e <strtod+0x20a>
    7402:	6b 01       	movw	r12, r22
    7404:	7c 01       	movw	r14, r24
    7406:	f7 fa       	bst	r15, 7
    7408:	f0 94       	com	r15
    740a:	f7 f8       	bld	r15, 7
    740c:	f0 94       	com	r15
    740e:	20 e0       	ldi	r18, 0x00	; 0
    7410:	30 e0       	ldi	r19, 0x00	; 0
    7412:	a9 01       	movw	r20, r18
    7414:	c7 01       	movw	r24, r14
    7416:	b6 01       	movw	r22, r12
    7418:	0e 94 e1 31 	call	0x63c2	; 0x63c2 <__cmpsf2>
    741c:	88 23       	and	r24, r24
    741e:	09 f4       	brne	.+2      	; 0x7422 <strtod+0x21e>
    7420:	45 c0       	rjmp	.+138    	; 0x74ac <strtod+0x2a8>
    7422:	17 ff       	sbrs	r17, 7
    7424:	06 c0       	rjmp	.+12     	; 0x7432 <strtod+0x22e>
    7426:	11 95       	neg	r17
    7428:	01 95       	neg	r16
    742a:	11 09       	sbc	r17, r1
    742c:	cb eb       	ldi	r28, 0xBB	; 187
    742e:	d1 e0       	ldi	r29, 0x01	; 1
    7430:	02 c0       	rjmp	.+4      	; 0x7436 <strtod+0x232>
    7432:	c3 ed       	ldi	r28, 0xD3	; 211
    7434:	d1 e0       	ldi	r29, 0x01	; 1
    7436:	5e 01       	movw	r10, r28
    7438:	b8 e1       	ldi	r27, 0x18	; 24
    743a:	ab 1a       	sub	r10, r27
    743c:	b1 08       	sbc	r11, r1
    743e:	46 01       	movw	r8, r12
    7440:	be 2d       	mov	r27, r14
    7442:	af 2d       	mov	r26, r15
    7444:	90 e2       	ldi	r25, 0x20	; 32
    7446:	e9 2e       	mov	r14, r25
    7448:	f1 2c       	mov	r15, r1
    744a:	0e 15       	cp	r16, r14
    744c:	1f 05       	cpc	r17, r15
    744e:	84 f0       	brlt	.+32     	; 0x7470 <strtod+0x26c>
    7450:	fe 01       	movw	r30, r28
    7452:	25 91       	lpm	r18, Z+
    7454:	35 91       	lpm	r19, Z+
    7456:	45 91       	lpm	r20, Z+
    7458:	54 91       	lpm	r21, Z
    745a:	b4 01       	movw	r22, r8
    745c:	8b 2f       	mov	r24, r27
    745e:	9a 2f       	mov	r25, r26
    7460:	0e 94 6d 33 	call	0x66da	; 0x66da <__mulsf3>
    7464:	4b 01       	movw	r8, r22
    7466:	b8 2f       	mov	r27, r24
    7468:	a9 2f       	mov	r26, r25
    746a:	0e 19       	sub	r16, r14
    746c:	1f 09       	sbc	r17, r15
    746e:	ed cf       	rjmp	.-38     	; 0x744a <strtod+0x246>
    7470:	24 97       	sbiw	r28, 0x04	; 4
    7472:	f5 94       	asr	r15
    7474:	e7 94       	ror	r14
    7476:	ca 15       	cp	r28, r10
    7478:	db 05       	cpc	r29, r11
    747a:	39 f7       	brne	.-50     	; 0x744a <strtod+0x246>
    747c:	64 01       	movw	r12, r8
    747e:	eb 2e       	mov	r14, r27
    7480:	fa 2e       	mov	r15, r26
    7482:	8e 2d       	mov	r24, r14
    7484:	88 0f       	add	r24, r24
    7486:	8f 2d       	mov	r24, r15
    7488:	88 1f       	adc	r24, r24
    748a:	8f 3f       	cpi	r24, 0xFF	; 255
    748c:	49 f0       	breq	.+18     	; 0x74a0 <strtod+0x29c>
    748e:	20 e0       	ldi	r18, 0x00	; 0
    7490:	30 e0       	ldi	r19, 0x00	; 0
    7492:	a9 01       	movw	r20, r18
    7494:	c7 01       	movw	r24, r14
    7496:	b6 01       	movw	r22, r12
    7498:	0e 94 e1 31 	call	0x63c2	; 0x63c2 <__cmpsf2>
    749c:	81 11       	cpse	r24, r1
    749e:	06 c0       	rjmp	.+12     	; 0x74ac <strtod+0x2a8>
    74a0:	82 e2       	ldi	r24, 0x22	; 34
    74a2:	90 e0       	ldi	r25, 0x00	; 0
    74a4:	90 93 ba 02 	sts	0x02BA, r25
    74a8:	80 93 b9 02 	sts	0x02B9, r24
    74ac:	c7 01       	movw	r24, r14
    74ae:	b6 01       	movw	r22, r12
    74b0:	09 c0       	rjmp	.+18     	; 0x74c4 <strtod+0x2c0>
    74b2:	60 e0       	ldi	r22, 0x00	; 0
    74b4:	70 e0       	ldi	r23, 0x00	; 0
    74b6:	80 e8       	ldi	r24, 0x80	; 128
    74b8:	9f ef       	ldi	r25, 0xFF	; 255
    74ba:	04 c0       	rjmp	.+8      	; 0x74c4 <strtod+0x2c0>
    74bc:	60 e0       	ldi	r22, 0x00	; 0
    74be:	70 e0       	ldi	r23, 0x00	; 0
    74c0:	80 ec       	ldi	r24, 0xC0	; 192
    74c2:	9f e7       	ldi	r25, 0x7F	; 127
    74c4:	df 91       	pop	r29
    74c6:	cf 91       	pop	r28
    74c8:	1f 91       	pop	r17
    74ca:	0f 91       	pop	r16
    74cc:	ff 90       	pop	r15
    74ce:	ef 90       	pop	r14
    74d0:	df 90       	pop	r13
    74d2:	cf 90       	pop	r12
    74d4:	bf 90       	pop	r11
    74d6:	af 90       	pop	r10
    74d8:	9f 90       	pop	r9
    74da:	8f 90       	pop	r8
    74dc:	7f 90       	pop	r7
    74de:	6f 90       	pop	r6
    74e0:	08 95       	ret

000074e2 <__ftoa_engine>:
    74e2:	28 30       	cpi	r18, 0x08	; 8
    74e4:	08 f0       	brcs	.+2      	; 0x74e8 <__ftoa_engine+0x6>
    74e6:	27 e0       	ldi	r18, 0x07	; 7
    74e8:	33 27       	eor	r19, r19
    74ea:	da 01       	movw	r26, r20
    74ec:	99 0f       	add	r25, r25
    74ee:	31 1d       	adc	r19, r1
    74f0:	87 fd       	sbrc	r24, 7
    74f2:	91 60       	ori	r25, 0x01	; 1
    74f4:	00 96       	adiw	r24, 0x00	; 0
    74f6:	61 05       	cpc	r22, r1
    74f8:	71 05       	cpc	r23, r1
    74fa:	39 f4       	brne	.+14     	; 0x750a <__ftoa_engine+0x28>
    74fc:	32 60       	ori	r19, 0x02	; 2
    74fe:	2e 5f       	subi	r18, 0xFE	; 254
    7500:	3d 93       	st	X+, r19
    7502:	30 e3       	ldi	r19, 0x30	; 48
    7504:	2a 95       	dec	r18
    7506:	e1 f7       	brne	.-8      	; 0x7500 <__ftoa_engine+0x1e>
    7508:	08 95       	ret
    750a:	9f 3f       	cpi	r25, 0xFF	; 255
    750c:	30 f0       	brcs	.+12     	; 0x751a <__ftoa_engine+0x38>
    750e:	80 38       	cpi	r24, 0x80	; 128
    7510:	71 05       	cpc	r23, r1
    7512:	61 05       	cpc	r22, r1
    7514:	09 f0       	breq	.+2      	; 0x7518 <__ftoa_engine+0x36>
    7516:	3c 5f       	subi	r19, 0xFC	; 252
    7518:	3c 5f       	subi	r19, 0xFC	; 252
    751a:	3d 93       	st	X+, r19
    751c:	91 30       	cpi	r25, 0x01	; 1
    751e:	08 f0       	brcs	.+2      	; 0x7522 <__ftoa_engine+0x40>
    7520:	80 68       	ori	r24, 0x80	; 128
    7522:	91 1d       	adc	r25, r1
    7524:	df 93       	push	r29
    7526:	cf 93       	push	r28
    7528:	1f 93       	push	r17
    752a:	0f 93       	push	r16
    752c:	ff 92       	push	r15
    752e:	ef 92       	push	r14
    7530:	19 2f       	mov	r17, r25
    7532:	98 7f       	andi	r25, 0xF8	; 248
    7534:	96 95       	lsr	r25
    7536:	e9 2f       	mov	r30, r25
    7538:	96 95       	lsr	r25
    753a:	96 95       	lsr	r25
    753c:	e9 0f       	add	r30, r25
    753e:	ff 27       	eor	r31, r31
    7540:	ef 5c       	subi	r30, 0xCF	; 207
    7542:	fd 4f       	sbci	r31, 0xFD	; 253
    7544:	99 27       	eor	r25, r25
    7546:	33 27       	eor	r19, r19
    7548:	ee 24       	eor	r14, r14
    754a:	ff 24       	eor	r15, r15
    754c:	a7 01       	movw	r20, r14
    754e:	e7 01       	movw	r28, r14
    7550:	05 90       	lpm	r0, Z+
    7552:	08 94       	sec
    7554:	07 94       	ror	r0
    7556:	28 f4       	brcc	.+10     	; 0x7562 <__ftoa_engine+0x80>
    7558:	36 0f       	add	r19, r22
    755a:	e7 1e       	adc	r14, r23
    755c:	f8 1e       	adc	r15, r24
    755e:	49 1f       	adc	r20, r25
    7560:	51 1d       	adc	r21, r1
    7562:	66 0f       	add	r22, r22
    7564:	77 1f       	adc	r23, r23
    7566:	88 1f       	adc	r24, r24
    7568:	99 1f       	adc	r25, r25
    756a:	06 94       	lsr	r0
    756c:	a1 f7       	brne	.-24     	; 0x7556 <__ftoa_engine+0x74>
    756e:	05 90       	lpm	r0, Z+
    7570:	07 94       	ror	r0
    7572:	28 f4       	brcc	.+10     	; 0x757e <__ftoa_engine+0x9c>
    7574:	e7 0e       	add	r14, r23
    7576:	f8 1e       	adc	r15, r24
    7578:	49 1f       	adc	r20, r25
    757a:	56 1f       	adc	r21, r22
    757c:	c1 1d       	adc	r28, r1
    757e:	77 0f       	add	r23, r23
    7580:	88 1f       	adc	r24, r24
    7582:	99 1f       	adc	r25, r25
    7584:	66 1f       	adc	r22, r22
    7586:	06 94       	lsr	r0
    7588:	a1 f7       	brne	.-24     	; 0x7572 <__ftoa_engine+0x90>
    758a:	05 90       	lpm	r0, Z+
    758c:	07 94       	ror	r0
    758e:	28 f4       	brcc	.+10     	; 0x759a <__ftoa_engine+0xb8>
    7590:	f8 0e       	add	r15, r24
    7592:	49 1f       	adc	r20, r25
    7594:	56 1f       	adc	r21, r22
    7596:	c7 1f       	adc	r28, r23
    7598:	d1 1d       	adc	r29, r1
    759a:	88 0f       	add	r24, r24
    759c:	99 1f       	adc	r25, r25
    759e:	66 1f       	adc	r22, r22
    75a0:	77 1f       	adc	r23, r23
    75a2:	06 94       	lsr	r0
    75a4:	a1 f7       	brne	.-24     	; 0x758e <__ftoa_engine+0xac>
    75a6:	05 90       	lpm	r0, Z+
    75a8:	07 94       	ror	r0
    75aa:	20 f4       	brcc	.+8      	; 0x75b4 <__ftoa_engine+0xd2>
    75ac:	49 0f       	add	r20, r25
    75ae:	56 1f       	adc	r21, r22
    75b0:	c7 1f       	adc	r28, r23
    75b2:	d8 1f       	adc	r29, r24
    75b4:	99 0f       	add	r25, r25
    75b6:	66 1f       	adc	r22, r22
    75b8:	77 1f       	adc	r23, r23
    75ba:	88 1f       	adc	r24, r24
    75bc:	06 94       	lsr	r0
    75be:	a9 f7       	brne	.-22     	; 0x75aa <__ftoa_engine+0xc8>
    75c0:	84 91       	lpm	r24, Z
    75c2:	10 95       	com	r17
    75c4:	17 70       	andi	r17, 0x07	; 7
    75c6:	41 f0       	breq	.+16     	; 0x75d8 <__ftoa_engine+0xf6>
    75c8:	d6 95       	lsr	r29
    75ca:	c7 95       	ror	r28
    75cc:	57 95       	ror	r21
    75ce:	47 95       	ror	r20
    75d0:	f7 94       	ror	r15
    75d2:	e7 94       	ror	r14
    75d4:	1a 95       	dec	r17
    75d6:	c1 f7       	brne	.-16     	; 0x75c8 <__ftoa_engine+0xe6>
    75d8:	e7 ed       	ldi	r30, 0xD7	; 215
    75da:	f1 e0       	ldi	r31, 0x01	; 1
    75dc:	68 94       	set
    75de:	15 90       	lpm	r1, Z+
    75e0:	15 91       	lpm	r17, Z+
    75e2:	35 91       	lpm	r19, Z+
    75e4:	65 91       	lpm	r22, Z+
    75e6:	95 91       	lpm	r25, Z+
    75e8:	05 90       	lpm	r0, Z+
    75ea:	7f e2       	ldi	r23, 0x2F	; 47
    75ec:	73 95       	inc	r23
    75ee:	e1 18       	sub	r14, r1
    75f0:	f1 0a       	sbc	r15, r17
    75f2:	43 0b       	sbc	r20, r19
    75f4:	56 0b       	sbc	r21, r22
    75f6:	c9 0b       	sbc	r28, r25
    75f8:	d0 09       	sbc	r29, r0
    75fa:	c0 f7       	brcc	.-16     	; 0x75ec <__ftoa_engine+0x10a>
    75fc:	e1 0c       	add	r14, r1
    75fe:	f1 1e       	adc	r15, r17
    7600:	43 1f       	adc	r20, r19
    7602:	56 1f       	adc	r21, r22
    7604:	c9 1f       	adc	r28, r25
    7606:	d0 1d       	adc	r29, r0
    7608:	7e f4       	brtc	.+30     	; 0x7628 <__ftoa_engine+0x146>
    760a:	70 33       	cpi	r23, 0x30	; 48
    760c:	11 f4       	brne	.+4      	; 0x7612 <__ftoa_engine+0x130>
    760e:	8a 95       	dec	r24
    7610:	e6 cf       	rjmp	.-52     	; 0x75de <__ftoa_engine+0xfc>
    7612:	e8 94       	clt
    7614:	01 50       	subi	r16, 0x01	; 1
    7616:	30 f0       	brcs	.+12     	; 0x7624 <__ftoa_engine+0x142>
    7618:	08 0f       	add	r16, r24
    761a:	0a f4       	brpl	.+2      	; 0x761e <__ftoa_engine+0x13c>
    761c:	00 27       	eor	r16, r16
    761e:	02 17       	cp	r16, r18
    7620:	08 f4       	brcc	.+2      	; 0x7624 <__ftoa_engine+0x142>
    7622:	20 2f       	mov	r18, r16
    7624:	23 95       	inc	r18
    7626:	02 2f       	mov	r16, r18
    7628:	7a 33       	cpi	r23, 0x3A	; 58
    762a:	28 f0       	brcs	.+10     	; 0x7636 <__ftoa_engine+0x154>
    762c:	79 e3       	ldi	r23, 0x39	; 57
    762e:	7d 93       	st	X+, r23
    7630:	2a 95       	dec	r18
    7632:	e9 f7       	brne	.-6      	; 0x762e <__ftoa_engine+0x14c>
    7634:	10 c0       	rjmp	.+32     	; 0x7656 <__ftoa_engine+0x174>
    7636:	7d 93       	st	X+, r23
    7638:	2a 95       	dec	r18
    763a:	89 f6       	brne	.-94     	; 0x75de <__ftoa_engine+0xfc>
    763c:	06 94       	lsr	r0
    763e:	97 95       	ror	r25
    7640:	67 95       	ror	r22
    7642:	37 95       	ror	r19
    7644:	17 95       	ror	r17
    7646:	17 94       	ror	r1
    7648:	e1 18       	sub	r14, r1
    764a:	f1 0a       	sbc	r15, r17
    764c:	43 0b       	sbc	r20, r19
    764e:	56 0b       	sbc	r21, r22
    7650:	c9 0b       	sbc	r28, r25
    7652:	d0 09       	sbc	r29, r0
    7654:	98 f0       	brcs	.+38     	; 0x767c <__ftoa_engine+0x19a>
    7656:	23 95       	inc	r18
    7658:	7e 91       	ld	r23, -X
    765a:	73 95       	inc	r23
    765c:	7a 33       	cpi	r23, 0x3A	; 58
    765e:	08 f0       	brcs	.+2      	; 0x7662 <__ftoa_engine+0x180>
    7660:	70 e3       	ldi	r23, 0x30	; 48
    7662:	7c 93       	st	X, r23
    7664:	20 13       	cpse	r18, r16
    7666:	b8 f7       	brcc	.-18     	; 0x7656 <__ftoa_engine+0x174>
    7668:	7e 91       	ld	r23, -X
    766a:	70 61       	ori	r23, 0x10	; 16
    766c:	7d 93       	st	X+, r23
    766e:	30 f0       	brcs	.+12     	; 0x767c <__ftoa_engine+0x19a>
    7670:	83 95       	inc	r24
    7672:	71 e3       	ldi	r23, 0x31	; 49
    7674:	7d 93       	st	X+, r23
    7676:	70 e3       	ldi	r23, 0x30	; 48
    7678:	2a 95       	dec	r18
    767a:	e1 f7       	brne	.-8      	; 0x7674 <__ftoa_engine+0x192>
    767c:	11 24       	eor	r1, r1
    767e:	ef 90       	pop	r14
    7680:	ff 90       	pop	r15
    7682:	0f 91       	pop	r16
    7684:	1f 91       	pop	r17
    7686:	cf 91       	pop	r28
    7688:	df 91       	pop	r29
    768a:	99 27       	eor	r25, r25
    768c:	87 fd       	sbrc	r24, 7
    768e:	90 95       	com	r25
    7690:	08 95       	ret

00007692 <isspace>:
    7692:	91 11       	cpse	r25, r1
    7694:	0c 94 7a 3b 	jmp	0x76f4	; 0x76f4 <__ctype_isfalse>
    7698:	80 32       	cpi	r24, 0x20	; 32
    769a:	19 f0       	breq	.+6      	; 0x76a2 <isspace+0x10>
    769c:	89 50       	subi	r24, 0x09	; 9
    769e:	85 50       	subi	r24, 0x05	; 5
    76a0:	c8 f7       	brcc	.-14     	; 0x7694 <isspace+0x2>
    76a2:	08 95       	ret

000076a4 <strncasecmp_P>:
    76a4:	fb 01       	movw	r30, r22
    76a6:	dc 01       	movw	r26, r24
    76a8:	41 50       	subi	r20, 0x01	; 1
    76aa:	50 40       	sbci	r21, 0x00	; 0
    76ac:	88 f0       	brcs	.+34     	; 0x76d0 <strncasecmp_P+0x2c>
    76ae:	8d 91       	ld	r24, X+
    76b0:	81 34       	cpi	r24, 0x41	; 65
    76b2:	1c f0       	brlt	.+6      	; 0x76ba <strncasecmp_P+0x16>
    76b4:	8b 35       	cpi	r24, 0x5B	; 91
    76b6:	0c f4       	brge	.+2      	; 0x76ba <strncasecmp_P+0x16>
    76b8:	80 5e       	subi	r24, 0xE0	; 224
    76ba:	65 91       	lpm	r22, Z+
    76bc:	61 34       	cpi	r22, 0x41	; 65
    76be:	1c f0       	brlt	.+6      	; 0x76c6 <strncasecmp_P+0x22>
    76c0:	6b 35       	cpi	r22, 0x5B	; 91
    76c2:	0c f4       	brge	.+2      	; 0x76c6 <strncasecmp_P+0x22>
    76c4:	60 5e       	subi	r22, 0xE0	; 224
    76c6:	86 1b       	sub	r24, r22
    76c8:	61 11       	cpse	r22, r1
    76ca:	71 f3       	breq	.-36     	; 0x76a8 <strncasecmp_P+0x4>
    76cc:	99 0b       	sbc	r25, r25
    76ce:	08 95       	ret
    76d0:	88 1b       	sub	r24, r24
    76d2:	fc cf       	rjmp	.-8      	; 0x76cc <strncasecmp_P+0x28>

000076d4 <strrev>:
    76d4:	dc 01       	movw	r26, r24
    76d6:	fc 01       	movw	r30, r24
    76d8:	67 2f       	mov	r22, r23
    76da:	71 91       	ld	r23, Z+
    76dc:	77 23       	and	r23, r23
    76de:	e1 f7       	brne	.-8      	; 0x76d8 <strrev+0x4>
    76e0:	32 97       	sbiw	r30, 0x02	; 2
    76e2:	04 c0       	rjmp	.+8      	; 0x76ec <strrev+0x18>
    76e4:	7c 91       	ld	r23, X
    76e6:	6d 93       	st	X+, r22
    76e8:	70 83       	st	Z, r23
    76ea:	62 91       	ld	r22, -Z
    76ec:	ae 17       	cp	r26, r30
    76ee:	bf 07       	cpc	r27, r31
    76f0:	c8 f3       	brcs	.-14     	; 0x76e4 <strrev+0x10>
    76f2:	08 95       	ret

000076f4 <__ctype_isfalse>:
    76f4:	99 27       	eor	r25, r25
    76f6:	88 27       	eor	r24, r24

000076f8 <__ctype_istrue>:
    76f8:	08 95       	ret

000076fa <__muluhisi3>:
    76fa:	0e 94 88 3b 	call	0x7710	; 0x7710 <__umulhisi3>
    76fe:	a5 9f       	mul	r26, r21
    7700:	90 0d       	add	r25, r0
    7702:	b4 9f       	mul	r27, r20
    7704:	90 0d       	add	r25, r0
    7706:	a4 9f       	mul	r26, r20
    7708:	80 0d       	add	r24, r0
    770a:	91 1d       	adc	r25, r1
    770c:	11 24       	eor	r1, r1
    770e:	08 95       	ret

00007710 <__umulhisi3>:
    7710:	a2 9f       	mul	r26, r18
    7712:	b0 01       	movw	r22, r0
    7714:	b3 9f       	mul	r27, r19
    7716:	c0 01       	movw	r24, r0
    7718:	a3 9f       	mul	r26, r19
    771a:	70 0d       	add	r23, r0
    771c:	81 1d       	adc	r24, r1
    771e:	11 24       	eor	r1, r1
    7720:	91 1d       	adc	r25, r1
    7722:	b2 9f       	mul	r27, r18
    7724:	70 0d       	add	r23, r0
    7726:	81 1d       	adc	r24, r1
    7728:	11 24       	eor	r1, r1
    772a:	91 1d       	adc	r25, r1
    772c:	08 95       	ret

0000772e <_exit>:
    772e:	f8 94       	cli

00007730 <__stop_program>:
    7730:	ff cf       	rjmp	.-2      	; 0x7730 <__stop_program>
